;***************************************************************
;** Project: dial_light
;** File:    Custom.pro
;** Version: 2.0.3
;** Date:    July, 30th, 2002
;** Author:  E. Farhi
;** Object:  Contains specific instrument routines (IN6)
;**          Most Procedures are Instrument dependent (either TOF or IN6)
;
;** Require: dial_light.pro, Tools_StructSetValue.pro, Dialog_Fields.pro, TagFile.pro, dial_display.pro
;
;Created  June 4th 2002: Contains specific instrument routines (IN6)
;Modified Jul 8th 2002:  added monok+choppers. Improved computation of TOF par
;Modified Jul 11th 2002: added check elastic peak+auto
;Modified Jul 24th 2002: added Run/Sequence execution+stop
;Modified Jul 30th 2002: reorganised procedure names
;
;***************************************************************

; These procedures handle stand-alone processes that are not directly related to user actions/events
;
; pro Light_Custom_IN6_Update, LightVars, update_buttons=update_buttons, stop=stop, start=start, $
; pro Light_Custom_IN6_Init, LightVars, update_buttons=update_buttons, stop=stop, start=start
; pro Light_Custom_IN6_Sensitive, LightVars, mode=mode
; pro Light_Custom_IN6_Collect, LightVars
; pro Light_Custom_IN6_Setup_Check, LightVars, Changed=Changed, FromMad=FromMad, PhaseSpeed=PhaseSpeed, wavelength=wavelength
; pro Light_Custom_IN6_Calc_TOF_Choppers, LightVars, Wavelength=Wavelength, show=show
;
; These procedures handle processes that are triggered by user events (managed through Light_Base_Event_Parser)
;
; pro Light_Event_Custom_IN6_Edit_Header, LightVars
; pro Light_Event_Custom_IN6_Stop, LightVars, motors=motors, choppers=choppers
; pro Light_Event_Custom_IN6_Default_Displays, LightVars
; pro Light_Event_Custom_IN6_Setup_Build, LightVars, auto=auto, help=help, wavelength=wavelength, update=update
; pro Light_Event_Custom_IN6_Setup_Choppers, LightVars, Wavelength=Wavelength, update=update, auto=auto, help=help
; pro Light_Event_Custom_IN6_Setup_Monochromators, LightVars, Wavelength=Wavelength, rocking=rocking, position=position, update=update, help=help
;
; These procedures handle processes that are either automatic or launched by user, but may then live for a given time
;
; pro Light_SubDial_Custom_IN6_Check_Choppers, LightVars
; pro Light_SubDial_Custom_IN6_Check_Monochromators, LightVars, Wavelength=Wavelength
; pro Light_SubDial_Custom_IN6_Check_Elastic_Peak, LightVars, auto=auto, help=help
; pro Light_SubDial_Custom_IN6_Check_Run, LightVars

; Still to do:
; pro Light_SubDial_Base_Check_Temperature, LightVars
;   will use Physica B A.Stunault et al., 180 (1992) 926 implemented in /home/cs/richard/lamp/lamp_mac/corel.pro
;   only if more than 1 repetition
;   call with wkin is [ [data0], [data1], [data2]... ] with dim(2) = nrepet. Returns R(i,c) (with dims of data0)
;   result should be around 1

;***************************************************************
; this routine is used only for off-line tests, and modifies directly the Lightvars.Mad structure members
; example: 
;   madtest,'status','"idle"'
;   madtest,'t_res.tempea(1)',5 
pro MadTest, type, value

  LightVars = Light_Get_LightVars()
  cmd = 'LightVars.Mad.'+type+' = '+string(value)
  print, 'MadTest:', cmd
  ok  = execute(cmd)
  DialTag, 'light', tag='Mad',       set=LightVars.Mad

end ; PRO MadTest

;***************************************************************
;** Main Custom procedure (executed through Instrument.InitPro), called from Light_Base
pro Light_Custom_IN6_Update, LightVars, update_buttons=update_buttons, stop=stop, start=start, $
                                        collect=collect, edit_header=edit_header

  if n_elements(start) ne 0 then Light_Custom_IN6_Init, LightVars
    
  if n_elements(collect) ne 0 then Light_Custom_IN6_Collect, LightVars
  
  if n_elements(edit_header) ne 0 then Light_Event_Custom_IN6_Edit_Header, LightVars
  
  if n_elements(stop) ne 0 then begin
    Light_Event_Custom_IN6_Stop, LightVars
    update_buttons=1 ; to update menu item/buttons according to SU/normal mode
  endif
  
  if n_elements(update_buttons) ne 0 then Light_Custom_IN6_Sensitive, LightVars

end ; PRO Light_Custom_IN6_Update

;***************************************************************
;** Procedure executed when starting light, specific to the instrument
; (see also light/custom.pro, line 221)
pro Light_Custom_IN6_Init, LightVars

    ; Define specific Custom blocks

    ; Here follows a default IN6 configuration
    ;           center    range    time     step    opt_value
    Data =  [[[4920.00,  200.00,  1.00000, 10.0000, 4920.00 ]   ,$  ;wave=4.14 monok 1
              [5060.00,  200.00,  1.00000, 10.0000, 5060.00 ]   ,$  ;          monok 2
              [5355.00,  200.00,  1.00000, 10.0000, 5355.00 ]]  ,$  ;          monok 3

             [[4400.00,  300.00,  1.00000, 30.0000, 4400.00 ]   ,$  ;wave=4.60
              [4556.00,  300.00,  1.00000, 30.0000, 4556.00 ]   ,$
              [4825.00,  300.00,  1.00000, 30.0000, 4825.00 ]]  ,$

             [[3800.00,  190.00,  1.00000, 10.0000, 3800.00 ]   ,$  ;wave=5.12
              [3960.00,  190.00,  1.00000, 10.0000, 3960.00 ]   ,$
              [4220.00,  190.00,  1.00000, 10.0000, 4220.00 ]]  ,$

             [[2640.00,  200.00,  10.0000, 20.0000, 2640.00 ]   ,$  ;wave=5.92
              [2790.00,  200.00,  10.0000, 20.0000, 2790.00 ]   ,$
              [3050.00,  200.00,  10.0000, 20.0000, 3050.00 ]]]

    CustomData = {LIGHT_CUSTOMDATA_IN6, $ ; instrument configuration to be loaded/saved from/into .ini files
      Type:'Time-of-Flight' , Name:'IN6', $
      CustomMenuItems   :['Instrument...', $
                              'Instrument (Choppers)...', $
                              'Instrument (Monochromators)...', $
                              'Restore IN6 Default Displays', $
                              'Experiment header...' ], $
      CustomMenuPro     :['Light_Event_Custom_IN6_Setup_Build, LightVars', $
                              'Light_Event_Custom_IN6_Setup_Build, LightVars & Light_Event_Custom_IN6_Setup_Choppers, LightVars', $
                              'Light_Event_Custom_IN6_Setup_Build, LightVars & Light_Event_Custom_IN6_Setup_Monochromators, LightVars', $
                              'Light_Event_Custom_IN6_Default_Displays, LightVars', $
                              'Light_Event_Custom_IN6_Edit_Header, LightVars'], $
      EnergyDefinitions : [4.14,  4.6,  5.12,  5.92], $    ; energy values physically achievable on the instrument
      EnergyOptions     :'discrete wavelength superuser', $   ; may be limits, free, discrete
      ElastPeakChannels : [235L, 275L, 315L, 350L], $  ; default elastic line channel for 512 channels
      MonokSequence     : [2,1,0], $
      MonokDSpacing     : 3.355, $          ; d[AA] lattice-spacing for monochromators. PG002=3.355
      MonokData         : Data, $           ; reform(Data, 5,n_elements(MonokSequence),n_elements(EnergyValues))
      MonokFluxMon_TOF  : 0L, $             ; 0 if monochromator rocking curve calibrates on Monitor, 1 if on TOF (detectors)
      MonokUseOldValues : 1L, $             ; 0 if monochromator rocking angles are computed, 1 if use table (Y. Blanc)
      EnergyCommand     :'par wavelength %f', $ ; <lambda>
      MonokRAZCommand   :'raz', $
      MonokSetCommand   :'mono%d %d', $       ; <number> <position>
      MonokCntCommand   :'count %f t n', $    ; <time_s>
      CountCommand      :'count %f %s %d %s',$; <time> <time|mon> <nrep> <save|nosave>
      TempReadCommand   :'rte', $
      TempWriteCommand  :'pte %f', $
      ChoppersStopCommand:'kill', $
      StopCommand       : 'stop', $
      CommentCommand    : '! %s', $
      SetUserCommand    :'par user %s', $       ; <UserName+' '+LocalContact>
      SetTitleCommand   :'par title %s', $      ; <title>
      SetSubTitleCommand:'par subtitle %s', $   ; <subtitle>
      SetEnvirCommand   :'par environement %s', $ ; <env. code>
      SetComputeCommand :'par compute %s', $    ; t_para.compute_par
      ChoppersSetCommand:'par chop s %7.2f r %d P1 %6.2f P2 %6.2f', $  ; <fermi_speed> <ratio> <phase_ferm> <phase_supp> (<offset>)
      ChoppersSynchro   :'chopper synchro wait', $
      TOFSetCommand     :'par tof channel %f width %f delay %f', $ ; <n_chan> <chan_width> <delay>
      ElPeakCommand     :'par elpeak %d', $     ; <elpeak chan>
      PeriodCommand     :'par period %f', $     ; <period>
      AutoFlags         : [1,1,1], $        ; automatic setup flags for Choppers/Monok/Check of elastic peak
      SetupEnergies     : [4.14, 0., 0.], $ ; values of the energy for which chopper/monok/elastic peak where set
      Distances_CC_CS_SD: [0.200, 0.395, 2.483], $; [m] Distances Chopper1-Chopper2, Chopper2-Sample, Sample-Detector
      ChopperSpeedRatio : 1., $             ; [1]   speed ratio Fermi/Supp
      Focus_Energy      : 0., $             ; [meV] focusing to specified energy transfert
      N_channels        : 512L, $           ; [512] Number of time channels
      ElectronicTimeBase: 0.125, $          ; [us]  Electronic base time
      ElectronicDelay   : 44.875, $         ; [us]  Default Electronic Delay
      ReferencePhase    : 90., $            ; [deg] Reference Phase
      PhaseOffset       : 0. $              ; [deg] Phase Offset (added to Fermi phase)
    } ; enrich Light.Instrument

    CustomPrivate = {LIGHT_PRIVATE_IN6, $
      MonokCurrentIndex : 0L, $             ; current monok index in sequence during rocking curve/positioning
      MonokScanPoint    : 0L, $             ; current scan point during rocking curve
      MonokPosition     : 0L, $             ; current position during rocking curve/positioning
      MonokLambdaData   : 0L, $             ; current part of MonokData table for given lambda
      MonokX            : [0.], $           ; vector of positions
      MonokY            : [0.], $           ; vector of counts
      MonokYfit         : [0.], $           ; vector of fitted counts
      MonokDisplayMsg   : ['','',''], $     ; comment lines for the tree monochromators of IN6

      EnergyValues      : [0.,0.,0.,0.], $  ; energy values stored from previous setting
      EnergyUnit        :'', $
      EnergyToSet       : 0., $
      EnergyIndex       : 0L, $
      Elastic_Peak_Chan : 315L, $           ; [315] Current Elastic_Peak position        
      KeepMadData       : 0L, $
      Environement      : 'xx', $
      Delay             : 0., $
      SpeedFermiTarget  : 0., $
      PhaseFermiTarget  : 0., $
      SpeedFermi        : 0., $
      PhaseFermi        : 0., $
      SpeedSupprTarget  : 0., $
      PhaseSupprTarget  : 0., $
      SpeedSuppr        : 0., $
      PhaseSuppr        : 0., $
      Period            : 0., $
      ChannelWidth      : 0., $
      AutoProcess       : 0L, $
      DeadTime          : 0. $
      }

    CustomHandles = { LIGHT_CUSTOMHANDLES_IN6, $
      SetupButtons: [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L], $ ; chopper/monok/DoElastpeak/auto/stop/focusEn/Ratio/ChanNb/ElPeak/ElPeakMenu
      SetupStatus : [0L, 0L, 0L], $
      SetupFlags  : [0L, 0L, 0L], $     ;  auto flag handles
      Energy      : [0L, 0L, 0L, 0L], $ ;  energy value displays handles: lambda, E, k, v
      EnergySetup : 0L, $               ; main setup window handle
      MonokSetup  : 0L, $               ; main monok window handle
      MonokButtons: [0L, 0L, 0L, 0L], $ ; Mono setup: rocking curve/position/status/table handles
      ChoppersSetup:0L, $               ; main Choppers window handle
      ChoppersButtons: [0L, 0L, 0L, 0L], $ ; Choppers setup: set/status/table handles
      ChopTofText : 0L $               ; TOF Choppers text Display
    } ; enrich Light.Handles

    CustomNames = tag_names(CustomData)
    for index=0, n_elements(CustomNames)-1 do begin
      ThisTag = CustomNames(index)
      ; store and extend Light.Instrument Data block
      Tools_StructSetValue, struct=LightVars, tag='Instrument.'+ThisTag, val= CustomData.(index)
    endfor

    CustomNames = tag_names(CustomHandles)
    for index=0, n_elements(CustomNames)-1 do begin
      ThisTag = CustomNames(index)
      ; store and extend Light.Handles Data block
      Tools_StructSetValue, struct=LightVars, tag='Handles.'+ThisTag, val= CustomHandles.(index)
    endfor

    CustomNames = tag_names(CustomPrivate)
    for index=0, n_elements(CustomNames)-1 do begin
      ThisTag = CustomNames(index)
      ; store and extend Light.Handles Data block
      Tools_StructSetValue, struct=LightVars, tag='Private.'+ThisTag, val= CustomPrivate.(index)
    endfor

    if file_test('light_in6.mad') ne 0 and LightVars.Global.Simulation eq 3 then begin
      restore, 'light_in6.mad'
      Light_LogMessage, LightVars, 'normal','[ ] Importing real session MAD data. Setting frozen mode.'
      LightVars.Private.KeepMadData = 1
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_nother', val= t_nother
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_res'   , val= t_res
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_para'  , val= t_para
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_status', val= t_status
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_counts', val= t_counts
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_chopper',val= t_chopper
      LightVars.Global.Simulation = 1L
    endif

    ; execute IN6 Instrument Control startup commands: see ../light/DIALS/dial_set_inst_def.pro
    ;mad,'par lim mono1 -6000 6000'
    ;mad,'par lim mono2 -6000 6000'
    ;mad,'par lim mono3 -6000 6000'

end ; PRO Light_Custom_IN6_Init

;***************************************************************
pro Light_Custom_IN6_Sensitive, LightVars, mode=mode
; Setup window buttons in inactive/normal/extended/SU mode (activate/unactivate)

    ; force unactivate buttons if Monok/Choppers/Check Inelastic/RunsSequence are running
    MonokOn    = ''
    ChoppersOn = ''
    CheckElPOn = ''
    RunIsOn    = ''
    if LightVars.Handles.SetupStatus(0) ne 0 then $
      widget_control, LightVars.Handles.SetupStatus(0), get_uvalue=ChoppersOn, bad_id=tmp
    if LightVars.Handles.SetupStatus(1) ne 0 then $
      widget_control, LightVars.Handles.SetupStatus(1), get_uvalue=MonokOn,    bad_id=tmp
    if LightVars.Handles.SetupStatus(2) ne 0 then $
      widget_control, LightVars.Handles.SetupStatus(2), get_uvalue=CheckElPOn, bad_id=tmp
    if LightVars.Handles.RunStatus ne 0 then $
      widget_control, LightVars.Handles.RunStatus,      get_uvalue=RunIsOn, bad_id=tmp
      
    if strlen(MonokOn) gt 0 or strlen(ChoppersOn) gt 0 or strlen(CheckElPOn) gt 0 or  strlen(RunIsOn) gt 0 then mode = 'inactive'
    
    if n_elements(mode) eq 0 then begin
      if LightVars.Private.IsSuperUser eq 0 then begin
        if strpos(Lightvars.Instrument.EnergyOptions, 'superuser') lt 0 then mode='extended' else mode = 'normal'
      endif else mode ='superuser'
      if LightVars.Private.AutoProcess gt 0 then begin
        if LightVars.Private.AutoProcess gt 5 then LightVars.Private.AutoProcess = 0 $
        else LightVars.Private.AutoProcess = LightVars.Private.AutoProcess+1
      endif
    endif

    if mode eq 'inactive' then begin
      widget_control, LightVars.Handles.SetupButtons(2), sensitive=0, bad_id=tmp1   ; check elastic peak button
      widget_control, LightVars.Handles.SetupButtons(9), sensitive=0, bad_id=tmp1   ; check elastic peak menu
      widget_control, LightVars.Handles.RunStartButton(0), sensitive=0, bad_id=tmp1 ; START runs button/menu
      widget_control, LightVars.Handles.RunStartButton(1), sensitive=0, bad_id=tmp1 ; START runs button/menu
      widget_control, LightVars.Handles.RunStartButton(2), sensitive=0, bad_id=tmp1 ; START runs button/menu
      widget_control, LightVars.Handles.Energy(0), sensitive=0, bad_id=tmp1         ; Energy value
      widget_control, LightVars.Handles.Energy(1), sensitive=0, bad_id=tmp1         ; Energy value
      widget_control, LightVars.Handles.Energy(2), sensitive=0, bad_id=tmp1         ; Energy value
      widget_control, LightVars.Handles.Energy(3), sensitive=0, bad_id=tmp1         ; Energy value
    endif else begin
      widget_control, LightVars.Handles.SetupButtons(2), sensitive=1, bad_id=tmp1   ; check elastic peak button
      widget_control, LightVars.Handles.SetupButtons(9), sensitive=1, bad_id=tmp1   ; check elastic peak menu
      widget_control, LightVars.Handles.RunStartButton(0), sensitive=1, bad_id=tmp1 ; START runs button/menu
      widget_control, LightVars.Handles.RunStartButton(1), sensitive=1, bad_id=tmp1 ; START runs button/menu
      widget_control, LightVars.Handles.RunStartButton(2), sensitive=1, bad_id=tmp1 ; START runs button/menu
      widget_control, LightVars.Handles.Energy(0), sensitive=1, bad_id=tmp1         ; Energy value
      widget_control, LightVars.Handles.Energy(1), sensitive=1, bad_id=tmp1         ; Energy value
      widget_control, LightVars.Handles.Energy(2), sensitive=1, bad_id=tmp1         ; Energy value
      widget_control, LightVars.Handles.Energy(3), sensitive=1, bad_id=tmp1         ; Energy value
    endelse

    Lightvars.Instrument.EnergyOptions = strlowcase(Lightvars.Instrument.EnergyOptions)
    ; normal mode: LightVars.Private.IsSuperUser eq 0  and superuser is in options -> all inactivate
    ; SU mode: LightVars.Private.IsSuperUser eq 1 -> all activated
    ; extened normal mode: LightVars.Private.IsSuperUser eq 0  and superuser not in options -> some activated
    if mode eq 'normal' or mode eq 'extended' or mode eq 'inactive' then begin ; common normal mode
      ; Monok position, rocking and table edition
      widget_control, LightVars.Handles.MonokButtons(0), sensitive=0, bad_id=tmp1 ; rocking
      widget_control, LightVars.Handles.MonokButtons(3), editable=0,  bad_id=tmp1 ; table
      ; menu items Setup:Load/save config
      widget_control, LightVars.Handles.LoadSaveCfg(0), sensitive=0, bad_id=tmp1  ; load config setup menu item
      widget_control, LightVars.Handles.LoadSaveCfg(1), sensitive=0, bad_id=tmp1  ; save config setup menu item
      ;choppers set and table
      widget_control, LightVars.Handles.ChoppersButtons(0), sensitive=0, bad_id=tmp1; set
      widget_control, LightVars.Handles.ChoppersButtons(2), editable=0, bad_id=tmp1; table 1
      widget_control, LightVars.Handles.ChoppersButtons(3), editable=0, bad_id=tmp1; table 2
      if mode eq 'extended' then begin  ; extended mode
        ; restricted actions
        widget_control, LightVars.Handles.SetupButtons(3), sensitive=1, bad_id=tmp1 ; auto button
        widget_control, LightVars.Handles.SetupButtons(4), sensitive=1, bad_id=tmp1 ; auto menu item
        widget_control, LightVars.Handles.Lambda, sensitive=1, bad_id=tmp1          ; lambda in Runs
        widget_control, LightVars.Handles.MonokButtons(1), sensitive=1, bad_id=tmp1 ; position
      endif else begin  ; normal mode
        ; Auto+Lambda in runs
        widget_control, LightVars.Handles.SetupButtons(3), sensitive=0, bad_id=tmp1 ; auto button
        widget_control, LightVars.Handles.SetupButtons(4), sensitive=0, bad_id=tmp1 ; auto menu item
        widget_control, LightVars.Handles.Lambda, sensitive=0, bad_id=tmp1          ; lambda in Runs
        ; Monok position, rocking and table edition
        widget_control, LightVars.Handles.MonokButtons(1), sensitive=0, bad_id=tmp1 ; position
      endelse
    endif else begin  ; SU mode
      ; Auto+Lambda in runs
      widget_control, LightVars.Handles.SetupButtons(3), sensitive=1, bad_id=tmp1 ; auto button
      widget_control, LightVars.Handles.SetupButtons(4), sensitive=1, bad_id=tmp1 ; auto menu item
      widget_control, LightVars.Handles.Lambda, sensitive=1, bad_id=tmp1          ; lambda in Runs
      ; Monok position, rocking and table edition
      widget_control, LightVars.Handles.MonokButtons(1), sensitive=1, bad_id=tmp1 ; position
      widget_control, LightVars.Handles.MonokButtons(0), sensitive=1, bad_id=tmp1 ; rocking
      widget_control, LightVars.Handles.MonokButtons(3), editable=1,  bad_id=tmp1 ; table
      ;choppers set and table
      widget_control, LightVars.Handles.ChoppersButtons(0), sensitive=1, bad_id=tmp1; set
      widget_control, LightVars.Handles.ChoppersButtons(2), editable=1, bad_id=tmp1; table 1
      widget_control, LightVars.Handles.ChoppersButtons(3), editable=1, bad_id=tmp1; table 2
      ; menu items Setup:Load/save config
      widget_control, LightVars.Handles.LoadSaveCfg(0), sensitive=1, bad_id=tmp1  ; load config setup menu item
      widget_control, LightVars.Handles.LoadSaveCfg(1), sensitive=1, bad_id=tmp1  ; save config setup menu item
    endelse
    
end ; PRO Light_Custom_IN6_Sensitive

;***************************************************************
;** (Full) Collect data from the Generic Instrument Control program
; if LightVars.Private.Update_Nb is 1 then performs a major update
pro Light_Custom_IN6_Collect, LightVars

  forward_function DialNewValue

  Update_Nb       = LightVars.Private.Update_Nb
  Previous_Status = LightVars.Mad.Status

  ; MINOR UPDATE SECTION ***************************************************

  ; checks frozen mode from Simulation flag
  if LightVars.Global.Simulation eq 3 then begin
    LightVars.Private.KeepMadData = 1
    LightVars.Global.Simulation   = 1
  endif

  ; if frozen mode, retain previous t_status (structure)
  ; else gets new Mad.t_status
  if LightVars.Private.KeepMadData ne 0 then t_status = LightVars.Mad.t_status $
  else begin
    t_status = DialNewValue(type='t_status')
    Tools_StructSetValue, struct=LightVars, tag='Mad.t_status',val= t_status
  endelse

  ; now sets Mad.Status (string)
  if size(LightVars.Mad.t_status, /type) ne 8 then begin ; not a structure. MAD is off-line
    LightVars.Mad.Status = strupcase(LightVars.Generic)+' INACTIVE (Idle)'
    Light_Event_Base_Simulation, LightVars, Simulation = 1L
    LightVars.Global.Simulation = 1L
  endif else begin
    if LightVars.Private.KeepMadData ne 0 then begin
      ; frozen mode
      Light_Event_Base_Simulation, LightVars, Simulation = 2L
      LightVars.Global.Simulation = 2L
      LightVars.Mad.Status = ['Frozen (Idle)']
    endif else begin
      ; gets MAD.status
      LightVars.Mad.Status = DialNewValue(type='status')
      if LightVars.Global.Simulation ne 0 then LightVars.Mad.Status = '['+LightVars.Mad.Status+']'
    endelse
    ; is Light in simulation mode ?
    if LightVars.Global.Simulation eq 1L then begin
      Light_LogMessage, LightVars, 'silent','[w] MAD is active, but in Simulation mode (no Action).'
      LightVars.Global.Simulation = 2L
    endif
  endelse
  if size(LightVars.Mad.t_nother, /type) eq 8 and strpos(strupcase(LightVars.Mad.Status), 'IDLE') ge 0 then $
    if LightVars.Mad.t_nother.count_flag eq 2 then LightVars.Mad.Status = 'Paused'

  ; if a normal major Update is requested, or Mad Status just changed
  Major_Flag = (Update_Nb le 1 or strcmp(LightVars.Mad.Status, Previous_Status) eq 0)
  if Update_Nb ne 0 and LightVars.Private.KeepMadData eq 0 and Major_Flag ne 0 then begin
    Update_Message= "<UPDATING>" 
    widget_control, LightVars.Handles.Mad_Status, set_value=Update_Message, bad_id=tmp1 
  endif else if Update_Nb eq 0 then begin
    Update_Message="** Starting **"
    widget_control, LightVars.Handles.Mad_Status, set_value=Update_Message, bad_id=tmp1 
  endif

  ; MAJOR UPDATE SECTION ***************************************************

  ; update possibilities: 
  ;   simulation (3)    : retain MAD values (does not perform any collect). Static = 1. Store  = 0
  ; else
  ;   retrieve previous values
  ;   simulation (0,1,2): gets MAD Data at major Updates or when Status changed. Static = 0. Store = 1
  if LightVars.Private.KeepMadData eq 0 and Major_Flag ne 0 then begin 
    ; Major_Update, and not Static
    ;** Get MAD data from MAD_IDL shared memory, and will put them in the LightVars.Mad tags
    ;** (if MAD is not running: status='Idle', values are 3.14 for t_*)
    t_nother = DialNewValue(type='t_nother')
    t_res    = DialNewValue(type='t_res')
    t_para   = DialNewValue(type='t_para')
    t_counts = DialNewValue(type='t_counts')
    t_chopper= DialNewValue(type='t_chopper')
    data     = DialNewValue(type='data')
  endif else begin
    ; retrieve old values, as we are going to test them (and store them)
    if Major_Flag ne 0 then begin ; here LightVars.Private.KeepMadData ne 0 
      Mad = LightVars.Mad
      t_nother = Mad.t_nother
      t_res    = Mad.t_res
      t_para   = Mad.t_para
      t_status = Mad.t_status
      t_counts = Mad.t_counts
      t_chopper= Mad.t_chopper
      data     = Mad.Data
    endif
  endelse

  if Major_Flag ne 0 then begin
    ; test new values. If they are not properly defined, redefine them.
    if size(t_chopper, /type) ne 8 then t_chopper = 3.14

    if size(t_res, /type) ne 8 then begin
      tempea = [4.2, 4.7+0.1*randomn(seed), 4.8+0.1*randomn(seed), 0.1+0.01*randomn(seed)]
      t_res = { TEMPEA:tempea, LASNUM:101L, N_TOTAL_SPECT:340L, N_MON_SPECT:3, N_SINGLE_SPECT:337L, $
                PHASE_REQ:[99.3492, 90.0000], PHASE_ACT:[99.0640,90.0010], $
                SPEED_REQ:[6020.00,0.000000], SPEED_ACT:[6019.00,6020.00], $
                CHOP_STATUS:[63L, 63L], NREPET:0L, NPREP:0L, JC:0L, XC:0L, ISODIS:1L, NUM_TEMP:100L }
      LightVars.Private.KeepMadData = 1
    endif
    if size(t_para, /type) ne 8 then begin
      t_para = {TOF_CHA_RESOL:512L, WAVE:4.12, TOF_CHA_WIDTH:77L, NUM_CHAN_USED:0L, $
                RAT_CHOPPER:1., SPE_CHOPPER:[6020.00,6020.00], ICRY:1L, $
                UPDATE_TIMER:20L, STATE_TIMER:0L, COMPUTE_PAR:0L, $
                DEPH_CHOPPER:[99.3492,90.0000], DEPH_OFFSET:0., PERIOD:4983.39, $
                CHA_WIDTH:9.62500,TOF_DELAY:991.375, ELPEAK:315L, DISTANCE:fltarr(6), $
                DIS_S_M:0., ALARM_TIMER:0L, $
                C_TXT:'', C_USER:'', C_LC:'', SUB_TITLE:'', ENVIRONMENT:12L }
      LightVars.Private.KeepMadData = 1
    endif
    if size(t_nother, /type) ne 8 then begin
      t_nother = {PCODE:0L, PSTATE:0L, CSTATE:0L, XBU_STATE:0L, XBU_INTER:0L, NFUNC:0L, NKEY:0L, $
                  CHOP_STOP_NUMBER:lonarr(2), CHOP_STOP_TIME:lonarr(2),$
                  INST_NAME:'IN6     ', NSWITCH:0L, NWHICHR:0L, COUNT_FLAG:0L, $
                  ACTANG: fltarr(16), motor_error:lonarr(16), $
                  PRESET_REST:30L, SUCCES:25L, SIM:0L, PCP_KILL:0L, $
                  STOP_TIME:'00:00:00', START_TIME:'00:00:00' }
      LightVars.Private.KeepMadData = 1
    endif
    if size(t_STATUS, /type) ne 8 then begin
      t_STATUS= {PCODE:0L, PSTATE:0L, CSTATE:0L, count_flag:0L, JC:0L, $
                  det_sum:0L, ss_counts:lonarr(2), cstate_flags:0L, motor_flags:0L }
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_status',val= t_status
    endif

    N_cha = t_para.tof_cha_resol
    N_det = t_res.N_TOTAL_SPECT

    if size(t_counts,  /type) eq 8 and n_elements(data) le 1 then data = t_counts.data
    if n_elements(data) le 1 then data = findgen(N_cha,N_det)+uint(5*randomn(seed, N_cha,N_det))

    data = reform(data(0:(N_cha*N_det-1)), N_cha, N_det) ; for IN6 only
    if size(t_counts,  /type) ne 8 then $
      t_counts = {data:data, det_sums:total(data,1), sum:total(data) }

    ; Test previous Mad structures if we are not starting Light 
    ; (that is some reasonable Mad.t_* structures were stored at start-up or updated after)
    if Update_Nb eq 1 then begin

      ; ** test MAD changes (Temp, wavelength, cumulated data...).
      ; now handle n_repetitions: should store data from memory into cumulated data (before MAD update in memory)
      ; except when doing 'wait T control' countings
      ; if no repetition (t_res.NPREP eq 1) or wrong size, data_cumulated = data*0
      ; if changed repetition number, Mad.t_res.NPREP lt t_res.NPREP data_cumulated = data_cumulated + LightVars.Mad.data
      if LightVars.Private.LastValidNumor(0) eq 0 then begin
        ; if no repeptition (NREPET = 1) or no valid size -> data_cumulated = data
        data_cumulated = LightVars.Private.Data_Cumulated
        if n_elements(LightVars.Private.Data_Cumulated) ne n_elements(LightVars.Mad.data) $
        or t_res.NREPET le 1 then data_cumulated = data $
        else begin
          ; if just changed repetition number (t_res.NPREP), and t_res.NREPET gt 1
          if LightVars.Mad.t_res.NPREP lt t_res.NPREP then begin ; detected t_res.NPREP++
            data_cumulated = data_cumulated + LightVars.Mad.data  ; add data before starting new repetition counting
          endif
        endelse
        Tools_StructSetValue, struct=LightVars, tag='Private.Data_Cumulated', val=data_cumulated
      endif
      ;detects wavelength changes
      if  LightVars.Mad.t_para.wave ne t_para.wave then begin
        msg = '[ ] Wavelength changed from '+strcompress(string(LightVars.Mad.t_para.wave))+' [K] to '+strcompress(string(t_para.wave))+' [K]'
        Light_LogMessage, LightVars, 'normal', msg
      endif
      ; look if a temperature change was performed
      if t_res.tempea(0) ne  LightVars.Mad.t_res.tempea(0) then begin
          msg = '[ ] Temperature changed from '+strcompress(string( LightVars.Mad.t_res.tempea(0)))+' [K] to '+strcompress(string(t_res.tempea(0)))+' [K] (Set Point)'
          Light_LogMessage, LightVars, 'normal', msg
          LightVars.Private.WaitTempTime = systime(1)
      endif

      ; ** test MAD errors  (Choppers, Monoks...).  
      ; handle possible MAD errors and operation conflicts ***********************
      if (t_nother.XBU_STATE ne 0 and LightVars.Mad.t_nother.XBU_STATE eq 0) $
      or (t_nother.XBU_INTER ne 0 and LightVars.Mad.t_nother.XBU_INTER eq 0) $
      and LightVars.Global.Simulation eq 0 then begin
        ; something is going on with XBU files, independently of Light. Stop current controls, Put Light to simulation
        Light_Base_Alert, Lightvars, error='XBU file conflict'
        Light_LogMessage, LightVars, 'silent','[I] Switching to Simulation.'
        Light_Event_Base_Simulation, LightVars, Simulation=1L
      endif
      ; MAD is already in simulation mode ?
      if t_nother.sim ne 0 and LightVars.Mad.t_nother.sim eq 0 then Light_Event_Base_Simulation, LightVars, Simulation=1L
      tmp0 = where(LightVars.Mad.t_nother.MOTOR_ERROR ne 0)
      tmp1 = where(t_nother.MOTOR_ERROR ne 0)
      if tmp1(0) ge 0 and tmp0(0) lt 0 then begin
        ; new MOTOR_ERROR: display ERROR
        Light_LogMessage, LightVars, 'silent','[E] Motor '+strcompress(string(tmp1+1))+' error: '+strcompress(string(t_nother.MOTOR_ERROR(tmp1)))
      endif
      ; Chopper error check (bit 64, 128 or 256 in CHOP_STATUS)
      ErrorBytes = (64 or 128 or 256)
      tmp0 = where((LightVars.Mad.t_res.Chop_Status and ErrorBytes) ne 0)
      tmp1 = where((t_res.Chop_Status and ErrorBytes) ne 0)
      if tmp1(0) ge 0 and tmp0(0) lt 0 then begin
        ; new Chopper ERROR: stop and display ERROR
        Light_Base_Alert, Lightvars, error='Chopper '+strcompress(string(tmp1))+' setting'
        Light_LogMessage, LightVars, 'silent','[E] Chopper error: '+strcompress(string(t_res.Chop_Status(tmp1)))
        Light_Event_Custom_IN6_Stop, LightVars, /choppers
      endif
      if t_para.ALARM_TIMER ne 0 and LightVars.Mad.t_para.ALARM_TIMER eq 0 and LightVars.Global.Simulation eq 0 then begin
        ; new Alarm ERROR: stop and display ERROR
        Light_Base_Alert, Lightvars, error='Alarm Timer'
        Light_LogMessage, LightVars, 'silent','[E] An alarm timer occured in MAD. Switching to Simulation.'
        Light_Event_Base_Simulation, LightVars, Simulation=1L
      endif
      if  LightVars.Mad.t_nother.PCP_KILL eq 0 and t_nother.PCP_KILL ne 0 and LightVars.Global.Simulation eq 0 then begin
        ; new PCP event
        Light_LogMessage, LightVars, 'silent','[I] PCP Kill/Pause detected.'
      endif

      ; handle Major_Update, not frozen, no simulation: rte
      if LightVars.Global.Simulation eq 0 then begin
        ; force Temp Read when not in automatic mode
        if t_para.icry eq 0 then Light_Control, LightVars, LightVars.Instrument.TempReadCommand
      endif
      
      ; Now transfert Mad.t_* structure 'passive' members to dedicated Light variables
      ; 'user','local', ... are updated after edition by Dialog_Fields in Light_Event_Custom_IN6_Edit_Header
      LightVars.Private.ExpTitle    = string(t_para.C_TXT)
      LightVars.Private.UserName    = strcompress(string(t_para.C_USER))
      LightVars.Private.LocalContact= strcompress(string(t_para.C_LC))
      LightVars.Private.Environement= strcompress(string(t_para.ENVIRONMENT),/remove_all)
      LightVars.Private.SubTitle    = strcompress(string(t_para.SUB_TITLE))+' (Env:'+LightVars.Private.Environement+')'
      ; build the current numor.
      if t_res.isodis eq 0 then numor = t_res.num_temp $
      else numor = t_res.lasnum
      numor = strcompress(string(numor),/remove_all)
      numor = numor+' ['
      
      if t_status.count_flag ne 0 then begin
        ; t_res.NPREP current repetition times,  until eq t_res.NREPET
        ; t_res.npmes current point (usually 1), until eq t_res.NKMES
        ; t_nother.COUNT_FLAG: 0='not counting', 1='counting', 2='pause', 3='update', 4:'stop nosave'
        ; t_res.JC: preselection type: 1='time', 2='monitor'
        ; t_res.XC: preselection value (integer)
        numor = numor+strcompress(string(t_res.XC), /remove_all)
        if t_res.JC eq 1 then numor = numor+' Ti' else numor = numor+' Mon'
        numor = numor+', #'+strcompress(string(t_res.NPREP), /remove_all)+'/'+strcompress(string(t_res.NREPET), /remove_all)
        start_time = strsplit(string(t_nother.START_TIME), /extract)
        start_time = start_time(n_elements(start_time)-1)
        numor = numor+', '+start_time
      endif else begin
        stop_time = strsplit(string(t_nother.STOP_TIME), /extract)
        stop_time = stop_time(n_elements(stop_time)-1)
        numor = numor+' ended '+stop_time
      endelse
      numor = numor+']'
      ; detects change of Run numor
      if t_res.lasnum ne LightVars.Mad.t_res.lasnum then begin
        msg = 'Saved Run '+numor+' T='+strcompress(string(t_res.tempea(2)))+' K, " '+strcompress(string(t_para.SUB_TITLE))+'"'
        Light_LogMessage, LightVars, 'normal', msg
      endif

      LightVars.Private.Numor       = numor
      dims      = size(data, /dim)
      ndata     = data(0:(dims(0) -2), *) ; remove last channel = integral
      Monitor   = ndata(*,0)              ; this is Monitor1
      ndata     = ndata(*,t_res.N_MON_SPECT:(t_res.N_TOTAL_SPECT-1)) ; for IN6, remove monitor channels
      detectors = total(ndata,1)          ; Detectors on X (length=340), sum of row
      Temperatures = t_res.tempea
      TReg    = Temperatures(1)
      TSample = Temperatures(2)

      LightVars.Private.MonitorSum  = total(Monitor)
      LightVars.Private.DetectorSum = total(detectors)
      LightVars.Private.TSample     = Tsample
      LightVars.Private.TRegulation = TReg

    endif ; Update_Nb gt 0

    ; will also store new values
  endif ; Major_Flag (startup, or Major_Update or Status changed), also in forzen/simulation mode

  ; on-going SubDial processes ***********************************************
  ; handle on-going run/sequence process
  Light_SubDial_Custom_IN6_Check_Run, LightVars

  ; handle on-going monochromator setting process
  Light_SubDial_Custom_IN6_Check_Monochromators, LightVars

  ; handle on-going chopper setting process
  Light_SubDial_Custom_IN6_Check_Choppers, LightVars

  ; handle on-going check elastic peak process
  Light_SubDial_Custom_IN6_Check_Elastic_Peak, LightVars

  if Major_Flag ne 0  then begin
    ; store Mad variables into LightVars
    if Update_Nb le 1 then begin
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_nother', val= t_nother
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_res'   , val= t_res
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_para'  , val= t_para
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_counts', val= t_counts
      Tools_StructSetValue, struct=LightVars, tag='Mad.t_chopper',val= t_chopper
      Tools_StructSetValue, struct=LightVars, tag='Mad.Data',     val= data
    endif
  endif

end ; PRO Light_Custom_IN6_Collect

;***************************************************************
; compute Lambda, Ei, vi, Ki from last modified field (if valid).
; update Instrument fields from widget handles after edition
; optionally transfert Data from MAD into widgets (when edition of widget is off)
pro Light_Custom_IN6_Setup_Check, LightVars, Changed=Changed, FromMad=FromMad, PhaseSpeed=PhaseSpeed, wavelength=wavelength
; get current widget values

  if widget_info(LightVars.Handles.EnergySetup, /valid_id) eq 0 then return

  Mn     = 1.674928e-27 ; [kg] mass of neutron
  hbar   = 1.054572e-34 ; [Js] h bar Planck constant
  meV    = 1.6021773e-22; [J]
  kTOv   = hbar*1e10/Mn                 ; k   [A-1]    -> v [m/s] constant (629.622)
  k2TOe  = hbar*1e10/Mn/meV/2*1e10*hbar ; k2  [A-2]    -> E [meV] constant (2.07212)

; first look for the Value which is modified from Private.EnergyValues (if valid else return)

  if n_elements(Changed) gt 0 then begin
  ; update Energy values...
    if widget_info(LightVars.Handles.Energy(Changed), /name) eq 'DROPLIST' then begin
      res = widget_info(LightVars.Handles.Energy(Changed), /DROPLIST_select)
      value = Lightvars.Instrument.EnergyDefinitions(res)
    endif else begin
      widget_control, LightVars.Handles.Energy(Changed), get_value=Value
    endelse

    if n_elements(FromMad) gt 0 then Value    = LightVars.Mad.t_para.wave
    if n_elements(wavelength) ne 0 then Value = wavelength

    res = execute('Value = float(Value)')
    if res eq 0 or Value eq 0 then return
    case Changed of
      0: Lambda = Value                       ; lambda
      1: Lambda = sqrt(k2TOe*4*!pi*!pi/Value) ; energy
      2: Lambda = (2*!pi)/Value               ; k
      3: Lambda = (2*!pi*kTOv)/Value          ; v
      else: return
    endcase

    k =(2*!pi)/Lambda
    v = kTOv*abs(k)
    E = k2TOe*k^2
    NewValues = [ Lambda, E, k, v ]

    EnergyTable = ['wavelength','energy','wavevector','velocity']

    ; now constrain energy values following the EnergyOptions fields: look for unit to use
    EnergyUnit = 0
    for index = 0,3 do $
      if strpos(Lightvars.Instrument.EnergyOptions, EnergyTable(index)) ge 0 then EnergyUnit = index

    EnergyValue = NewValues(EnergyUnit)
    ; now set the constrain mode
    tmpe = EnergyValue
    if strpos(Lightvars.Instrument.EnergyOptions, 'limits') ge 0 then begin
      if EnergyValue lt min(Lightvars.Instrument.EnergyDefinitions) then EnergyValue = min(Lightvars.Instrument.EnergyDefinitions)
      if EnergyValue gt max(Lightvars.Instrument.EnergyDefinitions) then EnergyValue = max(Lightvars.Instrument.EnergyDefinitions)
      if tmpe ne EnergyValue then $
        Light_LogMessage, LightVars, 'normal','[w] Constraining '+EnergyTable(EnergyUnit)+' '+string(tmpe)+' within limits: '+strjoin(string(Lightvars.Instrument.EnergyDefinitions))
    endif else if strpos(Lightvars.Instrument.EnergyOptions, 'discrete') ge 0 then begin
      idx=-1 &  tmp1=min(abs(Lightvars.Instrument.EnergyDefinitions-EnergyValue), idx)
      droplist_select = idx
      LightVars.Private.EnergyIndex  = idx
      if Lightvars.Instrument.EnergyDefinitions(idx) ne EnergyValue then begin
        EnergyValue = Lightvars.Instrument.EnergyDefinitions(idx)
        Light_LogMessage, LightVars, 'normal','[w] Constraining '+EnergyTable(EnergyUnit)+' '+string(tmpe)+' to nearest discrete value in ['+strjoin(string(Lightvars.Instrument.EnergyDefinitions))+']'
      endif
    endif
    ; recompute values
    Value = EnergyValue
    case EnergyUnit of
      0: Lambda = Value                       ; lambda
      1: Lambda = sqrt(k2TOe*4*!pi*!pi/Value) ; energy
      2: Lambda = (2*!pi)/Value               ; k
      3: Lambda = (2*!pi*kTOv)/Value          ; v
      else: return
    endcase
    k =(2*!pi)/Lambda
    v = kTOv*abs(k)
    E = k2TOe*k^2
    NewValues = [ Lambda, E, k, v ]

    LightVars.Private.EnergyValues = NewValues
    LightVars.Private.EnergyUnit   = EnergyTable(EnergyUnit)
    LightVars.Private.EnergyToSet  = NewValues(EnergyUnit)

    Lightvars.Private.Elastic_Peak_Chan = Lightvars.Instrument.ElastPeakChannels(LightVars.Private.EnergyIndex)

    ; set widget values
    for index=0,3 do begin
      if widget_info(LightVars.Handles.Energy(index), /name) eq 'DROPLIST' then $
        widget_control, LightVars.Handles.Energy(index), set_droplist_select=droplist_select, Bad_Id=tmp1 $
      else $
        widget_control, LightVars.Handles.Energy(index), set_value=strcompress(string(NewValues(index)), /remove_all), Bad_Id=tmp1
    endfor

    ; update status and window titles
    EnergyStr = strcompress(string(LightVars.Private.EnergyToSet, format='(F4.2)'), /remove_all)
    TitleEner = '['+strupcase(LightVars.Instrument.Name)+'] Setup > Instrument ('+EnergyStr+')'
    TitleChop = '['+strupcase(LightVars.Instrument.Name)+'] Setup > Instrument > Choppers ('+EnergyStr+')'
    TitleMono = '['+strupcase(LightVars.Instrument.Name)+'] Setup > Instrument > Monochromators ('+EnergyStr+')'

    IsReady = 1
    for index=0,2 do begin
      if Value ne LightVars.Instrument.SetupEnergies(index) then begin
        NewStatus = 'Not Set'
        if index eq 0 then TitleChop = '* '+TitleChop
        if index eq 1 then TitleMono = '* '+TitleMono
        IsReady = 0
      endif else begin
        NewStatus = 'Ready'
      endelse
      if LightVars.Instrument.SetupEnergies(index) ne 0 then NewStatus = NewStatus+' ('+strcompress(string(LightVars.Instrument.SetupEnergies(index), format='(F6.2)'), /remove_all)+')'
      widget_control, LightVars.Handles.SetupStatus(index), set_value=NewStatus
      if index eq 0 then begin
        if n_elements(FromMad) ne 0 then NewStatus =  NewStatus+'. Data retrieved from MAD.'
        widget_control, LightVars.Handles.ChoppersButtons(1), set_value=NewStatus, Bad_Id=tmp1
      endif
      if index eq 1 then widget_control, LightVars.Handles.MonokButtons(2),    set_value=NewStatus, Bad_Id=tmp1
    endfor


    if IsReady eq 0 then begin
      TitleEner = '* '+TitleEner
    endif

    widget_control, LightVars.Handles.EnergySetup,   tlb_set_title= TitleEner, Bad_ID=Bad_ID
    widget_control, LightVars.Handles.ChoppersSetup, tlb_set_title= TitleChop, Bad_ID=Bad_ID
    widget_control, LightVars.Handles.MonokSetup,    tlb_set_title= TitleMono, Bad_ID=Bad_ID

    widget_control, LightVars.Handles.SetupButtons(8), set_value= LightVars.Private.Elastic_Peak_Chan, Bad_ID=Bad_ID

  endif ; Changed

  if n_elements(FromMad) ne 0 then begin
    ; get from MAD instrument parameters (choppers, tof)
    ; not updated yet: ReferencePhase
    Mad = LightVars.Mad
    t_para = Mad.t_para
    t_res  = Mad.t_res
    if n_elements(PhaseSpeed) eq 0 then begin
      LightVars.Instrument.ChopperSpeedRatio  = t_para.RAT_CHOPPER
      LightVars.Private.Elastic_Peak_Chan     = t_para.ELPEAK
      LightVars.Instrument.N_channels         = t_para.TOF_CHA_RESOL
      LightVars.Instrument.PhaseOffset        = t_para.DEPH_OFFSET
      ; LightVars.Instrument.Focus_Energy       = t_para.HOMEGA
    endif
    LightVars.Private.Period                = t_para.PERIOD
    LightVars.Private.Delay                 = t_para.TOF_DELAY
    LightVars.Private.SpeedFermiTarget      = t_para.SPE_CHOPPER(0)
    LightVars.Private.PhaseFermiTarget      = t_para.DEPH_CHOPPER(0)
    LightVars.Private.SpeedFermi            = t_res.SPEED_ACT(0)
    LightVars.Private.PhaseFermi            = t_res.PHASE_ACT(0)
    LightVars.Private.SpeedSupprTarget      = t_para.SPE_CHOPPER(1)
    LightVars.Private.PhaseSupprTarget      = t_para.DEPH_CHOPPER(1)
    LightVars.Private.SpeedSuppr            = t_res.SPEED_ACT(1)
    LightVars.Private.PhaseSuppr            = t_res.PHASE_ACT(1)
    LightVars.Private.ChannelWidth          = t_para.CHA_WIDTH

    ; now update associated widgets
    ; chopper/monok/DoElastpeak/auto/stop/focusEn/ChanNb/Ratio/ElPeak
    widget_control, LightVars.Handles.SetupButtons(5), set_value= LightVars.Instrument.Focus_Energy
    widget_control, LightVars.Handles.SetupButtons(7), set_value= LightVars.Instrument.N_channels
    widget_control, LightVars.Handles.SetupButtons(6), set_value= LightVars.Instrument.ChopperSpeedRatio
    widget_control, LightVars.Handles.SetupButtons(8), set_value= LightVars.Private.Elastic_Peak_Chan
    Lightvars.Instrument.ElastPeakChannels(LightVars.Private.EnergyIndex) = LightVars.Private.Elastic_Peak_Chan
  endif else begin
    ; now get value from associated widgets
    ; chopper/monok/DoElastpeak/auto/stop/focusEn/ChanNb/Ratio/ElPeak
    widget_control, LightVars.Handles.SetupButtons(5), get_value= a & LightVars.Instrument.Focus_Energy       = a
    widget_control, LightVars.Handles.SetupButtons(7), get_value= a 
    if a ne LightVars.Instrument.N_channels then begin
      LightVars.Private.Elastic_Peak_Chan = round( LightVars.Private.Elastic_Peak_Chan*(double(a)/LightVars.Instrument.N_channels))
      LightVars.Instrument.N_channels = a
      widget_control, LightVars.Handles.SetupButtons(8), set_value= LightVars.Private.Elastic_Peak_Chan
    endif else begin
      widget_control, LightVars.Handles.SetupButtons(8), get_value= a
      LightVars.Private.Elastic_Peak_Chan     = a
    endelse
    widget_control, LightVars.Handles.SetupButtons(6), get_value= a & LightVars.Instrument.ChopperSpeedRatio  = a

    Lightvars.Instrument.ElastPeakChannels(LightVars.Private.EnergyIndex) = LightVars.Private.Elastic_Peak_Chan

  endelse
  
  ; re-calculate phases, speeds, etc...
  Light_Custom_IN6_Calc_TOF_Choppers, LightVars, Wavelength=LightVars.Private.EnergyToSet

  for index=0,2 do begin
    ; now update AutoFlags
    widget_control, LightVars.Handles.SetupFlags(index), get_value=tmp1
    LightVars.Instrument.AutoFlags(index) = tmp1
  endfor

  ; now put the instrument specific configuration to SU/normal Mode (call InitPro in SU check mode)
  ;** execute Custom InitPro SU check procedure
  Light_Custom_IN6_Sensitive, LightVars

  ; update choppers tables with values
  ThisData = [ LightVars.Private.SpeedFermiTarget, Lightvars.Instrument.ChopperSpeedRatio, $
    LightVars.Private.PhaseFermiTarget, LightVars.Private.PhaseSupprTarget, Lightvars.Instrument.PhaseOffset ]
  widget_control, LightVars.Handles.ChoppersButtons(2), set_value=transpose(ThisData), bad_id=tmp

  ThisData = [ LightVars.Private.Period, LightVars.Private.ChannelWidth, LightVars.Private.DeadTime, LightVars.Private.Delay ]
  widget_control, LightVars.Handles.ChoppersButtons(3), set_value=transpose(ThisData), bad_id=tmp

  ; update Monok table shown on Monok window (if opened already)
  Light_Event_Custom_IN6_Setup_Monochromators, LightVars, /update

end ; PRO Light_Custom_IN6_Setup_Check

;***************************************************************
; choppers and TOF parameters computation
; based on original Fortran code by J. Cook (in6:mad:compute_par.f)
; improved by A. Schober for Light 1.0
; also displays detailed information in text window
pro Light_Custom_IN6_Calc_TOF_Choppers, LightVars, Wavelength=Wavelength, show=show

   ; inputs for computation (from Mad and edit boxes)
  if n_elements(Wavelength) eq 0 then begin
    Wavelength = LightVars.Private.EnergyToSet
  endif

  ; parameters that are obtained from Instrument (may be changed within IN6 Setup Interfaces)
  ratio       = Lightvars.Instrument.ChopperSpeedRatio     ; [1]   speed ratio Fermi/Supp
  homega      = Lightvars.Instrument.Focus_Energy          ; [meV] focusing to specified energy transfert
  el_peak     = Lightvars.Private.Elastic_Peak_Chan     ; [315] Elastic_Peak position
  n_chan      = Lightvars.Instrument.N_channels            ; [512] Number of time channels

  ; other parameters that are obtained from Instrument (usually not changed)
  de          = Lightvars.Instrument.MonokDSpacing         ; [AA] lattice d-spacing for monochromators
  lcc         = Lightvars.Instrument.Distances_CC_CS_SD(0) ; [m] Chopper1-Chopper2 distance
  lce         = Lightvars.Instrument.Distances_CC_CS_SD(1) ; [m] Chopper2-Sample distance
  led         = Lightvars.Instrument.Distances_CC_CS_SD(2) ; [m] Sample-Detector distance
  el_t_resol  = Lightvars.Instrument.ElectronicTimeBase    ; [us] Electronic Time Base
  ref_phas    = Lightvars.Instrument.ReferencePhase        ; [deg] Reference Phase
  phase_offset= Lightvars.Instrument.PhaseOffset           ; [deg] Phase Offset (added to Fermi phase)
  el_delay    = Lightvars.Instrument.ElectronicDelay          ; [us]  Default Electronic Delay

  ; other parameters that are computed
  Mn     = 1.674928e-27 ; [kg] mass of neutron
  hbar   = 1.054572e-34 ; [Js] h bar Planck constant
  meV    = 1.6021773e-22; [J]
  kTOv   = hbar*1e10/Mn                 ; k   [A-1]    -> v [m/s] constant (629.622)
  k2TOe  = hbar*1e10/Mn/meV/2*1e10*hbar ; k2  [A-2]    -> E [meV] constant (2.07212)
  ce     = 1/(kTOv*2*!pi)

  k      =(2*!pi)/Wavelength     ; incident wavevector [AA-1]
  Ezero  = k2TOe*k^2         ; incident energy     [meV]
  if LightVars.Instrument.MonokUseOldValues eq 0 then begin
    Theta  = asin(Wavelength/2/de)  ; Monochromator rotation for Bragg reflexion old=37.66   43.28   49.47   61.55
  endif else begin
    ThetaBlancValues = [37.66, 43.28, 49.47, 61.55]*!pi/180 ; Values of monochromator angles from Y. Blanc, Rap. ILL/83BL21G
    Theta = ThetaBlancValues(LightVars.Private.EnergyIndex)
  endelse
  neut_vel = kTOv*abs(k)

  if abs(homega) gt 0.75*abs(Ezero) then begin
    LightVars.Instrument.Focus_Energy = 0.75*abs(Ezero)
    homega = LightVars.Instrument.Focus_Energy
    widget_control, LightVars.Handles.SetupButtons(5), set_value= homega
    Light_LogMessage, LightVars, 'normal','[w] Focusing Energy transfert should not exceed 3/4 of the incident energy ('+strcompress(string(Ezero))+'). Constraining to '+strcompress(string(homega))

  endif

  ; Here we go...
  aa          = (1-(homega/ezero))^(-1.5)
  aa          = lce+(led*aa)
  bb          = ce*de*cos(theta)
  dd          = 1/(bb*aa)
  speed       = (dd*60)/(2*!pi)
  period      = 0.5e6 * 60 * ratio/speed
  chan_width  = period/n_chan
  chan_width  = fix(chan_width/el_t_resol)*el_t_resol
  dead_time   = period-(n_chan*chan_width)
  time_of_flight = (lcc+lce+led)/neut_vel*1e6
  trav_time   = lcc/neut_vel*1e6
  delta_phase = (trav_time/(period))*180.
  phas_ferm   = ref_phas + delta_phase
  if (ratio mod 2) eq 0 then phas_ferm=2*phas_ferm
  phas_ferm   = phas_ferm + phase_offset
  el_peak_O   = fix((time_of_flight + el_delay)/chan_width)
  delay       =  (el_peak_O-el_peak) * chan_width
  if el_peak ge el_peak_O then delay   =  delay + period
  if delay le 1 then delay = 2

  ; transfert results to LightVars.Private values
  LightVars.Private.Delay             = delay       ; delay                     para.TOF_DELAY=delay
  LightVars.Private.SpeedFermiTarget  = speed       ; Fermi chopper speed para.SPE_CHOPPER(1)
  LightVars.Private.PhaseFermiTarget  = phas_ferm   ; Fermi chopper phase para.DEPH_CHOPPER(1)
  LightVars.Private.SpeedSupprTarget  = speed/ratio ; Suppressor speed    para.SPE_CHOPPER(2)
  LightVars.Private.PhaseSupprTarget  = ref_phas   ; Suppressor phase    para.DEPH_CHOPPER(2)
  LightVars.Private.Period            = period      ; Chopper period (us)       para.PERIOD
  LightVars.Private.ChannelWidth      = chan_width  ; Channel Width (us)        para.CHA_WIDTH
  LightVars.Private.DeadTime          = dead_time

  ; display all computation results as a table

  Values = [ $
  Wavelength, $
  neut_vel, $
  theta*180/!pi, $
  Ezero, $
  homega, $
  trav_time, $
  (lcc+lce+led)/neut_vel*1e6, $
  delay, $
  dead_time, $
  period, $
  chan_width, $
  phas_ferm, $
  ref_phas, $
  speed, $
  speed/ratio, $
  n_chan, $
  el_peak, $
  el_peak_O ]

  Labels    = [ $
  'Wavelength               [AA] ', $
  'Neutron velocity         [m/s]', $
  'Monochr. Bragg angle     [deg]', $
  'Incident Energy          [meV]', $
  'Focusing Energy Transfert[meV]', $
  'Travel time: Fermi/Supp. [us] ', $
  'Travel time: Supp/Det.   [us] ', $
  'TOF Delay                [us] ', $
  'TOF Dead Time            [us] ', $
  'TOF Period (1 cycle)     [us] ', $
  'TOF Channel width        [us] ', $
  'CHOP Fermi Phase         [deg]', $
  'CHOP Suppressor Phase    [deg]', $
  'CHOP Fermi Speed         [rpm]', $
  'CHOP Suppressor Speed    [rpm]', $
  'Number of time channels       ', $
  'Current Elastic Peak Ch.      ', $
  'Elast. peak ch. for 0-delay   ' ]

  ; Now look the Chopper Status bytes
  t_res = LightVars.Mad.t_res
  StatusString = [ $
    'microC program runs       ', $
    'nominal speed achieved    ', $
    'actual phase within gate  ', $
    'magnetic bearing on       ', $
    'DC supply voltage on      ', $
    'drive generator on        ', $
    'drive in DC(stop-) mode   ', $
    'emergency rundown released', $
    'rotor in open position    ' ]

  ThisByte = 1
  for index=1,9 do begin
    if (t_res.Chop_Status[0] and ThisByte) ne 0 then ChopStatStr1 = 'X' else ChopStatStr1 = '.'
    if (t_res.Chop_Status[1] and ThisByte) ne 0 then ChopStatStr2 = 'X' else ChopStatStr2 = '.'
    ToAdd = '  '+ChopStatStr1+'     '+ChopStatStr2+'   '+StatusString[index-1]
    if index eq 1 then ChopStatStr = [ ToAdd ] else ChopStatStr = [ ChopStatStr, ToAdd ]
    ThisByte = ThisByte*2
  endfor
  ; now adds-up the actual Phase and speed for each chopper
  ChopStatStr = [ ChopStatStr, '', '', $
    strcompress(string(t_res.Phase_act[0])), $
    '       '+strcompress(string(t_res.Phase_act[1])), $
    strcompress(string(t_res.speed_act[0])), $
    '       '+strcompress(string(t_res.speed_act[0])), $
    '', '(corresponding to TOF Delay)', '']

  ToDisplay = ['IN6 Chopper/Time of flight calculated settings', 'Date: '+systime(0), '', $
    '** Calculated values                        Fermi/Suppr.:Chopper Status', $
                Labels+string(Values, format='(A13)')+' '+ChopStatStr ]

  widget_control, LightVars.Handles.ChopTofText, set_value=ToDisplay, Bad_ID=Bad_ID

  if Bad_ID ne 0 or LightVars.Handles.ChopTofText eq 0 and n_elements(show) ne 0 then  begin
    xdisplayfile, 'chopperstof.cfg', text=ToDisplay, Group=LightVars.Handles.EnergySetup, $
          title='[IN6] TOF/Choppers', /editable, $
          Height=25,Width=80,Done_Button='Close [Choppers/TOF]', WText=ID
    LightVars.Handles.ChopTofText = ID
  endif

end ; PRO Light_Custom_IN6_Calc_TOF_Choppers

;***************************************************************
;** Display experiment header and send it to mad
pro Light_Event_Custom_IN6_Edit_Header, LightVars

  Header = {Header, User_Name:LightVars.Private.Username,$
            Local_Contact:LightVars.Private.LocalContact,$
            Exp_Title:LightVars.Private.ExpTitle,$
            Environement:LightVars.Private.Environement}

  Dialog_Fields, Header, Group=LightVars.Handles.Base, COLUMN_WIDTHS=300, $
    Name='Please enter new experiment header', Title='Exp. Header in Light', $
    FieldNames = [ 'User Name', 'Local Contact', 'Exp Title', 'Environement Code']

  ;** check if fields where changed, and send modifications to MAD
  Light_Control, LightVars, string(Header.User_Name+' '+Header.Local_Contact, $
                                                        format='(%"'+LightVars.Instrument.SetUserCommand+'")')
  Light_Control, LightVars, string(strtrim(Header.Exp_Title,2),    format='(%"'+LightVars.Instrument.SetTitleCommand+'")')
  Light_Control, LightVars, string(Header.Environement, format='(%"'+LightVars.Instrument.SetEnvirCommand+'")')

end ; PRO Light_Event_Custom_IN6_Edit_Header

;***************************************************************
; stop all in6 setup procedures
pro Light_Event_Custom_IN6_Stop, LightVars, motors=motors, choppers=choppers

  MonokOn    = ''
  ChoppersOn = ''
  CheckElPOn = ''
  RunIsOn    = ''
  if LightVars.Handles.SetupStatus(0) ne 0 then $
    widget_control, LightVars.Handles.SetupStatus(0), get_uvalue=ChoppersOn, bad_id=tmp
  if LightVars.Handles.SetupStatus(1) ne 0 then $
    widget_control, LightVars.Handles.SetupStatus(1), get_uvalue=MonokOn,    bad_id=tmp

  
  if strlen(MonokOn) gt 0 or n_elements(motors) ne 0 then begin
    ; stop Monochromators
    Light_LogMessage, LightVars, 'silent','[I] STOP Monochromators.'
    Light_Control, LightVars, LightVars.Instrument.StopCommand
    widget_control, LightVars.Handles.SetupStatus(1), set_uvalue='', bad_id=tmp
  endif else begin
    if strpos(strupcase(LightVars.Mad.Status), 'COUNTING') ge 0 then begin
      Light_LogMessage, LightVars, 'silent','[I] STOP current counting'
      Light_Control, LightVars, LightVars.Instrument.StopCommand
    endif
  endelse

  if strlen(ChoppersOn) gt 0 or n_elements(choppers) ne 0 then begin
    ; stop Choppers
    Light_LogMessage, LightVars, 'silent','[I] STOP Choppers'
    widget_control, LightVars.Handles.SetupStatus(0), set_uvalue='', bad_id=tmp
    Light_Control, LightVars, LightVars.Instrument.ChoppersStopCommand
  endif
  
  ;stop auto process, check elastic peak
  LightVars.Private.AutoProcess = 0
  widget_control, LightVars.Handles.SetupStatus(2), set_uvalue='', bad_id=tmp
  
  Light_Custom_IN6_Sensitive, LightVars

end ; PRO Light_Event_Custom_IN6_Stop

;***************************************************************
; Defautl displays for IN6
pro Light_Event_Custom_IN6_Default_Displays, LightVars

  OPTIONS    = [ '/log, name_IX="Time_Channels",Name_IY="Detectors", comment="X:TOF,Y:Det."', $
                 'Name_IX="Det", Name_IY="Signal"', 'name_IX="Time_Channels", Name_IY="Signal", /log', $
                 '/catenate, display_name="temperatures", name_IX="Time", Name_IY="Temp"', $
                 '/catenate, display_name="temperatures"', $
                 '/catenate, display_name="temperatures"' ]
  TYPE       = [ 'image', '', '', '', '', '' ]
  VARIABLES  = [ 'data', 'detectors', 'tof', 'TReg', 'TSet', 'TSample' ]
  
  Light_LogMessage, LightVars, 'normal','[I] Default IN6 Displays were installed. They will appear after next Displays Refreshing.'
  
  Tools_StructSetValue, struct=LightVars, Tag='Displays.Variables', val=VARIABLES
  Tools_StructSetValue, struct=LightVars, Tag='Displays.Options',   val=OPTIONS
  Tools_StructSetValue, struct=LightVars, Tag='Displays.Type',      val=TYPE

end ; PRO Light_Event_Custom_IN6_Default_Displays

;*****************************************
; display incident energy/lambda/ki config,
; and enable automatic calibration (monok, choppers, etc...)
; as well as elastic peak range settings
pro Light_Event_Custom_IN6_Setup_Build, LightVars, auto=auto, help=help, wavelength=wavelength, update=update

  if n_elements(help) ne 0 then begin
    ;** Display information about Light/Light_Event_Custom_IN6_Setup_Build

    ToDisplay =['IN6 Instrument settings main window Help in "Light on George"',$
                '',$
                'This window enables to change IN6 Instrument configuration (incident energy,', $
                'monochromators, choppers, and time-of-flight). It displays the incident energy', $
                'being used, or to be changed. Both menu and buttons lead to the display, and', $
                'eventually the modification, of the current settings.', $
                '', $
                '[Auto]', $
                '   performs an automatic energy change for each specified process (when "auto"', $
                '   boxes are checked), in the order (only in SuperUser mode):', $
                '   1-choppers and TOF settings,', $
                '   2-monochromators positioning,', $
                '   3-check of the elastic peak position.', $
                '[Choppers]', $
                '   display Choppers and TOF settings (speed, phase, times), and',$
                '   enable their setting (only in SuperUser Mode)',$
                '   A detailed Choppers/TOF status may be displayed.', $
                '[Monochromators]',$
                '   display Monochromator settings (energy, position), and',$
                '   enable their setting (only in SuperUser Mode)',$
                '[Elastic Peak]',$
                '   measure and display Elastic Peak position',$
                '[STOP]', $
                '   Stop all current settings and countings processes' $
                ]

    widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='IN6 Monochromators Help in Light'
    if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
      xdisplayfile, 'monochromators.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
            title='Monochromators Help in Light', /editable, $
            Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
      LightVars.Handles.Base_Help = ID
    endif

    return
  endif

  ;** Raise existing Energy Setup window
  widget_control, LightVars.Handles.EnergySetup, Bad_ID=Bad_ID, show=1, iconify=0
  ;** If does not exist, make it
  if Bad_ID ne 0 or LightVars.Handles.EnergySetup eq 0 then  begin
    ; build EnergySetup window
    LightVars.Handles.EnergySetup  = widget_base(Group_Leader=LightVars.Handles.Base, $
                      title='['+strupcase(LightVars.Instrument.Name)+'] Setup > Instrument', mbar=Base_Menu, /column)
    ; Menu bar for manual operations
    Base_Run=widget_button(Base_Menu, value='Operations >',             uvalue='Light_Event_Custom_IN6_Setup_Build, LightVars', menu=2)
    tmp1= widget_button(Base_Run,value='SuperUser login...',   uvalue='Light_Event_Base_SuperUser, LightVars, Event=Event')
    LightVars.Handles.SetupButtons(4) = widget_button(Base_Run,value='Automatic setup...', uvalue='Light_Event_Custom_IN6_Setup_Build, LightVars, /auto')
    tmp1= widget_button(Base_Run,value='Choppers setup...',             uvalue='Light_Event_Custom_IN6_Setup_Choppers, LightVars', /  separator)
    tmp1= widget_button(Base_Run,value='Show Choppers detailed status...',uvalue='Light_Custom_IN6_Calc_TOF_Choppers, LightVars,   /show')
    tmp1= widget_button(Base_Run,value='Monochromators setup...',       uvalue='Light_Event_Custom_IN6_Setup_Monochromators, LightVars')
    LightVars.Handles.SetupButtons(9)= widget_button(Base_Run,value='Check elastic peak position...',uvalue='Light_SubDial_Custom_IN6_Check_Elastic_Peak, LightVars, /auto')
    tmp1= widget_button(Base_Run,value='STOP',                          uvalue='Light_Event_Custom_IN6_Stop, LightVars')
    tmp1= widget_button(Base_Run,value='Exit IN6 Setup',                uvalue='widget_control, LightVars.Handles.EnergySetup,   /destroy', /separator)

    Base_Run=widget_button(Base_Menu, value='Help >',                   uvalue='Light_Event_Custom_IN6_Setup_Build, LightVars  ', menu=2)
    tmp1= widget_button(Base_Run,value='About [Instrument setup]', uvalue='Light_Event_Custom_IN6_Setup_Build, LightVars  , /help')
    tmp1= widget_button(Base_Run,value='About [Choppers setup]',        uvalue='Light_Event_Custom_IN6_Setup_Choppers, LightVars, /help', /separator)
    tmp1= widget_button(Base_Run,value='About [Monochromators setup]',  uvalue='Light_Event_Custom_IN6_Setup_Monochromators, LightVars, /help')
    tmp1= widget_button(Base_Run,value='About [Check elastic peak]',    uvalue='Light_SubDial_Custom_IN6_Check_Elastic_Peak, /help')
    ; Incident Energy displays:
    ; we do the same as in Setup_Check, as window build occurs before call to that procedure
    tmp1  = widget_base(LightVars.Handles.EnergySetup, /row, frame=1)
    XSize = 7

    Titles=['Wavelength [AA]', 'Energy [meV]', 'Wavevector [AA-1]', 'Velocity [m/s]']
    for index=0,3 do begin
      ThisEnergyTitle = strsplit(Titles(index), /extract)
      ThisEnergyTitle = ThisEnergyTitle(0)
      if strpos(Lightvars.Instrument.EnergyOptions, 'discrete') ge 0 $
         and strpos(Lightvars.Instrument.EnergyOptions, strlowcase(ThisEnergyTitle)) ge 0 then begin
        tmp2 = widget_base(tmp1, /column)
        tmp3 = widget_label(tmp2, value=Titles(index))
        LightVars.Handles.Energy(index)  = widget_droplist(tmp2, value=string(Lightvars.Instrument.EnergyDefinitions), $
          uvalue  ='Light_Custom_IN6_Setup_Check, LightVars, Changed='+strcompress(string(index),/remove_all), title='')
      endif else LightVars.Handles.Energy(index)  = cw_field(tmp1, title=Titles(index), value  = 0, xsize=XSize,  $
        uvalue  ='Light_Custom_IN6_Setup_Check, LightVars, Changed='+strcompress(string(index),/remove_all), /column, /return_events, floating=1)
    endfor

    ; auto setup button
    LightVars.Handles.SetupButtons(3)= widget_button(tmp1, value='Auto Setup', uvalue='Light_Event_Custom_IN6_Setup_Build, LightVars, /auto')
    tmp1 = widget_button(tmp1,value=' STOP ', uvalue='Light_Event_Custom_IN6_Stop, LightVars')
    ; Monok/Choppers/Elastic peak setup
    tmp1     = widget_base(LightVars.Handles.EnergySetup, /column, frame=1)

    Base_r  = widget_base(tmp1, /row) ; Choppers: button+status+auto flag
    LightVars.Handles.SetupButtons(0)= widget_button(Base_r, value='Choppers', xsize=100, uvalue='Light_Event_Custom_IN6_Setup_Choppers, LightVars')
    LightVars.Handles.SetupStatus(0) = widget_label(Base_r, value='Not set (x.xx)  ', uvalue='')
    LightVars.Handles.SetupFlags(0)  = cw_bgroup(Base_r, label_left='',/row,$
        ['Auto'], /nonexclusive, uvalue='Light_Custom_IN6_Setup_Check, LightVars', set_value=LightVars.Instrument.AutoFlags(0))
    LightVars.Handles.SetupButtons(5)  = cw_field(Base_r, title='', value = 0., xsize=10,  $
        uvalue  ='Light_Custom_IN6_Setup_Check, LightVars', /row, /all_events, floating=1)
    tmp = widget_label(Base_r, value='Focus Energy Transfert [meV]')

    Base_r  = widget_base(tmp1, /row) ; Monochromators: button+status+auto flag
    LightVars.Handles.SetupButtons(1)= widget_button(Base_r, value='Monochromators', xsize=100, uvalue='Light_Event_Custom_IN6_Setup_Monochromators, LightVars')
    LightVars.Handles.SetupStatus(1) = widget_label(Base_r, value='Not set (x.xx)  ', uvalue='')
    LightVars.Handles.SetupFlags(1)  = cw_bgroup(Base_r, label_left='',/row,$
        ['Auto'], /nonexclusive, uvalue='Light_Custom_IN6_Setup_Check, LightVars', set_value=LightVars.Instrument.AutoFlags(1))
    LightVars.Handles.SetupButtons(7)  = cw_field(Base_r, title='', value = 0, xsize=4,  $
        uvalue  ='Light_Custom_IN6_Setup_Check, LightVars', /row, /return_events, integer=1)
    tmp = widget_label(Base_r, value='Channel Nb.   ')
    LightVars.Handles.SetupButtons(6)  = cw_field(Base_r, title='', value = 0, xsize=2,  $
        uvalue  ='Light_Custom_IN6_Setup_Check, LightVars', /row, /all_events, integer=1)
    tmp = widget_label(Base_r, value='Ratio [1-6]')


    Base_r  = widget_base(tmp1, /row) ; Elastic: button+status+auto flag
    LightVars.Handles.SetupButtons(2)= widget_button(Base_r, value='Elastic Peak', xsize=100, uvalue='Light_SubDial_Custom_IN6_Check_Elastic_Peak, LightVars, /auto')
    LightVars.Handles.SetupStatus(2) = widget_label(Base_r, value='Not set (x.xx)  ', uvalue='')
    LightVars.Handles.SetupFlags(2)  = cw_bgroup(Base_r, label_left='',/row,$
        ['Auto'], /nonexclusive, uvalue='Light_Custom_IN6_Setup_Check, LightVars', set_value=LightVars.Instrument.AutoFlags(2))
    LightVars.Handles.SetupButtons(8)  = cw_field(Base_r, title='', value = 0, xsize=4,  $
        uvalue  ='Light_Custom_IN6_Setup_Check, LightVars', /row, /all_events, integer=4)
    tmp = widget_label(Base_r, value='Elastic Peak Ch.  ')

    widget_control, LightVars.Handles.EnergySetup, /realize
    XManager, 'Base_Options', LightVars.Handles.EnergySetup, Event_Handler='Light_Base_Event_Parser', $
        /just_reg, /no_block
    Light_Custom_IN6_Setup_Check, LightVars, Changed=0, /FromMad

    ; now put the instrument specific configuration to SU/normal Mode (call InitPro in SU check mode)
    ;** execute Custom InitPro SU check procedure
    Light_Custom_IN6_Sensitive, LightVars
    
    Light_Event_Custom_IN6_Setup_Build, LightVars  , /help, /update
  endif

  ; is there an auto proces to start...
  if n_elements(auto) ne 0 and LightVars.Private.AutoProcess eq 0 then begin
    ; update values before action
    if n_elements(Wavelength) eq 0 then Wavelength = LightVars.Private.EnergyToSet
    Light_Custom_IN6_Setup_Check, LightVars, Changed=0, wavelength=wavelength
    
    if ((LightVars.Private.IsSuperUser eq 0 and strpos(Lightvars.Instrument.EnergyOptions, 'superuser') lt 0) $
    or (LightVars.Private.IsSuperUser eq 1)) then begin
      ; SU/normal extended mode: we can launch auto settings -> chopper+monochromators positioning
      ; normally, only runs (at Wavelength change) and active 'auto' button may get there
      Light_LogMessage, LightVars, 'normal','[I] Starting Auto Setup process for '+strcompress(string(Wavelength))
      LightVars.Private.AutoProcess = 1
      Light_Event_Custom_IN6_Setup_Choppers, LightVars, /auto
    endif
  endif

end ; PRO Light_Event_Custom_IN6_Setup_Build

;***************************************************************
; choppers setting window.
pro Light_Event_Custom_IN6_Setup_Choppers, LightVars, Wavelength=Wavelength, update=update, auto=auto, help=help

  if n_elements(help) ne 0 then begin
    ;** Display information about Light/Light_Event_Custom_IN6_Setup_Choppers

    ToDisplay =['IN6 Choppers settings Help in "Light on George"',$
                '',$
                'This window dialog enables to compute and set the IN6 Choppers and', $
                'Time-Of-Flight settings. It displays the current configuration, with the', $
                'wavelength that is currently used on the instrument or a new value that was', $
                'changed by the user.', '', $
                'IN6 neutron beam that exits from the 3 Monochromators first encounters the', $
                'Fermi chopper (horizontal rotating collimator), and then passes trough the', $
                'Suppressor chopper (classical disk chopper), that removes higher order and', $
                'background signal.', $
                '', $
                'The Status line on top of the window indicates if the choppers are set for', $
                'the selected wavelength', '', $
                '[Details...] Displays full choppers/TOF settings', $
                '[Set]        Sets the choppers parameters, wait for stabilisation, and finally', $
                '             sets TOF parameters. This button is only active in SuperUser mode.', $
                '[STOP]       Stop all current settings and countings processes' $
                ]

    widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='IN6 Choppers Help in Light'
    if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
      xdisplayfile, 'choppers.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
            title='Choppers Help in Light', /editable, $
            Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
      LightVars.Handles.Base_Help = ID
    endif

    return
  endif

  if n_elements(Wavelength) eq 0 then begin
    Wavelength = LightVars.Private.EnergyToSet
  endif

  Title = '['+strupcase(LightVars.Instrument.Name)+'] Setup > Instrument > Choppers ('+strcompress(string(Wavelength, format='(F6.2)'), /remove_all)+')'
  ; display Chopper values for current wavelength+buttons Rocking curve/position
  widget_control, LightVars.Handles.ChoppersSetup, Bad_ID=Bad_ID, iconify=0 ;, tlb_set_title=Title
  ;** If does not exist, make it
  if Bad_ID ne 0 or LightVars.Handles.ChoppersSetup eq 0 then begin
    ; do not build if table update was requested, but choppers window is not there...
    if n_elements(update) ne 0 then if update ne 0 then return
    ; build ChoppersSetup window
    LightVars.Handles.ChoppersSetup  = widget_base(Group_Leader=LightVars.Handles.EnergySetup, $
                      title=Title, /column)
    tmp1 = widget_base(LightVars.Handles.ChoppersSetup, /row)
    LightVars.Handles.ChoppersButtons(1) = widget_label(tmp1, value='Choppers Setup: Starting interface                               ')
    tmp = widget_button(tmp1, value='Details...', uvalue='Light_Custom_IN6_Calc_TOF_Choppers, LightVars, /show')
    LightVars.Handles.ChoppersButtons(0) = widget_button(tmp1,value=' Set ', uvalue='Light_Event_Custom_IN6_Setup_Choppers, LightVars, /auto')
    tmp1= widget_button(tmp1, value='STOP', uvalue='Light_Event_Custom_IN6_Stop, LightVars')

    tmp1 = widget_base(LightVars.Handles.ChoppersSetup, /row)
    ThisData = [ LightVars.Private.SpeedFermiTarget, Lightvars.Instrument.ChopperSpeedRatio, $
      LightVars.Private.PhaseFermiTarget, LightVars.Private.PhaseSupprTarget, Lightvars.Instrument.PhaseOffset ]

    LightVars.Handles.ChoppersButtons(2) = widget_table(tmp1, /all_events, $
      column_labels= ['Choppers'], $
      row_labels   = ['Speed Fermi [rpm]', 'Ratio Supp./Fermi', 'Phase Fermi [deg]', 'Phase Sup. [deg]', 'Offset'], $
      value = transpose(ThisData), alignment=1, uvalue='') ; no callback because if edited, SU will force to its own values

    ThisData = [ LightVars.Private.Period, LightVars.Private.ChannelWidth, LightVars.Private.DeadTime, LightVars.Private.Delay ]
    LightVars.Handles.ChoppersButtons(3) = widget_table(tmp1, /all_events, $
      column_labels= ['Time-Of-Flight'],$
      row_labels   = ['Period [us]', 'Channel Width [us]', 'Dead Time [us]', 'Delay [us]'], $
      value = transpose(ThisData), alignment=1, uvalue='') ; no callback because if edited, SU will force to its own values

    widget_control, LightVars.Handles.ChoppersSetup, /realize
    XManager, 'ChoppersSetup', LightVars.Handles.ChoppersSetup, Event_Handler='Light_Base_Event_Parser', $
        /just_reg, /no_block
        
    Light_Event_Custom_IN6_Setup_Choppers, LightVars, /help, /update
  endif
  ; display Status (Not set, ready, auto) from Status line in Setup window
  widget_control, LightVars.Handles.SetupStatus(0), get_value=Status

  ; Status line: look for unit to use
  Status = Status+'. '+LightVars.Private.EnergyUnit+'='+strcompress(string(Wavelength, format='(F6.2)'), /remove_all)
  ; if EnergyOptions=superuser and not SU then add message in Status
  if strpos(Lightvars.Instrument.EnergyOptions, 'superuser') ge 0 and LightVars.Private.IsSuperUser eq 0 then $
    Status = Status+'. Switch to SU mode for action'
  widget_control, LightVars.Handles.ChoppersButtons(1), set_value=Status

  Light_Custom_IN6_Sensitive, LightVars

  ; now look if we start settings...
  a = ''
  widget_control, LightVars.Handles.SetupStatus(0), get_uvalue =a, bad_id=tmp
  if n_elements(auto) ne 0 then begin
    if strlen(a) eq 0 then widget_control, LightVars.Handles.SetupStatus(0), set_uvalue = 'start', set_value='start', bad_id=tmp $
    else Light_LogMessage, LightVars, 'normal','[w] IN6 Choppers setting is already running !'
  endif

end ; PRO Light_Event_Custom_IN6_Setup_Choppers

;***************************************************************
; monochromators setting window. 
pro Light_Event_Custom_IN6_Setup_Monochromators, LightVars, Wavelength=Wavelength, rocking=rocking, position=position, update=update, help=help
; **

  if n_elements(help) ne 0 then begin
    ;** Display information about Light/Light_Event_Custom_IN6_Setup_Monochromators

    ToDisplay =['IN6 Monochromator settings Help in "Light on George"',$
                '',$
                'This window dialog enables to calibrate and set the IN6 Monochromator.', $
                'It displays the current position and rocking curve scans configuration, or a', $
                'new value that was changed by the user.', '', $
                'IN6 neutron beam exiting from the cold neutron guide illuminates three', $
                'monochromators mounted in series. Each of them reflects a monochromatic part', $
                'of the beam, occording to the Bragg law.', $
                'The three PG002 curved multiple blades monochromtors focus to the sample', $
                'position, and these 3 beams (that have slightly different energies) are', $
                'chopped by the Fermi and Suppressor choppers, before coming to the sample.', $
                '', $
                'The Status line on top of the window indicates if the monochromators are set', $
                'for the selected wavelength', '', $
                '[Rocking Curve] Starts a rocking curve process for each monochromator,', $
                '                computes maximum reflected flux position and position', $
                '                the monochromators there. These data are stored for further', $
                '                direct positionings. A plot showing the 3 monochromator', $
                '                reflected beam rocking curve. This button is only active in', $
                '                SuperUser mode (Light:Setup menu:SuperUser login)', $
                '[Position]      Position the monochromators according to a previously', $
                '                calibrated maximum flux table obtained from a rocking curve.', $
                '[STOP]          Stop all current settings and countings processes' $
                ]

    widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='IN6 Monochromators Help in Light'
    if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
      xdisplayfile, 'monochromators.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
            title='Monochromators Help in Light', /editable, $
            Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
      LightVars.Handles.Base_Help = ID
    endif

    return
  endif

  ; determine if wavelength was changed (need positioning ?) and if choppers are already set (to get signal !)
  if n_elements(Wavelength) eq 0 then begin
    Wavelength = LightVars.Private.EnergyToSet
  endif
  ; get the table section corresponding to the wavelength to set
  idx=-1 &  tmp1=min(abs(LightVars.Instrument.EnergyDefinitions-Wavelength), idx)
  Wavelength = LightVars.Instrument.EnergyDefinitions(idx)

  Data = LightVars.Instrument.MonokData
  Data = reform(Data, 5, n_elements(LightVars.Instrument.MonokSequence), n_elements(LightVars.Instrument.EnergyDefinitions))
  ThisData = data(*,*,idx)

  Title = '['+strupcase(LightVars.Instrument.Name)+'] Setup > Instrument > Monochromators ('+strcompress(string(Wavelength, format='(F6.2)'), /remove_all)+')'
  ; display Monok table for current wavelength+buttons Rocking curve/position
  widget_control, LightVars.Handles.MonokSetup, Bad_ID=Bad_ID, iconify=0  ; , tlb_set_title=Title
  ;** If does not exist, make it
  if Bad_ID ne 0 or LightVars.Handles.MonokSetup eq 0 then begin
    ; do not build if table update was requested, but Monok window is not there...
    if n_elements(update) ne 0 then if update ne 0 then return
    ; build MonokSetup window
    LightVars.Handles.MonokSetup  = widget_base(Group_Leader=LightVars.Handles.EnergySetup, $
                      title=Title, /column)
    tmp1 = widget_base(LightVars.Handles.MonokSetup, /row)
    LightVars.Handles.MonokButtons(2) = widget_label(tmp1, value='Monochromators Setup: Starting interface                   ')
    LightVars.Handles.MonokButtons(0) = widget_button(tmp1,value='Rocking Curve', uvalue='Light_Event_Custom_IN6_Setup_Monochromators, LightVars, /rocking')
    LightVars.Handles.MonokButtons(1) = widget_button(tmp1,value='Position',      uvalue='Light_Event_Custom_IN6_Setup_Monochromators, LightVars, /position')
    tmp1= widget_button(tmp1, value='STOP', uvalue='Light_Event_Custom_IN6_Stop, LightVars')

    LightVars.Handles.MonokButtons(3) = widget_table(LightVars.Handles.MonokSetup, /editable, /all_events, $
      column_labels= ['Center','Range','Duration[s]','Step Width','Optimum Value'],$
      row_labels   = ['Mono1', 'Mono2','Mono3'], value = ThisData, alignment=1, uvalue='')

    widget_control, LightVars.Handles.MonokSetup, /realize
    XManager, 'MonokSetup', LightVars.Handles.MonokSetup, Event_Handler='Light_Base_Event_Parser', $
        /just_reg, /no_block
    Light_Event_Custom_IN6_Setup_Monochromators, LightVars, /help, /update
  endif
  widget_control, LightVars.Handles.MonokButtons(3), set_value=ThisData
  ; display Status (Not set, ready, auto) from Status line in Setup window
  widget_control, LightVars.Handles.SetupStatus(1),  get_value=Status

  ; Status line: look for unit to use
  Status = Status+'. '+LightVars.Private.EnergyUnit+'='+strcompress(string(Wavelength, format='(F6.2)'), /remove_all)
  ; if EnergyOptions=superuser and not SU then add message in Status
  if strpos(Lightvars.Instrument.EnergyOptions, 'superuser') ge 0 and LightVars.Private.IsSuperUser eq 0 then $
    Status = Status+'. Switch to SU mode for action'
  widget_control, LightVars.Handles.MonokButtons(2), set_value=Status

  Light_Custom_IN6_Sensitive, LightVars

  ; return if only table update was requested (energy change -> update table)
  if n_elements(update) ne 0 then return

  if Wavelength ne LightVars.Instrument.SetupEnergies(0) then begin
    ; chopper energy is not set yet
    Light_Base_Alert, Lightvars, warning='Choppers not set'
    Light_LogMessage, LightVars, 'normal','[I] Please set choppers for '+strcompress(string(Wavelength), /remove_all)+' before monochromators'
    ; activate Light Warning
    ; add warning into Light Log
    return
  endif

  ; return when no action is requested
  if n_elements(rocking) eq 0 and n_elements(position) eq 0 then return
  
  ; now look if we start settings...
  a = ''
  widget_control, LightVars.Handles.SetupStatus(1), get_uvalue =a, bad_id=tmp

  if strlen(a) eq 0 then begin
    MonoUValue = ''
    if n_elements(rocking) ne 0  then MonoUValue = 'start rocking'
    if n_elements(position) ne 0 then MonoUValue = 'start positioning'
    ; if non empty, then initialise Data table at required wavelength
    Tools_StructSetValue, struct=LightVars, Tag='Private.MonokLambdaData',val=ThisData
    widget_control, LightVars.Handles.SetupStatus(1), set_uvalue = MonoUValue, set_value=MonoUValue, bad_id=tmp
    ; set StatusValue to 0.00 (so that Monok remains unset in case of error during positioning)
    LightVars.Instrument.SetupEnergies(1) = 0
  endif else Light_LogMessage, LightVars, 'normal','[w] IN6 Monochromators setting is already running !'


end ; PRO Light_Event_Custom_IN6_Setup_Monochromators

;***************************************************************
; choppers setting window: on going operation handling
pro Light_SubDial_Custom_IN6_Check_Choppers, LightVars

  Wavelength = LightVars.Private.EnergyToSet
  
  ChopUValue = ''
  ; we use the same philosophy as in usual dials, inside Light. We monitor the uvalue of the Chopper status
  widget_control, LightVars.Handles.SetupStatus(0), get_uvalue = ChopUValue, bad_id=tmp    ; choppers

  if strlen(ChopUValue) eq 0 then return

  ; test if MAD is Idle before doing anything
  if strpos(ChopUValue, 'start') ge 0 and strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    Light_LogMessage, LightVars, 'normal','[w] Instrument control (MAD) is not ready (doing '+LightVars.Mad.Status+'). Ignoring Choppers operation. If MAD is blocked in non-Idle state, launch a short counting.'
    widget_control, LightVars.Handles.SetupStatus(0), set_uvalue = '', bad_id=tmp
    return
  endif
  if strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    ; MAD Status should be either Idle, or a CHOPPER SETTING, or a WAVELENGTH SETTING
    Light_Custom_IN6_Setup_Check, LightVars, /FromMad, /PhaseSpeed
    if strpos(strupcase(LightVars.Mad.Status), 'CHOPPER SETTING') lt 0 and strpos(strupcase(LightVars.Mad.Status), 'WAVELENGTH SETTING') lt 0 then begin
      ; conflict with an other operation: stop process.
      Light_Base_Alert, LightVars, warning='Choppers conflict:'+LightVars.Mad.Status
      Light_LogMessage, LightVars, 'normal','[E] The instrument is doing '+LightVars.Mad.Status+' which prevents Choppers setting. Aborting. If MAD is blocked in non-Idle state, launch a short counting.'
      widget_control, LightVars.Handles.SetupStatus(0), set_uvalue = '', bad_id=tmp    ; choppers
      return
    endif else begin
      ; blink table
      if LightVars.Private.ErrorMsgToggle eq 0 then widget_control, LightVars.Handles.ChoppersButtons(2), SET_TABLE_SELECT=[-1, -1, -1, -1], bad_id=tmp1 $
      else widget_control, LightVars.Handles.ChoppersButtons(2), SET_TABLE_SELECT=[0, 0, 0, 5], bad_id=tmp1
    endelse
  endif else begin
    ; MAD is Idle
    widget_control, LightVars.Handles.SetupStatus(0),     set_value=ChopUValue, bad_id=tmp
    widget_control, LightVars.Handles.ChoppersButtons(1), set_value=ChopUValue, bad_id=tmp
    case ChopUValue of
    'start':  $
      begin
        widget_control, LightVars.Handles.SetupStatus(0), set_value= 'par chop', bad_id=tmp
        Light_LogMessage, LightVars, 'normal','[I] Starting IN6 Choppers setting for '+strcompress(string(Wavelength, format='(F6.2)'))
        Light_Control, LightVars, string('off', format='(%"'+LightVars.Instrument.SetComputeCommand+'")')
        Light_Control, LightVars, string(Wavelength, format='(%"'+LightVars.Instrument.EnergyCommand+'")')
        Light_Control, LightVars, string(LightVars.Private.SpeedFermiTarget, LightVars.Instrument.ChopperSpeedRatio, $
            LightVars.Private.PhaseFermiTarget, LightVars.Private.PhaseSupprTarget, $
            format='(%"'+LightVars.Instrument.ChoppersSetCommand+'")')
            ; LightVars.Instrument.PhaseOffset, 
        widget_control, LightVars.Handles.ChoppersButtons(2), SET_TABLE_SELECT=[0, 0, 0, 5], bad_id=tmp1
        widget_control, LightVars.Handles.ChoppersButtons(3), SET_TABLE_SELECT=[-1, -1, -1, -1], bad_id=tmp1
        Light_Control, LightVars, LightVars.Instrument.ChoppersSynchro
        ChopUValue = 'chop synchro wait'
      end
    'chop synchro wait': $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Achieved Choppers synchronisation'
        ChopUValue = 'par tof'
      end
    'par tof': $
      begin
        Light_Control, LightVars, string(LightVars.Instrument.N_channels, LightVars.Private.ChannelWidth, $
            LightVars.Private.Delay, format='(%"'+LightVars.Instrument.TOFSetCommand+'")')
        Light_Control, LightVars, string(LightVars.Private.Elastic_Peak_Chan, format='(%"'+LightVars.Instrument.ElPeakCommand+'")')
        Light_Control, LightVars, string(LightVars.Private.Period, format='(%"'+LightVars.Instrument.PeriodCommand+'")')
        widget_control, LightVars.Handles.ChoppersButtons(3), SET_TABLE_SELECT=[0, 0, 0, 4], bad_id=tmp1
        widget_control, LightVars.Handles.ChoppersButtons(2), SET_TABLE_SELECT=[-1, -1, -1, -1], bad_id=tmp1
        ChopUValue = 'end'
      end
    'end': $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Achieved TOF/Choppers settings'
        Light_Custom_IN6_Setup_Check, LightVars, changed=0, /FromMad
        widget_control, LightVars.Handles.ChoppersButtons(3), SET_TABLE_SELECT=[-1, -1, -1, -1], bad_id=tmp1
        widget_control, LightVars.Handles.ChoppersButtons(2), SET_TABLE_SELECT=[-1, -1, -1, -1], bad_id=tmp1
        ; now update SetupEnergies
        LightVars.Instrument.SetupEnergies(0) = Wavelength
        ChopUValue = ''
        ; if auto process is on then start monochromators
        if LightVars.Private.AutoProcess gt 0 then begin
          ; close choppers window
          widget_control, LightVars.Handles.ChoppersSetup, Bad_ID=Bad_ID, /destroy
          ; launch monok settings
          Light_Event_Custom_IN6_Setup_Monochromators, LightVars, /position
        endif
      end
    else:
    endcase

    widget_control, LightVars.Handles.SetupStatus(0), set_uvalue=ChopUValue, bad_id=tmp
    if strlen(ChopUValue) ne 0 then begin
      Light_Custom_IN6_Setup_Check, LightVars, /FromMad, /PhaseSpeed
    endif else Light_Custom_IN6_Setup_Check, LightVars, changed=0, /FromMad
  endelse ; if strpos(LightVars.Mad.Status, 'Idle') lt 0

end ; PRO Light_SubDial_Custom_IN6_Check_Choppers

;***************************************************************
; handle monochromators setting process: on going operation handling
pro Light_SubDial_Custom_IN6_Check_Monochromators, LightVars, Wavelength=Wavelength
; **

  if n_elements(Wavelength) eq 0 then begin
    Wavelength = LightVars.Private.EnergyToSet
  endif
  
  MonokUValue = ''
  ; we use the same philosophy as in usual dials, inside Light. We monitor the uvalue of the MonokUValue status
  widget_control, LightVars.Handles.SetupStatus(1), get_uvalue = MonokUValue, bad_id=tmp    ; MonokUValue

  if strlen(MonokUValue) eq 0 then return

  ; test if MAD is Idle before doing anything
  if strpos(MonokUValue, 'start') ge 0 and strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    Light_LogMessage, LightVars, 'normal','[w] Instrument control (MAD) is not ready (doing '+LightVars.Mad.Status+'). Ignoring Monochromators operation. If MAD is blocked in non-Idle state, launch a short counting.'
    widget_control, LightVars.Handles.SetupStatus(1), set_uvalue = '', bad_id=tmp
    return
  endif
  Data = LightVars.Private.MonokLambdaData
  idx  = LightVars.Instrument.MonokSequence(LightVars.Private.MonokCurrentIndex) ; monok ID (0,1,2)
  if strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    ; MAD Status should be either Idle, POSITIONNING, or COUNTING
    if strpos(strupcase(LightVars.Mad.Status), 'POSITIONNING') lt 0 and strpos(strupcase(LightVars.Mad.Status), 'COUNTING') lt 0 then begin
      ; conflict with an other operation: stop process.
      Light_Base_Alert, LightVars, warning='Monochromators conflict:'+LightVars.Mad.Status
      Light_LogMessage, LightVars, 'normal','[E] The instrument is doing '+LightVars.Mad.Status+' which prevents Monochromators setting. Aborting. If MAD is blocked in non-Idle state, launch a short counting.'
      widget_control, LightVars.Handles.SetupStatus(1), set_uvalue = '', bad_id=tmp    ; Monochromators
      return
    endif else begin
      ; display current Lightvars.Mad.t_nother.actang(x) value in last column of Table
      ActData = Data
      ActData(4,idx) = Lightvars.Mad.t_nother.actang(idx)
      ; update table values in widget
      widget_control, LightVars.Handles.MonokButtons(3), set_value=ActData
    endelse
  endif else begin
    ; MAD is Idle
    n_step = long(Data(1, idx)/Data(3, idx))  ; range/step_width
    ProcessStep = strsplit(MonokUValue, ':', /extract)
    widget_control, LightVars.Handles.SetupStatus(1),  set_value=ProcessStep(0), bad_id=tmp
    widget_control, LightVars.Handles.MonokButtons(2), set_value=MonokUValue, bad_id=tmp
    case ProcessStep(0) of
    'start rocking':  $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Starting IN6 Monochromators Rocking Curve for '+strcompress(string(Wavelength, format='(F6.2)'))
        MonokUValue = 'RAZ (rocking)'
      end
    'start positioning':  $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Starting IN6 Monochromators Positioning for '+strcompress(string(Wavelength, format='(F6.2)'))
        MonokUValue = 'RAZ (positioning)'
      end
    'RAZ (rocking)': $
      begin
        Light_LogMessage, LightVars, 'normal','[ ] Sending all monochromators to lower switch limit (reference point, before rocking curve)'
        if LightVars.Global.Simulation ne 0 then R=TstControl(LightVars.Instrument.MonokRAZCommand) $
        else R=Light_Control(LightVars.Instrument.MonokRAZCommand)
        widget_control,LightVars.Handles.MonokButtons(3),SET_TABLE_SELECT=[0, 0, 4, n_elements(LightVars.Instrument.MonokSequence)], bad_id=tmp1
        LightVars.Private.MonokCurrentIndex = 0L
        LightVars.Private.MonokScanPoint    = 0L
        LightVars.Private.MonokDisplayMsg(0)= ''
        LightVars.Private.MonokDisplayMsg(1)= ''
        LightVars.Private.MonokDisplayMsg(2)= ''
        idx  = LightVars.Instrument.MonokSequence(LightVars.Private.MonokCurrentIndex)
        MonokUValue = 'rotate monochromators: mono'+strcompress(string(idx+1))+', scan step '+strcompress(string(LightVars.Private.MonokScanPoint))+'/'+strcompress(string(n_step))
      end
    'rotate monochromators': $
      begin
        ; send positioning command for monochromator in sequence
        ; position = (center-range/2) + MonokScanPoint*step_width
        position = (Data(0, idx) - Data(1, idx)/2.0) + LightVars.Private.MonokScanPoint*Data(3, idx)
        LightVars.Private.MonokPosition = position
        value=string(idx+1, position, format='(%"'+LightVars.Instrument.MonokSetCommand+'")')
        if LightVars.Global.Simulation ne 0 then R=TstControl(value) $
        else R=Light_Control(value)
        MonokUValue = 'count: after '+value+' (mono'+strcompress(string(idx+1))+', scan step '+strcompress(string(LightVars.Private.MonokScanPoint))+'/'+strcompress(string(n_step))+')'
        ActData = Data
        ActData(4,idx) = position
        ; update table values in widget
        widget_control, LightVars.Handles.MonokButtons(3), SET_TABLE_SELECT=[0, idx, 4, idx], bad_id=tmp1, set_value=ActData
      end        
    'count': $
      begin
        ; send count command
        value=string(Data(2, idx), format='(%"'+LightVars.Instrument.MonokCntCommand+'")')
        if LightVars.Global.Simulation ne 0 then R=TstControl(value) $
        else R=Light_Control(value)
        MonokUValue = 'get count: after '+value+' (mono'+strcompress(string(idx+1))+', scan step '+strcompress(string(LightVars.Private.MonokScanPoint))+'/'+strcompress(string(n_step))+')'
      end
    'get count': $
      begin
        ; get count value
        if LightVars.Global.Simulation ne 0 then R=TstNewValue(type='monitor') $
        else begin
          ; use counts retrieved from last Data Collect
          ; get detectors, integrate over detectors (length=tof channels-1, last=integral)
          Mad       = LightVars.Mad
          t_res     = Mad.t_res
          data      = Mad.Data
          ; now specialised aliases for IN6 ************************************************
          dims      = size(data, /dim)
          data     = data(0:(dims(0) -2), *)  ; removes last channel (= integral)
          Monitor  = data(*,0)                ; this is Monitor1
          tof      = total(data(*,t_res.N_MON_SPECT:(t_res.N_TOTAL_SPECT-1)),2) 
          if LightVars.Instrument.MonokFluxMon_TOF ne 0 then R=total(tof) $   ; if we calibrate monochromators on Detectors flux optimum 
          else R=total(Monitor)  ; if we calibrate monochromators on Monitor flux optimum
          ; 
        endelse
        ; store [LightVars.Private.MonokPosition, count] for further fitting
        x = [LightVars.Private.MonokX, LightVars.Private.MonokPosition]
        y = [LightVars.Private.MonokY, R]
        if LightVars.Private.MonokScanPoint eq 0 then begin
          Light_LogMessage, LightVars, 'normal','[ ] Now scanning Monochromator '+strcompress(string(idx+1))
          if LightVars.Private.MonokCurrentIndex eq 0 then begin
            x = LightVars.Private.MonokPosition
            y = R
            ; will clear any Rocking_Curve previous display
            display, Display_Name='Rocking_Curve', /delete
          endif
        endif
        
        Tools_StructSetValue, struct=LightVars,  Tag='Private.MonokX',val=x
        Tools_StructSetValue, struct=LightVars,  Tag='Private.MonokY',val=y
        ; display current [position, count] on Dial_Display
        display, IX=x, Data=y, Name_Data='Mono', Display_Name='Rocking_Curve', $
          Name_IX='Position', Name_IY='Counts', /scatter, /detached, /update
        ; if LightVars.Private.MonokScanPoint le n_step=long(range/step_width) then go to next scan step
        if LightVars.Private.MonokScanPoint ge 0 and LightVars.Private.MonokScanPoint lt n_step then begin
          LightVars.Private.MonokScanPoint = LightVars.Private.MonokScanPoint+1
          MonokUValue = 'rotate monochromators: mono'+strcompress(string(idx+1))+', scan step '+strcompress(string(LightVars.Private.MonokScanPoint))+'/'+strcompress(string(n_step))
        endif else begin
          ; else go to 'fit maximum'
          MonokUValue = 'fit maximum: mono'+strcompress(string(idx+1))
        endelse
      end
    'fit maximum': $
      begin
        ; get last n_step points in [MonoX, MonokY]
        n_points = n_elements(LightVars.Private.MonokX)-1
        x = LightVars.Private.MonokX((n_points-n_step):n_points)
        y = LightVars.Private.MonokY((n_points-n_step):n_points)
        ;fit current curve, store into MonokData
        ;ESTIMATE [height,center,width,constant]
        mii=min(y)
        maa=max(y) & paa=total(x*y)/total(y)
        waa=sqrt(total(x*x*y)/total(y) - paa*paa)
        S1 =[maa-mii,paa,waa,mii]
        ;FIT. Fitted maximum is A1(1)
        fit=gaussfit(x,y,A1,nterms=4,estimates=S1)
        ; estimate fitted curve
        yfit = A1(0)*exp(-(((x-A1(1))/A1(2))^2)/2)+A1(3)  ;+A1(4)*x+A1(5)*x^2
        ; store fit result
        Private = LightVars.Private
        if LightVars.Private.MonokCurrentIndex eq 0 then $
          Tools_StructSetValue, struct=LightVars,    Tag='Private.MonokYfit',val=Yfit $
        else $
          Tools_StructSetValue, struct=LightVars,    Tag='Private.MonokYfit',val=[LightVars.Private.MonokYfit, Yfit ]
        Data(4, idx) = A1(1)
        Tools_StructSetValue, struct=LightVars,   Tag='Private.MonokLambdaData',val=Data
        ; update table values in widget
        widget_control, LightVars.Handles.MonokButtons(3), set_value=Data, bad_id=tmp
        ; display current fitted curve on Dial_Display (/update, /overlay)+ comment lines
        LightVars.Private.MonokDisplayMsg(idx) = 'M'+strtrim(string(idx+1),2)+'='+strtrim(string(round(A1(1))),2) $
                                                +' ('+strtrim(string(round(A1(2))),2)+')'
        display,IX=LightVars.Private.MonokX, Data=LightVars.Private.MonokY,    Display_Name='Rocking_Curve', Name_Data='Mono',     Comment=LightVars.Private.MonokDisplayMsg, /no, /catenate
        display,IX=LightVars.Private.MonokX, Data=LightVars.Private.MonokYfit, Display_Name='Rocking_Curve', Name_Data='Mono_Fit', /update, /overlay
        Light_LogMessage, LightVars, 'normal','[ ] Monochromator '+strtrim(string(idx+1),2)+' optimum position='+strtrim(string(round(A1(1))),2)+' width='+strtrim(string(round(A1(2))),2)
        
        ; go to next monochromator in sequence
        LightVars.Private.MonokScanPoint = 0L
        if LightVars.Private.MonokCurrentIndex lt n_elements(LightVars.Instrument.MonokSequence)-1 then begin
          LightVars.Private.MonokCurrentIndex = LightVars.Private.MonokCurrentIndex+1
          idx = LightVars.Instrument.MonokSequence(LightVars.Private.MonokCurrentIndex)
          MonokUValue = 'rotate monochromators: mono'+strcompress(string(idx+1))+', scan step '+strcompress(string(LightVars.Private.MonokScanPoint))+'/'+strcompress(string(n_step))
        endif else begin
          ; if last monochromator in sequence, go to 'RAZ (before positioning)'
          MonokUValue = 'RAZ (positioning)'
        endelse
      end
    'RAZ (positioning)': $
      begin
        Light_LogMessage, LightVars, 'normal','[ ] Sending all monochromators to lower switch limit (reference point, before final positioning)'
        if LightVars.Global.Simulation ne 0 then R=TstControl(LightVars.Instrument.MonokRAZCommand) $
        else R=Light_Control(LightVars.Instrument.MonokRAZCommand)
        widget_control,LightVars.Handles.MonokButtons(3),SET_TABLE_SELECT=[0, 0, 4, n_elements(LightVars.Instrument.MonokSequence)], bad_id=tmp1
        MonokUValue = 'positioning'
        LightVars.Private.MonokCurrentIndex = 0L
      end
    'positioning': $
      begin
        value = Data(4, idx)
        NormRatio = abs((value/Data(0, idx)) -1)
        if NormRatio ge 0.1 then begin
          Light_Base_Alert, Lightvars, error='Mono'+strcompress(string(idx+1), /remove_all)+' not set'
          Light_LogMessage, LightVars, 'silent','[E] Mono'+strcompress(string(idx+1), /remove_all)+' fitted position '+strcompress(string(value), /remove_all)+' more than 10% out of '+strcompress(string(Data(0, idx)), /remove_all)+'. Ignoring (not positioning).'
        endif else begin
          Light_LogMessage, LightVars, 'normal','[ ] Positioning Monochromator '+strtrim(string(idx+1),2)+' to optimum position='+strtrim(string(Data(4, idx)),2)
          value=string(idx+1, value, format='(%"'+LightVars.Instrument.MonokSetCommand+'")')
          if LightVars.Global.Simulation ne 0 then R=TstControl(value) $
          else R=Light_Control(value)
          widget_control, LightVars.Handles.MonokButtons(3), SET_TABLE_SELECT=[0, idx, 4, idx], bad_id=tmp1
        endelse
        
        if LightVars.Private.MonokCurrentIndex ge n_elements(LightVars.Instrument.MonokSequence)-1 then $
          MonokUValue = 'end: after '+value $
        else begin
          MonokUValue = 'positioning: after '+value
          LightVars.Private.MonokCurrentIndex = LightVars.Private.MonokCurrentIndex+1
        endelse
      end
    'end': $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Achieved Monochromators settings'
        ; transfert Data to main MonokData table
        MonokData = LightVars.Instrument.MonokData
        MonokData(*,*,LightVars.Private.EnergyIndex) = Data
        Tools_StructSetValue, struct=LightVars,    Tag='Instrument.MonokData',val=MonokData
        
        widget_control, LightVars.Handles.MonokButtons(3), SET_TABLE_SELECT=[-1, -1, -1, -1], bad_id=tmp1
        ; now update SetupEnergies
        LightVars.Instrument.SetupEnergies(1) = Wavelength
        MonokUValue = ''
        ; if auto process is on then start CheckElastic
        if LightVars.Private.AutoProcess gt 0 then begin
          ; close monok windows
          widget_control, LightVars.Handles.MonokSetup, Bad_ID=Bad_ID, /destroy
          display, Display_Name='Rocking_Curve', /delete
          ; launch check of elastic peak
          Light_SubDial_Custom_IN6_Check_Elastic_Peak, LightVars, /auto
        endif else Light_Custom_IN6_Setup_Check, LightVars
      end
    else:
    endcase
    
    widget_control, LightVars.Handles.SetupStatus(1),   set_uvalue=MonokUValue, bad_id=tmp
    widget_control, LightVars.Handles.MonokButtons(2),  set_value =MonokUValue, bad_id=tmp
  endelse ; if strpos(LightVars.Mad.Status, 'Idle') lt 0

end ; PRO Light_SubDial_Custom_IN6_Check_Monochromators

;***************************************************************
; check of the elastic peak channel on detectors and monitor1
pro Light_SubDial_Custom_IN6_Check_Elastic_Peak, LightVars, auto=auto, help=help

  if n_elements(help) ne 0 then begin
    ;** Display information about Light/Light_SubDial_Custom_IN6_Check_Elastic_Peak

    ToDisplay =['IN6 Check of the Elastic Peak Channel Help in "Light on George"',$
                '',$
                'This item counts the signal for a short time, and determines the position', $
                'of the elastic line on the TOF axis from Monitor1 and the integral of all', $
                'Detectors. A graphic is displayed, as well as basic statistics.' $
                ]

    widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Elastic Peak Check Help in Light'
    if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
      xdisplayfile, 'checkelastic.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
            title='Elastic Peak Check Help in Light', /editable, $
            Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
      LightVars.Handles.Base_Help = ID
    endif
    return
  endif

  ChElPkUValue = ''
  ; we use the same philosophy as in usual dials, inside Light. We monitor the uvalue of the Check El Peak status
  widget_control, LightVars.Handles.SetupStatus(2), get_uvalue = ChElPkUValue, bad_id=tmp
  
  if n_elements(auto) ne 0 then begin
    if strlen(ChElPkUValue) gt 0 then begin
      Light_LogMessage, LightVars, 'normal','[w] IN6 Check of the Elastic Peak is already running !'
      return
    endif else begin
      if LightVars.Private.EnergyToSet ne LightVars.Instrument.SetupEnergies(1) then begin
        ; chopper energy is not set yet
        Light_Base_Alert, Lightvars, warning='Monochromators not set'
        Light_LogMessage, LightVars, 'normal','[I] Please set monochromators for '+strcompress(string(LightVars.Private.EnergyToSet), /remove_all)+' before checking elastic peak channel'
        ; activate Light Warning
        ; add warning into Light Log
        return
      endif else ChElPkUValue = 'start'
    endelse 
  endif

  if strlen(ChElPkUValue) eq 0 then return

  ; test if MAD is Idle before doing anything
  if strpos(ChElPkUValue, 'start') ge 0 and strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    Light_LogMessage, LightVars, 'normal','[w] Instrument control (MAD) is not ready (doing '+LightVars.Mad.Status+'). Ignoring Check Elastic Peak operation. If MAD is blocked in non-Idle state, launch a short count.'
    widget_control, LightVars.Handles.SetupStatus(2), set_uvalue = '', bad_id=tmp
    return
  endif
  if strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    ; MAD Status should be either Idle, or a COUNTING
    if strpos(strupcase(LightVars.Mad.Status), 'COUNTING') lt 0  then begin
      ; conflict with an other operation: stop process.
      Light_Base_Alert, LightVars, warning='Check Elastic Peak conflict:'+LightVars.Mad.Status
      Light_LogMessage, LightVars, 'normal','[E] The instrument is doing '+LightVars.Mad.Status+' which prevents the Check of the Elastic Peak channel. Aborting. If MAD is blocked in non-Idle state, launch a short count.'
      widget_control, LightVars.Handles.SetupStatus(2), set_uvalue = '', bad_id=tmp
      return
    endif ; else wait (not Idle but counting)...

  endif else begin
    ; MAD is Idle
    widget_control, LightVars.Handles.SetupStatus(2), set_value=ChElPkUValue, bad_id=tmp
    case ChElPkUValue of
    'start':  $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Starting the Check of the Elastic Peak channel for '+strcompress(string(LightVars.Private.EnergyToSet, format='(F6.2)'))
        Light_Control, LightVars, string(1, format='(%"'+LightVars.Instrument.MonokCntCommand+'")')
        ChElPkUValue = 'measure'
      end
    'measure': $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Counting achieved. Analysing.'
        ChElPkUValue = 'end'
        ;get detectors, integrate over detectors (length=tof channels-1, last=integral)
        Mad       = LightVars.Mad
        t_res     = Mad.t_res
        data      = Mad.Data
        
        ; now specialised aliases for IN6 ************************************************
        dims      = size(data, /dim)
        data     = data(0:(dims(0) -2), *)
        Monitor  = data(*,0)      ; this is Monitor1
        data     = data(*,t_res.N_MON_SPECT:(t_res.N_TOTAL_SPECT-1)) ; for IN6
        detectors= total(data,1)  ; Channels on X (length=340), sum of row
        tof      = total(data,2)  ; TOF on X (length=LightVars.Mad.t_para.tof_cha_resol = 512, 1024...)
        IX=lindgen(n_elements(Monitor))
        
        Monitor = Monitor/60  ; 1 minute counting -> per sec.
        tof     = tof/60
        
        ;get 1st, 2nd moments for Monitor(1)
        fmon = total(IX*Monitor)/total(Monitor)
        smon = total(IX*IX*Monitor)/total(Monitor) - fmon*fmon
        if smon gt 0 then smon = round(sqrt(smon))
        imon  = max(Monitor, mmon)
        Light_LogMessage, LightVars, 'verbose','[ ] Monitor 1st moment='+strcompress(string(total(fmon))) $
          +' width='+strcompress(string(smon))+' channels'
        Light_LogMessage, LightVars, 'normal','[ ] Monitor Channel='+strcompress(string(mmon))+' ('+strcompress(string(imon))+' counts/s) Sum='+strcompress(string(total(Monitor)))+' counts/s. '
        ;get 1st, 2nd moments for tof
        ftof = total(IX*tof)/total(tof)
        stof = total(IX*IX*tof)/total(tof) - ftof*ftof
        if stof gt 0 then stof = round(sqrt(stof))
        itof  = max(tof, mtof)
        ; now look if itof is around ftof 
        Light_LogMessage, LightVars, 'verbose','[ ] TOF 1st moment=' +strcompress(string(total(ftof))) $
          +' width='+strcompress(string(stof))+' channels'
          Light_LogMessage, LightVars, 'normal','[>] TOF Channel='+strcompress(string(mtof))+' ('+strcompress(string(itof))+' counts/s) Sum='+strcompress(string(total(tof)))+' counts/s [elastic channel].'
        ; create a detached display
        comment=[ 'M1 ='+strcompress(string(mmon))+' ('+strcompress(string(smon))+')', $
                  'TOF='+strcompress(string(mtof))+' ('+strcompress(string(stof))+')' ]
        display,IX=IX, Data=Monitor, Name_Data='M1' , display_name='Check_Elastic', Name_IX='channel', Name_IY='Counts/s', Comment=comment, /detached
        display,IX=IX, Data=tof,     Name_Data='TOF', display_name='Check_Elastic', /update, /overlay
      end
    'end': $
      begin
        Light_LogMessage, LightVars, 'normal','[I] Achieved Check of the Elastic Peak'
        ; now update SetupEnergies
        LightVars.Instrument.SetupEnergies(2) = LightVars.Private.EnergyToSet
        ChElPkUValue = ''
        ; if auto process is on then enable runs to go on
        if LightVars.Private.Autoprocess gt 0 then begin
          Light_LogMessage, LightVars, 'normal','[I] Achieved Auto Setup process for '+strcompress(string(LightVars.Private.EnergyToSet))
          IsRunOn = ''
          if LightVars.Handles.RunStatus ne 0 then $
            widget_control, LightVars.Handles.RunStatus, get_uvalue=RunIsOn, bad_id=tmp
          if IsRunOn eq 'wave' then widget_control, LightVars.Handles.RunStatus, set_uvalue='wait', bad_id=tmp
          LightVars.Private.Autoprocess = 0
          widget_control, LightVars.Handles.EnergySetup, /destroy, bad_id=tmp
        endif
      end
    else:
    endcase
    widget_control, LightVars.Handles.SetupStatus(2), set_uvalue=ChElPkUValue, bad_id=tmp
    if strlen(ChElPkUValue) ne 0 then begin
      Light_Custom_IN6_Setup_Check, LightVars, /FromMad
    endif else Light_Custom_IN6_Setup_Check, LightVars, changed=0, /FromMad
  endelse ; if strpos(LightVars.Mad.Status, 'Idle') lt 0

end ; PRO Light_SubDial_Custom_IN6_Check_Elastic_Peak

;***************************************************************
;** Handles on going run/sequence
pro Light_SubDial_Custom_IN6_Check_Run, LightVars

  RunUValue = ''
  ; we use the same philosophy as in usual dials, inside Light. We monitor the uvalue of the Run status
  widget_control, LightVars.Handles.RunStatus, get_uvalue = RunUValue, bad_id=tmp

  if strlen(RunUValue) eq 0 then return
  
  Run_Nb = LightVars.Private.OnGoing_Run_Nb

  ; test if MAD is Idle before doing anything
  if strpos(RunUValue, 'start') ge 0 and strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    Light_LogMessage, LightVars, 'normal','[w] Instrument control (MAD) is not ready (doing '+LightVars.Mad.Status+'). Ignoring Run/Sequence execution. If MAD is blocked in non-Idle state, launch a short count.'
    widget_control, LightVars.Handles.RunStatus, set_uvalue = '', bad_id=tmp, set_value=''
    return
  endif
  if strpos(strupcase(LightVars.Mad.Status), 'IDLE') lt 0 then begin
    ; MAD Status should be either Idle, or a COUNTING
    if strpos(strupcase(LightVars.Mad.Status), 'COUNTING') ge 0 then begin
      if LightVars.Private.TemperatureUnstable ge 1 and LightVars.Run.Flag_T(Run_Nb) ne 0 then begin
        LightVars.Private.TemperatureUnstable = 0
        msg = '[ ] Starting temporary counting (waiting to recover T control).'
        Light_LogMessage, LightVars, 'normal', msg
        ; stop current counting, then restart without incrementing
        Light_Control, LightVars, LightVars.Instrument.StopCommand
        RunUValue = 'T_Out'
        widget_control, LightVars.Handles.RunStatus,  set_uvalue=RunUValue, bad_id=tmp
        ; starting time for this temporary period is LightVars.Private.TempoTempTime
        ; (this is done in Light_SubDial_Base_Check_Temperature)
        ; a new TemperatureUnstable will be generated every Wait_Error (changing temporary counting numor)
      endif
      if LightVars.Private.TemperatureUnstable le -1 and LightVars.Run.Flag_T(Run_Nb) ne 0 then begin
        LightVars.Private.TemperatureUnstable = 0
        msg = '[ ] Stopping temporary counting (recovered T control).'
        Light_LogMessage, LightVars, 'normal', msg
        ; stop current counting without incrementing
        Light_Control, LightVars, LightVars.Instrument.StopCommand
        RunUValue = 'count'
        widget_control, LightVars.Handles.RunStatus,  set_uvalue=RunUValue, bad_id=tmp
        ; handle the remaining time and number of repetition for current counting (that continues)
        ; change current sequence number of repetition to t_res.NREPET-t_res.NPREP
        nrep = max([LightVars.Private.LastValidNumor(1) - LightVars.Private.LastValidNumor(2), 1])
        LightVars.Run.Repetition(Run_Nb)  = nrep
        ; recompute the next sequence times, so that total time is kept (as far as possible).
        ; each counting should have a minimum duration of Wait_Error
        LostTime = double(systime(1) - abs(LightVars.Private.TempoTempTime))/60.0 ; time lost in [min]
        LightVars.Private.TempoTempTime = 0
        TotalTime = 0
        ; first compute the Total+Waiting time for the remaining sequence
        for index=Run_Nb, n_elements(LightVars.Run.Temperatures)-1 do begin
          DuRep = LightVars.Run.Preset(index)*LightVars.Run.Repetition(index)
          if LightVars.Run.Flag_MonTi(index) then TotalTime = TotalTime+DuRep
        endfor
        ; now rescale measuring time (not waiting time)
        NewTotalTime = TotalTime - LostTime
        LostRatio = max([ double(NewTotalTime)/TotalTime, 0.25])
        NewTotalTime = 0
        for index=Run_Nb, n_elements(LightVars.Run.Temperatures)-1 do begin
          if LightVars.Run.Flag_MonTi(index) then begin
            tmp = max([LightVars.Run.Wait_Error(Run_Nb), LightVars.Run.Wait_T(Run_Nb)])
            if LightVars.Run.Preset(index) gt tmp then $
              NewRunDuration    = max([ LightVars.Run.Preset(index)*LostRatio, tmp, 5]) $
            else NewRunDuration = max([ LightVars.Run.Preset(index)*LostRatio, 5])
            NewTotalTime = NewTotalTime+NewRunDuration*LightVars.Run.Repetition(index)
          endif else NewRunDuration = LightVars.Run.Preset(index)*LostRatio
          LightVars.Run.Preset(index) = NewRunDuration
        endfor
        msg = '[ ] Re-scalling sequence (ratio='+strcompress(string(LostRatio))+') to maintain total execution time (as far as possible)'
        Light_LogMessage, LightVars, 'normal', msg
        ; show new sequence analysis
        Light_Event_Base_Run_Analyse, LightVars
        ; resuming Last Valid Numor...
        msg = '[>] Restarting run/sequence (same as numor '+strcompress(string(abs(long(LightVars.Private.LastValidNumor(0)))))+')'
        Light_LogMessage, LightVars, 'normal', msg
        LightVars.Private.LastValidNumor(0) = 0
      endif
      if LightVars.Private.AccuracyAchieved ge 0 and LightVars.Run.Flag_Count(Run_Nb) ne 0 then begin
        ; the ROI check determined that statistics was now ok
        LightVars.Private.AccuracyAchieved = 0
        Light_LogMessage, LightVars, 'normal','[ ] Stopping current counting and going to the next in the sequence (accuracy achieved)'
        ; stop current counting and go to next
        Light_Control, LightVars, LightVars.Instrument.StopCommand
        RunUValue = 'next'
        widget_control, LightVars.Handles.RunStatus,  set_uvalue=RunUValue, bad_id=tmp
      endif

    endif else begin
      if  strpos(strupcase(LightVars.Mad.Status), 'POSITIONNING') lt 0 $
      and strpos(strupcase(LightVars.Mad.Status), 'CHOPPER SETTING') lt 0 $
      and strpos(strupcase(LightVars.Mad.Status), 'WAVELENGTH SETTING') lt 0 then begin
        ; conflict with an other operation: stop process.
        Light_Base_Alert, LightVars, warning='Run/Sequence conflict:'+LightVars.Mad.Status
        Light_LogMessage, LightVars, 'normal','[E] The instrument is doing '+LightVars.Mad.Status+' which prevents the Run/Sequence execution Aborting. If MAD is blocked in non-Idle state, launch a short count.'
        widget_control, LightVars.Handles.RunStatus, set_uvalue = '', bad_id=tmp, set_value=''
        return
      endif ; else wait...
    endelse

  endif else begin
    ; MAD is Idle
    ProcessStep = strsplit(RunUValue, ':', /extract)
    widget_control, LightVars.Handles.RunStatus,  set_value=strcompress(string(Run_Nb))+':'+RunUValue, bad_id=tmp
    case ProcessStep(0) of
    'start':  $
      begin
        if LightVars.Private.First_Run_Nb eq LightVars.Private.Last_Run_Nb then $
          Light_LogMessage, LightVars, 'normal','[I] Starting Single Run '+strcompress(string(LightVars.Private.First_Run_Nb)) $
        else begin
          message = '[I] Starting Sequence '+strcompress(string(LightVars.Private.First_Run_Nb))+'-'
          if LightVars.Private.Last_Run_Nb eq -1 then message = message+'(end)' $
          else message = message+strcompress(string(LightVars.Private.Last_Run_Nb))
            Light_LogMessage, LightVars, 'normal', message
        endelse
        LightVars.Private.OnGoing_Run_Nb = LightVars.Private.First_Run_Nb
        RunUValue = 'setup'
      end
    'setup': $
      begin
        Light_Control, LightVars, $
          string(strtrim(LightVars.Private.ExpTitle,2),    format='(%"'+LightVars.Instrument.SetTitleCommand+'")')
        comment = 'This is Run '+strcompress(string(Run_Nb))+' from Light'
        Light_Control, LightVars, $
          string(comment ,                      format='(%"'+LightVars.Instrument.CommentCommand+'")')
        ; sets subtitle
        subtitle = LightVars.Run.Titles(Run_Nb)
        Light_Control, LightVars, string(subtitle, format='(%"'+LightVars.Instrument.SetSubTitleCommand+'")')
        ; execute optional command
        opt_command = LightVars.Run.Option_Command(Run_Nb)
        if strlen(opt_command) gt 0 then begin
          command_type = ''
          opt_cmd_tokens=strsplit(opt_command, ':', /extract)
          print, opt_cmd_tokens
          case opt_cmd_tokens(0) of
          'idl': command_type = 'idl'
          'system': command_type = 'system'
          'unix': command_type = 'system'
          'mad': command_type = 'mad'
          endcase
          if strlen(command_type) eq 0 then begin
            command_type = 'mad'
            command      = opt_command
          endif else command = strjoin(opt_cmd_tokens(1:(n_elements(opt_cmd_tokens)-1)), ':')
          
          Light_LogMessage, LightVars, 'normal', '[*] '+command_type+':'+command
          case command_type of
            'idl': ok = execute(command)
            'system': spawn, command
            'mad': Light_Control, LightVars, command
          endcase
        endif
        RunUValue = 'temp'
      end
    'temp': $
      begin
        ; if required: change temperature and sets stabilisation T-delay
        LightVars.Private.WaitTempTime = 0
        if LightVars.Run.Temperatures(Run_Nb) ne LightVars.Mad.t_res.tempea(0) then begin
          Light_Control, LightVars, $
            string(LightVars.Run.Temperatures(Run_Nb), format='(%"'+LightVars.Instrument.TempWriteCommand+'")')
          if LightVars.Run.Wait_T(Run_Nb) gt 0 then begin
            msg = '[ ] Wait Temperature stabilisation until about '+systime(0, systime(1)+LightVars.Run.Wait_T(Run_Nb)*60)
            Light_LogMessage, LightVars, 'normal', msg
          endif
        endif
        RunUValue = 'wave'
      end
    'wave': $
      begin
        ; this can take place during wait T-delay
        ; if desired wavelength is changed from current settings, launch an auto setup
        if LightVars.Private.IsSuperUser ne 0 and LightVars.Run.Lambda(Run_Nb) ne LightVars.Mad.t_para.wave then begin
          msg = '[ ] Changing incident wavelength from '+strcompress(string(LightVars.Mad.t_para.wave))+' [Angs] to '+strcompress(string(LightVars.Run.Lambda(Run_Nb)))+' [Angs] (automatic setup)'
          Light_LogMessage, LightVars, 'normal', msg
          Light_Event_Custom_IN6_Setup_Build, LightVars, /auto, wavelength=LightVars.Run.Lambda(Run_Nb)
        endif
        RunUValue = 'wait'
      end
    'wait': $
      begin
        ; ATTN: should also check that T is ok before starting counting !!
        if LightVars.Private.AutoProcess le 0 then begin
          ; check that T-delay has elapsed before starting to count 
          ; (also occurs when T is within limits). See Light_SubDial_Base_Check_Temperature
          if systime(1) ge LightVars.Private.WaitTempTime+LightVars.Run.Wait_T(Run_Nb)*60 then begin
            RunUValue = 'count'
            LightVars.Private.WaitTempTime = 0
          endif
        endif
      end
    'count': $
      begin
        if LightVars.Run.Repetition(Run_Nb) lt 1 then begin
          msg = '[ ] Ignoring Run '+strcompress(string(Run_Nb))+' (repetition='+strcompress(string(LightVars.Run.Repetition(Run_Nb)))+')'
          Light_LogMessage, LightVars, 'verbose', msg
        endif else begin
          ; send count command on time/mon, with or without saving and repetition number
          preset = LightVars.Run.Preset(Run_Nb)
          if LightVars.Run.Flag_MonTi(Run_Nb) ne 0 then TiMon = 'time' else TiMon = 'mon'
          if LightVars.Run.Flag_Save(Run_Nb)  ne 0 then Save  = 'save' else Save  = 'nosave'
          nrep   = LightVars.Run.Repetition(Run_Nb)
          cmd = string(preset, TiMon, nrep, Save, format='(%"'+LightVars.Instrument.CountCommand+'")')
          Light_Control, LightVars, cmd
        endelse
        RunUValue = 'next'
      end
    'T_Out': $
      begin
        base_time = LightVars.Run.Wait_Error(Run_Nb)
        wait_time = LightVars.Run.Wait_T(Run_Nb)
        preset= max([ base_time, wait_time, 5])
        if LightVars.Run.Flag_Save(Run_Nb)  ne 0 then Save  = 'save' else Save  = 'nosave'
        nrep  = 1
        TiMon = 1; 1:time, 0:monitor
        cmd = string(preset, TiMon, nrep, Save, format='(%"'+LightVars.Instrument.CountCommand+'")')
        Light_Control, LightVars, cmd
      end
    'next': $
      begin
        LightVars.Private.OnGoing_Run_Nb = LightVars.Private.OnGoing_Run_Nb+1
        if LightVars.Private.Last_Run_Nb lt 0 then last = n_elements(LightVars.Run.Repetition)-1 $
        else last = LightVars.Private.Last_Run_Nb
        if LightVars.Private.OnGoing_Run_Nb le last then begin
          Light_Event_Base_Run_Fields, LightVars, Run_Nb=LightVars.Private.OnGoing_Run_Nb, /restore
          RunUValue = 'setup'
        endif else begin
          RunUValue = 'end'
        endelse
      end
    'end': $
      begin
        Light_LogMessage, LightVars, 'normal','[I] End of Run/Sequence'
        LightVars.Private.OnGoing_Run_Nb = -1
        LightVars.Private.TemperatureUnstable = 0
        RunUValue = ''
        widget_control, LightVars.Handles.RunStatus,  set_value=RunUValue
      end
    else:
    endcase
    widget_control, LightVars.Handles.RunStatus,  set_uvalue=RunUValue, bad_id=tmp
  endelse ; if strpos(LightVars.Mad.Status, 'Idle') lt 0
  
end ; PRO Light_SubDial_Custom_IN6_Check_Run




;***************************************************************
;** Project: Light
;** File:    Light.pro
;** Version: 0.2
;** Date:    Jan, 23rd, 2002
;** Author:  E. Farhi
;** Object:  Dial_Display to display anything
;
;** Require: Tools_StructSetValue.pro, Dialog_Fields.pro
;
;** Modified Feb 28th 2002: use structure elements with numbered labels instead
;                           of array of structure (that MUST have all same size in IDL)
;** Modified Mar 7th 2002:  stand-alone version is now ok, except File/Edit Help
;** Modified Mar 11th 2002: automatic recording ok.
;** Modified Jul 24th 2002: corrected small bugs (/delete when no valid display), added group_leader
;
; USAGE EXAMPLE:
; dial_bygeorge,'display' & x=lindgen(10)+10 & y=exp(x)
; display, ix=x, data=y, name_data='exp10'
; display, data=dist(20), name_data='e2',type='surface'
;
;***************************************************************
; pro Dial_Display_LogMessage, DisplayVars, DisplayLevel, Message
; pro Dial_Display_Set_Index, Structure=Structure, Index=Index, Value=Value
; pro Dial_Display_Add_Data, DisplayVars, Display_Name=Display_Name, $
; pro Dial_Display_Delete_Data, DisplayVars, Display_Name=Display_Name, Display_Index=Display_Index, $
; pro Dial_Display_Delete_Display, DisplayVars, Display_Name=Display_Name, Display_Index=Display_Index
; pro Dial_Display_Get_List, DisplayVars, DataList=DataList, DataArr=DataArr, DisplayArr=DisplayArr
; pro Dial_Display_Build, DisplayVars
; pro Dial_Display_Event_Parser, event
; pro Dial_Display_Event_Close, DisplayVars
; pro Dial_Display_Event_Resize, DisplayVars
; pro Dial_Display_Event_Show_List, DisplayVars, no_raise=no_raise
; pro Dial_Display_Event_Help_Preferences, DisplayVars, update=update
; pro Dial_Display_Event_Help_File, DisplayVars
; pro Dial_Display_Event_Help_Edit, DisplayVars
; pro Dial_Display_Event_Displays_Help, DisplayVars, DisplayHelp=DisplayHelp
; pro Dial_Display_Event_Preferences, DisplayVars
; pro Dial_Display_Event_Update_All, DisplayVars
; pro Dial_Display_Event_Update, DisplayVars
; pro Dial_Display_Event_Save_Data_Image, DisplayVars, Display_Index=Display_Index, Data_Index=Data_Index, Type=Type, filename=filename, Name_Data=Name_Data
; pro Dial_Display_Event_Close_DisplayData, DisplayVars
; pro Dial_Display_Event_Save_Data_Text, DisplayVars
; pro Dial_Display_Event_Save_Data_PS, DisplayVars
; pro Dial_Display_Event_Delete_All, DisplayVars
; pro Dial_Display_Event_AutoSave, DisplayVars
; pro Dial_Display_Event_AutoUpdate, DisplayVars
; pro Display, Display_Name=Display_Name,
;
; function Dial_Display_Get_DisplayVars
; function Dial_Display_Get_Index, Structure, Index
; function Dial_Display_Get_Display, DisplayVars, Display_Name
; function Dial_Display_Get_Data, DisplayVars, Data_Name, Display_Index=Display_Index
; function Dial_Display_Add_Display, DisplayVars, Name, Type

;***************************************************************
;** Output Dial_Display message to IDL prompt
pro Dial_Display_LogMessage, DisplayVars, DisplayLevel, Message
;** Displays the Message if the present ActualLevel (DisplayVars.Verbosity)
;** matches the DisplayLevel (in silent, user, debug)
;** The date is appended before the message
;** LogString: Message is appened to LogString (string array)
;** File:      LogString is saved to file if specified

ActualLevel    = DisplayVars.Global.Verbosity

LevelList      = ['silent','normal','verbose','debug']
LocActualLevel = where(strcmp(LevelList, ActualLevel))
LocDisplayLevel= where(strcmp(LevelList, DisplayLevel))

if LocActualLevel(0) ge LocDisplayLevel(0) then begin

  for index=0,n_elements(Message)-1 do begin
    if n_elements(Message) eq 1 then $
      Message(index) = '['+systime(0)+'] '+Message(index)
    print, Message(index)  ; print to IDL terminal
  endfor

endif

end; PRO Light_LogMessage

;***************************************************************
;** Procedure to get Dial_Display data
function Dial_Display_Get_DisplayVars

  DialTag, 'display', Get=DisplayVars
  return, DisplayVars

end; FUN Dial_Display_Get_DisplayVars

;***************************************************************
; gets the index element of an array-like structure
; this is necessary as IDL arrays can only be of elements of identical size
; and we nned here variable size elements for Data and Displays
function Dial_Display_Get_Index, Structure, Index

    if Index lt 0 then Index = 0
    if Index ge Structure.Length then Index = Structure.Length-1
    ToReturn = -1
    ok = execute('ToReturn = Structure.Element_'+strtrim(string(Index),2))
    return, ToReturn

end; FUN Dial_Display_Get_Index

;***************************************************************
; sets the index element of an array-like structure to given value
pro Dial_Display_Set_Index, Structure=Structure, Index=Index, Value=Value

    n_Index = index
    if n_Index lt 0 then n_Index = 0
    Tools_StructSetValue, struct=Structure, tag='Element_'+strtrim(string(n_Index),2), val=Value

end; PRO Dial_Display_Set_Index


;***************************************************************
; look for the Display 'Display_Name' in Displays(..).Name array
function Dial_Display_Get_Display, DisplayVars, Display_Name

  Display_Name = strjoin(strsplit(Display_Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')

  Display_Index = -1
  for index=0, DisplayVars.Displays.Length-1 do begin
    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    if strcmp(Display_Name, Display.Name) ne 0 then Display_Index = index
  endfor
  return, Display_Index

end; FUN Dial_Display_Get_Display

;***************************************************************
; returns the Data_Index, (and Display_Index in parameters)
function Dial_Display_Get_Data, DisplayVars, Data_Name, Display_Index=Display_Index

  if n_elements(Data_Name) eq 0 then return, -1
  Data_Name       = strjoin(strsplit(Data_Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')

  Display_Index = -1
  if n_elements(Data_Name) eq 0 then return, -1
  ; look for the Data 'Data_Name' in Display(..).Data(..).Name array
  Data_Index    = -1

  for index=0, DisplayVars.Displays.Length-1 do begin
    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    for d_index=0, Display.Length-1 do begin
      Data = Dial_Display_Get_Index(Display, d_index)
      if strcmp(Data_Name, Data.Name_Data) ne 0 then begin
        Display_Index = index
        Data_Index    = d_index
      endif
    endfor
  endfor
  return, Data_Index

end; PRO Dial_Display_Get_Display

;***************************************************************
; Create/activate a new Display (or re-use an existing one) and retuns its Display_Index
function Dial_Display_Add_Display, DisplayVars, Name, Type

  Name       = strjoin(strsplit(Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')

  ; if Display already exists, return it
  Display_Index = Dial_Display_Get_Display(DisplayVars, Name)
  if Display_Index ge 0 then begin
    Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Display: using Display '+strtrim(string(Display_Index),2)+' "'+Name+'" '+Type
    return, Display_Index
  endif

  ; if a display is empty, re-use array slot and create live_tool
  ; empty displays are created at init, or by myself (see below)
  Empty_Display = Dial_Display_Get_Display(DisplayVars, "")
  Type = strlowcase(Type)
  if Empty_Display ge 0 then begin  ; re-use that array slot, and create live_tool
    Displays = DisplayVars.Displays
    Display  = Dial_Display_Get_Index(DisplayVars.Displays, Empty_Display)
    Display.Name  = Name
    Display.Type  = Type
    Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Display: Creating Display '+strtrim(string(Empty_Display),2)+' "'+Name+'" '+Type
    ; now create text display/live_tool
    if DisplayVars.Global.OrientRow eq 0 then dimension =  DisplayVars.Global.XSize $
    else dimension = DisplayVars.Global.YSize
    DrawDimension = [ dimension, dimension ]
    ExampleDim = 10
    ToExec = ''
    case Type of
      'text': begin
                xdisplayfile, 'dummy', text='['+systime(0)+'] New Text Display '+Name+' created.', $
                Group=DisplayVars.Handles.Base, /Editable, title=Name, Done_Button='Close ['+Name+']', WText=ID
                ID = strtrim(string(ID),2)
              end
      'plot':   begin
                  Data0 = sin(lindgen(ExampleDim)/3.0)
                end
      'image':  begin
                  Data0 = dist(ExampleDim)
                end
      'surface':begin
                  Data0 = dist(ExampleDim)
                end
      'contour':begin
                  Data0 = dist(ExampleDim)
                end
      else: begin
              Dial_Display_LogMessage, DisplayVars, 'normal','[E] Dial_Display_Add_Display. Unknow Display type'
              Dial_Display_LogMessage, DisplayVars, 'normal','[I] valid types are text, plot, image, surface, contour'
              return, -1
            end
    endcase

    if Type ne 'text' then begin
      ok = execute(Name+' = Data0')
      ToExec = ToExec+', '+Name+', DRAW_DIMENSIONS=DrawDimension, reference_out=R_out'
      if DisplayVars.Global.Gathered eq 1 then $
        ToExec = ToExec+', PARENT_BASE=DisplayVars.Handles.DisplayPanel' $
      else ToExec = ToExec+', TITLE=Name'
      ok = execute('live_'+Type+' '+ToExec+', Error=Error')
      if strlen(Error) ne 0 then begin
        Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Add_Display '+Error
        return, -1
      endif
      ID = R_out.win
      if strlen(ID) eq 0 then $
        ID = R_out.vis
      Display.Vis = R_out.vis
    endif

    ; store new ID (live tool name or string(widget_ID)). Data is still empty here
    Display.ID = ID

    ; save new Display in Dial Structure
    Dial_Display_Set_Index, Structure=Displays, Index=Empty_Display, Value=Display
    Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
    DialTag, 'display', tag='Displays',  set=Displays
    Display_Index = Empty_Display
  endif else begin
    ; add an empty DisplayStructure slot in Displays array and call again myself (see up there)
    Displays = DisplayVars.Displays
    Dial_Display_Set_Index, Structure=Displays, Index=Displays.Length, Value=DisplayVars.Global.EmptyDisplay
    Displays.Length = Displays.Length+1

    Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
    DialTag, 'display', tag='Displays',  set=Displays

    Display_Index = Dial_Display_Add_Display(DisplayVars, Name, Type)
  endelse
  ; else add new DisplatStruct in Displays array and create a new named Display live_tool of given Type with empty Data
  return, Display_Index

end; PRO Dial_Display_Add_Display

;***************************************************************
; Add/Set/Catenate new Data to a given Display/Data
pro Dial_Display_Add_Data, DisplayVars, Display_Name=Display_Name, $
                           IX=IX, IY=IY, Data=Data, $
                           Name_IX=Name_IX, Name_IY=Name_IY, Name_Data=Name_Data, $
                           Type = Type, Options=Options, Auto_Load=Auto_Load, $
                           Add=Add, Overlay=Overlay, Catenate=Catenate, $
                           Scatter=Scatter, Histogram=Histogram, Polar=Polar, Log=Log, $
                           Comment=Comment, No=No, Exact=Exact

  if n_elements(Type)    ne 0 then inputType = Type  ; save Type from input parameters

  ; determine the type of data if not given
  if n_elements(Type) eq 0 then Type = ''
  sData = size(Data)
  if strlen(Type) eq 0 then begin
    if size(Data,/type) eq 7 then Type = 'text' $
    else if sData(0) eq 1 or sData(0) eq 0 then Type='plot' $
    else if sData(0) eq 2 then Type='surface' $
    else Type = 'unknown'
  endif

  if Type eq 'unknown' then begin
    Dial_Display_LogMessage, DisplayVars, 'normal','[E] Dial_Display_Add_Data: Unknown data type. size='+string(sData)
    help, Data
    return
  endif

  if n_elements(Name_Data) eq 0 then Name_Data = "" $
  else Name_Data       = strjoin(strsplit(Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')

  ; look if Name_Data already exists in opened Displays. Returns Data_Index and Display_Index
  Data_Index     = Dial_Display_Get_Data(DisplayVars, Name_Data, Display_Index=Display_Index)

  if n_elements(Overlay) ne 0 and Data_Index lt 0 then begin
      ; force creation of a new Data set, but keep Display if it was found
      Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Overlay'
      Data_Index = -1
  endif

  ; look for the Display 'Display_Name' in Displays(..).Name array.
  ; if exists, use it (Display_Index ne 0), else if none exist find it by Name (Display_Name ne 0)
  ; or create new display
  if Display_Index lt 0 or n_elements(Display_Name) ne 0 then begin
    if n_elements(Display_Name) eq 0 then Display_Name = Name_Data $
    else Display_Name       = strjoin(strsplit(Display_Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
    Display_Index = Dial_Display_Add_Display(DisplayVars, Display_Name, Type)
  endif

  ; here, a display is available (either a new one, or use existing one)
  Displays     = DisplayVars.Displays
  Display      = Dial_Display_Get_Index(Displays, Display_Index)    ; this DisplayStruct
  Display_Name = Display.Name

  if Display.Type eq 'text' and size(Data, /type) ne 7 then begin
    Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Translating numerics into text'
    Data = string(Data)
  endif

  if Display.Type ne 'text' and Type eq 'text' then begin
      Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Translating text into numerics'
      sData= size(Data, /dimensions)
      ok = execute('Data = ['+strjoin(strjoin(string(Data)))+']')
      if Display.Type ne 'plot' then $
        Data = reform(Data, sData)
  endif

  Update = 0
  if Display.Type ne 'text' and Display.Type ne 'plot' and n_elements(inputType) ne 0 then begin
    ; can change display type for 2d (surface, image, contour)
    if inputType ne 'text' and inputType ne 'plot' and inputType ne Display.Type then begin
      Display.Type = inputType
      Update = 2
    endif
  endif

  if Display.Type eq 'plot' and sData(0) ne 1 then begin
    ; reshape Data to 1D vector
    if size(Data, /type) eq 0 then begin
      Dial_Display_LogMessage, DisplayVars, 'verbose','[I] Dial_Display_Add_Data: undefined data'
    endif else begin
      if sData(0) eq 0 then begin
        Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: forcing catenate of scalar'
        Catenate = 1
      endif else begin
        Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Changing 2D array to 1D vector'
        Data = reform(Data, sData(n_elements(sData)-1))
      endelse
    endelse
  endif

  if Display.Type ne 'plot' and Display.Type ne 'text' and sData(0) eq 1 then begin
    Data = transpose(Data)
  end

  if Data_Index lt 0 or Data_Index ge Display.Length then begin
    ; Data does not exist yet
    ; search for empty Data slot in display and use that if any, else extend array
    Data_Index = -1
    for d_index=0, Display.Length-1 do begin
      This_Data = Dial_Display_Get_Index(Display, d_index)
      if strlen(This_Data.Name_Data) eq 0 then Data_index    = d_index
    endfor

    if Data_Index lt 0 then begin
      ; new Data to create (no empty slot found)
      This_Data = DisplayVars.Global.EmptyData
      ; extend data array in Display(Struct). Index is Display.Length
      Dial_Display_Set_Index, Structure=Display, Index=Display.Length, Value=DisplayVars.Global.EmptyData
      Display.Length = Display.Length+1
      Data_index = Display.Length-1
    endif else begin
      ; we found an empty slot. Use that
      This_Data = Dial_Display_Get_Index(Display, Data_Index)     ; Unamed Data "" (Empty) to act on is there
      ; Name_Data = This_Data.Name_Data
    endelse
    This_Data.Date = systime(1)

  endif else begin
    ; Data exists already
    This_Data = Dial_Display_Get_Index(Display, Data_Index)     ; Named Data to act on is there
    Name_Data = This_Data.Name_Data
  endelse

  ; This_Data is now defined

  if strlen(Display_Name) eq 0 then begin
    Display_Name = 'Display'+strtrim(string(Display_Index),2)
    Display.Name = Display_Name
  endif

  if n_elements(Options) ne 0 then NewOption = Options else NewOption = ''

  if n_elements(Add)        ne 0 then NewOption = NewOption+'add '
  if n_elements(Delete)     ne 0 then NewOption = NewOption+'delete '
  if n_elements(Catenate)   ne 0 then NewOption = NewOption+'catenate '
  if n_elements(Scatter)    ne 0 then NewOption = NewOption+'scatter '
  if n_elements(Histogram)  ne 0 then NewOption = NewOption+'histogram '
  if n_elements(Polar)      ne 0 then NewOption = NewOption+'polar '
  if n_elements(Log)        ne 0 then NewOption = NewOption+'log '
  if n_elements(Exact)      ne 0 then NewOption = NewOption+'exact '

  NewOption    = strlowcase(NewOption)
  This_Option  = strlowcase(This_Data.Options)


  if strlen(NewOption) gt 0 then begin
    if n_elements(No) ne 0 then begin
      This_OptionA = strsplit(This_Option, /extract)
      ; set This_OptionA(index) to '' for elements that are found in NewOption
      for o_index = 0, n_elements(This_OptionA)-1 do begin
        if strpos(NewOption, This_OptionA(o_index)) ge 0 then This_OptionA(o_index) = ''
      endfor
      This_Option = strjoin(This_OptionA,' ')
    endif else begin
      NewOptionA   = strsplit(NewOption, /extract)
      ; add NewOptionA(index) to This_Option for elements that are not in This_Option
      for o_index = 0, n_elements(NewOptionA)-1 do begin

        if strpos(This_Option, NewOptionA(o_index)) lt 0 then This_Option = This_Option+' '+NewOptionA(o_index)
      endfor
    endelse
  endif

  if This_Option ne This_Data.Options then begin
    This_Data.Options = This_Option
    Update = 2
  endif

  ; handle the Data options...

  if strpos(This_Data.Options, 'add') ge 0 then begin
    Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Add'
    ; add new data to the existing one. Do not touch the axes
    ; dimensions must match !!
    if n_elements(Data) gt 0     then Data = This_Data.Data + Data
  endif

  if strpos(This_Data.Options, 'delete') ge 0 then begin
    Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Delete'
    ; delete data
    Dial_Display_Delete_Data, DisplayVars, Display_Index=Display_Index, Data_Index=Data_Index
    widget_control, DisplayVars.Handles.Base_About, Bad_ID=Bad_ID
    ; Bad_ID: If no error occurs, a zero is stored.
    if Bad_ID eq 0 and DisplayVars.Handles.Base_About ne 0 then Dial_Display_Event_Show_List, DisplayVars, /no_raise
    return
  endif

  if n_elements(IX) gt 0 then nIX=IX
  if n_elements(IY) gt 0 then nIY=IY
  if n_elements(Data) gt 0 then nData=Data

  if strpos(This_Data.Options, 'catenate') ge 0 then begin
    Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Catenate'
    ; catenate new data, and optionally (if given) new axes
    if n_elements(IX) eq 0 then IX = systime(1) - This_Data.Date
    if strlen(This_Data.Name_Data) eq 0 then begin
      if n_elements(IX) gt 0       then nIX   = [ IX(0), IX ]
      if n_elements(IY) gt 0       then nIY   = [ IY(0), IY ]
      if n_elements(Data) gt 0     then nData = [ Data(0), Data ]
    endif else begin
      if n_elements(IX) gt 0       then nIX   = [ This_Data.IX, IX ]
      if n_elements(IY) gt 0       then nIY   = [ This_Data.IY, IY ]
      if n_elements(Data) gt 0     then nData = [ This_Data.Data, Data ]
    endelse

    if DisplayVars.Plot ge 2 then begin ; keep last Plot values
      sData = size(nData, /dim)
      max_index = sData(0)
      min_index = max([0, max_index - DisplayVars.Plot +1])
      index = lindgen(max_index - min_index +1)+min_index
      if n_elements(nIX) gt 0       then nIX   = nIX(index,*)
      if n_elements(nIY) gt 0       then nIY   = nIY(index,*)
      if n_elements(nData) gt 0     then nData = nData(index,*)
    endif
  endif

  ; Replace: will use Data as supplied in parameters, and override This_Data
  Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Add_Data: Update Data'

  ; now fill-in the data X,Y,Data in Data_index slot; determine Update level.
  ; Update = 1: keep current live view, and just update the data block (faster)
  ; Update = 2: destroy current view and rebuild a new one at the same place, with present values
  if n_elements(Name_Data) gt 0 then begin
    if Name_Data ne This_Data.Name_Data then begin
      Tools_StructSetValue, struct=This_Data, tag='Name_Data', val= Name_Data
      Update = 2
    endif
  endif
  if n_elements(Auto_Load) gt 0 then begin
    if Auto_Load(0) ne This_Data.Auto_Load then begin
      Tools_StructSetValue, struct=This_Data, tag='Auto_Load', val= Auto_Load(0)
      if Update eq 0 then Update = 1
    endif
  endif
  if n_elements(Data) gt 0      then begin
    Tools_StructSetValue, struct=This_Data, tag='Data'    , val= nData
    ; if same size,  update = 1
    ; if other size, update = 2
    if n_elements(nData) eq n_elements(This_Data.Data) and Update eq 0 then Update = 1
    Tools_StructSetValue, struct= DisplayVars, tag='Value' , val= nData
  endif
  if n_elements(IX) gt 0        then begin
    if n_elements(where(nIX ne This_Data.IX)) or n_elements(nIX) ne n_elements(This_Data.IX) then begin
      Tools_StructSetValue, struct=This_Data, tag='IX'      , val= nIX
      Update=2
    endif
  endif
  if n_elements(IY) gt 0        then begin
    if n_elements(where(nIY ne This_Data.IY)) then begin
      Tools_StructSetValue, struct=This_Data, tag='IY'      , val= nIY
      Update = 2
    endif
  endif
  if strlen(Name_Data) eq 0 then begin
    Name_Data = 'Display'+strtrim(string(Display_Index),2)+'_Data'+strtrim(string(Data_index),2)
    This_Data.Name_Data = Name_Data
    Update = 2
  endif
  if n_elements(Name_IX) gt 0   then begin
    if Name_IX(0) ne This_Data.Name_IX then begin
      Tools_StructSetValue, struct=This_Data, tag='Name_IX' , val= Name_IX(0)
      Update = 2
    endif
  endif
  if n_elements(Name_IY) gt 0   then begin
    if Name_IY(0) ne This_Data.Name_IY then begin
      Tools_StructSetValue, struct=This_Data, tag='Name_IY' , val= Name_IY(0)
      Update = 2
    endif
  endif
  if n_elements(Comment) gt 0   then begin
    if strjoin(Comment) ne strjoin(This_Data.Comment) then begin
      Tools_StructSetValue, struct=This_Data, tag='Comment',  val= Comment
      Update = 2
    endif
  endif

  ; activate Redraw Flag for display

  ; save Structures
  ; Display_Data(Data_Index)    = This_Data
  Dial_Display_Set_Index, Structure=Display, Index=Data_Index, Value=This_Data
  Display.Update              = Update
  ; Displays(Display_Index)     = Display
  Dial_Display_Set_Index, Structure=Displays, Index=Display_Index, Value=Display

  Tools_StructSetValue, struct= DisplayVars, tag='Displays' , val= Displays
  DialTag, 'display', tag='Displays',  set=Displays

end; PRO Dial_Display_Add_Data

;***************************************************************
; set the Name to "" and remove Data (free memory) (given by Name or Index)
pro Dial_Display_Delete_Data, DisplayVars, Display_Name=Display_Name, Display_Index=Display_Index, $
                           Name_Data=Name_Data, Data_Index=Data_Index

  if n_elements(Display_Name) gt 0 then begin
    Display_Name       = strjoin(strsplit(Display_Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
    if n_elements(Display_Index) eq 0 and strlen(Display_Name) gt 0 then $
      Display_Index = Dial_Display_Get_Display(DisplayVars, Display_Name)
  endif
  if n_elements(Name_Data) gt 0 then begin
    Name_Data       = strjoin(strsplit(Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
    if n_elements(Data_Index) eq 0 and strlen(Name_Data) gt 0 then $
      Data_Index = Dial_Display_Get_Data(DisplayVars, Data_Name, Display_Index=Display_Index)
  endif

  if n_elements(Name_Data) eq 0 and n_elements(Data_Index) eq 0 then begin
    Dial_Display_Delete_Display, DisplayVars, Display_Index=Display_Index
    return
  endif

  if n_elements(Display_Index) eq 0 then return

  Displays = DisplayVars.Displays
  Display = Dial_Display_Get_Index(Displays, Display_Index)

  if Display.Type ne 'text' then begin
    if strlen(Display.vis) gt 0 then ok = execute('live_destroy, "'+Display.vis+'", WINDOW_IN=Display.ID, Error=Error')
  endif

  ; now shifts following Data elements in Display
  if Data_Index+1 ge Display.Length-1 then begin
    for index = Data_Index+1, Display.Length-1 do begin
      Next_Data = Dial_Display_Get_Index(Display, Index)
      Dial_Display_Set_Index, Structure=Display, Index=Index-1, Value=Next_Data
    endfor
  endif
  Display.Length = Display.Length-1
  Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Delete_Data: Delete Data ' $
    +strtrim(string(Data_Index),2)+'. Now '+strtrim(string(Display.Length),2)+' elements in Display '+strtrim(string(Display_Index),2)
  if Display.Length gt 0 then Display.Update = 2

  Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
  DialTag, 'display', tag='Displays',  set=Displays

  if Display.Length ge 1 then begin
    Dial_Display_Set_Index, Structure=Displays, Index=Display_Index, Value=Display
    Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
    DialTag, 'display', tag='Displays',  set=Displays
  endif else Dial_Display_Delete_Display, DisplayVars, Display_Index=Display_Index

end; PRO Dial_Display_Delete_Data

;***************************************************************
; delete a given Display (by Name or Index)
pro Dial_Display_Delete_Display, DisplayVars, Display_Name=Display_Name, Display_Index=Display_Index

  if n_elements(Display_Name) gt 0 then begin
    Display_Name       = strjoin(strsplit(Display_Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
    if n_elements(Display_Index) eq 0 and strlen(Display_Name) gt 0 then $
      Display_Index = Dial_Display_Get_Display(DisplayVars, Display_Name)
  endif

  ; delete a non-empty Display name, when more than one Display exists
  if Display_Index ge 0 then begin
      Display = Dial_Display_Get_Index(DisplayVars.Displays, Display_Index)
      if strcmp(Display.Type, 'text') ne 0 then begin
        top = widget_info(long(Display.ID), /parent)
        widget_control, top, /destroy, Bad_id=id
      endif else live_destroy, window_in=Display.ID, Error=Error
      Displays = DisplayVars.Displays

      ; now shifts following Display elements in Displays
      if Display_Index+1 ge Displays.Length-1 then begin
        for index = Display_Index+1, Displays.Length-1 do begin
          Next_Display = Dial_Display_Get_Index(Displays, Index)
          Dial_Display_Set_Index, Structure=Displays, Index=Index-1, Value=Next_Display
        endfor
      endif
      Displays.Length = Displays.Length-1
      Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Delete_Display: Delete Display ' $
    +strtrim(string(Display_Index),2)+'. Now '+strtrim(string(Displays.Length),2)+' elements in Displays '

      Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
      DialTag, 'display', tag='Displays',  set=Displays

  endif ; else begin
    ; if n_elements((Display_Name) eq 0 then widget_control, DisplayVars.Handles.Base, /destroy, bad_id=tmp
  ; endelse

end; PRO Dial_Display_Delete_Display

;***************************************************************
pro Dial_Display_Get_List, DisplayVars, DataList=DataList, DataArr=DataArr, DisplayArr=DisplayArr

  for index=0, DisplayVars.Displays.Length-1 do begin
    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    ToDisplay = [ 'Display "'+strtrim(Display.Name,2)+'" (' $
                + Display.Type +') '+Display.ID ]
    if n_elements(DataList) eq 0 then DataList = ToDisplay else DataList = [ DataList, ToDisplay ]

    if n_elements(DisplayArr) eq 0 then DisplayArr = index else DisplayArr = [ DisplayArr, index ]
    if n_elements(DataArr) eq 0    then DataArr = -1       else DataArr = [ DataArr, -1 ]
    if strlen(Display.Name) gt 0 then begin
      for d_index=0, Display.Length-1 do begin
        Data = Dial_Display_Get_Index(Display, d_index)
        DataArr = [ DataArr, d_index ]
        DisplayArr = [ DisplayArr, index ]
        if strlen(Data.Name_Data) gt 0 then begin
          if Display.Type eq 'text' then begin
                      sv = size(Data.Data)
                      if sv(0) eq 0 then  DSize = [ strtrim(string(sv(1)),2)+' characters' ] $
                      else DSize = [ strtrim(string(sv(1)),2)+' lines' ]
                      ToDisplay = [ ' + Data "'+strtrim(Data.Name_Data,2)+'" ['+DSize+'] '+Data.Auto_Load ]
          endif
          if Display.Type eq 'plot' then begin
                      Stats = ''
                      sdata = size(Data.Data)
                      DSize = strtrim(string(sdata(1)),2)+' elements'
                      ToDisplay = [ ' + Data "'+strtrim(Data.Name_Data,2)+'" ['+DSize+'] '+Data.Auto_Load ]
          endif
          if Display.Type eq 'image' or Display.Type eq 'surface' or Display.Type eq 'contour' then begin
                    Stats = ''
                    sdata = size(Data.Data)
                    DSize = strtrim(string(sdata(1)),2)+' x '+strtrim(string(sdata(2)),2)+' elements'
                    ToDisplay = [ ' + Data "'+strtrim(Data.Name_Data,2)+'" ['+DSize+'] '+Data.Auto_Load ]
          endif
          DataList = [ DataList, ToDisplay ]
        endif
      endfor
    endif
  endfor

end; PRO Dial_Display_Get_List

;***************************************************************
; build main Display panel interface and menu
pro Dial_Display_Build, DisplayVars

  ; if not exist or Descriptor is not found in properties, then create whole Dial Interface
  if DisplayVars.Handles.Base eq 0 and xregistered('Dial_Display_Interface') eq 0 then begin

    Dial_Display_LogMessage, DisplayVars, 'normal','[ ] Welcome to Dial Display '+DisplayVars.Global.Version

    widget_control, /HOURGLASS

    if DisplayVars.Global.ParentBase eq 0 then begin ; create new window
      if DisplayVars.Global.Group_Leader eq 0 then begin
        DisplayVars.Handles.Base = widget_base(/column, title='Display Panel', $
          /TLB_SIZE_EVENTS, /TLB_KILL_REQUEST_EVENTS, mbar=Base_Menu) 
      endif else begin
        DisplayVars.Handles.Base = widget_base(/column, title='Display Panel', $
          Group_Leader=DisplayVars.Global.Group_Leader, /TLB_SIZE_EVENTS, $
          /TLB_KILL_REQUEST_EVENTS, mbar=Base_Menu) 
      endelse
    endif else begin ; incorporate into existing Widget_Base
      DisplayVars.Handles.Base = widget_base(DisplayVars.Global.ParentBase, /column)
      Base_Menu = widget_base(DisplayVars.Handles.Base, /row)
    endelse

    Base_File = widget_button(Base_Menu,value='File >',uvalue='Display_File_Menu', menu=2)
    ;** now comes the pop-up 'File >' menu items
    tmp1= widget_button(Base_File,value='Export as Image...', uvalue='Save_Data_Image')
    tmp1= widget_button(Base_File,value='Export as Postscript/Print...',     uvalue='Save_Data_PS')
    tmp1= widget_button(Base_File,value='Export as Text...',     uvalue='Save_Data_Text')
    tmp1= widget_button(Base_File,value='Close Data/Display...',    uvalue='Close_DisplayData')
    tmp1= widget_button(Base_File,value='Close All',    uvalue='Delete_All')
    tmp1= widget_button(Base_File,value='Exit',           uvalue='Close', /separator)

    Base_Edit = widget_button(Base_Menu,value='Edit >',uvalue='Display_Edit_Menu', menu=2)
    ;** now comes the pop-up 'Edit >' menu items
    tmp1= widget_button(Base_Edit,value='Edit Preferences...',     uvalue='Preferences')
    tmp1= widget_button(Base_Edit,value='Show Display List...',    uvalue='Show_List')
    tmp1= widget_button(Base_Edit,value='Update Displays',         uvalue='Update_All')
    DisplayVars.Handles.AutoUpdate= widget_button(Base_Edit,value='Auto Update: ON',         uvalue='AutoUpdate', /separator)
    DisplayVars.Handles.AutoSave  = widget_button(Base_Edit,value='Auto Save: OFF',         uvalue='AutoSave')

    Base_Help = widget_button(Base_Menu,value='Help >',uvalue='Display_Help_Menu', menu=2)
    ;** now comes the pop-up 'Help >' menu items
    tmp1= widget_button(Base_Help,value='About [File]',         uvalue='Help_File')
    tmp1= widget_button(Base_Help,value='About [Edit]',         uvalue='Help_Edit')
    tmp1= widget_button(Base_Help,value='About [Preferences]',  uvalue='Help_Preferences')
    tmp1= widget_button(Base_Help,value='About [Options]',      uvalue='Displays_Help')
    tmp1= widget_button(Base_Help,value='About Displays',       uvalue='Show_List', /separator)

    ;** now comes the Display fields Panel into a Base
    if DisplayVars.Global.OrientRow eq 0 then $
      DisplayVars.Handles.DisplayPanel = widget_base(DisplayVars.Handles.Base,/column, xpad=0, /scroll) $
    else $
      DisplayVars.Handles.DisplayPanel = widget_base(DisplayVars.Handles.Base,/row, xpad=0, /scroll)

    if DisplayVars.Global.XSize ne 0 then $
      widget_control, DisplayVars.Handles.DisplayPanel, xsize=DisplayVars.Global.XSize, bad_id=id
    if DisplayVars.Global.YSize ne 0 then $
      widget_control, DisplayVars.Handles.DisplayPanel, ysize=DisplayVars.Global.YSize, bad_id=id

    widget_control, DisplayVars.Handles.Base, /realize, bad_id=id
    XManager, 'Dial_Display_Interface', DisplayVars.Handles.Base, Event_Handler='Dial_Display_Event_Parser', $
        /just_reg, /no_block

  endif

  ; if exist, but change display type then delete display widget (text or draw) in Dial Interface

end; PRO Dial_Display_Build

;***************************************************************
;** Dial_Display_Event_Parser : event manager
pro Dial_Display_Event_Parser, event

  ;** retrieve the 'uvalue' from Widget -> Get event description
  widget_control, event.id, get_uvalue=uv, bad_id=id
  DisplayVars = Dial_Display_Get_DisplayVars()
  res = execute('Displays = DisplayVars.Displays.Length')
  if DisplayVars.Displays.Length eq 0 then res=Dial_Display_Add_Display( DisplayVars, 'example', 'plot')

  ;** First handle close and resize events
  if  tag_names(event, /STRUCTURE_NAME) eq 'WIDGET_KILL_REQUEST' then begin
      Dial_Display_Event_Close, DisplayVars
      return
  endif else begin
    type = size(uv, /type)

    if type eq 7 then begin ; String type
      ;** Checks that the Event routine exists...
      Routine = 'Dial_Display_Event_'+uv
      tmp1 = routine_info('')
      tmp1 = where(strcmp(tmp1, strupcase(Routine)))
      if tmp1(0) ge 0 then begin
       Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Event_Parser:'+uv
       call_procedure, Routine, DisplayVars
       if uv eq 'Close' then return
      endif else begin
       Dial_Display_LogMessage, DisplayVars, 'debug','[E] Dial_Display_Event_Parser: PRO '+Routine+' ?'
      endelse
    endif else begin
      if tag_names(event, /STRUCTURE_NAME) eq 'WIDGET_BASE' then begin
        DisplayVars.Global.XSize = min([event.X, 1024])
        DisplayVars.Global.YSize = min([event.Y, 768])
        Dial_Display_Event_Resize, DisplayVars

      endif else begin
        Dial_Display_LogMessage, DisplayVars, 'debug','[E] Dial_Display_Event_Parser: Unknown event'
        help, event, uv
      endelse
    endelse
  endelse

  if DisplayVars.Handles.Base ne 0 then begin
    ;** Update Dial structure
    DialTag, 'display', tag='Global',  set=DisplayVars.Global
    DialTag, 'display', tag='Handles', set=DisplayVars.Handles
    DialTag, 'display', tag='Displays',set=DisplayVars.Displays
  endif else begin
    Dial_Display_LogMessage, DisplayVars, 'normal','[ ] Dial_Display: Exiting'
  endelse

end; PRO Dial_Display_Event_Parser

;***************************************************************
pro Dial_Display_Event_Close, DisplayVars

  Dial_Display_Event_Delete_All, DisplayVars

  ; close main base
  widget_control, DisplayVars.Handles.Base, /destroy, Bad_id = id
  ;DisplayVars.Handles.Base  = 0L
  DialStop,  'display'
  DialClear, 'display'

end; PRO Dial_Display_Event_Close


;***************************************************************
; resize Base, and all Displays
pro Dial_Display_Event_Resize, DisplayVars
; Get new size of Base as event.X and event.Y depending on Global.OrientRow

  widget_control, DisplayVars.Handles.Base, map=0
  ; store original base location
  Base_Geometry = widget_info(DisplayVars.Handles.Base, /geometry)

  ; set size of DisplayPanel with that (- borders)
  widget_control, DisplayVars.Handles.DisplayPanel, xsize=DisplayVars.Global.XSize, bad_id=id
  widget_control, DisplayVars.Handles.DisplayPanel, ysize=DisplayVars.Global.YSize, bad_id=id

  new_dim = min([DisplayVars.Global.XSize, DisplayVars.Global.YSize])

  ; set size of each Live_display inside
  for index=0, DisplayVars.Displays.Length-1 do begin
    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    if strlen(Display.Name) gt 0 then begin

      live_info, Window_In=Display.ID, Properties=Prop_Vis, Error=Error
      if strlen(Error) eq 0 and DisplayVars.Global.Gathered eq 1 then begin
        Prop_Vis.Dimensions = [ new_dim, new_dim]
        if (DisplayVars.Global.OrientRow) ne 0 then $
          Prop_Vis.Location   = [ (index)*new_dim, 0 ] $
        else $
          Prop_Vis.Location   = [ 0, (index)*new_dim ]
        live_control, Window_In=Display.ID, Properties=Prop_Vis, /no_draw
      endif else Dial_Display_LogMessage, DisplayVars, 'debug','[E] Dial_Display_Event_Resize '+Error

    endif
  endfor
  ; reset Base location to original one
  if DisplayVars.Global.XSize ne 0 then $
      widget_control, DisplayVars.Handles.DisplayPanel, xsize=DisplayVars.Global.XSize, bad_id=id
  if DisplayVars.Global.YSize ne 0 then $
      widget_control, DisplayVars.Handles.DisplayPanel, ysize=DisplayVars.Global.YSize, bad_id=id
  widget_control, DisplayVars.Handles.Base, xoffset=Base_Geometry.Xoffset, yoffset=Base_Geometry.Yoffset, bad_id=id, map=1

end; PRO Dial_Display_Event_Resize

;***************************************************************
pro Dial_Display_Event_Show_List, DisplayVars, no_raise=no_raise

  ToDisplay = [ 'List of Displays and Data sets ['+systime(0)+']', '' ]
  for index=0, DisplayVars.Displays.Length-1 do begin
    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    if strlen(Display.Name) gt 0 then begin
      ToDisplay = [ ToDisplay, $
                'Display "'+strtrim(Display.Name,2)+'" (' $
                + Display.Type +') '+Display.ID ]
      for d_index=0, Display.Length-1 do begin
        Data = Dial_Display_Get_Index(Display, d_index)
        Head = '    '
        if strlen(Data.Name_Data) gt 0 and n_elements(data.data) gt 1 then begin
          myexcept = !except
          !except = 0
          if Display.Type eq 'text' then begin
                      sv = size(Data.Data)
                      if sv(0) eq 0 then  DSize = [ strtrim(string(sv(1)),2)+' characters' ] $
                      else DSize = [ strtrim(string(sv(1)),2)+' lines' ]
                      ToDisplay = [ ToDisplay, ' + Data "'+strtrim(Data.Name_Data,2)+'" ['+DSize+'] '+Data.Auto_Load ]
          endif
          if Display.Type eq 'plot' then begin
                      Stats = ''
                      sdata = size(Data.Data)
                      if n_elements(Data.IX) eq sdata(1) then IX = Data.IX else IX=lindgen(sdata(1))
                      IX = double(IX)
                      DSize = strtrim(string(sdata(1)),2)+' elements '
                      Stats = [ Head+'min='+strtrim(string(min(Data.Data)),2)+' max='+strtrim(string(max(Data.Data)),2)+' mean='+strtrim(string(mean(Data.Data)),2)+' std='+strtrim(string(stddev(Data.Data)),2)+' sum='+strtrim(string(total(Data.Data)),2) ]
                      if total(Data.Data) ne 0 then begin
                        fmon = total(IX*Data.Data)/total(Data.Data)
                        smon = total(IX*IX*Data.Data)/total(Data.Data) - fmon*fmon
                      endif else begin
                        fmon = 'NaN'
                        smon = 0
                      endelse
                      if smon gt 0 then smon = sqrt(smon)  else smon = 'NaN'
                      Stats = [ Stats, Head+'X=['+strtrim(string(min(IX)),2)+':'+strtrim(string(max(IX)),2)+']. Center='+strtrim(string(fmon),2)+' width='+strtrim(string(smon),2) ]
                      ToDisplay = [ ToDisplay, ' + Data "'+strtrim(Data.Name_Data,2)+'" ['+DSize+'] '+Data.Auto_Load+' with '+Data.Options, Stats ]
          endif
          if Display.Type eq 'image' or Display.Type eq 'surface' or Display.Type eq 'contour' then begin
                    Stats = ''
                    sdata = size(Data.Data)

                    DSize = strtrim(string(sdata(1)),2)+' x '+strtrim(string(sdata(2)),2)+' elements'
                    Stats = [ Head+'min='+strtrim(string(min(Data.Data)),2)+' max='+strtrim(string(max(Data.Data)),2)+' mean='+strtrim(string(mean(Data.Data)),2)+' std='+strtrim(string(stddev(Data.Data)),2)+' sum='+strtrim(string(total(Data.Data)),2) ]
                    if n_elements(Data.IX) eq sdata(1) then IX = Data.IX else IX=lindgen(sdata(1))
                    IX = double(IX)
                    XData = total(Data.Data,1)
                    if total(XData) ne 0 then begin
                      fmon = total(IX*XData)/total(XData)
                      smon = total(IX*IX*XData)/total(XData) - fmon*fmon
                    endif else begin
                      fmon = 'NaN'
                      smon = 0
                    endelse
                    if smon gt 0 then smon = sqrt(smon)  else smon = 'NaN'
                    Stats = [ Stats, Head+'X=['+strtrim(string(min(IX)),2)+':'+strtrim(string(max(IX)),2)+']. Center='+strtrim(string(fmon),2)+' width='+strtrim(string(smon),2) ]
                    if n_elements(Data.IY) eq sdata(2) then IY = Data.IY else IY=lindgen(sdata(2))
                    IY = double(IY)
                    YData = total(Data.Data,2)
                    if total(YData) ne 0 then begin
                      fmon = total(IY*YData)/total(YData)
                      smon = total(IY*IY*YData)/total(YData) - fmon*fmon
                    endif else begin
                      fmon = 'NaN'
                      smon = 0
                    endelse
                    if smon gt 0 then smon = sqrt(smon)  else smon = 'NaN'
                    Stats = [ Stats, Head+'Y=['+strtrim(string(min(IY)),2)+':'+strtrim(string(max(IY)),2)+']. Center='+strtrim(string(fmon),2)+' width='+strtrim(string(smon),2) ]
                    ToDisplay = [ ToDisplay, ' + Data "'+strtrim(Data.Name_Data,2)+'" ['+DSize+'] '+Data.Auto_Load+' with '+Data.Options, Stats ]
          endif
          a = check_math()
          !except   = myexcept
        endif
      endfor
    endif
  endfor

  Mem = memory(/current)
  ToDisplay = [ToDisplay, '', $
               'This is Dial Display for George.',$
               'Version:     '+DisplayVars.Global.Version, $
               'Author:      '+DisplayVars.Global.Author, $
               'Memory used: '+strtrim(Mem/1024,2)+' ko', $
               '',$
               'This IDL interface is a Dial that displays/updates data sets', $
               'originating from other IDL programs.',$
               'Contributions: D. Richard, ILL for Dial_ByGeorge; R. Sterner', $
               'and Johns Hopkins University/Applied Physics Laboratory for XList', $
               'License: This software may be used, copied, or redistributed as', $
               'long as it is not sold and this copyright notice is reproduced', $
               'on each copy made. This routine is provided as is without any', $
               'express or implied warranties whatsoever.' ]

  widget_control, DisplayVars.Handles.Base_About, set_value=ToDisplay, Bad_ID=Bad_ID
  if n_elements(no_raise) eq 0 then widget_control, DisplayVars.Handles.Base_About, show=1, iconify=0, Bad_ID=Bad_ID
  if Bad_ID ne 0 or DisplayVars.Handles.Base_About eq 0 then  begin
    xdisplayfile, 'dummy', text=ToDisplay, Group=DisplayVars.Handles.Base, $
          title='About Displays', /Editable, $
          Height=15,Width=60,Done_Button='Close [About Displays]', WText=ID

    DisplayVars.Handles.Base_About = ID
    ;** Update Dial structure
    DialTag, 'display', tag='Handles', set=DisplayVars.Handles
  endif

end; PRO Dial_Display_Event_Show_List

;***************************************************************
;** Display information about Displays/Preferences
pro Dial_Display_Event_Help_Preferences, DisplayVars, update=update

  ToDisplay =['PREFERENCES menu Help for "Displays"',$
              '',$
              'This menu enables to change some internal settings controling the execution of Displays',$
              'OrientRow=<0|1>',$
              '   sets the prefered orientation of display panel',$
              'Gathered=<0|1>',$
              '   when 1, all displays are gathered in the same panel',$
              '   when 0, they appear as separate windows',$
              'Verbosity=<level>',$
              '   affects the amount of messages displayed by Displays',$
              'History size=<-2,0,3:100>', $
              '   sets the number of counts values to remember and plot (and optionally save)', $
              'Frequency', $
              '   sets the update frequency of Displays' $
              ]

  widget_control, DisplayVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Preferences Help for Displays'
  if Bad_ID ne 0 or DisplayVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
    xdisplayfile, 'dummy', text=ToDisplay, Group=DisplayVars.Handles.Base, $
          title='Preferences Help for Displays',$
          Height=20,Width=80,Done_Button='Close [Displays Help]', WText=ID
    DisplayVars.Handles.Base_Help = ID
    ;** Update Dial structure
    DialTag, 'display', tag='Handles', set=DisplayVars.Handles
  endif

end; PRO Dial_Display_Event_Help_Preferences

;***************************************************************
;** Display information about Displays/File menu
pro Dial_Display_Event_Help_File, DisplayVars

  ToDisplay =['File menu Help for "Displays"',$
              '',$
              'This menu enables to export data and close exit appilcation',$
              'Export ar Image',$
              '   choose a Display and save it as JPG, GIF, TIFF, BMP, PICT, PNG', $
              'Export ar Postscript/Print',$
              '   choose a Display and save it as PostScript or send it to a Printer', $
              'Export ar Text',$
              '   choose a Display and save it as a text file', $
              'Close Data/Display', $
              '   choose a Display/Data set and close it (delete data/remove)', $
              'Exit', $
              '   exit Display application' $
              ]

  widget_control, DisplayVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Preferences Help for Displays'
  if Bad_ID ne 0 or DisplayVars.Handles.Base_Help eq 0 then  begin
    xdisplayfile, 'dummy', text=ToDisplay, Group=DisplayVars.Handles.Base, $
          title='File Help for Displays',$
          Height=20,Width=80,Done_Button='Close [Displays Help]', WText=ID
    DisplayVars.Handles.Base_Help = ID
    ;** Update Dial structure
    DialTag, 'display', tag='Handles', set=DisplayVars.Handles
  endif

end; PRO Dial_Display_Event_Help_File

;***************************************************************
;** Display information about Displays/Edit menu
pro Dial_Display_Event_Help_Edit, DisplayVars

  ToDisplay =['Edit menu Help for "Displays"',$
              '',$
              'This menu enables to configure/view display options',$
              'Edit Preferences',$
              '   edit the Dial Display preferences (see Help for that topic)', $
              'Show display list',$
              '   displays the list of active displays, as well as basic statistics', $
              'Update displays',$
              '   force the update of displays (instead of waiting for automatic update)', $
              'Auto Update: ON/OFF', $
              '   toggles the automatic display update (with Frequency specified in Preferences)', $
              'Auto Save: ON/OFF', $
              '   toggles the automatic display save as text files (with each display Update)' $
              ]

  widget_control, DisplayVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Preferences Help for Displays'
  if Bad_ID ne 0 or DisplayVars.Handles.Base_Help eq 0 then  begin
    xdisplayfile, 'dummy', text=ToDisplay, Group=DisplayVars.Handles.Base, $
          title='File Help for Displays',$
          Height=20,Width=80,Done_Button='Close [Displays Help]', WText=ID
    DisplayVars.Handles.Base_Help = ID
    ;** Update Dial structure
    DialTag, 'display', tag='Handles', set=DisplayVars.Handles
  endif

end; PRO Dial_Display_Event_Help_Edit

;***************************************************************
;** Display information about Display options
pro Dial_Display_Event_Displays_Help, DisplayVars, DisplayHelp=DisplayHelp

  ToDisplay =['Options=</log,/scatter,/histogram,/polar>', $
              '        </add,/overlay,/catenate,/unactivate,/exact,/no,/delete>', $
              '        <IX=[expr], IY=[expr], Name_IX="...", Name_IY="..."', $
              '         Comment="...", Auto_Load="...">', $
              '   sets some display options to use. ', $
              '   options that affect Data', $
              '      IX=[expr] sets the expression/variable to use as X axis values (for 1D/2D data sets)', $
              '      IY=[expr] sets the expression/variable to use as Y axis values (for 2D maps)', $
              '      Name_IX="..." sets the name of X axis (when IX is given)', $
              '      Name_IY="..." sets the name of Y axis (when IY is given)', $
              '      Name_Data="..." sets the name of the Data set (default is the Variable name)', $
              '      Auto_Load="..." sets the expression to be evaluated before each update', $
              '      Comment="..." sets a comment to appear on plot', $
              '   options that affect the way data is stored. Default is to replace data.', $
              '      /add: to add (sum-up) new data with the existing one', $
              '      /overlay: to display new data set on the same axis system', $
              '      /catenate: to append new data with previous one', $
              '      /unactivate: do not update/display data', $
              '      /delete: delete data set/display', $
              '      /no: remove the other options from data/plot options list', $
              '   options that affect the way the display appears', $
              '      /scatter: only plots symbols (default is line and symbols)', $
              '      /histogram: plots data as an histogram (steps)', $
              '      /polar: plots data in polar coordinates, when IX is given', $
              '      /detached: when a new plot will be created, it will appear as a separate window', $
              '      /exact: the [XYZ] axis will be tight around data' $
              ]

  if n_elements(DisplayHelp) ne 0 then begin
    DisplayHelp = ToDisplay
    return
  endif

  ToDisplay = [ 'Dial Display Options', '', $
                'These options are to be used when calling the "display" command:', '', $
                '    display, Data=<data set>, Name_Data="<Data set Name>", [Options]', $
                'with:', '', $
                ToDisplay, $
                '']

  widget_control, DisplayVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Display Options Help'
  if Bad_ID ne 0 or DisplayVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
    xdisplayfile, 'dummy', text=ToDisplay, Group=DisplayVars.Handles.Base, $
          title='Display Options Help',$
          Height=20,Width=80,Done_Button='Close [Displays Help]', WText=ID
    DisplayVars.Handles.Base_Help = ID
    ;** Update Dial structure
    DialTag, 'display', tag='Handles', set=DisplayVars.Handles
  endif

end; PRO Dial_Display_Event_Displays_Help


;***************************************************************
; enable to change preferences for Dial Displays
pro Dial_Display_Event_Preferences, DisplayVars

  Preferences = {Display_Preferences, $
            OrientRow:DisplayVars.Global.OrientRow,$
            Gathered:DisplayVars.Global.Gathered,$
            Verbosity:DisplayVars.Global.Verbosity, $
            Plot:DisplayVars.Plot, $
            Frequency:DisplayVars.Frequency}

  Dial_Display_Event_Help_Preferences, DisplayVars, update=1

  Dialog_Fields, Preferences, Group=DisplayVars.Handles.Base, COLUMN_WIDTHS=500, $
    Name='Please enter new Display Preferences', Title='Preferences for Displays', $
    y_scroll_size=n_elements(tag_names(Preferences)), $
    FieldNames = [ 'Orient Row', 'Gathered','Verbosity', 'History size', 'Frequency' ]

  DisplayVars.Global.OrientRow = Preferences.OrientRow
  DisplayVars.Global.Gathered  = Preferences.Gathered
  DisplayVars.Plot             = Preferences.Plot
  DisplayVars.Frequency        = Preferences.Frequency
  LevelList      = ['silent','normal','verbose','debug']
  tmp1 = where(strcmp(LevelList, Preferences.Verbosity))
  if tmp1(0) ne -1 then $
    DisplayVars.Global.Verbosity = Preferences.Verbosity $
  else $
    Light_LogMessage, DisplayVars, 'normal','[w] Verbosity can be: silent, normal, verbose, debug'

  ;** Update Dial structure
  DialTag, 'display', tag='Global',  set=DisplayVars.Global
  DialTag, 'display', tag='Frequency',  set=DisplayVars.Frequency
  DialTag, 'display', tag='Plot',  set=DisplayVars.Plot


end; PRO Dial_Display_Event_Preferences

;***************************************************************
; update all displays
pro Dial_Display_Event_Update_All, DisplayVars

  Displays = DisplayVars.Displays
  DisplayVars.Global.Update = 1;

  for index=0,DisplayVars.Displays.Length-1 do begin
    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    Display.Update = 2
    Dial_Display_Set_Index, Structure=Displays, Index=index, Value=Display
  endfor

  Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
  DialTag, 'display', tag='Displays',  set=Displays

  Dial_Display_Event_Update, DisplayVars

end; PRO Dial_Display_Event_Update_All

;***************************************************************
; update displays that have their Display.Update =1
pro Dial_Display_Event_Update, DisplayVars

  widget_control, DisplayVars.Handles.Base, bad_id=tmp1
  if tmp1 ne 0 then begin
    ; Dial_Display_Event_Close, DisplayVars
    return
  endif

  Displays = DisplayVars.Displays

  for index=0,DisplayVars.Displays.Length-1 do begin

    Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
    ; execute autoload for Each Data set if exists
    for d_index = 0, Display.Length-1 do begin
      This_Data = Dial_Display_Get_Index(Display, d_index)
      if strlen(This_Data.Auto_Load) gt 0 then begin
        ok = execute(This_Data.Auto_Load)
        if ok ne 0 then begin
          if n_elements(IX) ne 0 or n_elements(IY) ne 0 or n_elements(Data) ne 0 $
          or n_elements(Auto_Load) ne 0 or n_elements(Type) ne 0 or n_elements(Options) ne 0 then begin
            Dial_Display_Add_Data, DisplayVars, IX=IX, IY=IY, Data=Data, Name_Data=This_Data.Name_Data, Type=Type, Options=Options, Auto_Load=Auto_Load
            Display = Dial_Display_Get_Index(DisplayVars.Displays, index)
          endif
        endif
      endif
    endfor  ; d_index

    ; then update Displays if requested (DisplayVars.Global.Update)

    if Display.Update ne 0 and DisplayVars.Global.Update ne 0 then begin
      Dial_Display_LogMessage, DisplayVars, 'debug','[I] Dial_Display_Event_Update: Updating Display '+string(index)+' "'+Display.Name+'":'+' '+Display.ID+' ('+Display.Type+') Update level='+strtrim(string(Display.Update),2)
      IsLogScale = 0
      Comment = ""
      Name_IX = ""
      Name_IY = ""
      Name_Data = ""
      Comments = ""
      for d_index = 0, Display.Length-1 do begin
        if DisplayVars.Global.AutoSave ne 0 then Dial_Display_Event_Save_Data_Image, DisplayVars, Display_Index=Index, Data_Index=D_Index, filename='auto'
        This_Data = Dial_Display_Get_Index(Display, d_index)
        Data = This_Data.Data
        SizeData = size(Data)
        Name_Data = This_Data.Name_Data
        if strpos(This_Data.Options, 'log') ge 0 and n_elements(Data) ge 0 then begin
          if Display.Type eq 'contour' or Display.Type eq 'image' then begin
            tmp1 = where(Data gt 0)
            if tmp1(0) lt 0 then begin
              Data = data+1e-37
              tmp1 = where(Data gt 0)
            endif
            minData = min(Data(tmp1))
            tmp1 = where(Data le 0)
            if tmp1(0) ge 0 then Data(tmp1) = (tmp1*0)+minData
            Data= alog10(Data)
          endif
          IsLogScale = 1
        endif
        if strlen(strjoin(This_Data.Comment)) gt 0 then $
          if strlen(Comments(0)) eq 0 then Comments = This_Data.Comment $
          else  Comments = [ Comments, This_Data.Comment ]
        ok = execute('Data'+strtrim(string(d_index),2)+' = Data')
        if d_index eq 0 then begin
          X = This_Data.IX
          Y = This_Data.IY
          Comment = This_Data.Comment
          Name_IX = This_Data.Name_IX
          Name_IY = This_Data.Name_IY
          Names = Name_Data
          if strlen(Name_IX) gt 0 and n_elements(X) ne SizeData(1) then X = lindgen(SizeData(1))
          if strlen(Name_IY) gt 0 and n_elements(Y) ne SizeData(2) then Y = lindgen(SizeData(2))
          minX = min(X) & maxX = max(X)      & if minX eq maxX then maxX = minX + 1e-3
          minY = min(Y) & maxY = max(Y)      & if minY eq maxY then maxY = minY + 1e-3
          minD = min(Data) & maxD=max(Data)  & if minD eq maxX then maxD = minD + 1e-3
          ;if strpos(This_Data.Options, 'log') then Name_IX = Name_IX+' (log)'
          Indep = ''
          if Display.Type ne 'text' and strpos(This_Data.Options,'exact') ge 0 then Indep = Indep+', XRange=[minX, maxX], YRange=[minY, maxY]'
          if Display.Type eq 'plot' then begin
            ToName = '{Data:Names, I:Name_IX}'
            if SizeData(1) eq n_elements(X) then Indep = Indep+', INDEPENDENT=X'
            minY = minD & maxY=maxD
          endif else begin
            if Display.Type ne 'image' then begin
              ToName = '{Data:Names, IX:Name_IX, IY:Name_IY}'
              if Display.Type ne 'text' and strpos(This_Data.Options,'exact') ge 0 then Indep = Indep+', ZRange=[minD, maxD]'
              if SizeData(1) eq n_elements(X) then Indep = Indep+', XINDEPENDENT=X'
              if SizeData(2) eq n_elements(Y) then Indep = Indep+', YINDEPENDENT=Y'
            endif else ToName = '{Data:Names}'
          endelse
        endif else Names = [ Names, Name_Data]
        ok = execute('Name = '+ToName)
        if strcmp(Display.Type, 'text') ne 0 then begin
          if d_index eq 0 then ToDisplay = Data0 $
          else ok = execute('ToDisplay = [ ToDisplay, Data'+strtrim(string(d_index),2)+']')
        endif else begin
          if d_index eq 0 then ToDisplay = 'Data0' $
          else ok = execute("ToDisplay = ToDisplay+', Data"+strtrim(string(d_index),2)+"'")
        endelse
      endfor  ; d_index
      if Display.Length ne 0 then begin
        case Display.Type of
        'text': begin
                  widget_control, long(Display.ID), set_value=ToDisplay, Bad_ID=Bad_ID
                  if Bad_ID ne 0 and long(Display.ID) ne 0 then begin
                    xdisplayfile, 'dummy', text=ToDisplay, $
                    Group=DisplayVars.Handles.Base, /Editable, title=Display.Name, Done_Button='Close ['+Display.Name+']', WText=ID
                    Display.ID = strtrim(string(ID),2)
                  endif
                end
        else:   begin
                  Error = ''
                    ; Update = 1: keep current live view, and just update the data block (faster)
                    ; Update = 2: destroy current view and rebuild a new one at the same place, with present values
                  if Display.Update eq 1 and Display.Length eq 1 then begin
                    ; fast update when only Data changes:
                    ; require to use same Variable Name as Data Name
                    ok = execute(Display.Name+' = Data0')
                    ok = execute('live_control, '+Display.Name+', WINDOW_IN=Display.ID, Error=Error, /update_data')
                    if ok eq 0 or strlen(Error) ne 0 then begin
                      Display.Update = 2
                      Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Update (fast)'+Error
                    endif
                  endif
                  if Display.Update eq 2 or Display.Length gt 1 then begin
                   if strlen(Display.vis) gt 0 then ok = execute('live_destroy, "'+Display.vis+'", WINDOW_IN=Display.ID, Error=Error')
                    if strlen(Error) ne 0 then Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Update (destroy)'+Error
                    ; handle specific options
                    if Display.Type eq 'plot' and size(This_Data, /type) eq 8 then begin
                      if strpos(This_Data.Options, 'scatter') ge 0 then ToDisplay = ToDisplay+', /scatter' $
                      else if strpos(This_Data.Options, 'polar') ge 0 and strpos(Indep, 'INDEPENDENT=X') then ToDisplay = ToDisplay+', /polar' $
                      else if strpos(This_Data.Options, 'histogram') ge 0 then ToDisplay = ToDisplay+', /histogram'
                    endif
                    ok = execute('live_'+Display.Type+', '+ToDisplay+', WINDOW_IN=Display.ID, Name=Name, Reference_out=R_out, Error=Error, Title=Display.Name '+Indep)
                    if strlen(Error) ne 0 then begin
                      ; recreate that Display (external window that was closed, Gathered must be 0 for that)
                      if DisplayVars.Global.Gathered eq 0 then begin
                        ok = execute('live_'+Display.Type+', '+ToDisplay+', Name=Name, Reference_out=R_out, Error=Error, Title=Display.Name, DRAW_DIMENSIONS=[200, 200] '+Indep)
                      endif else begin
                        ok = execute('live_'+Display.Type+', '+ToDisplay+', Name=Name, Reference_out=R_out, Error=Error, Title=Display.Name, PARENT_BASE=DisplayVars.Handles.DisplayPanel, DRAW_DIMENSIONS=[200, 200] '+Indep)
                      endelse
                      if strlen(Error) ne 0 then begin
                        Dial_Display_LogMessage, DisplayVars, 'normal','[E] Dial_Display_Event_Update (rebuild)'+Error
                        Dial_Display_LogMessage, DisplayVars, 'normal','[I] Dial_Display_Event_Update Removing Invalid Data Set '+string(d_index)+' in '+string(index)
                        Dial_Display_Delete_Data, DisplayVars, Display_Index=index, Data_Index=D_Index
                      endif

                    endif
                    ; now update axis/titles
                    if strlen(Error) eq 0 then begin
                      Display.ID = R_out.win
                      if strlen(R_out.win) eq 0 then $
                        Display.ID = R_out.vis
                      Display.Vis = R_out.vis

                      if Display.Type ne 'image' then begin
                        ModifiedX = 0
                        ModifiedY = 0
                        ModifiedZ = 0
                        live_info, R_out.xaxis, WINDOW_IN=Display.ID, Error=Error, Properties=XaxisProp
                        live_info, R_out.yaxis, WINDOW_IN=Display.ID, Error=Error, Properties=YaxisProp
                        if Display.Type ne 'plot' and Display.Type ne 'contour' then begin
                          live_info, R_out.zaxis, WINDOW_IN=Display.ID, Error=Error, Properties=ZaxisProp
                          if strpos(Indep, 'ZRange') ge 0 and ZaxisProp.exact ne 1 then begin
                            ModifiedZ       = 1
                            ZaxisProp.exact = 1
                          endif
                        endif
                        if Display.Type eq 'plot' and Display.Length eq 1 and Display.Update eq 2 then begin
                          Colors = ['Red','Green','Blue','Magenta','Cyan','Dark Gray','Brown','Light Red','Light Green','Light Blue','Light Magenta']
                          info = {color:Colors(randomu(seed, /long) mod n_elements(Colors))}
                          live_control, R_out.graphic, properties=info, window_in=Display.ID
                        endif

                        if strpos(Indep, 'XRange') ge 0 and XaxisProp.exact ne 1 then begin
                          ModifiedX       = 1
                          XaxisProp.exact = 1
                        endif
                        if strpos(Indep, 'YRange') ge 0 and YaxisProp.exact ne 1 then begin
                          ModifiedY       = 1
                          YaxisProp.exact = 1
                        endif

                        if IsLogScale then begin
                          if Display.Type eq 'plot' or Display.Type eq 'contour' then begin
                            if (YaxisProp.axistitle ne Name_IY+' (log)' and YaxisProp.axistitle ne Name_Data+' (log)') or YaxisProp.log ne 1 then begin
                              ModifiedY     = 1
                              YaxisProp.log = 1
                              if strlen(Name_IY) gt 0 then YaxisProp.axistitle = Name_IY+' (log)' $
                              else YaxisProp.axistitle = Name_Data+' (log)'
                            endif
                          endif else begin
                            if ZaxisProp.axistitle ne Name_Data+' (log)' or ZaxisProp.log ne 1 then begin
                              ModifiedZ     = 1
                              ZaxisProp.log = 1
                              ZaxisProp.axistitle = Name_Data+' (log)'
                            endif
                          endelse
                        endif else begin
                          if Display.Type ne 'plot' and Display.Type ne 'contour' then begin
                            if ZaxisProp.axistitle ne Name_Data then begin
                              ModifiedZ      = 1
                              ZaxisProp.axistitle = Name_Data
                            endif
                          endif else if Display.Type ne 'contour' and YaxisProp.axistitle ne Name_IY then begin
                              ModifiedY      = 1
                              YaxisProp.axistitle = Name_IY
                            endif
                        endelse

                        if ModifiedX ne 0 then live_control, R_out.xaxis, WINDOW_IN=Display.ID, Error=Error, Properties=XaxisProp
                        if ModifiedY ne 0 then live_control, R_out.yaxis, WINDOW_IN=Display.ID, Error=Error, Properties=YaxisProp
                        if ModifiedZ ne 0 then live_control, R_out.zaxis, WINDOW_IN=Display.ID, Error=Error, Properties=ZaxisProp

                      endif else begin
                        live_info,    R_out.graphic, properties=info, window_in=Display.ID
                        if info.palette ne DisplayVars.Global.DefaultColorMap and Display.Update eq 2 then begin
                          info.palette          = DisplayVars.Global.DefaultColorMap
                          info.SIZING_CONSTRAINT= 2
                          live_control, R_out.graphic, properties=info, window_in=Display.ID
                        endif
                      endelse
                      if strlen(strjoin(Comment)) gt 0 then begin
                        live_text, Comments, WINDOW_IN=Display.ID, Error=Error, Location=[0.3,0.9]
                      endif
                    endif else Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Update (rebuild)'+Error
                  endif ; whole update
                end
        endcase
      endif ; Display.Length
      Display.Update = 0
      widget_control, DisplayVars.Handles.Base_About, Bad_ID=Bad_ID
      ; Bad_ID: If no error occurs, a zero is stored.
      if Bad_ID eq 0 and DisplayVars.Handles.Base_About ne 0 then Dial_Display_Event_Show_List, DisplayVars, /no_raise

      n_index = index+1
      n_index = n_index-1
      Dial_Display_Set_Index, Structure=Displays, Index=n_index, Value=Display

    endif ; Display.Update ne 0


  endfor  ; index
  DisplayVars.Global.Update = 0;
  Tools_StructSetValue, struct=DisplayVars, tag='Displays', val=Displays
  DialTag, 'display', tag='Displays',  set=Displays

end; PRO Dial_Display_Event_Update

;***************************************************************
; ask for a given data set/display to be saved as an image file/text file or to delete
; other calls with Type='text' [to save as a text] and Type='close' to delete a DataSet/Display
; filename can be given for automatic Data save as type='text'. Provide Display_Index/Data_Index/Name_Data
pro Dial_Display_Event_Save_Data_Image, DisplayVars, Display_Index=Display_Index, Data_Index=Data_Index, Type=Type, filename=filename, Name_Data=Name_Data

  if n_elements(type) eq 0 then  type ='image'
  if n_elements(Name_Data) gt 0 then begin
    Name_Data       = strjoin(strsplit(Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
    if n_elements(Data_Index) eq 0 and strlen(Name_Data) gt 0 then $
      Data_Index = Dial_Display_Get_Data(DisplayVars, Data_Name, Display_Index=Display_Index)
  endif

  if n_elements(Display_Index) eq 0 then begin
    Dial_Display_Get_List, DisplayVars, DataList=DataList, DataArr=DataArr, DisplayArr=DisplayArr
    if n_elements(DataList) eq 0 then begin
      Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Save_Data_Image: no active Display '
      return
    endif
    title = 'Select a Display to export as an Image'
    if type eq 'close' then title = 'Select a Display to Close/Delete' $
    else if type eq 'text' then title = 'Select a Display to export as Text'

    UserChoice = xlist(DataList, title=title)
    if strlen(UserChoice) gt 0 then begin
      index = where(UserChoice eq DataList)
      index = index(0)
      if index eq -1 then begin
        Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Save_Data_Image: '+UserChoice+' ?'
        return
      endif
      Display_Index = DisplayArr(index)
      Data_Index    = DataArr(index)
    endif else return
  endif

  if Display_Index lt 0 or Display_Index ge DisplayVars.Displays.length then begin
    Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Save_Data_Image: invalid Display index '+string(Display_Index)
    return
  endif

  Display = Dial_Display_Get_Index(DisplayVars.Displays, Display_Index)

  if n_elements(filename) ne 0 then  type ='text'

  if type eq 'close' then begin
    if Data_Index ge 0 then $
      Dial_Display_Delete_Data, DisplayVars, Display_Index=Display_Index, Data_Index=Data_Index $
    else $
      Dial_Display_Delete_Display, DisplayVars, Display_Index=Display_Index
    return
  endif

  if type eq 'image' or type eq 'postscript' then begin
    if Display.Type eq 'text' then begin
      Dial_Display_LogMessage, DisplayVars, 'normal','[E] Dial_Display_Event_Save_Data_Image: can not save text Display as an image'+string(index)+' "'+Display.Name+'":'+' '+Display.ID+' ('+Display.Type+')'
      return
    endif
    filename = strjoin(strsplit(Display.Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
    if type eq 'image' then begin
      live_export, WINDOW_IN=Display.ID, /dialog, filename=filename+'.jpg'
    endif else begin
      live_print, WINDOW_IN=Display.ID, /dialog, Error=Error, /vector
    endelse
    Dial_Display_LogMessage, DisplayVars, 'verbose','[E] Dial_Display_Event_Save_Data_Image: save Display as an image/postscript '+string(index)+' "'+Display.Name+'":'+' '+Display.ID+' ('+Display.Type+')'
    return
  endif

  if type eq 'text' then begin
    if Data_Index lt 0 then begin
      for d_index = 0, Display.Length-1 do $ ; for all Data Sets
        Dial_Display_Event_Save_Data_Image, DisplayVars, Display_Index=Display_Index, Data_Index=d_index, Type='text'
    endif else begin ; for an existing Data Set
      This_Data = Dial_Display_Get_Index(Display, Data_Index)
      sData = size(This_Data.Data, /dim)
      if n_elements(filename) ne 0 then $
        if filename eq 'auto' then $
          if Display.Name ne This_Data.Name_Data then filename = strjoin(strsplit(Display.Name+This_Data.Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')+'.dat' $
          else filename = strjoin(strsplit(This_Data.Name_Data,' /\;*?$!~<>{}()|[]%&', /extract),'_')+'.dat'
      if n_elements(filename) eq 0 then begin
        if Display.Name ne This_Data.Name_Data then filename = strjoin(strsplit(Display.Name+This_Data.Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')+'.dat' $
          else filename = strjoin(strsplit(This_Data.Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')+'.dat'
        filename = dialog_pickfile(Dialog_Parent=DisplayVars.Handles.Base, file=filename, filter='*.dat', $
            Get_Path=Selected_Path, Title='Saving Data "'+This_Data.Name_Data+'" as Text')
      endif
      if n_elements(filename) eq 0 then return
      Header = [ '# Display: '+string(Display_Index)+' "'+Display.Name+'":'+' '+Display.ID+' ('+Display.Type+')', $
                 '# Data:    '+string(Data_Index)+' "'+This_Data.Name_Data+'" ['+strtrim(strjoin(string(sData)),2)+'] elements', $
                 '# Comment: '+strjoin(This_Data.Comment,' '), $
                 '# Date:    '+systime(0)+' [Started '+systime(0, This_Data.Date)+'='+strtrim(string(This_Data.Date, format='(I11)'),2)+']', $
                 '# Exported by Dial Display '+DisplayVars.Global.Version ]
      ToExport = Header
      if Display.Type ne 'text' then begin
        ; translate IX, IY, Data to text
        Data = This_Data.Data
        IX = This_Data.IX
        IY = This_Data.IY
        Data = string(Data)
        if n_elements(sData) eq 2 then begin
          Data = strjoin(transpose(Data))
          for index = 0, sData(1)-1 do ToExport = [ ToExport, Data(index) ]
        endif else ToExport = [ ToExport, strjoin(Data) ]
        if sData(0) eq size(IX, /n_elements) then begin
          IX = strjoin(string(IX),/single)
          ToExport = [ ToExport, '# X axis values ('+This_Data.Name_IX+')', IX ]
        endif
        if n_elements(sData) gt 1 then $
          if sData(1) eq size(IY, /n_elements) then begin
            IY = strjoin(string(IY),/single)
            ToExport = [ ToExport, '# Y axis values ('+This_Data.Name_IY+')', IY ]
          endif
      endif else begin
        ToExport = [ ToExport, This_Data.data ]
      endelse
      OPENW, unit, FILENAME, /GET_LUN, ERROR=i    ;open the file and then
      if i lt 0 then begin    ;OK?
        a = [ !error_state.msg, filename + ' could not be opened for writing.']  ;No
        void = DIALOG_MESSAGE(a, /ERROR, DIALOG_PARENT=wText)
      endif else begin
        ON_IOERROR, done_writing
        ; print out each line separately in order to get desired line breaks
        for j = 0, N_ELEMENTS(ToExport)-1 do PRINTF, unit, ToExport[j]
        done_writing:
        ON_IOERROR, null
        FREE_LUN, unit        ;free the file unit.
      endelse
      Dial_Display_LogMessage, DisplayVars, 'verbose','[I] Dial_Display_Event_Save_Data_Image: save Data as text '+filename

    endelse
    return
  endif

end; PRO Dial_Display_Event_Save_Data_Image

;***************************************************************
; delete a given data set/display
pro Dial_Display_Event_Close_DisplayData, DisplayVars

  Dial_Display_Event_Save_Data_Image, DisplayVars, type='close'

end; PRO Dial_Display_Event_Close_DisplayData

;***************************************************************
; ask for a given data set/display to be saved as a text file or to delete
pro Dial_Display_Event_Save_Data_Text, DisplayVars

  Dial_Display_Event_Save_Data_Image, DisplayVars, type='text'

end; PRO Dial_Display_Event_Save_Data_Text

;***************************************************************
; ask for a given data set/display to be saved as a text file or to delete
pro Dial_Display_Event_Save_Data_PS, DisplayVars

  Dial_Display_Event_Save_Data_Image, DisplayVars, type='postscript'

end; PRO Dial_Display_Event_Save_Data_PS


;***************************************************************
; ask for a given data set/display to be saved as a text file or to delete
pro Dial_Display_Event_Delete_All, DisplayVars

; close all Live_displays and text windows
tmp = where(strmatch(tag_names(DisplayVars),'DISPLAYS'))
  if tmp(0) eq -1 then return
  for index=DisplayVars.Displays.Length-1, 0, -1 do begin
    Dial_Display_Delete_Display, DisplayVars, Display_Index=Index
  endfor

end; PRO Dial_Display_Event_Delete_All

;*****************************************
; start/stop auto save of updated data
pro Dial_Display_Event_AutoSave, DisplayVars

  if (DisplayVars.Global.AutoSave eq 0) then begin
    DisplayVars.Global.AutoSave = 1
    widget_control, DisplayVars.Handles.AutoSave, set_value='Auto Save: ON'
  endif else begin
    DisplayVars.Global.AutoSave = 0
    widget_control, DisplayVars.Handles.AutoSave, set_value='Auto Save: OFF'
  endelse
  DialTag, 'display', tag='Global',  set=DisplayVars.Global

end; PRO Dial_Display_Event_AutoSave

;*****************************************
; start/stop auto update of displays
pro Dial_Display_Event_AutoUpdate, DisplayVars

  if (DisplayVars.Global.AutoUpdate eq 0) then begin
    DisplayVars.Global.AutoUpdate = 1
    widget_control, DisplayVars.Handles.AutoUpdate, set_value='Auto Update: ON'
  endif else begin
    DisplayVars.Global.AutoUpdate = 0
    widget_control, DisplayVars.Handles.AutoUpdate, set_value='Auto Update: OFF'
  endelse
  DialTag, 'display', tag='Global',  set=DisplayVars.Global

end; PRO Dial_Display_Event_AutoUpdate

;***************************************************************
; Add/Set/Catenate new Data to a given Display/Data (user entry call)
pro Display, Display_Name=Display_Name, $
             IX=IX, IY=IY, Data=Data, $
             Name_IX=Name_IX, Name_IY=Name_IY, Name_Data=Name_Data, $
             Type = Type, Options=Options, Auto_Load=Auto_Load, unactivate=unactivate, $
             Add=Add, Overlay=Overlay, Catenate=Catenate, $
             Scatter=Scatter, Histogram=Histogram, Polar=Polar, Log=Log, $
             Comment=Comment, Update=Update, Delete=Delete, Gathered=Gathered, No=No, Exact=Exact, $
             Detached=Detached, DisplayHelp=DisplayHelp, save=save, group_leader=group_leader

  ; launch Dial_Display if not active yet
  DisplayVars = Dial_Display_Get_DisplayVars()
  if DisplayVars.Name ne 'display' or xregistered('Dial_Display_Interface') eq 0 then begin
    DialInit,  'display'
    DisplayVars = Dial_Display_Get_DisplayVars()
    DisplayVars.OnOff = 0
    if n_elements(group_leader) ne 0 then DisplayVars.Global.group_leader = group_leader
  endif
  widget_control, DisplayVars.Handles.Base, Bad_id = Bad_id
  if (Bad_ID ne 0 or DisplayVars.Handles.Base eq 0) then Dial_Display_Build, DisplayVars
  if DisplayVars.OnOff eq 0 then DialStart, 'display'

  if n_elements(Name_Data) gt 0 then Name_Data       = strjoin(strsplit(Name_Data,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
  if n_elements(Display_Name) gt 0 then Display_Name = strjoin(strsplit(Display_Name,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')

  if n_elements(DisplayHelp)       ne 0 then Dial_Display_Event_Displays_Help, DisplayVars, DisplayHelp=DisplayHelp
  if n_elements(unactivate) gt 0 then return
  if n_elements(save)       ne 0 and n_elements(Name_Data) ne 0 then Dial_Display_Event_Save_Data_Image, DisplayVars, type='text', filename=filename, Name_Data=Name_Data
  if n_elements(Detached)   ne 0 then Gathered = 0
  if n_elements(Gathered)   ne 0 then begin
    GatheredOld = DisplayVars.Global.Gathered
    DisplayVars.Global.Gathered = Gathered(0)
  endif

  if n_elements(Delete) gt 0 then begin
    if n_elements(Name_Data) eq 0 and n_elements(Display_Name) eq 0 then Dial_Display_Event_Delete_All, DisplayVars $
    else Dial_Display_Delete_Data, DisplayVars, Display_Name=Display_Name, Name_Data=Name_Data
    return
  endif

  Dial_Display_Add_Data, DisplayVars, Display_Name=Display_Name, $
                           IX=IX, IY=IY, Data=Data, $
                           Name_IX=Name_IX, Name_IY=Name_IY, Name_Data=Name_Data, $
                           Type = Type, Options=Options, Auto_Load=Auto_Load, $
                           Add=Add, Overlay=Overlay, Catenate=Catenate, $
                           Scatter=Scatter, Histogram=Histogram, Polar=Polar, Log=Log, $
                           Comment=Comment, No=No, Exact=Exact

  if n_elements(Update) gt 0 then begin
    DisplayVars.Global.Update = 1;
    Dial_Display_Event_Update, DisplayVars
  endif

  if n_elements(Gathered) ne 0 then begin
    DisplayVars.Global.Gathered = GatheredOld
  endif

  ;** Update Dial structure
  DialTag, 'display', tag='Global',  set=DisplayVars.Global
  DialTag, 'display', tag='Handles', set=DisplayVars.Handles
  DialTag, 'display', tag='Displays',set=DisplayVars.Displays

end; PRO Display

;*********************
PRO dial_display_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_display
;** This macro procedure is called by George every D.frequency seconds

    if D.init eq 0 then begin
      D.init = 1
      Dial_Display_Build, D
    endif
    if D.init eq 1 then begin
      if D.Global.AutoUpdate ne 0 then D.Global.Update = 1;
      Dial_Display_Event_Update, D
    endif

    ;V=DialNewValue()    ; get value to display on Dial display
    ;DialModValue, V ,tag='VALUE'    ;(or D.value=V if dimensions are correct)
end



;*********************
FUNCTION dial_display
;*********************
;**
;** The dial initialisation (and stucture definition)

  if xregistered('Dial_Display_Interface') ne 0 then begin
    DisplayVars = Dial_Display_Get_DisplayVars()
    Dial_Display_LogMessage, DisplayVars, 'normal','[E] Dial_Display_Event_Update: Dial_Display is already running !'
    widget_control, DisplayVars.Handles.Base, Bad_ID=Bad_ID, show=1, iconify=0
    return, DisplayVars
  endif else begin

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;then V=DialNewValue() stands for V=DialNewValue(TYPE='monitor')
    ONOFF=1          ;state of the Dial 1=running
    FREQUENCY=60.0     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0 ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0L           ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file light.his
    Preset=0       ;if >0 then Dial is stopped after running Preset seconds
    WUPDATE=0        ;=1 to automaticaly update corresponding workspace, =-1 silent!
                     ;=2 to automaticaly update and plot workspace to the main window
                     ;   0,1,2 are set by pressing the left,middle,right mouse button on the dial snapshot
    INIT=0

    ;User Variables (Must be present in return statement to be available)
    ;-------------

    DataStruct = { IX:[0], IY:[0], Data:[0], $  ; Description and content of one data set
                Name_IX:'X', Name_IY:'Y', Name_Data:'', $
                Auto_Load:"", $     ; executed for each Frequency dial tic
                Date:systime(1), $  ; time of first load
                Comment:"", $       ; comment to be displayed
                Options:"" }        ; may contain Add, Overlay, Replace, Catenate, Scatter, Histogram, Polar

    DisplayStruct = { Name:"", $    ; Description and content of one display
                    ID:"", $        ; ID is either a widget handle or a Reference.win from Live tools
                    Vis:"", $        ; ID is a Reference.vis from Live tools
                    Type:"plot", $
                    Update:0L, $           ; true when Display should be redrawn (updated)
                    Length:0L, $         ; number of Data to show in that display
                    Element_0:DataStruct} ; each Display can show many data structure contents.

    Displays= { Length: 0L, $ ; number of active displays
                Element_0: DisplayStruct}   ; one for each display

    Global = { $
              OrientRow:0L, $ ; orient Panel as a Column/Row for false/true
              ParentBase:0L, $  ; ID of Widget_base to put Display in
              XSize:200, $    ; default starting size of panel
              YSize:200, $
              Update:0L, $  ; 1 when whole update is requested
              Gathered:1L, $  ; 0: Each Display is in a separate window, 1 gathered on same panel
              Version:'0.2.1 (Jul 19th, 2002)', $
              Author:'E. Farhi (c)ILL', $
              AutoSave:0L, $
              AutoUpdate:1L, $
              Verbosity:'normal',$
              group_leader:0L, $
              DefaultColorMap:'Hue Sat Value 2', $  ; Blue-Red(11), EOS B(27), GREEN-PINK(10), Hue Sat Value 2(22),  RAINBOW(13)
              EmptyData:DataStruct, $     ; used when creating a new data set record in display
              EmptyDisplay:DisplayStruct }; used when creating a new display sub-panel

    Handles = { DISPLAYS_HANDLES, $
                Base:0L, $        ; main window (if not inserted in a previously existing Widget_Base)
                DisplayPanel:0L, $  ; Widget_Base containing all displays
                Base_About:0L, $
                Base_Help:0L, $
                AutoUpdate:0L, $
                AutoSave:0L $
                }

    D = {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,init:INIT, OnOff:OnOff, PLOT:Plot, Global:Global, Handles:Handles, Displays:DisplayStruct}
    return, D

  endelse
end

;***************************************************************
;*********************** End of Dial_Display.pro ***************
;***************************************************************
;*****************************************************************************
PRO dial_in6mono_macro, D
;*****************************************************************************
;** METHOD TO POSITION THE MONOCHROMATORS on IN6.
;
; Usage: change lambda before calling the dial
;        replace Tst into Dial for real 

if strpos(D.Mode,'simulation') ge 0 then V=TstNewValue (type='status', /setvalue) $
else V=DialNewValue (type='status', /setvalue)

IF V eq 'Idle' THEN begin

  CASE  D.init OF

 ;RAZ MONOKs
 ;**********
  0:  begin
      ; look for measured lambda value closest to tabulated values
      if D.EnergyToSet eq 0 then begin
        if strpos(D.Mode,'simulation') ge 0 then wl =TstNewValue (type='wave') $
        else wl =DialNewValue (type='wave')
      endif else wl = D.EnergyToSet
      
      wl =round(wl*100)/100.
      idx=-1 &  tmp1=min(abs(D.EnergyDefinitions-wl), idx)
      D.TableIndex = idx
      wl = D.EnergyDefinitions(idx)
      if D.TableIndex lt 0 then begin
        D.value='Unknown Lambda:'+strtrim(string(wl),2)
        D.Mode = D.Mode+' error:lambda='+strtrim(string(wl),2)+' ?'
        D.Init = 6
      endif else begin
        D.value='Lambda='+strtrim(string(wl),2)+' RAZ'
        if strpos(D.Mode,'simulation') ge 0 then begin
          R=TstControl(D.MonokRAZCommand)
          D.Frequency = 0.1
        endif else begin
          R=DialControl(D.MonokRAZCommand)
          D.Frequency = 1
        endelse

        DialModValue,    D.MonokData(0,*,idx)  ,tag='CENTER'
        DialModValue,    D.MonokData(1,*,idx)  ,tag='RANGE'
        DialModValue,fix(D.MonokData(2,*,idx)) ,tag='TIME'
        DialModValue,    D.MonokData(3,*,idx)  ,tag='STEP'
        DialModValue,    D.MonokData(4,*,idx)  ,tag='RESULT'
        
        DialModValue,   -D.range(D.MonokSequence(0))/2 ,tag='LOOP_rang'
        D.LOOP_mono = 0
        D.Plot      = 0
        
        if strpos(D.Mode,'rocking') ge 0 then  begin
          IN6monoPlot, D,'first',idx
          D.init     =1        ; rocking curve
        endif else D.init = 4  ; position
      endelse
      end
 ;MOVE MONOKs
 ;***********
  1:  begin
      if D.LOOP_mono lt n_elements(D.MonokSequence) then begin
        im=D.MonokSequence(D.LOOP_mono)
        if D.LOOP_rang le D.range(im)/2-1 then begin
          ;MOVE CURRENT MONOK ONE STEP
          ;***************************
          Value = D.center(im)+D.LOOP_rang
          D.value=string(im+1, Value, format='(%"'+D.MonokSetCommand+'")')
          if strpos(D.Mode,'simulation') ge 0 then R=TstControl(D.value) $
          else R=DialControl(D.value)
          D.init=2
          D.MonokData(4,im,D.TableIndex) = Value
        endif else begin
          ;END OF RANGE-> FIT-> MOVE MONOK ASIDE-> NEXT MONOK
          ;**************************************************
          if strpos(D.Mode,'rocking') ge 0 then IN6monoPlot,D, 'fit'
          ; send mono to end (they are indeed be at end)
          D.value='mono' +strtrim(string(im+1),2)+' at end'
          ;R=TstControl(D.value)
          D.MonokData(4,im,D.TableIndex) = D.result(D.MonokSequence(D.LOOP_mono))
          D.LOOP_mono=D.LOOP_mono+1
          if D.LOOP_mono lt n_elements(D.MonokSequence) then $
             D.LOOP_rang=-D.range(D.MonokSequence(D.LOOP_mono))/2
        endelse
      endif else begin
         D.LOOP_mono=0 & D.init=4
      endelse
      end

 ;COUNT (no save)
 ;*****
  2:  begin
      D.value=string(D.time(D.MonokSequence(D.LOOP_mono)), format='(%"'+D.MonokCntCommand+'")')
      if strpos(D.Mode,'simulation') ge 0 then R=TstControl(D.value) $
      else R=DialControl(D.value)
      D.init=3
      end
 ;GET COUNT VALUE-> PLOT-> NEXT STEP
 ;**********************************
  3:  begin
      if strpos(D.Mode,'simulation') ge 0 then V=TstNewValue (type='monitor') $
      else V=DialNewValue (type='monitor')
      ;integrate monitor
      if strpos(D.Mode,'rocking') ge 0 then IN6monoPlot,D, 'plot', V
      D.LOOP_rang=D.LOOP_rang + D.step(D.MonokSequence(D.LOOP_mono))
      D.init=1
      end
 ;END OF LOOPs->MOVE MONOKS TO CALCULATED CENTERS
 ;**********************************************
  4:  begin
        ; send to home (raz) before 
        D.value='Mono RAZ'
        D.MonokData(4,D.MonokSequence(D.LOOP_mono),D.TableIndex) = 0
        if strpos(D.Mode,'simulation') ge 0 then R=TstControl(D.MonokRAZCommand) $
        else R=DialControl(D.MonokRAZCommand)
        D.init = 5
      end
  5:  begin
      if D.LOOP_mono lt n_elements(D.MonokSequence) then begin
        im=D.MonokSequence(D.LOOP_mono)
        ; send each mono to fitted position
        value = D.result(im)
        ; test if fitted value is reasonable within 5%
        NormRatio = abs((value/D.MonokData(0,im,D.TableIndex)) -1)
        if NormRatio ge 0.05 then begin
          LightVars=Light_Get_LightVars()
          Light_Event_Base_Alert, Lightvars, error='Mono'+strcompress(string(im+1), /remove_all)+' not set'
          Light_LogMessage, LightVars, 'silent','[E] Mono'+strcompress(string(im+1), /remove_all)+' fitted position '+strcompress(string(value), /remove_all)+' more than 5% out of '+strcompress(string(D.MonokData(0,im,D.TableIndex)), /remove_all)
          value = D.MonokData(0,im,D.TableIndex)
          D.Mode = D.Mode+' error:'+'Mono'+strcompress(string(im+1), /remove_all)
        endif else begin
          D.MonokData(4,im,D.TableIndex) = value
          D.value=string(im+1, value, format='(%"'+D.MonokSetCommand+'")')
          if strpos(D.Mode,'simulation') ge 0 then R=TstControl(D.value) $
          else R=DialControl(D.value)
        endelse
        D.LOOP_mono=D.LOOP_mono+1
      endif else begin
        D.value='Done'
        D.Mode = D.Mode+' completed'
        if strpos(D.Mode,'auto') ge 0 and strpos(D.Mode,'rocking') ge 0 then begin
          display, Display_Name='Rocking_Curve',Name_Data='Mono', /delete
          display, Display_Name='Rocking_Curve',Name_Data='Mono_Fit', /delete
        endif
        D.Init = 6
      endelse
      end
;STOP DIAL
;**********************************************      
  6:  begin
        D.Mode = D.Mode+' end'
        DialStop
      end
  else:
  endcase

endif else begin ; V ne 'Idle'
  ; test if Status means that something else is occuring at the same time:
  ; then stop in6mono to avoid conflicts
  if V eq 'WAVELENGTH SETTING'  or V eq 'CHOPPER SETTING' $
  or V eq 'COLLIMATION SETTING' or V eq 'ATTENUATOR SETTING' $
  or V eq 'BEAM STOP SETTING'   or V eq 'UNDEFINED' then begin
    Light_Event_Base_Alert, Lightvars, error='Monok Conflict: '+V
    Light_LogMessage, LightVars, 'silent','[E] The instrument is doing '+V+' which prevents Monochromators setting. Aborting.'
    D.Mode = D.Mode+' error:'+V
    DialStop
    D.Init = 6
  endif
endelse
;  wait in case of following operations:
; 'COUNTING' 'POSITIONNING' 'ENCODER READING' 'TEMPERATURE SETTING' 'WAITING'
; 'DATA UPDATING'
end



;*****************************************************************************
PRO IN6monoPlot, D, flag, V
;*****************************************************************************
;**PLOT RESULT
common IN6mono_c, xp, yp, xs, ys, comment, xd, yd

; DialWset
im=D.MonokSequence(D.LOOP_mono)

CASE flag of

'first': begin
    xp  = D.LOOP_rang+D.center(im)
    xpc = xp
    yp  = 0.
    rx  =[min(D.MonokData(0,*,V)-D.MonokData(1,*,V)),$
          max(D.MonokData(0,*,V)+D.MonokData(1,*,V))]
    wl  = strtrim(string(D.EnergyDefinitions(V)),2)
    mt  ='IN6 monochromators positions settings (WAVEL:'+wl+')'
    xt  ='Position' & yt='Counts'
   end
'plot' : begin
    nx=[D.LOOP_rang+D.center(im)] & xp=[xp,nx] & yp=[yp,V] & ep=[sqrt(V>0)]
    xt  ='Mono_Pos' & yt='Counts'
    display, IX=xp, Data=yp, Name_Data='Mono', Display_Name='Rocking_Curve', /scatter, $
      Name_IX=xt, Name_IY=yt, /detached, /update
   end
'fit'  : begin
    nbp=D.range(im)/D.step(im)+1
    nel=n_elements(xp)
    xe1=xp(nel-nbp:nel-1) & ye1=yp(nel-nbp:nel-1)
    ;ESTIMATE [height,center,width,constant]
    mii=min(ye1)
    maa=max(ye1) & paa=total(xe1*ye1)/total(ye1)
    waa=sqrt(total(xe1*xe1*ye1)/total(ye1) - paa*paa)
    S1 =[maa-mii,paa,waa,mii]
    ;FIT
    fit=gaussfit(xe1,ye1,A1,nterms=4,estimates=S1)
    D.result(im)=A1(1)

    xs1 = xe1
    ys1 = A1(0)*exp(-(((xs1-A1(1))/A1(2))^2)/2)+A1(3)  ;+A1(4)*xs1+A1(5)*xs1^2

    mess='M'+strtrim(string(im+1),2)+'='+strtrim(string(round(A1(1))),2)
    mess=mess+' ('+strtrim(string(round(A1(2))),2)+')'

    if D.LOOP_mono eq 0 then begin
      xs = xs1 & ys = ys1 & comment = mess
      xd = xe1 & yd = ye1
    endif else begin
      xs = [xs, xs1] & ys = [ys, ys1] & comment= [ comment, mess ]
      xd = [xd, xe1] & yd = [yd, ye1]
    endelse
    display,IX=xd, Data=yd, Display_Name='Rocking_Curve', Name_Data='Mono', Comment=comment
    display,IX=xs, Data=ys, Display_Name='Rocking_Curve', Name_Data='Mono_Fit', /update, /overlay

    if im eq n_elements(D.MonokSequence)-1 then begin
      D.Value='Done Fit'
    endif
   end
else:
endcase
end



;*****************************************************************************
FUNCTION dial_in6mono
;*****************************************************************************
;**CONSTRUCTOR.
    ; Default settings to be used
    
    ;           center    range    time     step    opt_value
    Data =  [[[4920.00,  200.00,  1.00000, 10.0000, 4920.00 ]   ,$  ;wave=4.14 monok 1
                [5060.00,  200.00,  1.00000, 10.0000, 5060.00 ]   ,$  ;          monok 2
                [5355.00,  200.00,  1.00000, 10.0000, 5355.00 ]]  ,$  ;          monok 3

               [[4400.00,  300.00,  1.00000, 30.0000, 4400.00 ]   ,$  ;wave=4.60
                [4556.00,  300.00,  1.00000, 30.0000, 4556.00 ]   ,$
                [4825.00,  300.00,  1.00000, 30.0000, 4825.00 ]]  ,$

               [[3800.00,  190.00,  1.00000, 10.0000, 3800.00 ]   ,$  ;wave=5.12
                [3960.00,  190.00,  1.00000, 10.0000, 3960.00 ]   ,$
                [4220.00,  190.00,  1.00000, 10.0000, 4220.00 ]]  ,$

               [[2640.00,  200.00,  10.0000, 20.0000, 2640.00 ]   ,$  ;wave=5.92
                [2790.00,  200.00,  10.0000, 20.0000, 2790.00 ]   ,$
                [3050.00,  200.00,  10.0000, 20.0000, 3050.00 ]]]

return,{  Generic           :'mad', $
          Value             :'Ready', $
          Frequency         : 1.0, $
          Mode              :'rocking simulation', $
          TableIndex        : -1, $
          LOOP_mono         : 0, $
          Plot              : 0, $
          EnergyDefinitions :[4.14, 4.60, 5.12, 5.92], $
          EnergyToSet       : 4.14, $
          MonokSequence     :[2,1,0], $
          MonokData         :Data, $
          MonokRAZCommand   :'raz', $
          MonokSetCommand   :'mono%d %d', $
          MonokCntCommand   :'count %d n' }
END
;***************************************************************
;** Project: dial_light
;** File:    dial_light.pro
;** Version: 2.0.3
;** Date:    July, 24th, 2002
;** Author:  E. Farhi
;** Object:  Port of Light into Dials for George.
;**          Procedures not Instrument dependent
;
;** Require: dial_light.pro, Tools_StructSetValue.pro, Dialog_Fields.pro, TagFile.pro, dial_display.pro
;** Instrum: dial_in6mono.pro, custom.pro
;
;Modified Mar 8th 2002:  Added Displays
;Modified Mar 13th 2002: Changed to dial
;Modified June 4th 2002: (2.0.0) Extended to Custom Menu and procedures
;Modified Jul 11th 2002: (2.0.1) added alert+light_control
;Modified Jul 24th 2002: (2.0.2) added run/sequence execution/stop+ROI analysis
;Modified Aug 08th 2002: (2.0.3) added T check, reorganised procedure names. re-ordered major updates

;
; Procedures:
; These procedures handle stand-alone processes that are not directly related to user actions/events
;
; pro Light_LogMessage, LightVars, DisplayLevel, Message
; pro Light_Control, LightVars, command
;
; pro Light_Base_Init, LightVars
; pro Light_Base_Load_Config_File, LightVars, file, contains=contains, path=path
; pro Light_Base_Save_Config_File, LightVars, file=file, comment=comment, runs=runs, config=config, instrument=instrument, displays=displays
; pro Light_Base_Get_Fields_ToDisplay, LightVars, index=index, $
; pro Light_Base_Build, LightVars
; pro Light_Base_Alert, Lightvars, clear=clear, warning=warning, error=error, toggle=toggle, show=show
; pro Light_Base_Update, LightVars
; pro Light_Base_Event_Parser, event
;
; These procedures handle processes that are triggered by user events (managed through Light_Base_Event_Parser)
;
; pro Light_Event_Base_Close, LightVars
; pro Light_Event_Base_Restart, LightVars
; pro Light_Event_Base_Simulation, LightVars, Simulation=Simulation
; pro Light_Event_Base_SuperUser, LightVars, Event=Event
; pro Light_Event_Base_Load_Instr_File, Lightvars
; pro Light_Event_Base_Save_Instr_File, Lightvars
; pro Light_Event_Base_Save_Preferences, LightVars
; pro Light_Event_Base_Edit_Preferences, LightVars
; pro Light_Event_Base_Edit_Displays, LightVars
; pro Light_Event_Base_Edit_ROI, LightVars, update=update
; pro Light_Event_Base_Edit_Header, LightVars
; pro Light_Event_Base_Show_MAD_Log, LightVars
; pro Light_Event_Base_Show_Light_Log, LightVars
; pro Light_Event_Base_Help_About, LightVars
; pro Light_Event_Base_Help_File, LightVars
; pro Light_Event_Base_Help_Setup, LightVars
; pro Light_Event_Base_Help_Run_Start, LightVars
; pro Light_Event_Base_Help_Preferences, LightVars, update=update
; pro Light_Event_Base_Help_Displays, LightVars, update=update
; pro Light_Event_Base_Help_Run_Options, LightVars, update=update
; pro Light_Event_Base_Run_Analyse, LightVars
; pro Light_Event_Base_Run_Delete, LightVars, Run_Nb=Run_Nb
; pro Light_Event_Base_Run_Clear_All, LightVars
; pro Light_Event_Base_Run_Insert, LightVars, Run_Nb=Run_Nb
; pro Light_Event_Base_Run_Next, LightVars, Run_Nb=Run_Nb
; pro Light_Event_Base_Run_Nb, LightVars, Run_Nb=Run_Nb
; pro Light_Event_Base_Run_Fields, LightVars, Run_Nb=Run_Nb, restore=restore
; pro Light_Event_Base_Run_Options_Build, LightVars, Run_Nb=Run_Nb
; pro Light_Event_Base_Run_Load, LightVars
; pro Light_Event_Base_Run_Save, LightVars
; pro Light_Event_Base_Run_Stop, LightVars
; pro Light_Event_Base_Run_Start_Sequence, LightVars, first=first, last=last
; pro Light_Event_Base_Run_Start_Run, LightVars
;
; These procedures handle processes that are either automatic or launched by user, but may then live for a given time
;
; pro Light_SubDial_Base_Check_ROI, LightVars, show=show
; pro Light_SubDial_Base_Check_Temperature, LightVars
;
; function Light_Get_LightVars
;
;** Usefull Widget Tools:
;**   IDL:  XVarEdit, Display_File, Dialog_Message, Dialog_Pickfile
;**   Light: Dialog_Fields
;***************************************************************


;***************************************************************
;** Procedure to get Light data
function Light_Get_LightVars

  DialTag, 'light', Get=LightVars
  return, LightVars

end; FUN Light_Get_LightVars

;***************************************************************
;** Output Light message to IDL prompt, Light Log window and Light Log file
pro Light_LogMessage, LightVars, DisplayLevel, Message
; input: DisplayLevel, Message
;** Displays the Message if the present ActualLevel (LightVars.Verbosity)
;** matches the DisplayLevel (in silent, user, debug)
;** The date is appended before the message
;** LogString: Message is appened to LogString (string array)
;** File:      LogString is saved to file if specified

ActualLevel    = LightVars.Global.Verbosity

LevelList      = ['silent','normal','verbose','debug']
LocActualLevel = where(strcmp(LevelList, ActualLevel))
LocDisplayLevel= where(strcmp(LevelList, DisplayLevel))

; display message only if level is high enough
if LocActualLevel(0) ge LocDisplayLevel(0) then begin
  LogText = LightVars.Private.LogText
  err     = 0
  isdemo = lmgr(/demo)
  if strlen(LogText(0)) eq 0 then $
    LogText =  ['######################## Light Log File: [I]:Information, [w]:Warning, [E]:Error' ]
  if strlen(LightVars.Global.LogFile) ne 0 then begin  ; append Message into LogFile
    if isdemo eq 0 then begin
        openw, FileUnit, LightVars.Global.LogFile, /append, /get_lun, ERROR=err
        if err ne 0 then $
          print, '[Light:OpenW] Cannot open LogFile '+LightVars.Global.LogFile+':'+!error_state.msg
    endif
  endif
  for index=0,n_elements(Message)-1 do begin
    if n_elements(Message) eq 1 then $
      Message(index) = '['+systime(0)+'] '+Message(index)

    if LightVars.Global.TerminalEcho then print, Message(index)  ; print to IDL terminal
    if (strlen(LightVars.Global.LogFile) ne 0) and (err eq 0) and (isdemo eq 0) then $
      printf, FileUnit, Message(index)
    LogText = [ LogText, Message(index) ]                       ; add to Log string
  endfor
  if (strlen(LightVars.Global.LogFile) ne 0) and (err eq 0) and (isdemo eq 0) then begin
    close, FileUnit
    free_lun, FileUnit
  endif

  Tools_StructSetValue, struct=LightVars, Tag='Private.LogText', val=LogText
  if LightVars.Handles.Base_Light_Log ne 0 then begin
    tmp1 = n_elements(LogText)-20
    if tmp1 lt 0 then tmp1 = 0
    widget_control, LightVars.Handles.Base_Light_Log, set_value=LogText, $
                    SET_TEXT_TOP_LINE=tmp1, Bad_ID=Bad_ID
  endif
endif

end ; PRO Light_LogMessage

;***************************************************************
; do the same as DialControl, but handles Simulation mode
; input: command
pro Light_Control, LightVars, command

  command = strcompress(command)  ; remove duplicated/leading/trailing blanks
  if strlen(command) gt 79 then begin
    Light_LogMessage, LightVars, 'verbose' , '[E] '+LightVars.Generic+': command too long : '+command
    command = strmid(command,0,79)
  endif

  if LightVars.Global.Simulation eq 0 then begin
    res = DialControl(command)
    Light_LogMessage, LightVars, 'verbose' , '[ ] '+LightVars.Generic+': '+command
    if res lt 0 then Light_LogMessage, LightVars, 'verbose' , '[ ] '+LightVars.Generic+': Command error. Look at MAD terminal for details.'
  endif else Light_LogMessage, LightVars, 'verbose' , '[ ] '+LightVars.Generic+': <'+command+'>'

end ; PRO Light_Control

;***************************************************************
;** Init of Light (start and read Config files)
; in the order: default structure loaded at start-up, overload default instr config+user config/preferences
pro Light_Base_Init, LightVars

  forward_function DialNewValue

  if (strlen(LightVars.Global.LogFile) ne 0) then file_delete, LightVars.Global.LogFile, /quiet

  Light_LogMessage, LightVars, 'verbose','[ ] Inititialise Light'

  ; check ICS state at start-up
  Tools_StructSetValue, struct=LightVars, tag='Mad.t_status', val= DialNewValue(type='t_status')

  ;** execute Custom initilization procedure
  ; that extend Light Instrument and Handles structures and define Setup menu
  res = execute(LightVars.Instrument.CustomPro+', /start')
  
  Light_LogMessage, LightVars, 'normal','[ ] Welcome to Light '+LightVars.Private.Version
  Light_LogMessage, LightVars, 'normal','[ ] Instrument is '+strupcase(LightVars.Instrument.Name)+' '+LightVars.Instrument.Type
  
  if strlen(LightVars.Instrument.Name) eq 0 then LightVars.Instrument.Name = getenv('HOSTNAME')
  if strlen(LightVars.Instrument.Name) eq 0 then LightVars.Instrument.Name = getenv('USER')
  if strlen(LightVars.Instrument.Name) eq 0 then LightVars.Instrument.Name = 'ILL'

  ;** Initialises pathes and Ini files
  cd, current=pwd
  LightVars.Global.CurrentDir = pwd         ; Main (current) working LAMP dir
  IniFile = LightVars.Global.IniFile
  if file_test(IniFile) eq 0 then begin
    IniFile  = LightVars.Global.ConfigDir+'Light.ini'  ; no local Light.ini, use ConfigDir (defined in dial_light)
  endif
  if file_test(LightVars.Global.ConfigFile) eq 0 then begin
    LightVars.Global.ConfigFile = LightVars.Global.ConfigDir+'Config.ini' ; default physical instrument info (Monochromators and Choppers)
  endif
  ; read default configuration
  Light_Base_Load_Config_File, LightVars, LightVars.Global.ConfigDir+'Config.ini'
  ; read user configuration
  Light_Base_Load_Config_File, LightVars, IniFile
  ;Light_Base_Load_Config_File, LightVars, file=LightVars.Global.ConfigFile ; Instrument variables definition file
  
  if size(LightVars.Mad.t_status, /type) ne 8 then begin ; not a structure
    LightVars.Mad.Status = '['+strupcase(LightVars.Generic)+' INACTIVE]'
    LightVars.Global.Simulation = 1L
    Light_LogMessage, LightVars, 'silent','[w] '+strupcase(LightVars.Generic)+' is not running. Simulation mode activated.'
  endif

end ; PRO Light_Base_Init

;***************************************************************
;** Read .INI file (Call TagFile for IniFile and ConfigFile)
; input: file
; keyword contains acts as a filter, getting only fields containing 'contains'
; keyword path is used for dialog_pickfile default path
pro Light_Base_Load_Config_File, LightVars, file, contains=contains, path=path

  if  strlen(file) eq 0 then begin  ; file was '' -> set file from dialog_pickfile
    file = dialog_pickfile(Dialog_Parent=LightVars.Handles.Base, file='*.ini', filter='*.ini', path=path, $
            Get_Path=Selected_Path, /Must_Exist, Title='Select a Configuration File to Read into Light')
  endif
  if strlen(file_which(file, /include_current_dir)) eq 0 and file_test(file, /regular) eq 0 then begin
    Light_LogMessage, LightVars, 'verbose' , '[w] Using Default settings (invalid file name '+file+').'
    return
  endif
  Tags=''  ;** To get all Tags in file
  Light_LogMessage, LightVars, 'normal' , '[ ] Reading file '+file_which(file, /include_current_dir)
  TagFile, file, TAG=Tags, GET=StrValues, HEADER=Header
  Light_LogMessage, LightVars, 'verbose', Header

  for index=0, n_elements(Tags)-1 do begin
    ;** Get each Tag, and evaluate corresponding value
    ThisTag      = Tags(index)
    ThisStrValue = StrValues(index)
    ; restrict file tag reading to tag containing 'contains'
    if n_elements(contains) ne 0 then $
      if strpos(ThisTag, contains) lt 0 then ThisTag=''
    if strlen(ThisTag) ne 0 and strlen(ThisStrValue) ne 0 then begin
      idx          = strpos(ThisTag, '.')
      BaseTag      = strtrim(strmid(ThisTag,0,idx(0)),2)
      ThisTag      = strtrim(strmid(ThisTag,idx(0)+1, strlen(ThisTag)),2)
      ok = execute('ThisValue = '+ThisStrValue)
      if ok and strcmp(strupcase(BaseTag), 'LIGHT') then begin
        Tools_StructSetValue, struct=LightVars, Tag=ThisTag, Val=ThisValue
      endif else $
        Light_LogMessage, LightVars, 'normal' , '[w] '+BaseTag+'.'+ThisTag+' = '+ThisStrValue+' ?'
    endif

  endfor

end ; PRO Light_Read_Config_File

;***************************************************************
;** Save Config_File (Inifile)
; input: file
; keywords /runs /config /instrument /displays activate saving of specific sections
; keyword comment is added to header
pro Light_Base_Save_Config_File, LightVars, file=file, comment=comment, runs=runs, config=config, instrument=instrument, displays=displays

  if n_elements(file) eq 0 then file = LightVars.Global.IniFile

  if LightVars.Private.IsSuperUser eq 0 and strmatch(file, LightVars.Global.ConfigDir+'*') then begin
    Light_LogMessage, LightVars, 'normal','[ ] Only SuperUser can save to '+file_which(file, /include_current_dir)
    return
  endif

  FileType = ''
  RunsData = ['']
  DisplaysData = ['']
  if keyword_set(runs) then begin
    tags = tag_names(LightVars.Run)
    FileType = 'Runs '+FileType
    for index=0, n_elements(tags)-1 do $
      RunsData = [ RunsData, 'Run.'+tags(index) ]
  endif

  if keyword_set(displays) then begin
    tags = tag_names(LightVars.Displays)
    FileType = 'Displays '+FileType
    for index=0, n_elements(tags)-1 do $
      DisplaysData = [ DisplaysData, 'Displays.'+tags(index) ]
  endif

  InstrData = ['']
  if keyword_set(instrument) and LightVars.Private.IsSuperUser ne 0 then begin
    tags = tag_names(LightVars.Instrument)
    FileType = 'Instrument '+FileType
    for index=0, n_elements(tags)-1 do $
      InstrData = [ InstrData, 'Instrument.'+tags(index) ]
  endif

  ConfigData = ['']
  if keyword_set(config) then begin
    FileType = 'Preferences '+FileType
    ConfigData =['Global.ConfigDir       ',$
                 'Global.Verbosity       ',$
                 'Global.TerminalEcho    ',$
                 'Global.CurrentDir      ',$
                 'Global.IniFile         ',$
                 'Global.ConfigFile      ',$
                 'Global.LogFile         ',$
                 'Global.RunFile         ',$
                 'Global.Simulation      ',$
                 'Global.Append_Runs     ',$
                 'Global.Current_Run     ',$
                 'GENERIC                ',$
                 'FREQUENCY              ',$
                 'PLOT                   ',$
                 'UPPERLIM               ',$
                 'LOWERLIM               ',$
                 'WUPDATE                ']
  endif

  IniFileData = [ RunsData, InstrData, ConfigData, DisplaysData ]

  Header   =[ '# Light Config file: '+file+' ('+FileType+')',$
              '# Date:              '+systime(0) ]
  if keyword_set(comment) then Header = [ Header, '# '+comment ]
  for index=0, n_elements(IniFileData)-1 do begin
    if strlen(IniFileData(index)) gt 0 then begin
      tmp1 = execute('val=LightVars.'+IniFileData(index))
      tagfile, file, TAG='Light.'+IniFileData(index), SET=val, HEADER=Header
    endif
  endfor
  if strlen(file_which(file, /include_current_dir)) gt 0 then file = file_which(file, /include_current_dir)
  Light_LogMessage, LightVars, 'normal','[ ] Saving '+FileType+' into '+file

end ; PRO Light_Base_Save_Config_File

;***************************************************************
;*********************** MAIN  INTERFACE ***********************
;***************************************************************

;***************************************************************
;** set values to display (from Global, updated on request) using index as Run_Nb in the Run sequence
; input: index
; other keywords are return values
pro Light_Base_Get_Fields_ToDisplay, LightVars, index=index, $
        header=header, h_val=h_val, spy=spy, s_val=s_val, run=run, r_val=r_val, check=check, c_val=c_val

  header=['User Name:     ',$
          'Local Contact: ',$
          '']; was initially 'Exp. Title:    ', 'Exp. Number:   ' changed to get space on Light interface
  h_val =[LightVars.Private.UserName, LightVars.Private.LocalContact ]
  spy   =['Monit.[cts]' ,$
          'Detec.[cts]', $
          'T Sam.[K]', $
          'T Reg.[K]']
  s_val =[LightVars.Private.MonitorSum, LightVars.Private.DetectorSum, LightVars.Private.TSample, LightVars.Private.TRegulation]
  run   =['SubTitle', $
          'Temperature [K]', $
          'Lambda [AA]', $
          'Preset', $
          'Repetition' ]
  if n_elements(index) eq 0 then index  = LightVars.Global.Current_Run
  r_val =[0.0, $
          LightVars.Run.Temperatures(index), $
          LightVars.Run.Lambda(index), $
          LightVars.Run.Preset(index), $
          LightVars.Run.Repetition(index) ]
  check =['Preset unit in Run',$
          'Check T',$
          'Save Perm.']
  c_val =[LightVars.Run.Flag_MonTi(index), $
          LightVars.Run.Flag_T(index), $
          LightVars.Run.Flag_Save(index)]

end ; PRO Light_Base_Get_Fields_ToDisplay

;***************************************************************
;** Build the Main instrument panel (show user, local, experiments, runs, ...)
pro Light_Base_Build, LightVars

  ;** Build base interface (that can call Instrument setup and Monochromator setup with buttons)
  
  ;** Get information and labels from LightVars
  Light_Base_Get_Fields_ToDisplay, LightVars, index=index, $
      header=header, h_val=h_val, spy=spy, s_val=s_val, run=run, r_val=r_val, check=check, c_val=c_val

  widget_control, /HOURGLASS
  LightVars.Handles.Base = widget_base(/column, $
    title='['+strupcase(LightVars.Instrument.Name)+'] Instrument Control', $
    /tlb_size_events, /TLB_KILL_REQUEST_EVENTS, mbar=Base_Menu)
  widget_control, LightVars.Handles.Base, tlb_set_xoffset=80, tlb_set_yoffset=80  ; original position/upper-left
  widget_control, LightVars.Handles.Base, Set_Uname='Light_Base_Interface'

  ;** TOP menu and buttons
  Base_Top  =widget_base(LightVars.Handles.Base,/row, xpad=0)  ; frame=10

  Base_File =widget_button(Base_Menu,value='File >',uvalue='Light_Event_Base_File_Menu, LightVars', menu=2)
  ;** now comes the pop-up 'File >' menu items
  tmp1= widget_button(Base_File,value='Edit Light Preferences...', uvalue='Light_Event_Base_Edit_Preferences, LightVars')
  tmp1= widget_button(Base_File,value='Save Light Preferences...', uvalue='Light_Event_Base_Save_Preferences, LightVars')
  tmp1= widget_button(Base_File,value='Show Light Log file...', uvalue='Light_Event_Base_Show_Light_Log, LightVars')
  tmp1= widget_button(Base_File,value='Show '+strupcase(LightVars.Generic)+' Log file...', uvalue='Light_Event_Base_Show_MAD_Log, LightVars')
  tmp1= widget_button(Base_File,value='Restart Light',uvalue='Light_Event_Base_Restart, LightVars')
  tmp1= widget_button(Base_File,value='Exit Light',    uvalue='Light_Event_Base_Close, LightVars', /separator)
  widget_control, LightVars.Handles.Base, cancel_button=tmp1

  Base_Setup=widget_button(Base_Menu, value='Setup >',uvalue='Light_Event_Base_Setup_Menu, LightVars', menu=2)
  ;** now comes the pop-up 'Setup >' menu items (from LightVars.Instrument.Custom)
  for index=0,n_elements(LightVars.Instrument.CustomMenuItems)-1 do begin
    tmp1= widget_button(Base_Setup,value=LightVars.Instrument.CustomMenuItems(index), $
                                   uvalue=LightVars.Instrument.CustomMenuPro(index))
  endfor
  tmp1= widget_button(Base_Setup,value='Displays...', uvalue='Light_Event_Base_Edit_Displays, LightVars', /separator)
  tmp1= widget_button(Base_Setup,value='Regions of Interest (ROIs)...', uvalue='Light_Event_Base_Edit_ROI, LightVars')
  tmp1= widget_button(Base_Setup,value='Analyse ROIs...', uvalue='Light_Event_Base_Edit_ROI, LightVars, /update & Light_SubDial_Base_Check_ROI, LightVars, /show')
  tmp1= widget_button(Base_Setup,value='SuperUser login...',   uvalue='Light_Event_Base_SuperUser, LightVars, Event=Event', /separator)
  LightVars.Handles.Simulation= widget_button(Base_Setup,value='Control Mode: Active',     uvalue='Light_Event_Base_Simulation, LightVars')
  LightVars.Handles.LoadSaveCfg(0)= widget_button(Base_Setup,value='Load configuration...', uvalue='Light_Event_Base_Load_Instr_File, LightVars', /separator)
  LightVars.Handles.LoadSaveCfg(1)= widget_button(Base_Setup,value='Save configuration...', uvalue='Light_Event_Base_Save_Instr_File, LightVars')


  Base_Run=widget_button(Base_Menu, value='Runs >',uvalue='Light_Event_Base_Run_Menu, LightVars', menu=2)
  ;** now comes the pop-up 'Runs >' menu items
  tmp1= widget_button(Base_Run,value='Load Run/Sequence...',  uvalue='Light_Event_Base_Run_Load, LightVars')
  tmp1= widget_button(Base_Run,value='Save Run/Sequence...',  uvalue='Light_Event_Base_Run_Save, LightVars')
  tmp1= widget_button(Base_Run,value='Analyse/Show Sequence...', uvalue='Light_Event_Base_Run_Analyse, LightVars', /separator)
  tmp1= widget_button(Base_Run,value='Run Options...',        uvalue='Light_Event_Base_Run_Options_Build, LightVars')
  tmp1= widget_button(Base_Run,value='Clear All Runs',        uvalue='Light_Event_Base_Run_Clear_All, LightVars')
  tmp1= widget_button(Base_Run,value='Delete Current Run',    uvalue='Light_Event_Base_Run_Delete, LightVars')
  tmp1= widget_button(Base_Run,value='Insert Run',            uvalue='Light_Event_Base_Run_Insert, LightVars')
  tmp1= widget_button(Base_Run,value='Next Run (go to)',      uvalue='Light_Event_Base_Run_Next, LightVars')
  LightVars.Handles.RunStartButton(0)= widget_button(Base_Run,value='Start Single Run',      uvalue='Light_Event_Base_Run_Start_Run, LightVars', /separator)
  LightVars.Handles.RunStartButton(1)= widget_button(Base_Run,value='Start Sequence',        uvalue='Light_Event_Base_Run_Start_Sequence, LightVars')
  tmp1= widget_button(Base_Run,value='Stop  Run/Sequence',    uvalue='Light_Event_Base_Run_Stop, LightVars')

  Base_Help =widget_button(Base_Menu, value='Help >',uvalue='Light_Event_Base_Help_Menu, LightVars', menu=2)
  ;now comes the pop-up 'Help >' menu items
  tmp1= widget_button(Base_Help,value='About [File]',      uvalue='Light_Event_Base_Help_File, LightVars')
  tmp1= widget_button(Base_Help,value='About [Setup]',     uvalue='Light_Event_Base_Help_Setup, LightVars')
  tmp1= widget_button(Base_Help,value='About [Runs]',      uvalue='Light_Event_Base_Help_Run_Start, LightVars')
  tmp1= widget_button(Base_Help,value='About [Preferences]',uvalue='Light_Event_Base_Help_Preferences, LightVars')
  tmp1= widget_button(Base_Help,value='About [Displays]',  uvalue='Light_Event_Base_Help_Displays, LightVars')
  tmp1= widget_button(Base_Help,value='About [Run Options]',uvalue='Light_Event_Base_Help_Run_Options, LightVars')
  tmp1= widget_button(Base_Help,value='About Light...'    ,uvalue='Light_Event_Base_Help_About, LightVars', /separator)

  ;** MAD status (colors/styles are defined in lamp.ressource: light1mad, light2mad)
  Base_Mad_Info                     = widget_base(LightVars.Handles.Base,/column, frame=5)
  Base_Mad_Control                  = widget_base(Base_Mad_Info,       /row,    frame=3)
  LightVars.Handles.Base_Mad_Status  = widget_base(Base_Mad_Control, resource_name='light1ics', map=1)
  LightVars.Handles.Mad_Status       = widget_label(LightVars.Handles.Base_Mad_Status, value=LightVars.Mad.Status, xsize=130, /align_center, frame=1)

  ;** MAD alert (colors/styles are defined in lamp.ressource: light1alert, light2alert)
  Base_Alert= widget_base(Base_Mad_Control, uvalue='Light_Event_Base_Display_Log, LightVars')
  ;** 'Clear' alert button
  cl_al = 'Light_Base_Alert, LightVars, /clear, /show'
  LightVars.Handles.Base_Alert_Status = widget_button(Base_Mad_Control, value='no alert ---------------------', uvalue=cl_al, sensitive=0)

  ;** 'SPY abstract' section (sum of counts, monitor, T), whole section clears alert
  Base_Spy= widget_base(Base_Mad_Info, uvalue=cl_al, /row, frame=1)
  lab_id  = lonarr(n_elements(spy))
  tmp1    = widget_base(Base_Spy, uvalue=cl_al, /column , space=0, xpad=0);
  for index=0,1 do begin
    tmp2         = widget_base(tmp1, uvalue=cl_al, /row, ypad=0, xpad=0);
    tmp3         = widget_label(tmp2, value=spy(index))
    lab_id(index)= widget_text(tmp2,  value=string(s_val(index)), xsize=7)
  endfor
  tmp1    = widget_base(Base_Spy, uvalue=cl_al, /column , space=0, xpad=0)
  for index=2,3 do begin
    tmp2         = widget_base(tmp1, uvalue=cl_al, /row, ypad=0, xpad=0)
    lab_id(index)= widget_text(tmp2,  value=string(s_val(index)), xsize=7)
    tmp3         = widget_label(tmp2, value=spy(index))
  endfor
  LightVars.Handles.MonitorSum   = lab_id(0)
  LightVars.Handles.DetectorSum  = lab_id(1)
  LightVars.Handles.TSample      = lab_id(2)
  LightVars.Handles.TRegulation  = lab_id(3)

  ;**Experiment (Run) setup. (Was initially in custom.pro:run_experiment)
  Base_Run= widget_base(LightVars.Handles.Base, /column, frame=5)
  tmp1    = widget_base(Base_Run, /row)  ; first row
  tmp2    = widget_label  (tmp1, value='EXP. RUNS ')
  LightVars.Handles.RunStartButton(2) = widget_button (tmp1, value='Start >', menu=2, uvalue='')  ; pop-up menu
  tmp3    = widget_button (LightVars.Handles.RunStartButton(2), value='Start Sequence',  uvalue='Light_Event_Base_Run_Start_Sequence, LightVars')
  tmp3    = widget_button (LightVars.Handles.RunStartButton(2), value='Start Single Run',       uvalue='Light_Event_Base_Run_Start_Run, LightVars')
  ;** STOP and Analyse buttons
  tmp2    = widget_button (tmp1, value='STOP',            uvalue='Light_Event_Base_Run_Stop, LightVars')        ; STOP button
  tmp2    = widget_button (tmp1, value='Analyse...',      uvalue='Light_Event_Base_Run_Analyse, LightVars')     ; Analyse button
  LightVars.Handles.RunStatus = widget_label  (tmp1, value='         ', uvalue='')


  ;** Run buttons: Run No, Next, Delete, Insert
  Base_Run_Def= widget_base(Base_Run,    /column, frame=3)
  Base_Run    = widget_base(Base_Run_Def,/row,    frame=1)
  LightVars.Handles.Current_Run = widget_droplist(Base_Run, $
                                value=string(LightVars.Global.Current_Run, format='(I3)'), $
                                uvalue='Light_Event_Base_Run_Nb, LightVars, Run_Nb=Event.Index', title='Run No:', /DYNAMIC_RESIZE)
  tmp1        = widget_button( Base_Run, value='Next', uvalue='Light_Event_Base_Run_Next, LightVars')
  tmp1        = widget_base(   Base_Run, /row, xsize=15) ; empty space on row
  Base_Run    = widget_base(   Base_Run, /row)
  tmp1        = widget_button (Base_Run, value='Delete', uvalue='Light_Event_Base_Run_Delete, LightVars')
  tmp1        = widget_button (Base_Run, value='Insert', uvalue='Light_Event_Base_Run_Insert, LightVars')

  ;** Run Title, Temp, Lambda, Preset, repetition
  Base_Run    = widget_base(Base_Run_Def,/column, frame=1)
  Base_0      = widget_base(Base_Run,/row)
  
  lab_id      = [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L ]

  index = 0 & XSize = 25 & value = LightVars.Run.Titles(index) ; Title is a 20 char string
  lab_id(0) = cw_field(Base_0, title='',$
      value  =value,   uvalue  ='Light_Event_Base_Run_Fields, LightVars', xsize=XSize, /row, /all_events)
  tmp2 = widget_label(Base_0, value=run(index))

  Base_0      = widget_base(Base_Run,/row)
  Base_1c      = widget_base(Base_0,/column)
  Base_2c      = widget_base(Base_0,/column)

  IntField    = [0,0,0,0,1]
  FloatField  = [0,1,1,1,0]
  order       = [2,3,4,1]
  ; 0 Title is a 20 char string
  ; 2 Lambda+Options
  ; 3 Preset+Mn/Ti
  ; 4 Repetition+Save
  ; 1 Temperature+Check T
  for o_index=0,n_elements(order)-1 do begin
    index = order(o_index)
    XSize = 7
    value = r_val(index)  ; other fields
    tmp1 = widget_base(   Base_1c, /row)
    lab_id(index) = cw_field(tmp1, title='',$
      value  =value,   uvalue  ='Light_Event_Base_Run_Fields, LightVars', xsize=XSize, /row, /all_events, $
      integer=IntField(index),floating=FloatField(index))
    tmp2 = widget_label(tmp1, value=run(index))
    if index eq 2 then begin  ;add a Modify/Options button after Lambda
      tmp2= widget_button( Base_2c, value='Options...', ysize=40, uvalue='Light_Event_Base_Run_Options_Build, LightVars')
    endif
    if index eq 1 then begin  ;add a Check T button after Temperature
      tmp2= widget_base(   Base_2c, /row)
      lab_id(7)= cw_bgroup(tmp2, label_left='',/row,$
      [' '], /nonexclusive, uvalue='Light_Event_Base_Run_Fields, LightVars', set_value=c_val(1))
      tmp2 = widget_label(tmp2, value=check(1))
    endif
    if index eq 3 then begin  ;add the Ti/Mn button text after Preset
      lab_id(5)= cw_bgroup(Base_2c, /exclusive, label_left='',/row,$
      ['Mon','Ti [min]'], uvalue='Light_Event_Base_Run_Fields, LightVars', set_value=c_val(0))
    endif
    if index eq 4 then begin  ;add the Save button after repetition
      tmp2= widget_base(   Base_2c, /row)
      lab_id(6)= cw_bgroup(tmp2, label_left='',/row,$
      [' '], /nonexclusive, uvalue='Light_Event_Base_Run_Fields, LightVars', set_value=c_val(2))
      tmp2 = widget_label(tmp2, value=check(2))
    endif
  endfor
  LightVars.Handles.Titles             = lab_id(0)
  LightVars.Handles.Temperatures       = lab_id(1)
  LightVars.Handles.Lambda             = lab_id(2)
  LightVars.Handles.Preset             = lab_id(3)
  LightVars.Handles.Repetition         = lab_id(4)
  LightVars.Handles.Flag_MonTi         = lab_id(5)
  LightVars.Handles.Flag_Save          = lab_id(6)
  LightVars.Handles.Flag_T             = lab_id(7)

  ;** Experiment (Header/info) setup. (Was initially in custom.pro:man_exp_head)
  lab_id        = lonarr(n_elements(header))
  Base_Exp_Base1=widget_base(LightVars.Handles.Base,/row)
  tmp1= widget_label(Base_Exp_Base1,  value='EXPERIMENT:  ')
  LightVars.Handles.UserName    = widget_label(Base_Exp_Base1, value=LightVars.Private.UserName,/align_left)
  LightVars.Handles.LocalContact= widget_label(Base_Exp_Base1, value=LightVars.Private.LocalContact,/align_left)

  tmp1= widget_button(Base_Exp_Base1, value='Edit Header',uvalue='Light_Event_Base_Edit_Header, LightVars')
  Base_Exp_Base1=widget_base(LightVars.Handles.Base,/column)
  row = widget_base(Base_Exp_Base1,/row)
  tmp                           = widget_label(row, value='Title:    ',/align_left)
  LightVars.Handles.ExpTitle    = widget_label(row, value=strmid(LightVars.Private.ExpTitle,0,46),/align_right)
  row = widget_base(Base_Exp_Base1,/row)
  tmp                           = widget_label(row, value='Sub Title:',/align_left)
  LightVars.Handles.SubTitle    = widget_label(row, value=strmid(LightVars.Private.SubTitle,0,46),/align_right)
  row = widget_base(Base_Exp_Base1,/row)
  tmp                           = widget_label(row, value='Numor:    ',/align_left)
  LightVars.Handles.Numor       = widget_label(row, value=LightVars.Private.Numor,/align_right)

  ;** Command File (Run)
  Base_Run= widget_base(LightVars.Handles.Base,/row, frame=1)
  LightVars.Handles.RunFile= widget_label(Base_Run, /align_left, /dynamic_resize, $
    value='Starting with '+LightVars.Global.RunFile)

  ;** display and launch XManager
  widget_control, LightVars.Handles.Base, /realize
  XManager, 'Light_Base_Interface', LightVars.Handles.Base, Event_Handler='Light_Base_Event_Parser', $
      /just_reg, /no_block

  Base_Geometry= widget_info(LightVars.Handles.Base, /geometry)
  LightVars.Private.Base_Size=[ Base_Geometry.XSize, Base_Geometry.YSize ]

  ;** Update Run fields
  Light_Event_Base_Run_Fields, LightVars, /restore
  Light_Event_Base_Simulation, LightVars, Simulation = LightVars.Global.Simulation

  ; now put the instrument specific configuration to SU/normal Mode (call CustomPro in SU check mode)
  ;** execute Custom CustomPro SU check procedure
  res = execute(LightVars.Instrument.CustomPro+', /update_buttons')

  Light_Base_Alert, Lightvars, /clear

end ; PRO Light_Base_Build

;*****************************************
; handle alert state
; warning/error message are also appended to Light Log
; keywords: 
; /clear: clear alert, 
; warning: add a warning
; error: add an error
; /toggle: toggle alert blinking state
; /show: show Lght log
pro Light_Base_Alert, Lightvars, clear=clear, warning=warning, error=error, toggle=toggle, show=show

if LightVars.Private.ErrorMsgToggle eq 0 then LightVars.Private.ErrorMsgToggle = 1 $
else LightVars.Private.ErrorMsgToggle = 0

; toggle sensitive state for blinking alert
if n_elements(toggle) ne 0 and strpos(LightVars.Private.LastErrorMsg, 'no alert') lt 0 then begin
  if LightVars.Private.ErrorMsgToggle eq 0 then begin
    widget_control, LightVars.Handles.Base_Alert_Status, sensitive=1, set_value=''
  endif else begin
    widget_control, LightVars.Handles.Base_Alert_Status, sensitive=1, set_value=LightVars.Private.LastErrorMsg
  endelse
endif

; clear alert, and show/raise Light Log
if n_elements(clear) ne 0 then begin
  widget_control, LightVars.Handles.Base_Alert_Status, sensitive=1
  if strpos(LightVars.Private.LastErrorMsg, 'no alert') lt 0 then show = 1
  LightVars.Private.LastErrorMsg = '   <no alert>    '
  widget_control, LightVars.Handles.Base_Alert_Status, set_value=LightVars.Private.LastErrorMsg, sensitive= 1
endif

if n_elements(show) ne 0 then Light_Event_Base_Show_Light_Log, LightVars

; set warning alert
if n_elements(warning) ne 0 then begin
  ToSet = '[W] '+warning
  Light_LogMessage, LightVars, 'silent' , '[W] WARNING '+warning
  ; only if was in 'no alert mode'
  if strpos(LightVars.Private.LastErrorMsg, 'no alert') ge 0 then begin
    LightVars.Private.LastErrorMsg = ToSet
    widget_control, LightVars.Handles.Base_Alert_Status, set_value=ToSet, sensitive= 1
  endif
endif

; set error alert
if n_elements(error) ne 0 then begin
  ToSet = 'ERROR '+error(0)
  Light_LogMessage, LightVars, 'silent' , '[E] '+ToSet(0)
  LightVars.Private.LastErrorMsg = ToSet(0)
  widget_control, LightVars.Handles.Base_Alert_Status, set_value=ToSet(0), sensitive= 1
endif

end ; PRO Light_Base_Alert

;***************************************************************
; Main Update procedure. Executed at each Dial Frequency
; calls instrument collect procedure, and update required base fields/widgets
pro Light_Base_Update, LightVars

  tic = systime(1)
  
  ;** Build base interface (that can call Instrument setup with buttons) if does not exist
  if LightVars.Handles.Base eq 0 or widget_info(LightVars.Handles.Base, /valid_id) eq 0 then Light_Base_Build, LightVars

  ;** MINOR UPDATE SECTION ***********************************************************
  
  ; Collect data from the Generic Instrument Control program (Custom routine)
  ; the collect procedure gets either a quick update status), or full data collect when Major Update occurs
  ; or when Mad.Status changed
  res = execute(LightVars.Instrument.CustomPro+', /collect')

  ;** Update MadStatus and Error
  Light_Base_Alert, Lightvars, /toggle
  widget_control, LightVars.Handles.Mad_Status, set_value=LightVars.Mad.Status
  
  LightVars.Value = LightVars.Mad.Status

  ;** Update SU mode
  widget_control, LightVars.Handles.Base_SuperUser, get_uvalue=Event, Bad_Id=Bad_Id
  LightVars.Private.IsSuperUser = 0
  if n_elements(Event) eq 0 then Event=''
  if LightVars.Handles.Base_SuperUser ne 0 and LightVars.Handles.Base_SuperUser eq Bad_Id then begin ; SU window was closed
    LightVars.Handles.Base_SuperUser = 0
    Light_LogMessage, LightVars, 'silent','[w] SuperUser logged out.'
    ; now put the instrument specific configuration to normal Mode (call CustomPro in SU check mode)
    ;** execute Custom Init SU procedure
    res = execute(LightVars.Instrument.CustomPro+', /update_buttons')
  endif
  if strcmp(strupcase(Event),'LIGHT_EVENT_SU_MODE') then begin
    LightVars.Private.IsSuperUser = 1
    ; now put the instrument specific configuration to SU Mode (call CustomPro in SU check mode)
    ;** execute Custom Init SU procedure
    res = execute(LightVars.Instrument.CustomPro+', /update_buttons')
  endif
  
  ; ** MAJOR UPDATE SECTION ***********************************************************
  if LightVars.Private.Update_Nb le 1 then begin

    ; update the displays, define aliases for Mad variables (temperature, data, etc...)
    Mad       = LightVars.Mad
    t_nother  = Mad.t_nother
    t_res     = Mad.t_res
    t_para    = Mad.t_para
    t_status  = Mad.t_status
    t_counts  = Mad.t_counts
    t_chopper = Mad.t_chopper
    data      = Mad.Data

    ; now specialised aliases for IN6 ************************************************
    dims      = size(data, /dim)
    data     = data(0:(dims(0) -2), *)
    Monitor  = data(*,0)     ; this is Monitor1
    data     = data(*,t_res.N_MON_SPECT:(t_res.N_TOTAL_SPECT-1)) ; for IN6
    detectors= total(data,1)  ; Detectors on X (length=340), sum of row
    tof      = total(data,2)  ; TOF channel on X (length=LightVars.Mad.t_para.tof_cha_resol = 512, 1024...)

    Temperatures = t_res.tempea
    TSet    = Temperatures(0)
    TReg    = Temperatures(1)
    TSample = Temperatures(2)
    Power   = Temperatures(3)
    ; end of specialised aliases for IN6 *********************************************

    ToUpdate = ['MonitorSum', 'DetectorSum',  'TSample',   'TRegulation', $
                'UserName',   'LocalContact', 'ExpTitle', 'Numor', 'Subtitle', $
                'RunFile' ]
    for index=0, n_elements(ToUpdate)-1 do begin
    ;** Update fields from ToUpdate, taking Widget Handle (ID) and its value...
      tmp1 = execute('Widget = LightVars.Handles.'+ToUpdate(index))
      if ToUpdate(index) eq 'RunFile' then $
        tmp2 = execute('Value  = LightVars.Global.'+ToUpdate(index)) $
      else tmp2 = execute('Value  = LightVars.Private.'+ToUpdate(index))
      if not tmp1 or not tmp2 then begin
        print, tmp1, ':Widget = LightVars.Handles.'+ToUpdate(index)+' ?'
        print, tmp2, ':Value  = LightVars.Global.'+ToUpdate(index)+' ?'
      endif else begin
        if strcmp(ToUpdate(index), 'RunFile') then begin
          if strlen(string(Value)) gt 25 then Value = 'Cmd File: ...'+strmid(string(Value),25,/reverse) $
          else Value = 'Cmd File: '+string(Value)
          if n_elements(Widget) ne 0 and Widget ne 0 then widget_control, Widget, set_value=string(Value), /dynamic_resize
        endif else begin
          Value = strcompress(string(Value))
          if n_elements(Widget) ne 0 and Widget ne 0 then widget_control, Widget, set_value=string(Value)
        endelse
      endelse
    endfor

    ; update displays and ROIs ***************************************************

    ; handle the temperature check
    Light_SubDial_Base_Check_Temperature, LightVars

    ; handle ROI regions (edition)
    Light_Event_Base_Edit_ROI, LightVars, /update
    ; handle ROI analysis
    Light_SubDial_Base_Check_ROI, LightVars
    
    toc = systime(1)
    Elapsed = toc-tic

    for index=0, n_elements(LightVars.Displays.Variables)-1 do begin
      Variable = LightVars.Displays.Variables(index)
      Type     = LightVars.Displays.Type(index)
      Options  = LightVars.Displays.Options(index)
      Name     = strjoin(strsplit(Variable,' /\;*?$!~<>{}()|[]%&.,', /extract),'_')
      if strlen(Variable) gt 0 and LightVars.Private.Update_Nb eq 1 then begin
        if Name(0) ge '0' and Name(0) le '9' then Name='Light_'+Name
        ToExec   = "display, group_leader=LightVars.Handles.Base, Data="+Variable
        if strpos(strlowcase(Options), "name_data") lt 0 then ToExec=ToExec+", Name_Data='"+Name+"'"
        if strlen(Type) gt 0 then ToExec   = ToExec+", type='"+Type+"'"
        if strlen(Options) gt 0 then ToExec   = ToExec+', '+Options
        ; Light_LogMessage, LightVars, 'debug','[ ] Light: '+ToExec
        ok = execute(ToExec)
        if not ok and strpos(LightVars.Displays.Options(index), "unactivate") lt 0 then if strlen(Options) eq 0 then LightVars.Displays.Options(index) = '/unactivate' $
          else LightVars.Displays.Options(index) = [ Options+', /unactivate' ]
      endif
    endfor

  endif
  
  ; handle Update level 'Private.Update_Nb': 0: starting, 1:Major Update. ++ until Private.Major_Update_Nb
  LightVars.Private.Update_Nb = LightVars.Private.Update_Nb+1
  if LightVars.Private.Update_Nb gt LightVars.Private.Major_Update_Nb then LightVars.Private.Update_Nb = 1
  
  ;** Update Dial structure
  DialTag, 'light', tag='Global',    set=LightVars.Global
  DialTag, 'light', tag='Private',   set=LightVars.Private
  DialTag, 'light', tag='Mad',       set=LightVars.Mad
  DialTag, 'light', tag='Handles',   set=LightVars.Handles
  DialTag, 'light', tag='Run',       set=LightVars.Run
  DialTag, 'light', tag='Instrument',set=LightVars.Instrument

end ; PRO Light_Base_Update

;***************************************************************
;*************************** EVENTS  ***************************
;***************************************************************

;***************************************************************
;** Light_Base_Event_Parser : event manager
pro Light_Base_Event_Parser, event

  ;** retrieve the 'uvalue' from Widget -> Get event description
  widget_control, event.id, get_uvalue=uv
  LightVars = Light_Get_LightVars()

  ;** First handle close and resize events
  if  tag_names(event, /STRUCTURE_NAME) eq 'WIDGET_KILL_REQUEST' then begin
      Light_Event_Base_Close, LightVars
      return
  endif else begin
    if tag_names(event, /STRUCTURE_NAME) eq 'WIDGET_BASE' then begin
        Light_LogMessage, LightVars, 'debug','[ ] Light: Restore Base dimensions'
        widget_control, LightVars.Handles.Base, XSize=LightVars.Private.Base_Size(0), YSize=LightVars.Private.Base_Size(1)
    endif else begin
      if size(uv, /type) eq 7 then begin
        ;** Checks that the Event routine exists...
        Routine = uv
        res = execute(Routine)
        if res ne 0 then begin
         if strpos(Routine, 'Light_Event_Base_Close') ge 0 then return
         Light_LogMessage, LightVars, 'debug','[ ] Light_Base_Event_Parser:'+uv
        endif else begin
         Light_LogMessage, LightVars, 'debug','[E] PRO '+Routine+' ?'
        endelse
      endif else begin
        Light_LogMessage, LightVars, 'debug','[E] Light: Unknown event'
        help, event, uv
      endelse
    endelse
  endelse

  if LightVars.Handles.Base ne 0 then begin
    ;** Update Dial structure
      DialTag, 'light', tag='Global',    set=LightVars.Global
      DialTag, 'light', tag='Private',   set=LightVars.Private
      DialTag, 'light', tag='Mad',       set=LightVars.Mad
      DialTag, 'light', tag='Handles',   set=LightVars.Handles
      DialTag, 'light', tag='Run',       set=LightVars.Run
      DialTag, 'light', tag='Instrument',set=LightVars.Instrument
      DialTag, 'light', tag='Displays',  set=LightVars.Displays
  endif

end ; PRO Light_Base_Event_Parser

;***************************************************************
;** Display information about Light/File menu
pro Light_Event_Base_Close, LightVars

  ; verify that MAD is not running (counting, xbu, ...)
  widget_control, LightVars.Handles.Mad_Status, set_value='<EXITING>'
  Light_Event_Base_Save_Preferences, LightVars
  if strlen(LightVars.Global.LogFile) ne 0 then $
    Light_LogMessage, LightVars, 'normal','[ ] Light Log was saved for this session in '+file_which(LightVars.Global.LogFile, /include_current_dir)
  Light_LogMessage, LightVars, 'normal','[ ] Exiting'
  widget_control, LightVars.Handles.Base, /destroy
  DialStop,  'light'
  DialClear, 'light'
  LightVars.Handles.Base = 0L
  return

end ; PRO Light_Event_Base_Close

;***************************************************************
;** Restart Light and Reads Initilisation files (Ini/Config)
pro Light_Event_Base_Restart, LightVars

  Light_LogMessage, LightVars, 'normal','[ ] Restart Light -> Init'
  widget_control, LightVars.Handles.Base, /destroy
  LightVars.Handles.Base = 0L
  Light_Base_Init, LightVars
  Light_Base_Build, LightVars

end ; PRO Light_Event_Base_Restart

;*****************************************
; start/stop simulation mode/control mode
pro Light_Event_Base_Simulation, LightVars, Simulation=Simulation

  if n_elements(Simulation) eq 0L then begin ; toggle mode
    if LightVars.Global.Simulation eq 0L then aSimulation = 1L $
    else aSimulation = 0L
  endif else aSimulation = Simulation

  if (aSimulation ne 0) then begin
    LightVars.Global.Simulation = 1L
    widget_control, LightVars.Handles.Simulation, set_value='Control Mode: Simulation', bad_id=tmp1
  endif else begin
    LightVars.Global.Simulation = 0L
    widget_control, LightVars.Handles.Simulation, set_value='Control Mode: Active', bad_id=tmp1
  endelse

end ; PRO Light_Event_Base_Simulation

;***************************************************************
;** Ask for SuperUser mode on creation,
pro Light_Event_Base_SuperUser, LightVars, Event=Event

  widget_control, LightVars.Handles.Base_SuperUser, Bad_ID=Bad_ID, show=1, iconify=0
  ;** If does not exist, make it
  if Bad_ID ne 0 or LightVars.Handles.Base_SuperUser eq 0 then  begin

    Title='SuperUser Login for '+LightVars.Instrument.Name
    Base = widget_base(/column, Group_Leader=LightVars.Handles.Base, Title=Title)
    LightVars.Handles.Base_SuperUser = cw_field(Base, Title='Please enter SuperUser password', $
                                      /column, /RETURN_EVENTS, UName='Not SU', uvalue='Light_Event_Base_SuperUser, LightVars, Event=Event')
    widget_control, Base, /realize
    XManager, 'Base_SU', Base, Event_Handler='Light_Base_Event_Parser', $
        /just_reg, /no_block

  endif else begin
    if strcmp(tag_names(event, /structure), 'WIDGET_BUTTON') then begin
      Light_LogMessage, LightVars, 'normal' , '[w] You are already SuperUser, Close window to log out'
      return
    endif
    Passwd = Event.Value
    Top    = Event.Top
    if n_elements(Passwd) eq 0 then begin
      Light_LogMessage, LightVars, 'silent' , '[E] Please enter a non empty Passwd.'
      return
    endif else begin
      ;** check value of SU passwd.
      if strcmp(Passwd, 'anita') then begin
        ;** if OK, set IsSuperser flag and hide text field (map=0), but keep window
        widget_control, Top, tlb_set_title='SUPERUSER MODE ACTIVE'
        widget_control, LightVars.Handles.Base_SuperUser, set_value='Close to log out SU', sensitive=0, set_uvalue='Light_Event_SU_Mode'
        Light_LogMessage, LightVars, 'silent' , '[w] SuperUser Login: Success. Close window to log-out.'
      endif else begin
        Light_LogMessage, LightVars, 'silent' , '[E] SuperUser Login: Bad password.'
        widget_control, LightVars.Handles.Base_SuperUser, set_value='* Bad password *'
      endelse
    endelse
  endelse

end ; PRO Light_Event_Base_SuperUser

;*****************************************
; load instrument configuration file (when SU mode)
pro Light_Event_Base_Load_Instr_File, Lightvars

  if LightVars.Private.IsSuperUser eq 0 then begin
    Light_LogMessage, LightVars, 'normal','[w] Only SuperUser can load new instrument configuration files'
    return
  endif else begin
    file = ''
    Light_Base_Load_Config_File, LightVars, file, path=LightVars.Global.ConfigDir
    if strlen(file_which(file, /include_current_dir)) ne 0 or file_test(file, /regular) ne 0 then $
      LightVars.Global.ConfigFile = file
  endelse

end ; PRO Light_Event_Base_Load_Instr_File

;*****************************************
; load instrument configuration file (when SU mode)
pro Light_Event_Base_Save_Instr_File, Lightvars

  if LightVars.Private.IsSuperUser eq 0 then begin
    Light_LogMessage, LightVars, 'normal','[w] Only SuperUser can save new instrument configuration files'
    return
  endif else begin
    file = dialog_pickfile(Dialog_Parent=LightVars.Handles.Base, $
            file = LightVars.Global.ConfigFile, filter='*.ini', $
            path = LightVars.Global.ConfigDir, $
            Get_Path=Get_Path, Title='Save Instrument Config File to')

    if strlen(file) eq 0 then return  ; canceled

    ;** display warning if file name was re-used
    if strlen(file_which(file, /include_current_dir)) ne 0 or file_test(file) eq 1 then begin
      Button = dialog_message([ 'File '+file+' already exists.', $
                                'Do you want to replace it ?' ], /Question, Title='Replace '+file+' ?', /default_cancel)
      if not strcmp(Button,'Yes') then return
      Light_LogMessage, LightVars, 'normal' , '[w] '+file+' will be over-written.'
    endif
    LightVars.Global.ConfigFile = file
    LightVars.Global.ConfigDir  = Get_Path
    Light_Base_Save_Config_File, LightVars, file=file, /instrument, /displays, /config, comment='Created in Light SuperUser mode'
  endelse

end ; PRO Light_Event_Base_Save_Instr_File

;***************************************************************
;** Save Config_File (Inifile)
pro Light_Event_Base_Save_Preferences, LightVars

  Light_Base_Save_Config_File, LightVars, file=LightVars.Global.IniFile, /config, /runs, /displays, comment = 'User Preferences file'

end ; PRO Light_Event_Base_Save_Preferences

;***************************************************************
;** Display/Change Light Preferences
pro Light_Event_Base_Edit_Preferences, LightVars

  Preferences = {Light_Preferences, $
            Verbosity:LightVars.Global.Verbosity,$
            TerminalEcho:LightVars.Global.TerminalEcho,$
            LogFile:LightVars.Global.LogFile,$
            IniFile:LightVars.Global.IniFile,$
            ConfigDir:LightVars.Global.ConfigDir,$
            ConfigFile:LightVars.Global.ConfigFile, $
            Simulation:LightVars.Global.Simulation, $
            Append_Runs:LightVars.Global.Append_Runs, $
            Plot:LightVars.Plot, $
            Frequency:LightVars.Frequency, $
            Generic:LightVars.Generic }

  Light_LogMessage, LightVars, 'verbose','[I] You will find help in menu Help:Preferences'
  Light_Event_Base_Help_Preferences, LightVars, update=1


  Dialog_Fields, Preferences, Group=LightVars.Handles.Base, COLUMN_WIDTHS=500, $
    Name='Please enter new Light Preferences', Title='Preferences in Light', $
    y_scroll_size=n_elements(tag_names(Preferences)), $
    FieldNames = [ 'Verbosity', 'IDL Echo', 'LogFile', 'IniFile', 'ConfigDir', 'ConfigFile','Simulation','Append Runs','History size','Frequency','Control Program']

  LevelList      = ['silent','normal','verbose','debug']
  tmp1 = where(strcmp(LevelList, Preferences.Verbosity))
  if tmp1(0) ne -1 then $
    LightVars.Global.Verbosity = Preferences.Verbosity $
  else $
    Light_LogMessage, LightVars, 'normal','[w] Verbosity can be: silent, normal, verbose, debug'
  if LightVars.Private.IsSuperUser then begin
    if file_test(Preferences.ConfigDir, /directory) ne 0 then $
      LightVars.Global.ConfigDir = Preferences.ConfigDir $
    else begin
      Light_LogMessage, LightVars, 'normal','[w] ConfigDir must be a valid (configuration) directory'
      Light_LogMessage, LightVars, 'normal','[w] Check: ' + Preferences.ConfigDir
    endelse
    LightVars.Global.ConfigFile = Preferences.ConfigFile
  endif else begin
    if not strcmp(strtrim(LightVars.Global.ConfigDir,2), strtrim(Preferences.ConfigDir,2)) $
       or not strcmp(strtrim(LightVars.Global.ConfigFile,2), strtrim(Preferences.ConfigFile,2)) then begin
      Light_LogMessage, LightVars, 'silent','[w] ConfigDir/ConfigFile may only be changed in SuperUser mode.'
      Light_LogMessage, LightVars, 'silent','[w] Ask Local Contact or Instrument Responsible.'
    endif
  endelse
  LightVars.Global.IniFile      = Preferences.IniFile
  LightVars.Global.TerminalEcho = Preferences.TerminalEcho
  LightVars.Global.LogFile      = Preferences.LogFile
  LightVars.Global.Append_Runs  = Preferences.Append_Runs
  LightVars.Plot             = Preferences.Plot
  LightVars.Frequency        = Preferences.Frequency
  LightVars.Generic          = Preferences.Generic

  if long(Preferences.Simulation) eq 0 then LightVars.Global.Simulation = 0L else LightVars.Global.Simulation = 1L

  ;** Update Dial structure
  DialTag, 'light', tag='Frequency',set=LightVars.Frequency
  DialTag, 'light', tag='Plot',     set=LightVars.Plot
  DialTag, 'light', tag='Generic',  set=LightVars.Generic

end ; PRO Light_Event_Base_Edit_Preferences

;***************************************************************
;** Edit variables to be displayed by dial_display
pro Light_Event_Base_Edit_Displays, LightVars

  ToUpdate = [ 'Variables', 'Type', 'Options' ]

  Light_Event_Base_Help_Displays, LightVars, update=1

  for index = 0, n_elements(LightVars.Displays.Variables)+4 do begin
    if index ge n_elements(LightVars.Displays.Variables) then begin
      Display = {Variable:'',Type:'auto',Options:''}
    endif else begin
      Display = {Variable:LightVars.Displays.Variables(index),$
         Type:LightVars.Displays.Type(index), $
         Options:LightVars.Displays.Options(index)}
    endelse
    if index eq 0 then Displays = Display else Displays = [ Displays, Display ]
  endfor
  ; automatic call of Displays/Help if active

  ; now call Dialog_Fields to display the Displays settings
  Dialog_Fields, Displays, Group=LightVars.Handles.Base, COLUMN_WIDTHS=300, $
    Name='Please enter Displays specifications', Title='Displays in Light', $
    FieldNames = [ 'Variable', 'Type', 'Options'], /swap

  ; update displays and remove invalid entries
  StructIndex = -1

  Mad = LightVars.Mad
  t_res    = Mad.t_res
  t_para   = Mad.t_para
  t_nother = Mad.t_nother
  t_chopper= Mad.t_chopper
  t_status = Mad.t_status
  data     = Mad.Data

  Monitor  = data(0, *) & data = data(1:(t_para.tof_cha_resol-1),*) ; for IN6
  detectors= total(data,1)  ; Channels on X (length=340), sum of row
  tof      = total(data,2)  ; TOF on X (length=LightVars.Mad.t_para.tof_cha_resol = 512, 1024...)

  Temperatures = t_res.tempea
  TSet    = Temperatures(0)
  TReg    = Temperatures(1)
  TSample = Temperatures(2)
  Power   = Temperatures(3)
  Lambda  = t_para.wave

  for index = 0, n_elements(LightVars.Displays.Variables)+4 do begin
    Display = Displays(index)
    if strlen(Display.Variable) gt 0 then begin
      ok = execute('DataToDisplay='+Display.Variable)
      if not ok then Light_LogMessage, LightVars, 'normal' , '[w] Light: Displays: "'+Display.Variable+'" does not seem to be a valid value. May be inactivated when displayed.'
      
      StructIndex = StructIndex+1
      IsValidType = where(Display.Type eq ['text','plot','surface','image','contour'])
      IsValidType = IsValidType(0)
      if IsValidType eq -1 then Display.Type = ''
      if StructIndex eq 0 then begin
        Variables = Display.Variable
        Type      = Display.Type
        Options   = Display.Options
      endif else begin
        Variables = [ Variables, Display.Variable ]
        Type      = [ Type, Display.Type ]
        Options   = [ Options, Display.Options ]
      endelse
    endif
  endfor
  if StructIndex ge 0 then begin
    NewDisplays={Variables:Variables, Type:Type, Options:Options}
    Tools_StructSetValue, struct=LightVars, Tag='Displays', val=NewDisplays
    LightVars.Private.Update_Nb = 10
  endif

end ; PRO Light_Event_Base_Edit_Displays

;***************************************************************
; Define and retrieve ROI (through IDL XROI tool)
pro Light_Event_Base_Edit_ROI, LightVars, update=update
  
  FORWARD_FUNCTION	LookupManagedWidget

  ; redimension the cumulated Mad.data image so that it fits in screen (max is ScreenDim pixels)
  if n_elements(LightVars.Private.Data_Cumulated) ne n_elements(LightVars.Mad.data) then $
   DataImage = LightVars.Private.Data_Cumulated+LightVars.Mad.data $
  else DataImage = LightVars.Mad.data
  DataImage = double(DataImage)
  
  ScreenDim = 512.0
  data_dims = size(DataImage, /dimensions)
  if data_dims(0) eq 0 then return
  
  ; setting monitors to zero (IN6 dependent)
  DataImage((data_dims(0) -2):(data_dims(0) -1), *)     = 0 ; removes last channel (= integral)
  DataImage(*,0:(LightVars.Mad.t_res.N_MON_SPECT-1))  = 0 ; removes monitors

  max_dim   = max(data_dims)
  scaling   = round(max_dim/ScreenDim)
  data_dims = data_dims/scaling
  data      = 0
  
  ; call xroi if not present yet
  if xregistered('xroi', /noshow) eq 0 and n_elements(update) eq 0 then begin
    
    ; now build a new regions_in array of IDLgrROI from xyrange
    if size(LightVars.Private.ROIs, /type) eq 8 then begin  ; is a structure
      for index = 0,(n_elements(LightVars.Private.ROIs) - 1) do begin
        ThisROIstr = LightVars.Private.ROIs(index)
        ; now build the 4 vertex (rectangle corners), and adjust to shown image size (scaling)
        X = round([ ThisROIstr.xrange(0), ThisROIstr.xrange(0), ThisROIstr.xrange(1), ThisROIstr.xrange(1) ]/scaling)
        Y = round([ ThisROIstr.yrange(0), ThisROIstr.yrange(1), ThisROIstr.yrange(1), ThisROIstr.yrange(0) ]/scaling)
        ThisROIobj = obj_new('IDLgrROI', X, Y, $
          color=[0, 255, 255], NAME=ThisROIstr.name, style=ThisROIstr.style, $
          THICK=ThisROIstr.THICK, type=ThisROIstr.type)
        if index eq 0 then Regions = ThisROIobj $
        else Regions = [Regions, ThisROIobj]
      endfor
    endif
    title = '['+LightVars.Instrument.name+'] ROI on TOF-det (log)'
    title = title+' 1:'+strcompress(string(round(scaling*10)/10))
    data  = congrid(DataImage+1, data_dims(0), data_dims(1), /interp)
    Light_LogMessage, LightVars, 'verbose','[I] ROI data axes:X is TOF channel, Y is det. number'
    Light_LogMessage, LightVars, 'verbose',['# Cumulated Data is shown as log scale from 0 to 255', '# Color table is Hue Sat Value 2 (22)' ]
    xroi, data,  $
      regions_in = Regions, regions_out = Regions, $
      tools=['Rectangle','TRANSLATE-SCALE', 'Selection'], $
      title=title
    ROI_ID = LookupManagedWidget('xroi')
    widget_control, ROI_ID, get_uvalue=sState
    ; change the palette
    ; Blue-Red(11), EOS B(27), GREEN-PINK(10), Hue Sat Value 2(22),  RAINBOW(13), Purple-red + Stripes (23)
    ; STERN SPECIAL(15)
    
    (*sState).oPalette->LoadCT, 22
    
    (*sState).oImage->SetProperty, PALETTE=(*sState).oPalette
  endif

  if xregistered('xroi', /noshow) ne 0 then begin
    ROI_ID = LookupManagedWidget('xroi')
    
    ; show window (not in update mode), if was iconified, or hiden
    if n_elements(update) eq 0 then $
      widget_control, ROI_ID, show=1, iconify=0
      
    if n_elements(data) eq 1 then data  = congrid(DataImage+1, data_dims(0), data_dims(1), /interp)
    data = alog(data)
    data = data-min(data)
    data = data/max(data)*255
    
    ; now retrieve IDLgrROI objects
    widget_control, ROI_ID, get_uvalue=sState
    Private = LightVars.private
    a = (*sState).oROIModel

    ROIs = 0L
    if a->Count() gt 0 then begin
      for index = 0, (a->Count()-1) do begin
        ThisROIobj = a->Get(position=index)
        ThisROIobj->GetProperty, all=ThisROIstr
        ThisROIstr.xrange = round(ThisROIstr.xrange*scaling)  ; real indexes on full image
        ThisROIstr.yrange = round(ThisROIstr.yrange*scaling)
        if index eq 0 then ROIs = ThisROIstr $
        else ROIs = [ROIs, ThisROIstr]
      endfor

      Tools_StructSetValue, struct=LightVars,  Tag='Private.ROIs',val=ROIs
    endif else Tools_StructSetValue, struct=LightVars,  Tag='Private.ROIs',val=0L
    (*sState).oImage->SetProperty, data=data
    (*sState).oWindow->Draw, (*sState).oView
  endif

end ; PRO Light_Event_Base_Edit_ROI

;***************************************************************
pro Light_Event_Base_Edit_Header, LightVars

  ;** execute Custom procedure
  res = execute(LightVars.Instrument.CustomPro+', /edit_header')

end ; PRO Light_Event_Base_Edit_Header

;***************************************************************
;** Show MAD log (recent lines)
pro Light_Event_Base_Show_MAD_Log, LightVars

  Private = LightVars.Private
  ToDisplay= DialNewValue(type='log')
  MadLog = Private.MadLogText
  MadLog = [ MadLog, ToDisplay ]
  n_lines = n_elements(MadLog)
  min_index=max([0, n_lines-1000])
  MadLog = MadLog(min_index:(n_lines-1))
  if min_index ne 0 then MadLog = [ 'Last 1000 lines of MAD Log ['+systime(0)+']', MadLog ]
  Tools_StructSetValue, struct=LightVars, Tag='Private.MadLogText', val=MadLog

  widget_control, LightVars.Handles.Base_Mad_Log, set_value=MadLog, Bad_ID=Bad_ID, show=1, iconify=0
  if Bad_ID ne 0 or LightVars.Handles.Base_Mad_Log eq 0 then  begin
    xdisplayfile, 'mad_light.log', text=MadLog, Group=LightVars.Handles.Base, $
          title=strupcase(LightVars.Generic)+' Log (tail of mad.log)',$
          Done_Button='Close ['+strupcase(LightVars.Generic)+' Log]', WText=ID, /editable
    LightVars.Handles.Base_Mad_Log = ID
  endif


end; Light_Event_Base_Show_MAD_Log

;***************************************************************
;** Show Light log (of session)
pro Light_Event_Base_Show_Light_Log, LightVars

  ToDisplay= LightVars.Private.LogText
  if n_elements(ToDisplay) ge 1 and strlen(ToDisplay(0)) gt 0 then begin
    widget_control, LightVars.Handles.Base_Light_Log, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0
    if Bad_ID ne 0 or LightVars.Handles.Base_Light_Log eq 0 then  begin
      Title = 'Light Log'
      if (strlen(LightVars.Global.LogFile) ne 0) then Title = Title+' ('+LightVars.Global.LogFile+')'
      xdisplayfile, 'light_light.log', text=ToDisplay, Group=LightVars.Handles.Base, $
            title=Title,$
            Done_Button='Close [Light Log]', WText=ID, /editable
      LightVars.Handles.Base_Light_Log = ID
    endif
  endif

end; Light_Event_Base_Show_Light_Log

;************************* Help  Events ************************
;***************************************************************
;** Display information about Light
pro Light_Event_Base_Help_About, LightVars

  Mem = memory(/current)
  ToDisplay = ['This is Light for George.',$
               '', $
               'Running on:  '+strupcase(LightVars.Instrument.Name), $
               'Version:     '+LightVars.Private.Version, $
               'Author:      '+LightVars.Private.Author,$
               'Active Run:  '+string(LightVars.Global.Current_Run), $
               'Memory used: '+strtrim(Mem/1024,2)+' ko',$
               'Date:        '+systime(0), '', $
               'Contributions: D. Richard, ILL for Dial_ByGeorge; A. Schober for Light 1.0', $
               'License: This software may be used, copied, or redistributed as long as it is ', $
               ' not sold and this copyright notice is reproduced on each copy made. This ', $
               ' routine is provided as is without any express or implied warranties whatsoever.' ]

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='About Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 then  begin
    xdisplayfile, 'aboutlight.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='About Light on ['+strupcase(LightVars.Instrument.Name)+']',$
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID

    LightVars.Handles.Base_Help = ID
  endif

end ; PRO Light_Event_Base_Help_About

;***************************************************************
;** Display information about Light/File menu
pro Light_Event_Base_Help_File, LightVars

  ToDisplay =['FILE menu Help in "Light on George"',$
              '',$
              'This menu gathers operations dealing with files, input and output', '', $
              'Edit Light Preferences',$
              '   set simulation mode, directories, configuration files, verbosity...', $
              'Save Light Preferences',$
              '   save Preferences (also done at Exit)', $
              'Show Light Log File',$
              '   display the "Light on George" Log file (errors, events, etc...)',$
              'Show '+strupcase(LightVars.Generic)+' Log File',$
              '   display the '+strupcase(LightVars.Generic)+' Log file (instrument commands, counts, errors, etc...)',$
              'Restart Light',$
              '   restart Light and read configuration files.',$
              'Exit',$
              '   save Preferences, exit Light program, close associated IDL windows']

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='File Help in Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 then  begin
    xdisplayfile, 'file.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='File Help in Light', /editable, $
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
    LightVars.Handles.Base_Help = ID
  endif

end ; PRO Light_Event_Base_Help_File

;***************************************************************
;** Display information about Light/Setup menu
pro Light_Event_Base_Help_Setup, LightVars

  ToDisplay =['SETUP menu Help in "Light on George"',$
              '',$
              'This menu enables to customise the configuration of the instrument/experiment', '', $
              'Refer to the specific Help menu of the Light:Setup:Instrument window for', $
              'additional information', $
              '', $
              'Displays', $
              '   set the displays to show in the Display Panel. See dedicated Help on that topic.', $
              'Regions of Interest (ROIs)', $
              '   edit/define ROIs on which to perform accuracy analysis (see below), using', $
              '   the cumulated signal (for repeated countings). In order to be efficient', $
              '   each ROI should contain, as far as possible, isolated peaks or features', $
              '   that are thought to be of particular interest to the physicist.', $
              'Analyse ROIs', $
              '   basic statistics are performed for each defined ROI. This includes the computation', $
              '   of the noise/signal ratio, the normalised Chi squared corresponding to a fit', $
              '   using a single Gaussian peak over a background parabola, and an estimate of the ', $
              '   deduced relative uncertainty for this simple model. When all these values are', $
              '   better (lower) than the "Relative Error" parameter of the Run Options, it is', $
              '   assumed that a reasonable statistics has been achieved. Then, if the "Count on ', $
              '   Statistics" Run Option is active, the counting is terminated, and goes-on with ', $
              '   the next run in the sequence.', $
              'SuperUser Login',$
              '   ask the SuperUser password. Close the dialog to log-out from SuperUser Mode.', $
              'Control Mode {Active|Simulation}', $
              '   display/toggle the current Instrument Control Mode', $
              'Load Configuration', $
              '   loads a Light configuration file (extended preferences)', $
              'Save Configuration', $
              '   saves a Light configuration file (extended preferences)' ]

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Setup Help in Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 then  begin
    xdisplayfile, 'setup.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='Setup Help in Light', /editable, $
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
    LightVars.Handles.Base_Help = ID
  endif

end ; PRO Light_Event_Base_Help_Setup

;***************************************************************
;** Display information about Light/Setup menu
pro Light_Event_Base_Help_Run_Start, LightVars

  ToDisplay =['START/RUN menu Help in "Light on George"',$
              '',$
              'This menu gathers operations concerning how to execute experiment runs/scans', $
              'Each run is an acquisition period at a given temeperature. You may repeat runs',$
              'and give them descriptive tiles (facilitate identification of files). Some', $
              'options concerning the automatic checks/tasks during runs may be activated.', $
              '', $
              'Load Run/Sequence (XBU)',$
              '   load a Run/Sequence file and display its contents (in Exp. Runs section)',$
              'Save Run/Sequence (XBU)',$
              '   save the current Run/Sequence as an XBU file',$
              'Analyse/Show', $
              '   display a time analysis of Runs as a table', $
              'Run Options',$
              '   set temperature control and options, as well as',$
              '   Diagnosis and Count On Statistics parameters',$
              'Clear All Runs',$
              '   remove all Run definitions but the first',$
              'Delete Current Run',$
              '   remove current Run definition from the Sequence',$
              'Insert', $
              '   duplicate the current Run in the Sequence', $
              'Next Run (go to)', $
              '   display next Run of the Sequence', $
              'Start Single Run',$
              '   start only the current displayed Run',$
              'Start Sequence',$
              '   start the whole run sequence (from Run #0 to the last Run)', $
              'Stop Run/Sequence', $
              '   stop current Run/Sequence']

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Start/Run Help in Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 then  begin
    xdisplayfile, 'run.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='Start/Run Help in Light', /editable, $
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
    LightVars.Handles.Base_Help = ID
  endif

end ; PRO Light_Event_Base_Help_Run_Start

;***************************************************************
;** Display information about Light/Preferences
pro Light_Event_Base_Help_Preferences, LightVars, update=update

  ToDisplay =['PREFERENCES menu Help in "Light on George"',$
              '',$
              'This menu enables to change some internal settings controling the execution of Light',$
              'Verbosity=<level>',$
              '   affects the amount of messages displayed by Light.',$
              '   values can be: silent, normal, verbose, debug',$
              'IDL Echo=<0 or 1>', $
              '   will display Light message in IDL promp window when true.', $
              'LogFile=<filename or empty>',$
              '   When non-empty, sets the name of the Light Log file, where messages are written.', $
              'IniFile=<filename>',$
              '   the name of the initialise file, that Light reads on start-up.',$
              '   it contains preferences and other stuff. e.g. Light.ini',$
              'ConfigDir=<dir>',$
              '   the directory where instrument configuration files are.',$
              '   e.g. /home/cs/lambda/CALIBRATION/<inst>/',$
              'ConfigFile=<filename>',$
              '   the name of the file containing instrument parameters.',$
              '   e.g. Config.ini',$
              '   ConfigDir and ConfigFile may only be changed in SuperUser mode',$
              'Simulation=<0 or 1>',$
              '   sets the Instrument Control mode to "simulation" when true',$
              '   unactivate calls and commands to the instrument control program '+strupcase(LightVars.Generic), $
              'Append Runs=<0 or 1>',$
              '   will append new loaded run file contents to the existing sequence if true', $
              'History size=<-2,0,3:100>', $
              '   sets the number of counts values to remember and plot in George', $
              'Frequency', $
              '   sets the update frequency of Light. A Major Update (displays) takes place every 10 updates.', $
              'Control Program', $
              '   sets the name of the program to control the instrument' $
              ]

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Preferences Help in Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
    xdisplayfile, 'preferences.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='Preferences Help in Light', /editable,$
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
    LightVars.Handles.Base_Help = ID
  endif

end ; PRO Light_Event_Base_Help_Preferences

;***************************************************************
;** Display information about Light/Displays
pro Light_Event_Base_Help_Displays, LightVars, update=update

  DisplayHelp = ''
  if xregistered('Dial_Display_Interface') ne 0 then $
    Display, DisplayHelp=DisplayHelp, /unactivate

  ToDisplay =['Displays menu Help in "Light on George"',$
              '',$
              'This menu enables to change/modify the definition of variables to monitor',$
              'Variable=[expression]',$
              '   defines the expression to be evaluated and displayed (Data)',$
              '   variables may be of type text (string array), scalar (single numerical values)', $
              '   numerical vector, and numerical image/map', $
              '   a single numerical value will be appended (catenate)', $
              'Type=<text|plot|surface|image|contour>', $
              '   defines the type of display to use', $
              '   default is to use a text, vector or surface display, depending on the Variable type', $
              '   but other displays may be chosen for images/maps, and it is also possible', $
              DisplayHelp, $
              'Ex:Variable          Type    Options', $
              '   memory(/current)                                                    (displays IDL memory usage with time)', $
              '   Mad.Temperature   surface Name_IX="Time", Name_IY="Temp", /catenate (record Temperatures vs time)', $
              '   Mad.Data,         image   Name_IX="Channels", Name_IX="TOF"         (displays all detectors)' $
              ]

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Displays Help in Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
    xdisplayfile, 'displays.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='Displays Help in Light', /editable, $
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
    LightVars.Handles.Base_Help = ID

  endif

end ; PRO Light_Event_Base_Help_Displays

;***************************************************************
;** Display information about Light/Displays
pro Light_Event_Base_Help_Run_Options, LightVars, update=update

  DisplayHelp = ''

  ToDisplay =['Run Options menu Help in "Light on George"',$
              '',$
              'This window enables to customize the way runs and sequences are executed', '', $
              '[Temperature control]', $
              '   Checks that temperature remains within specified limits. If temperature has', $
              '   gone outside limits for [wait on T Error] minutes:', $
              '     A warning is generated', $
              '     A new counting is started. The numor is thus incremented, keeping other run', $
              '       parameters unchanged (temporary counting, with saving). These countings', $
              '       may be repeated as long as the temperature is not stabilised', $
              '     When temperature is recovered and stable, the remaining sequence time is ', $
              '       rescalled, so that the total execution time, including lost time, still', $
              '       remains close to the original execution time.', $
              '   During temperature changes, the sequence suspends for [wait on Reach T]', $
              '   before starting to count.', $
              '   NOTE: the [wait on T Error] value should be higher than the [wait on Reach T] one', $
              '[Count on Statistics]', $
              '   basic statistics are performed for each defined ROI. This includes the computation', $
              '   of the noise/signal ratio, the normalised Chi squared corresponding to a fit', $
              '   using a single Gaussian peak over a background parabola, and an estimate of the ', $
              '   worse deduced relative uncertainty for this simple model (6 parameters). When all', $
              '   these values are better (lower) than the "Relative Error" parameter, it is', $
              '   assumed that a reasonable statistics has been achieved. Then, if the "Count on ', $
              '   Statistics" is active, the current counting is terminated, and goes-on with ', $
              '   the next run in the sequence.', $
              '[Optional Command]', $
              '   This line may contain a command to be executed when starting the run.', $
              '   It is sent to the Instrument by default, or usage may be specified with words', $
              '   "idl:", "system:", "mad:". Valid examples follow:', $
              '     idl: d=indgen(10) & plot, d', $
              '     system: ls ; nedit', $
              '     mad: par chop' $
              ]

  widget_control, LightVars.Handles.Base_Help, set_value=ToDisplay, Bad_ID=Bad_ID, show=1, iconify=0, tlb_set_title='Run Options Help in Light'
  if Bad_ID ne 0 or LightVars.Handles.Base_Help eq 0 and n_elements(update) eq 0 then  begin
    xdisplayfile, 'runoptions.hlp', text=ToDisplay, Group=LightVars.Handles.Base, $
          title='Run Options Help in Light', /editable, $
          Height=20,Width=80,Done_Button='Close [Light Help]', WText=ID
    LightVars.Handles.Base_Help = ID
  endif

end ; PRO Light_Event_Base_Help_Run_Options

;*********************** RUN EVENTS ****************************
;***************************************************************
;** Show/Analyse Run sequence
pro Light_Event_Base_Run_Analyse, LightVars

  Light_Base_Get_Fields_ToDisplay, LightVars, index=0, $
        header=header, h_val=h_val, spy=spy, s_val=s_val, run=run, r_val=r_val, check=check, c_val=c_val

  Titles    = ['Run NO', 'Title','Dur*Rept +','Max Wait', 'Targ Temp', 'Lambda', $
               'Preset', 'Check T', 'Save', 'Diagnosis', 'Count/Stat'  ]

  IsSamePresetType = 1
  TotalTime = 0
  TotalWait = 0
  for index=0, n_elements(LightVars.Run.Temperatures)-1 do begin
    if LightVars.Run.Flag_MonTi(0) ne LightVars.Run.Flag_MonTi(index) then IsSamePresetType=0
    RunNO = 'Run_'+strcompress(index,/remove_all)
    DuRep = LightVars.Run.Preset(index)*LightVars.Run.Repetition(index)
    MaxWt = LightVars.Run.Wait_T(index)
    if index eq LightVars.Private.OnGoing_Run_Nb then RunNO = '> '+RunNO $
    else if index eq LightVars.Global.Current_Run then RunNO = '* '+RunNO
    if LightVars.Run.Flag_T(index)     then TChek = 'Yes' else TChek = 'no'
    if LightVars.Run.Flag_Save(index)  then SaveP = 'Yes' else SaveP = 'no'
    if LightVars.Run.Flag_Diag(index)  then Diags = 'Yes' else Diags = 'no'
    if LightVars.Run.Flag_Count(index) then Count = 'Yes' else Count = 'no'
    if LightVars.Run.Flag_MonTi(index) then begin
      MonTi = 'Time'
      TotalTime = TotalTime+DuRep
    endif else MonTi = 'Monitor'
    TotalWait = TotalWait+MaxWt
    tmp1 = {RunNO:RunNO, $
          Title:LightVars.Run.Titles(index), $
          DuRep:DuRep, $
          MaxWt:MaxWt, $
          TargT:LightVars.Run.Temperatures(index),$
          Lambda:LightVars.Run.Lambda(index),$
          MonTi:MonTi, $
          TChek:TChek, $
          SaveP:SaveP, $
          Diags:Diags, $
          Count:Count }

    if index eq 0 then ToDisplay = tmp1 else ToDisplay = [ ToDisplay, tmp1]
  endfor
  if IsSamePresetType then $
    Name = 'Total Time ='+string(TotalTime)+' [min]' $
  else $
    Name = 'Mixed Monitor/Time runs'
  Name  = Name + '. Temperature Wait Time ='+ string(TotalWait)+' [min]'
  Title = 'Run/Sequence 0-'+strcompress(n_elements(LightVars.Run.Temperatures)-1)+' ['+systime(0)+']'

  ID = LightVars.Handles.Base_Run_Analyse
  Dialog_Fields, ToDisplay, Group=LightVars.Handles.Base, COLUMN_WIDTHS=100, $
    x_scroll_size=n_elements(tag_names(ToDisplay(0))), $
    y_scroll_size=n_elements(ToDisplay), $
    Name=Name, Title=Title, $
    FieldNames=Titles(0:(n_elements(tag_names(tmp1))-1)), $
    /swap,/display, ID=ID
  LightVars.Handles.Base_Run_Analyse = ID
end ; PRO Light_Event_Base_Run_Analyse

;***************************************************************
;** Delete Run definitions
pro Light_Event_Base_Run_Delete, LightVars, Run_Nb=Run_Nb

  ; delete active run if not given as parameter
  if n_elements(Run_Nb) eq 0 then $
    Run_Nb = LightVars.Global.Current_Run

  if n_elements(Run_Nb) gt 1 then begin
    ; delete each Run Number that is in the Run_Nb vector.
    for index=n_elements(Run_Nb)-1, 0, -1 do $
      Light_Event_Base_Run_Delete, LightVars, Run_Nb=Run_Nb(index)

  endif else begin
    ; delete a single Run
    Runs         = LightVars.Run
    Run_TagNames = tag_names(Runs)
    Run_Nelements= n_elements(Runs.Temperatures)-1
    if Run_Nelements eq 0 then begin
      Light_LogMessage, LightVars, 'verbose' , '[w] I must keep at least one Run element.'
      return
    endif
    if Run_Nb lt 0 then Run_Nb = 0
    if Run_Nb ge Run_Nelements then Run_Nb = Run_Nelements
    for index=0,n_elements(Run_TagNames)-1 do begin
      ; for each Run variable, make a copy of array when removing the element Run_Nb
      Run_Array = Runs.(index)
      if Run_Nb eq 0 then New_Array = Run_Array(1:Run_Nelements) $
      else begin
        if Run_Nb eq Run_Nelements then $
          New_Array = Run_Array(0:(Run_Nelements-1)) $
        else New_Array = [ Run_Array(0:(Run_Nb-1)), Run_Array((Run_Nb+1):Run_Nelements) ]
      endelse
      Tools_StructSetValue, struct=LightVars, Tag='Run.'+Run_TagNames(index), val=New_Array
    endfor
    Light_Event_Base_Run_Fields, LightVars, /restore

  endelse

end ; PRO Light_Event_Base_Run_Delete

;***************************************************************
;** Clear All Run definitions
pro Light_Event_Base_Run_Clear_All, LightVars

  ; clear all Run def arrays. Keep current one as the first.
  ; make a loop with Base_Run_Delete

  tmp1 = n_elements(LightVars.Run.Temperatures)-1
  if tmp1 gt 0 then begin
    ; Close analyse window
    widget_control, LightVars.Handles.Base_Run_Analyse, Bad_Id=Bad_Id, /destroy
    LightVars.Handles.Base_Run_Analyse = 0L
    ; close all
    Run_Nb = indgen(tmp1+1)
    Light_Event_Base_Run_Delete, LightVars, Run_Nb=Run_Nb
    Light_LogMessage, LightVars, 'verbose' , '[ ] Deleting '+string(tmp1+1)+' Run elements.'
  endif

  Light_Event_Base_Run_Fields, LightVars, /restore

end ; PRO Light_Event_Base_Run_Clear_All

;***************************************************************
;** Insert a new Run definition, and shift furthers (if any)
pro Light_Event_Base_Run_Insert, LightVars, Run_Nb=Run_Nb

  ; insert at active run if not given as parameter
  if n_elements(Run_Nb) eq 0 then $
    Run_Nb = LightVars.Global.Current_Run

  ; insert a new run in place of the current one, and duplicate its contents
  Runs         = LightVars.Run
  Run_TagNames = tag_names(Runs)
  Run_Nelements= n_elements(Runs.Temperatures)-1

  if Run_Nb lt 0 then Run_Nb = 0
  if Run_Nb ge Run_Nelements then Run_Nb = Run_Nelements
  for index=0,n_elements(Run_TagNames)-1 do begin
    ; for each Run variable, make a copy of array when removing the element Run_Nb
    Run_Array = Runs.(index)

    if Run_Nb eq Run_Nelements then $
      New_Array = [ Run_Array(0:Run_Nb), Run_Array(Run_Nb) ] $
    else New_Array = [ Run_Array(0:Run_Nb), Run_Array(Run_Nb), Run_Array((Run_Nb+1):Run_Nelements) ]

    Tools_StructSetValue, struct=LightVars, Tag='Run.'+Run_TagNames(index), val=New_Array
  endfor
  Light_Event_Base_Run_Fields, LightVars, /restore

end ; PRO Light_Event_Base_Run_Insert

;***************************************************************
;** Jump to next Run_Nb
pro Light_Event_Base_Run_Next, LightVars, Run_Nb=Run_Nb

  ; use active run if not given as parameter
  if n_elements(Run_Nb) eq 0 then $
    Run_Nb = LightVars.Global.Current_Run

  Light_Event_Base_Run_Fields, LightVars, Run_Nb=Run_Nb+1, /restore

end ; PRO Light_Event_Base_Run_Next

;***************************************************************
;** Change Run number from Pop-up:
pro Light_Event_Base_Run_Nb, LightVars, Run_Nb=Run_Nb

  widget_control, LightVars.Handles.Current_Run, SET_DROPLIST_SELECT=Run_Nb
  Light_Event_Base_Run_Fields, LightVars, Run_Nb=Run_Nb, /restore

end ; PRO Light_Event_Base_Run_Nb

;***************************************************************
;** Update Current Run definition (called when user changes the current Run settings on Base)
pro Light_Event_Base_Run_Fields, LightVars, Run_Nb=Run_Nb, restore=restore
; not keyword_set(restore): get from Widgets into LightVars.Run if restore not set
; keyword_set(restore): get from LightVars.Run into Widgets

  ; use active run if not given as parameter
  if n_elements(Run_Nb) eq 0 then $
    Run_Nb = LightVars.Global.Current_Run

  Runs         = LightVars.Run
  Run_TagNames = tag_names(Runs)
  Run_Nelements= n_elements(Runs.Temperatures)-1

  if Run_Nb lt 0 then Run_Nb = 0
  if Run_Nb gt Run_Nelements then Run_Nb = Run_Nelements
  LightVars.Global.Current_Run = Run_Nb

  ToUpdate = [ $
                  'Titles', 'Temperatures', 'Lambda', 'Preset', 'Repetition', $
                  'Wait_T', 'Wait_Error', 'dT_Low', 'dT_High', $
                  'Flag_T', 'Flag_Diag', 'Flag_Count', 'Flag_Save', 'Flag_MonTi', 'Flag_dT_AbsRel', $
                  'Option_Command', 'CountStatAccuracy' ]

  for index=0, n_elements(ToUpdate)-1 do begin
  ;** Update fields from ToUpdate, taking Widget Handle (ID) and its value...
    tmp1 = execute('Widget = LightVars.Handles.'+ToUpdate(index))

    if Widget ne 0 and widget_info(Widget, /valid_id) ne 0 then begin
      if keyword_set(restore) then begin
        tmp1 = execute('Value  = LightVars.Run.'+ToUpdate(index))
        Value = Value(Run_Nb)
        ; special IN6: force Lambda to actual value in non SU mode
        if LightVars.Private.IsSuperUser eq 0 and strcmp(ToUpdate(index), 'Lambda') ne 0 and LightVars.Private.Update_Nb gt 0 then Value = LightVars.Mad.t_para.wave
        if not strcmp(strupcase(strmid(ToUpdate(index),0,4)), 'FLAG_') then $
          Value = string(Value)
        widget_control, Widget, set_value=Value, Bad_Id=tmp1
      endif else begin
        widget_control, Widget, get_value=Value, Bad_Id=tmp1
        if tmp1 eq 0 then begin
          if strcmp(strupcase(ToUpdate(index)), 'TITLES') or strcmp(strupcase(ToUpdate(index)), 'OPTION_COMMAND') then begin
            Value = strsplit(Value(0),"'",/extract, /PRESERVE_NULL)
            Value = strjoin(Value,'"')
            tmp3 = execute('Value = '''+Value(0)+'''') 
          endif else Value = abs(Value)
          tmp1 = execute('LightVars.Run.'+ToUpdate(index)+'(Run_Nb) = Value(0)')
        endif
      endelse
    endif
  endfor
  Title = 'Options for Run '+strtrim(string(Run_Nb),2)
  widget_control, LightVars.Handles.Run_Options, tlb_set_title=Title, Bad_ID=Bad_ID
  
  if LightVars.Run.Wait_Error(Run_Nb) lt LightVars.Run.Wait_T(Run_Nb) then begin
    LightVars.Run.Wait_Error(Run_Nb) = LightVars.Run.Wait_T(Run_Nb)
    widget_control, LightVars.Handles.Wait_Error, set_value=LightVars.Run.Wait_Error(Run_Nb), Bad_Id=tmp1
  endif

  ;** Resize/change LightVars.Handles.Current_Run value and accessible elements...
  widget_control, LightVars.Handles.Current_Run, set_value=string(indgen(n_elements(LightVars.Run.Temperatures)), Format='(I3)')
  widget_control, LightVars.Handles.Current_Run, SET_DROPLIST_SELECT=Run_Nb

  widget_control, LightVars.Handles.Base_Run_Analyse, Bad_Id=Bad_Id
  if LightVars.Handles.Base_Run_Analyse ne 0 and Bad_Id eq 0 then $
    Light_Event_Base_Run_Analyse, LightVars

end ; PRO Light_Event_Base_Run_Fields

;***************************************************************
;** Define/display current Run Options (safety margins, etc...)
pro Light_Event_Base_Run_Options_Build, LightVars, Run_Nb=Run_Nb

  ; use active run if not given as parameter
  if n_elements(Run_Nb) eq 0 then $
    Run_Nb = LightVars.Global.Current_Run
    
  Light_Event_Base_Help_Run_Options, LightVars, update=1

  ;** Change title for existing Options window
  Title = 'Options for Run '+strtrim(string(Run_Nb),2)
  widget_control, LightVars.Handles.Run_Options, tlb_set_title=Title, Bad_ID=Bad_ID, show=1, iconify=0
  ;** If does not exist, make it
  if Bad_ID ne 0 or LightVars.Handles.Run_Options eq 0 then  begin

    LightVars.Handles.Run_Options = widget_base(/column, Group_Leader=LightVars.Handles.Base, Title=Title, frame=7)
    ;** Temperature Control and checks
    option_base    = widget_base(LightVars.Handles.Run_Options, /column)
    temp_base      = widget_base(option_base, /column, frame=3)
    tmp2           = widget_label(temp_base,  /align_left,      value='Temperature Control')
    temp_marg_base = widget_base(temp_base,                    /column, frame=1)
    tmp2           = widget_label(temp_marg_base, /align_left, value='Margins')
    val_base       = widget_base(temp_marg_base,               /row)
    labels         = ['Lower: ','Upper: ']
    LightVars.Handles.dT_Low        = cw_field(val_base, title='Lower: ', value=LightVars.Run.dT_Low(Run_Nb), $
                       xsize=8, /all_events, /floating, /column, uvalue='Light_Event_Base_Run_Fields, LightVars')
    LightVars.Handles.dT_High       = cw_field(val_base, title='Upper: ', value=LightVars.Run.dT_High(Run_Nb), $
                       xsize=8, /all_events, /floating, /column, uvalue='Light_Event_Base_Run_Fields, LightVars')
    LightVars.Handles.Flag_dT_AbsRel= cw_bgroup(val_base, label_top='Unit', ['[K]','[%]'], set_value=LightVars.Run.Flag_dT_AbsRel(Run_Nb), $
                        /exclusive, /row, uvalue='Light_Event_Base_Run_Fields, LightVars')
    val_base       = widget_base(temp_marg_base, /column)
    tmp1           = widget_base(temp_marg_base, /row)
    LightVars.Handles.Wait_T        = cw_field(tmp1, title='Max Wait ', value=fix(LightVars.Run.Wait_T(Run_Nb)), $
                       xsize=5, /all_events,  /floating, /row, uvalue='Light_Event_Base_Run_Fields, LightVars')
    tmp2           = widget_label(tmp1, value=' [min] on Reach T')
    tmp1           = widget_base(temp_marg_base, /row)
    LightVars.Handles.Wait_Error    = cw_field(tmp1, title='Max Wait ', value=fix(LightVars.Run.Wait_Error(Run_Nb)), $
                       xsize=5, /all_events,  /floating, /row, uvalue='Light_Event_Base_Run_Fields, LightVars')
    tmp2           = widget_label(tmp1, value=' [min] on T Error')

    ;** Run Diagnosis Flag and params
    temp_base      = widget_base(LightVars.Handles.Run_Options, /row, frame=3)
    LightVars.Handles.Flag_Diag      = cw_bgroup(temp_base, label_left='',/row,$
        [' '], /nonexclusive, uvalue='Light_Event_Base_Run_Fields, LightVars', set_value=LightVars.Run.Flag_Diag(Run_Nb))
    tmp2 = widget_label(temp_base, value='Run Diagnosis')

    ;** Count on Statistics Flag and params
    temp_base      = widget_base(LightVars.Handles.Run_Options, /row, frame=3)
    col1           = widget_base(temp_base, /column)
    col2           = widget_base(temp_base, /column)
    tmp1           = widget_base(col1, /row)
    LightVars.Handles.Flag_Count     = cw_bgroup(tmp1, label_left='',/row,$
        [' '], /nonexclusive, uvalue='Light_Event_Base_Run_Fields, LightVars', set_value=LightVars.Run.Flag_Count(Run_Nb))
    tmp2 = widget_label(tmp1, value='Count on Statistics')
    tmp2 = widget_button (col2, value=' Set ROIs ',            uvalue='Light_Event_Base_Edit_ROI, LightVars')   
    
    tmp1           = widget_base(col1, /row)
    LightVars.Handles.CountStatAccuracy = cw_field(tmp1, title='Rel. Err.', value=fix(LightVars.Run.CountStatAccuracy(Run_Nb)), $
                       xsize=5, /all_events,  /floating, /row, uvalue='Light_Event_Base_Run_Fields, LightVars')
    tmp2 = widget_label(tmp1, value='%')
    tmp2 = widget_button(col2, value='Show Stats',            uvalue='Light_Event_Base_Edit_ROI, LightVars, /update & Light_SubDial_Base_Check_ROI, LightVars, /show')  

    ;** Other options
    temp_base      = widget_base(LightVars.Handles.Run_Options, /column, frame=3)
    LightVars.Handles.Option_Command = cw_field(temp_base, title='Optional Command (idl, system, '+LightVars.Generic+'):', value=LightVars.Run.Option_Command(Run_Nb), $
                      /all_events, /column, uvalue='Light_Event_Base_Run_Fields, LightVars')

    widget_control, LightVars.Handles.Run_Options, /realize
    XManager, 'Base_Options', LightVars.Handles.Run_Options, Event_Handler='Light_Base_Event_Parser', $
        /just_reg, /no_block

  endif

end ; PRO Light_Event_Base_Run_Options_Build

;***************************************************************
;** Load an existing Run/Sequence file.
pro Light_Event_Base_Run_Load, LightVars

  file = dialog_pickfile(Dialog_Parent=LightVars.Handles.Base, $
          file=LightVars.Global.RunFile, filter='*.ini', $
          Get_Path=Selected_Path, /must_exist, Title='Load Run/Sequence File from')

  if strlen(file) eq 0 then return  ; canceled

  LightVars.Global.RunFile = file
  SaveLightVars = LightVars
  Light_Base_Load_Config_File, LightVars, file, contains='Run'
  Run_Nb = string(n_elements(LightVars.Run.Temperatures))
  if LightVars.Global.Append_Runs ne 0 then begin
    tags = tag_names(LightVars.Run)
    for index=0, n_elements(tags)-1 do begin
      ok = execute('val=[ SaveLightVars.Run.'+tags(index)+', LightVars.Run.'+tags(index)+' ]')
      Tools_StructSetValue, struct=LightVars, Tag='Run.'+tags(index), val=val
    endfor
    Light_LogMessage, LightVars, 'normal' , '[ ] Loading '+Run_Nb+' runs after current sequence (append).'
    Light_LogMessage, LightVars, 'normal' , '[ ] Now '+string(n_elements(LightVars.Run.Temperatures))+' runs.'
  endif else $
    Light_LogMessage, LightVars, 'normal' , '[ ] Loading '+Run_Nb+' runs as a new sequence.'
  Light_Event_Base_Run_Fields, LightVars, /restore

  ;** Show analyse window
  Light_Event_Base_Run_Analyse, LightVars

end ; PRO Light_Event_Base_Run_Load

;***************************************************************
;** Save Run/Sequence into a file
pro Light_Event_Base_Run_Save, LightVars

  file = dialog_pickfile(Dialog_Parent=LightVars.Handles.Base, $
            file=LightVars.Global.RunFile, filter='*.run', $
            Get_Path=Selected_Path, Title='Save Run/Sequence File to')

  if strlen(file) eq 0 then return  ; canceled

  LightVars.Global.RunFile = file
  ;** display warning if file name was re-used
  if strlen(file_which(file, /include_current_dir)) ne 0 or file_test(file) eq 1 then begin
    Button = dialog_message([ 'File '+file+' already exists.', $
                              'Do you want to replace it ?' ], /Question, Title='Replace '+file+' ?', /default_cancel)
    if not strcmp(Button,'Yes') then return
    Light_LogMessage, LightVars, 'normal' , '[w] '+file+' will be over-written.'
  endif
  Light_Base_Save_Config_File, LightVars, file=file, /runs, comment='Run/sequence description file'

end ; PRO Light_Event_Base_Run_Save

;***************************************************************
;** Stop any on going Run/Sequence, as well as any setup process
pro Light_Event_Base_Run_Stop, LightVars

  Light_LogMessage, LightVars, 'silent','[I] STOP signal caught.'
  
  ; stop run/sequence
  widget_control, LightVars.Handles.RunStatus, set_uvalue='', set_value='', bad_id=tmp
  ;** execute Custom stop procedure
  res = execute(LightVars.Instrument.CustomPro+', /stop')

end ; PRO Light_Event_Base_Run_Save

;***************************************************************
;** Starts a Sequence, starting from first, until last
; if first = -1, starts at 0
; if last = -1,  ends with last run_nb
pro Light_Event_Base_Run_Start_Sequence, LightVars, first=first, last=last

  if n_elements(first) eq 0 then first = 0
  if n_elements(last) eq 0 then  last  = -1

  ; now look if we start settings...
  a = ''
  widget_control, LightVars.Handles.RunStatus, get_uvalue =a, get_value =b, bad_id=tmp

  if strlen(a) eq 0 then begin
    RunUValue = 'start'
    LightVars.Private.First_Run_Nb  = first
    LightVars.Private.Last_Run_Nb   = last
    LightVars.Private.OnGoing_Run_Nb= first
    
    widget_control, LightVars.Handles.RunStatus, set_uvalue = 'start', set_value='start', bad_id=tmp
  endif else Light_LogMessage, LightVars, 'normal','[w] Run/Sequence is already running ! (now at '+b+')'

end ; PRO Light_Event_Base_Run_Start_Sequence

;***************************************************************
;** Starts a Single Run (LightVars.Global.Current_Run)
pro Light_Event_Base_Run_Start_Run, LightVars

  n_run = LightVars.Global.Current_Run
  Light_Event_Base_Run_Start_Sequence, LightVars, first=n_run, last=n_run

end ; PRO Light_Event_Base_Run_Start_Sequence

;***************************************************************
; check all defined ROIs
; compute for each :
; 1-the signal/noise ratio normalized to pixel cell number
; 2-a gaussfit nterms=6 fit, getting sigmaa
; 3-abs(smoothed signal/signal)
; finish current counting if all criteria for all ROI are below specified accuracy
pro Light_SubDial_Base_Check_ROI, LightVars, show=show

  if LightVars.Private.OnGoing_Run_Nb ge 0 then Run_Nb = LightVars.Private.OnGoing_Run_Nb $
  else Run_Nb = LightVars.Global.Current_Run
  Accuracy = LightVars.Run.CountStatAccuracy(Run_Nb)/100
  
  ; will not perform accuracy analysis when Temperature is out limits
  ; LightVars.Private.LastValidNumor(0) = 0 normally (T is ok)
  ; LightVars.Private.LastValidNumor(0) = t_res.lasnum if Tout for Wait_Error
  ;  LightVars.Private.LastValidNumor(0) = -val if recovered T control
  if LightVars.Private.LastValidNumor(0) gt 0 then return 
  
  ; get all criteria for each region
  if size(LightVars.Private.ROIs, /type) eq 8 then begin  ; is a structure
    if n_elements(LightVars.Private.ROIs) gt 0 then begin
    
      DataImage = LightVars.Private.Data_Cumulated  ; use latest data set (updated in Collect)
  
      Criteria = fltarr(n_elements(LightVars.Private.ROIs))
      ToDisplay = ['Regions Of Interest (count statistics) on Cumulated Data', $
        'Date:              '+systime(0), $
        'Specified accuracy'+strcompress(string(Accuracy))+' for Run #'+strcompress(string(Run_Nb)), $
        'ROI_name Xmin Xmax Ymin Ymax   Noise/Signal  norm_ChiSq           dp/p' ]
      AccuracyNotAchieved = 0
      for index = 0,(n_elements(LightVars.Private.ROIs) - 1) do begin
        ThisROIstr = LightVars.Private.ROIs(index)
        ; now build the 4 vertex (rectangle corners), and adjust to shown image size (scaling)
        sData = size(DataImage, /dimensions)
        Xi =  ThisROIstr.xrange > 0 < sData(0)
        Yi =  ThisROIstr.yrange > 0 < sData(1)
        Data        = DataImage[ Xi(0):Xi(1), Yi(0):Yi(1)]
        ThisROItof  = total(Data, 2)+1
        S_over_N    = sqrt(n_elements(Data)/total(ThisROItof)) ; per pixel signal/noise (Poisson)

        ;ThisROItof  = ThisROItof/total(ThisROItof)                    ; normalised tof signal

        ; now fit a polynom and then a Gaussian+parabola: nt=6
        myexcept = !except
        !except = 0
        y = double(ThisROItof)
        errors = 1/sqrt(y)
        n = n_elements(y)
        x = double(lindgen(n))
        ; first try to fit with a 2nd order polynom
        poly_coefs = poly_fit(x, y, 2, chisq=poly_chisq, /double, $
          measure_errors=errors, sigma=poly_sigma, yfit=poly_yfit)
        n_param = 2
        poly_error = sqrt(total((y-poly_yfit)^2))/(n_elements(x)-n_param) ; normalised ChiSq per degree of freedom

        ; try gaussian+quad
        gauss_yfit = gaussfit(x,y,a, nterms=6)  ; guess parameters and compile GAUSS_FUNCT
        gauss_error= sqrt(total((y-gauss_yfit)^2))/(n_elements(x)-6)
        if gauss_error lt poly_error then begin
          ; Gauss+Poly is better than a single polynom. We estimate the sigma
          a = double(a)
          gauss_yfit = curvefit(x,y,errors,a,gauss_sigma, $
            function_name = "GAUSS_FUNCT", /double, iter=iter, chisq=chisq) ;call curvefit and estimate errors

          ; reject non-realistic parameter values
          if abs(a(0)) gt max(y)-min(y) or abs(a(0)) lt (max(y)-min(y))/100  then gauss_sigma(0) = 0 ; gaussian intensity
          if a(1) gt max(x) or a(1) lt min(x)             then gauss_sigma(1) = 0 ; gaussian center
          if abs(a(2)) gt max(x)-min(x) or abs(a(2)) lt 2 then gauss_sigma(2) = 0 ; gaussian width
          gauss_coefs = a

          ; use polynomial std dev if they were smaller
          tmp = where(abs(poly_sigma) lt abs(gauss_sigma(3:5)))
          if tmp(0) ge 0 then gauss_sigma(tmp+3) = poly_sigma(tmp)

          yfit    = gauss_yfit
          sigma   = gauss_sigma
          param   = gauss_coefs
          n_param = 6
        endif else begin
          ; 2nd order polynom is a good fit
          yfit    = poly_yfit
          sigma   = poly_sigma
          param   = poly_coefs
          n_param = 2
        endelse
        a = check_math()
        !except   = myexcept
        errors    = errors/total(errors)
        error     = sqrt(total(((y-yfit)/errors)^2))/(n_elements(x)-n_param)/total(y)

        ; now compute mean parameter relative error for sigma ne 0 
        tmp = where(sigma ne 0)
        if tmp(0) ne -1 then begin
          RelParamErr = abs(sigma/param)
          RelParamErr = RelParamErr(tmp) 
          RelParamErr = max(RelParamErr)
        endif else RelParamErr = 0

        name = ThisROIstr.name
        if strlen(name) gt 8 then name = name(0:7)

        ToDisplay = [ToDisplay, $
            string(name, format='(A8)') $
            +string(Xi(0), format='(I4)')+' '+string(Xi(1), format='(I4)')+' ' $
            +string(Yi(0), format='(I4)')+' '+string(Yi(1), format='(I4)')+' ' $
            +string(S_over_N)+' '+string(error)+' '+string(RelParamErr) ]

        if S_over_N gt Accuracy or error gt Accuracy $
          or RelParamErr gt Accuracy then AccuracyNotAchieved = 1

      endfor
      
      if AccuracyNotAchieved eq 0 then begin
        msg = 'Required accuracy for defined ROIs is now achieved on cumulated signal'
        ; reached required precision for all ROIs on signal -> command next count (if sequence is running)
        if LightVars.Private.AccuracyAchieved eq 0 or n_elements(show) ne 0 then begin
          Light_LogMessage, LightVars, 'normal', msg
          Light_LogMessage, LightVars, 'verbose', ToDisplay
          LightVars.Private.AccuracyAchieved = 1
        endif
        ToDisplay = [ ToDisplay, msg ]
      endif
      
      ; send statistics results to text window
      widget_control, LightVars.Handles.CountStatsText, set_value=ToDisplay, Bad_ID=Bad_ID

      if ((Bad_ID ne 0) or (LightVars.Handles.CountStatsText eq 0)) and n_elements(show) ne 0 then  begin
        xdisplayfile, 'countstats.txt', text=ToDisplay, Group=LightVars.Handles.Base, $
              title='Region of Interest analysis', /editable, $
              Height=15,Width=80,Done_Button='Close [ROI Stats]', WText=ID
        LightVars.Handles.CountStatsText = ID
      endif ; has 1 or more elements
    endif ; is structure
  endif else if n_elements(show) ne 0 then Light_LogMessage, LightVars, 'verbose', '[ ] No ROIs are defined. Please use menu Setup:Regions of Interest.'

end ; PRO Light_SubDial_Base_Check_ROI

;***************************************************************
; analyse last 10 temperature measures
; tells if temperature is within specified Run Options limits, or too high/low
; compute linear slope from Temp_History using linfit
; if Tout and AlarmTempTime eq 0 -> AlarmTempTime=now
; if Tin and AlarmTempTime ne 0 -> AlarmTempTime = 0, LastValidNumor=0 (temperature got back within limits)
; if Tout and now gt AlarmTempTime+Wait_Error (has been out for enough time) then
;   AlarmTempTime = 0 (remove alarm has it is handled here, a new alarm will be generated if required every Wait_T_error)
;   if slope is small then [set warning message]
;   if slope is high  then [set error message]
;   [stop, start 'wait T control counting' -> RunUValue='count', if LastValidNumor eq 0 -> = numor]
;
; when temperature change is requested, LightVars.Private.WaitTempTime ne 0 

pro Light_SubDial_Base_Check_Temperature, LightVars
  
  ; get current run or displayed one (active)
  if LightVars.Private.OnGoing_Run_Nb ge 0 then Run_Nb = LightVars.Private.OnGoing_Run_Nb $
  else Run_Nb = LightVars.Global.Current_Run
  
  ; determine temperature high/low limits in absolute [K] units
  dTLow  = abs(LightVars.Run.dT_Low(Run_Nb))
  dTHigh = abs(LightVars.Run.dT_High(Run_Nb))
  
  if LightVars.Run.Flag_dT_AbsRel(Run_Nb) ne 0 then begin ; % of TSet
    dTLow = dTlow*LightVars.Mad.t_res.tempea(0)/100
    dTHigh= dTHigh*LightVars.Mad.t_res.tempea(0)/100
  endif
  
  ; get set-point and regulation temperature
  TReg = LightVars.Mad.t_res.tempea(1)
  TSet = LightVars.Mad.t_res.tempea(0)
  
  ; update Temp_History
  History_length = 10
  Temp_History = Lightvars.Private.Temp_History
  if n_elements(Temp_History) eq 1 then Temp_History = [ TReg, TReg ] $ ; starting
  else Temp_History = [Temp_History, TReg]
  max_index = n_elements(Temp_History)-1
  min_index = max([0, max_index-History_length+1])
  Temp_History = Temp_History[min_index:max_index]
  Tools_StructSetValue, struct=LightVars, tag='Private.Temp_History', val=Temp_History
  
  if max_index le 2 then return
  
  ; compute mean-TSet value, stddev, as well as slope
  LightVars.Private.Temp_Stats(0) = mean(Temp_History) - TSet ; deviation from set Point
  LightVars.Private.Temp_Stats(1) = stddev(Temp_History)      ; fluctuations
  time_axis = lindgen(n_elements(Temp_History))*LightVars.Frequency*LightVars.Private.Major_Update_Nb
  lin_coefs = linfit(time_axis, Temp_History)
  LightVars.Private.Temp_Stats(2) = lin_coefs(1)*60              ; slope (K/min)
  
  ; Warning: Wait_T must be le Wait_Error 
  ; (else we generate temporary countings each time a T change is requested)
  base_time = max([ LightVars.Run.Wait_Error(Run_Nb), LightVars.Run.Wait_T(Run_Nb), 0.1])
  base_slope= abs(dTHigh+dTLow)/base_time/2         ; [K/min]
  
  dTLow  = TSet - dTLow
  dTHigh = TSet + dTHigh
  
  ; if T out and no AlarmTempTime -> AlarmTempTime=now
  ; this occurs when T deviates or T changes (wait time)
  if (dTHigh lt TReg or TReg lt dTLow) $
  and LightVars.Private.AlarmTempTime le 0 then begin
    LightVars.Private.AlarmTempTime = systime(1)  ; time when T gets out
    msg = '[ ] Regulation Temperature '+strcompress(string(TReg))+' [K] exits limits ['+strcompress(string(dTLow))+','+strcompress(string(dTHigh))+'] (defined by Sequence item'+strcompress(string(Run_Nb))+'). Slope '+strcompress(string(LightVars.Private.Temp_Stats(2)))+' [K/min]'
    Light_LogMessage, LightVars, 'verbose', msg
  endif
  
  ; if T in and AlarmTempTime ne 0 -> AlarmTempTime = 0, LastValidNumor=0 (temperature got back within limits)
  ; this ocurs when T change has succeeded (usually after Wait_T), or when T control is recovered within base_slope [K/s]
  if (dTLow lt TReg and TReg lt dTHigh) $
    and LightVars.Private.AlarmTempTime ne 0 $
    and abs(LightVars.Private.Temp_Stats(2)) lt base_slope then begin
    LightVars.Private.AlarmTempTime = 0
    msg = '[ ] Regulation Temperature '+strcompress(string(TReg))+' [K] gets back within limits ['+strcompress(string(dTLow))+','+strcompress(string(dTHigh))+'] (defined by Sequence item'+strcompress(string(Run_Nb))+')'
    Light_LogMessage, LightVars, 'verbose', msg
    if LightVars.Private.LastValidNumor(0) ge 0 then begin
      msg = '[ ] Next numor should be added to Last Valid numor '+strcompress(string(long(LightVars.Private.LastValidNumor(0))))+' that was interrupted when Temperature went out.'
      Light_LogMessage, LightVars, 'normal', msg
    endif
    if LightVars.Private.TempoTempTime ge 0 then begin
      LostTime = double(systime(1) - LightVars.Private.TempoTempTime)/60.0
      msg = '[ ] Lost '+strcompress(string(LostTime))+' [min] with unstable temperature'
      Light_LogMessage, LightVars, 'verbose', msg
      LightVars.Private.TempoTempTime = -LightVars.Private.TempoTempTime
    endif
    LightVars.Private.LastValidNumor(0)   = -abs(LightVars.Private.LastValidNumor(0))
    LightVars.Private.TemperatureUnstable = -1
    LightVars.Private.AlarmTempTime       = 0
    LightVars.Private.WaitTempTime        = 0 ; ends stabilisation if slope is ok
  endif
  
  ; if Tout and now gt AlarmTempTime+Wait_Error (has been out for enough time)
  ; this occurs when T is unstable, or T change can not be achieved
  if LightVars.Private.AlarmTempTime ne 0 $
      and (dTHigh lt TReg or TReg lt dTLow) $
      and systime(1) ge LightVars.Private.AlarmTempTime+base_time*60 then begin
    if LightVars.Private.LastValidNumor(0) le 0 then begin
      ; IN6: store valid numor, repetition number [numor, t_res.NREPET, t_res.NPREP, t_res.xc, t_res.jc]
      ; last counting with good T regulation. This unactivate cumulation of countings, until T recovers control
      LightVars.Private.LastValidNumor(0) = LightVars.Mad.t_res.lasnum
      LightVars.Private.LastValidNumor(1) = LightVars.Mad.t_res.NREPET
      LightVars.Private.LastValidNumor(2) = LightVars.Mad.t_res.NPREP
      LightVars.Private.LastValidNumor(3) = LightVars.Mad.t_res.xc
      LightVars.Private.LastValidNumor(4) = LightVars.Mad.t_res.jc
      msg = '[ ] Last Valid numor in the original sequence is '+strcompress(string(long(LightVars.Private.LastValidNumor(0))))
      Light_LogMessage, LightVars, 'normal', msg
    endif
    ;   if slope is small then [set warning message]
    ;   if slope is high  then [set error message]
    if abs(Lightvars.Private.Temp_Stats(2)) lt base_slope then begin
      Light_Base_Alert, LightVars, warning='Temperature unstable'
    endif else begin
      Light_Base_Alert, LightVars, error='Temperature error'
    endelse
    msg = '[ ] Temperature '+strcompress(string(TReg))+' [K] has been outside limits ['+strcompress(string(dTLow))+','+strcompress(string(dTHigh))+'] since '+systime(0, LightVars.Private.AlarmTempTime)+' Slope '+strcompress(string(LightVars.Private.Temp_Stats(2)))+' [K/min]' 
    Light_LogMessage, LightVars, 'normal', msg
    LightVars.Private.TemperatureUnstable = 1
    ; (remove alarm as it is handled here, a new alarm will be generated if required every Wait_T_error)
    LightVars.Private.AlarmTempTime = 0
    if LightVars.Private.TempoTempTime le 0 then LightVars.Private.TempoTempTime = systime(1)
  endif

end ; PRO Light_SubDial_Base_Check_Temperature


;***************************************************************
;*********************** End of Light internal routines ********
;***************************************************************

;*********************
PRO dial_light_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_light
;** This macro procedure is called by George every D.frequency seconds

    if D.init eq 0 then begin   ; first start
        ; test if Light is already active... This is done in 'dial_light'
        D.init = 1
    endif
    if D.init eq 1 then begin   ; normal start or restart
        Light_Base_Init, D  ; set user and pathes, and read config files
        D.init=2
    endif
    Light_Base_Update, D  ; create/update panel


    ; V=DialNewValue()    ; get value to display on Dial display
    ; DialModValue, V ,tag='VALUE'    ;(or D.value=V if dimensions are correct)
end



;*********************
FUNCTION dial_light
;*********************
;**
;** The dial initialisation (and stucture definition)

  if xregistered('Light_Base_Interface') ne 0 then begin
    LightVars = Light_Get_LightVars()
    Light_LogMessage, LightVars, 'verbose','[ ] Light is already running !'
    widget_control, LightVars.Handles.Base, Bad_ID=Bad_ID, show=1, iconify=0
    return, LightVars
  endif else begin

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;then V=DialNewValue() stands for V=DialNewValue(TYPE='monitor')
    ONOFF=1          ;state of the Dial 1=running
    FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE='Starting Light ' ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=100           ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file light.his
    Preset=0       ;if >0 then Dial is stopped after running Preset seconds
    WUPDATE=0        ;=1 to automaticaly update corresponding workspace, =-1 silent!
                     ;=2 to automaticaly update and plot workspace to the main window
                     ;   0,1,2 are set by pressing the left,middle,right mouse button on the dial snapshot
    INIT=0

   ;User Variables (Must be present in return statement to be available)
   ;-------------
    GLOBAL ={LIGHT_GLOBAL,$
            ConfigDir:'/home/cs/lambda/CALIBRATION/in6/',$
            Verbosity:'debug',$         ; information display verbosity level(silent, normal, verbose, debug)
            TerminalEcho:1L, $          ; if non 0 will output messages to IDL prompt window
            CurrentDir:'',$             ; starting directory
            IniFile:'Light.ini',$       ; contains Light init info
            ConfigFile:'Config.ini',$   ; contains info about Monochromators and Choppers
            LogFile:'Light.log',$       ; name of Light Log file
            RunFile:'Run.run',$         ; contains runs info
            Simulation:3L, $            ; 1:simulation mode (no action on instrument), 0:instrument control, 2: Mad active but in simulation mode, 3:use real MAD data
            Append_Runs:0L, $           ; 1: add new loaded runs after existing run sequence. 0: replace run sequence
            Current_Run:0L $            ; current run (displayed/running)
            }

    PRIVATE = {LIGHT_PRIVATE, $         ; these are only internal variables, not to be saved in .ini files
            LogText:'', $
            MadLogText:'Starting MAD Log recording at '+systime(0), $
            UserName:'unknown ',$
            LocalContact:'ILLstaff',$
            ExpTitle:'00-00-000 <sample><config><params> comments---', $
            Numor:   '99999                                         ', $
            SubTitle:'00-00-000 <sample><config><params> comments---', $
            MonitorSum:0., DetectorSum:0., TSample:0., TRegulation:0., $
            IsSuperUser:0L,$            ; set to true(1) for Restricted operations
            Version:'2.0.3 (Aug 08th 2002)',$
            Author:'E. Farhi, A. Schober, D. Richard. (c)ILL', $
            Base_Size:[0L, 0L], $
            Major_Update_Nb:10L, $
            Update_Nb:0L, $             ; this value is incremented, and every 10 steps, a Major Update is done
            OnGoing_Run_Nb:-1, $        ; # of running 'Run', -1 if inactive
            First_Run_Nb:0L, $          ; first run # in sequence
            Last_Run_Nb:-1L, $          ; last run # in sequence, -1 means go to end of sequence
            LastErrorMsg:'no alert', $
            WaitTempTime:0L, $          ; time of beginning of Wait temperature stabilisation
            AlarmTempTime:0L, $         ; time when T first gets out from limits
            TempoTempTime:0L, $         ; first time a temporary counting is requested
            AccuracyAchieved:0L, $      ; activated when statistics is ok for all ROIs on cumulated data, reset 
            ROIs  : 0L, $ ; list of last actualised {xrange, yrange} structures retrieved from XROI
            Data_Cumulated:0, $         ; cumulated data in same counting (repetition)
            Temp_History:0, $           ; last 10 regulation Temperature measures
            Temp_Stats:[0.,0.,0.], $; [mean-TSet, stddev, slope of Temp_History
            LastValidNumor:[0., 0., 0., 0., 0.], $ ; non 0 when T got out of limits, [numor, t_res.nrepet, t_res.nprep, t_res.xc, t_res.jc]
            TemperatureUnstable:0L, $   ; 0 means T is ok, 1 means out of limits since Wait_Error
            ErrorMsgToggle:1L}

    RUN = {LIGHT_RUN, Titles:['Run description'],$    ; all are arrays...
            Temperatures:[300.0],$
            Preset:[30.0],$
            Repetition:[1],$
            Lambda:[5.12], $
            Wait_T:[15.0],$            ; wait time between T changes
            Wait_Error:[15.0],$        ; wait time in case of T/scan error
            dT_Low:[1.0],$            ; lower check value for T stability
            dT_High:[1.0],$           ; higher check value for T stability
            Option_Command:[''], $  ; optional command to execute in Run. Can begin with: 'idl:','<generic>:','system:'. Default is 'idl:'
            CountStatAccuracy:[5.0], $
            Flag_T:[1L],$           ; flags for CheckT,RunDiag,CountStat,SavePerm,TShiftType(T/%)...
            Flag_Diag:[0L],$        ; use Diagnosis
            Flag_Count:[0L],$       ; Count on Statistics
            Flag_Save:[1L],$        ; save permanently
            Flag_MonTi:[1L],$       ; false/true for acquisition on Monitor/Time respect.
            Flag_dT_AbsRel:[0L] }   ; false/true for check DeltaT in Absolute/Relative}

    MAD     ={LIGHT_MAD, t_nother:0, t_res:0, t_para:0, t_status:0, t_counts:0, t_chopper:0, status:'<Starting>', data:0} ; will be re-dimensioned with Tools_StructSetValue

    HANDLES ={LIGHT_HANDLES, Base:0L,$
            Base_Mad_Status:0L, $ ; Base of MAD Status
            Mad_Status:0L, $ ; Text within Base of MAD Status
            Base_Alert_Status:0L, $   ; widget ID of Alert states (on top)
            MonitorSum:0L, DetectorSum:0L, TSample:0L, TRegulation:0L, $  ; widget IDs of Mon, Det, TSam, TReg
            UserName:0L, $      ; widget IDs of UserName, LocalContact, ExpN, ExpTitle
            LocalContact:0L, $
            ExpTitle:0L, $
            Current_Run:0L,$
            Titles:0L,$         ; widget IDs of Run Title, Temp, Preset, Repetition, Remaining time
            Temperatures:0L,$
            Preset:0L,$
            Repetition:0L,$
            Lambda:0L, $
            Wait_T:0L,$
            Wait_Error:0L,$
            dT_Low:0L,$
            dT_High:0L,$
            Flag_T:0L,$         ; widget IDs of Check temp, Run Diags, CountOnStat, SaverPerm
            Flag_Diag:0L,$
            Flag_Count:0L,$
            Flag_Save:0L,$
            Flag_MonTi:0L,$
            Flag_dT_AbsRel:0L,$
            CountStatAccuracy:0L, $
            RunFile:0L, $
            Base_Help:0L, $
            Base_Mad_Log:0L, $
            Base_Light_Log:0L, $
            Run_Options:0L, $
            Base_SuperUser:0L, $
            Option_Command:0L, $
            Base_Run_Analyse:0L, $
            Simulation:0L, $
            Numor:0L, $
            SubTitle:0L, $
            RunStartButton:[0L, 0L, 0L], $
            RunStatus:0L, $
            CountStatsText:0L, $
            LoadSaveCfg:[0L, 0L] }

    DISPLAYS = {LIGHT_DISPLAYS, $
            Variables:[''], $
            Type:[''], $
            Options:['']}

    ; should be loaded from Config.cfg (protected parameters) but here is a default config (just in case the file can not be found)
    INSTRUMENT = { Name:"", Type:"", CustomPro:'Light_Custom_IN6_Update, LightVars' }; custom Data block where are saved specific instrument data

    LightVars = {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY, OnOff:OnOff, init:INIT,plot:PLOT, global:GLOBAL,mad:MAD,handles:HANDLES, run:RUN, instrument:INSTRUMENT, displays:DISPLAYS, private:PRIVATE}

    return, LightVars
  endelse
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_dialexample_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V ,[tag='VALUE']           ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [Preset=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process

;***************************************************************
;** Project: Light
;** File:    Dialog_Fields.pro
;** Version: 0.1
;** Date:    Jan, 23rd, 2002
;** Author:  E. Farhi
;** Object:  Display a Widget_Table in modal or non modal mode and many options
;
;** Require: <none>
;
;** procedure copied from /usr/local/rsi/idl/lib/utilities/xvaredit.pro
;** Moved butons below table, centered. Display Structures as columns
;** Same usage, but with additional keywords.
;** Added Jan 16th, 2002
;**   Title=<string> set the title of the dialog
;**   Name=<string> add the string in front of Variable name, even for structures
;**       this text is displayed on top of the table
;**   COLUMN_WIDTHS=<value> set the width value of cells (e.g. about 100)
;**   FIELDNAMES=<string array> set the name of fields in structures
;**   /DISPLAY non-sensitive Table (only show, no modify)
;** Added Jan 22rd, 2002
;**   ID=ID replace the previous ID widget base
;**   SWAP transpose table
;**
;** Example: Dialog_Fields, Preferences, Group=Handles.Base,
;**  COLUMN_WIDTHS=500, Name='PEnter Preferences', Title='Preferences',
;**  y_scroll_size=5, FieldNames = [ 'Verbosity', 'IniFile', 'ConfigDir',
;** 'ConfigFile','Simulation']

FUNCTION Dialog_Fields__n_elements, arg
;
;function Dialog_Fields__N_ELEMENTS: return the number of elements in arg.
;This function is similar to N_ELEMENTS, but counts recursively,
;where applicable.
;
ON_ERROR, 2 ;return to caller on error.

CASE 1 OF
    SIZE(arg, /TYPE) EQ 8: BEGIN    ;structure or array of structures.
        result = 0L

        FOR i=0L,N_ELEMENTS(arg)-1 DO BEGIN
            FOR j=0L,N_TAGS(arg)-1 DO BEGIN
                result = result + Dialog_Fields__n_elements((arg[i]).(j))
            END
        END

        RETURN, result
    END

    ELSE: $
        RETURN, N_ELEMENTS(arg)
ENDCASE

END
;------------------------------------------------------------------------------
;   procedure Dialog_Fields_event
;------------------------------------------------------------------------------
; This procedure processes the events being sent by the XManager.
;------------------------------------------------------------------------------
PRO Dialog_Fields_event, event

COMPILE_OPT hidden
WIDGET_CONTROL, event.id, GET_UVALUE = whichevent
IF N_ELEMENTS(whichevent) EQ 0 THEN RETURN
IF whichevent NE "THEBUTTON" THEN RETURN

CASE event.value OF

    0: BEGIN                                            ;the user chose the
        WIDGET_CONTROL, event.top, /DESTROY     ;return the initial
      END                       ;variable

    1: BEGIN                        ;the user chose accept
        WIDGET_CONTROL, event.top, GET_UVALUE = pEval, /HOURGLASS
        IF (*pEval).usetable THEN BEGIN
            edit_cell = WIDGET_INFO((*pEval).table, /TABLE_EDIT_CELL)
            if (edit_cell[0] EQ -1 AND edit_cell[1] EQ -1) or ((*pEval).display) then begin
                (*pEval).modified = 1
                WIDGET_CONTROL, (*pEval).table, GET_VALUE = var
                if (SIZE((*pEval).var))[0] EQ 0 then begin
                  (*pEval).var = var[0]
                endif else begin
                  (*pEval).var = TEMPORARY(var)
                endelse
            endif else begin
                tmp = DIALOG_MESSAGE(['Please commit or cancel the edit',$
                                      'before pressing Accept.'])
                RETURN
            endelse
        ENDIF ELSE BEGIN
            i = 0LL
            ;so go ahead and modify the variable
            WIDGET_CONTROL, (*pEval).table, GET_VALUE = var
            WHILE(i LT N_ELEMENTS(var))DO BEGIN
                CASE (*pEval).entries[i].type OF
                    6: assign = '=COMPLEX'
                    9: assign = '=DCOMPLEX'
                    ELSE: assign = '='
                ENDCASE
                IF ((*pEval).entries[i].type EQ 10 AND var[i] NE '') $
                OR ((*pEval).entries[i].type EQ 11 AND var[i] NE '') $
                OR ((*pEval).entries[i].type NE 10 AND $
                    (*pEval).entries[i].type NE 11) $
                THEN BEGIN
                    str = "(*pEval)." + $
                        (*pEval).entries[i].name + $
                        assign + $
                        ((*pEval).entries[i].type EQ 7 ? "var[i]" : var[i])
                    IF NOT EXECUTE(str, 1) THEN BEGIN
                        void = DIALOG_MESSAGE( $
                            [ $
                                'Dialog_Fields: error converting "' $
                                    + var[i] $
                                    + '" to ' $
                                    + (*pEval).entries[i].name, $
                                '', $
                                !error_state.msg, $
                                !error_state.sys_msg $
                                ], $
                            /ERROR $
                            )
                        conversion_err = 1
                    ENDIF
                ENDIF
                i = i + 1
            ENDWHILE
        ENDELSE
        IF NOT KEYWORD_SET(conversion_err) THEN BEGIN
            (*pEval).modified = 1
            WIDGET_CONTROL, event.top, /DESTROY
        ENDIF
    END
    ELSE:

ENDCASE

END ;============= end of Dialog_Fields event handling routine task =============


;------------------------------------------------------------------------------
;   procedure AddEditEntry
;------------------------------------------------------------------------------
; This procedure adds an entry to the list that contains the variables names
; and the widget id for the edit field corresponding to the variable name.
;------------------------------------------------------------------------------

PRO Dialog_Fields__AddEditEntry, $
    entries, $      ; IN/OUT
    n_ents, $       ; IN/OUT
    thename, $      ; IN
    thetype, $      ; IN
    value, $        ; IN
    n_elems         ; IN

COMPILE_OPT hidden

IF(NOT(KEYWORD_SET(entries))) THEN BEGIN
    entries = REPLICATE({entstr, $
        name: thename, $
        value: value, $
        type: thetype $
        }, n_elems)
    n_ents = 1L
ENDIF ELSE BEGIN
    IF (N_ELEMENTS(entries) LE n_ents) THEN BEGIN
        entries = [temporary(entries), REPLICATE({entstr}, n_elems > 100)]
    END
    entries[n_ents].name = thename
    entries[n_ents].value = value
    entries[n_ents].type = thetype
    n_ents = n_ents + 1
ENDELSE
END ;============== end of Dialog_Fields event handling routine task ===============


;------------------------------------------------------------------------------
;   procedure Dialog_FieldsField
;------------------------------------------------------------------------------
;  This routine is used to create the widget or widgets needed for a given
;  variable type.  It could call itself recursively if the variable was itself
;  a structure comprised of other IDL variables.
;------------------------------------------------------------------------------

FUNCTION Dialog_FieldsField, $
    base, $     ; IN
    val, $      ; IN
    usetable, $ ; OUT
    entries, $  ; IN/OUT
    nentries, $ ; IN/OUT
    TOTAL_N_ELEMENTS = total_n_elements, $  ; IN/OUT (opt)
    NAME = NAME, $
    RECNAME = RECNAME, $
    X_SCROLL_SIZE = X_SCROLL_SIZE, $
    Y_SCROLL_SIZE = Y_SCROLL_SIZE, $
    COLUMN_WIDTHS = COLUMN_WIDTHS, $
    FIELDNAMES = FIELDNAMES, $
    SWAP = SWAP

COMPILE_OPT hidden
FORWARD_FUNCTION Dialog_FieldsField

typarr = [ $
    "Undefined", $                  ; 0
    "Byte", $                       ; 1
    "Integer", $                    ; 2
    "Longword Integer", $           ; 3
    "Floating Point", $             ; 4
    "Double Precision Floating", $  ; 5
    "Complex Floating", $           ; 6
    "String", $                     ; 7
    "Structure", $                  ; 8
    "Double Precision Complex", $   ; 9
    "Pointer", $                    ; 10
    "Object Reference", $           ; 11
    "Unsigned Integer", $           ; 12
    "Unsigned Longword Integer", $  ; 13
    '64-bit Integer', $             ; 14
    "Unsigned 64-bit Integer" $     ; 15
    ]

varsize = size(val)
vardims = N_ELEMENTS(varsize) - 2
type = varsize[vardims]
numelements = varsize[vardims + 1]

usetable = 0
IF (NOT(KEYWORD_SET(RECNAME)) $
AND (varsize[0] EQ 1 OR varsize[0] EQ 2)) THEN BEGIN
    IF(type EQ 8) THEN BEGIN
        IF varsize[0] EQ 1 THEN BEGIN
            IF !VERSION.OS_FAMILY EQ 'Windows' AND N_TAGS(val) GT 200 THEN $
                Goto, Cplx_Struct
            FOR i = 0, N_TAGS(val) - 1 DO BEGIN
                strsize = size(val.(i))
                strdims = N_ELEMENTS(strsize) - 2
                IF strsize[strdims] EQ 8 $  ; Structure
                OR strsize[strdims] EQ 10 $ ; Pointer
                OR strsize[strdims] EQ 11 $ ; Object Reference
                OR strsize[strdims + 1] NE varsize[vardims + 1] THEN $
                    Goto, Cplx_Struct
            ENDFOR
            usetable = 1
        ENDIF
    ENDIF ELSE BEGIN
        IF !VERSION.OS_FAMILY EQ 'Windows' AND varsize[1] GT 200 THEN $
            Goto, Cplx_Struct
        usetable = 1
    ENDELSE
ENDIF
Cplx_Struct:
recurse = KEYWORD_SET(RECNAME)

IF (NOT recurse) THEN $
  abase = WIDGET_BASE(base, /FRAME, /COLUMN, XPAD = 8, YPAD = 8)

IF(numelements GT 1) THEN BEGIN             ;if the variable is an
  suffix = " Array("                        ;array, then say so and
  FOR j = 1, varsize[0] DO BEGIN            ;show the array
    suffix = suffix + strtrim(varsize[j], 2)        ;dimensions.
    IF j NE varsize[0] THEN suffix = suffix + ", "
  ENDFOR
  suffix = suffix + ")"
ENDIF ELSE suffix = ""

LOCNAME = ''
IF(type EQ 8) THEN LOCNAME = TAG_NAMES(val, /STRUCTURE) ;if the variable is a
                            ;structure, use its
                            ;name

;build up the name of variable with the type in parentheses
IF(NOT recurse) THEN BEGIN
    IF(KEYWORD_SET(NAME)) THEN begin
      LOCNAME = NAME
    endif ELSE begin
        LOCNAME = LOCNAME + " " + typarr[type] + suffix
    endelse

    lbl = WIDGET_LABEL(abase, value = LOCNAME)
ENDIF

IF(NOT(KEYWORD_SET(RECNAME))) THEN BEGIN
    RECNAME = 'var'         ;establish the name
                            ;if not being called
                            ;recursively
END

IF(N_ELEMENTS(X_SCROLL_SIZE) EQ 0) THEN $
  XSCROLL_SIZE = 4 ELSE XSCROLL_SIZE = X_SCROLL_SIZE
IF(N_ELEMENTS(Y_SCROLL_SIZE) EQ 0) THEN $
  YSCROLL_SIZE = 4 ELSE YSCROLL_SIZE = Y_SCROLL_SIZE

if not(keyword_set(COLUMN_WIDTHS)) then COLUMN_WIDTHS = 100

IF (usetable) THEN BEGIN
    IF(type EQ 8) THEN BEGIN
        if not(keyword_set(FIELDNAMES))then $
            row_labels = TAG_NAMES(val) $
        else begin
            if n_elements(TAG_NAMES(val)) ne n_elements(FIELDNAMES) then $
                row_labels = TAG_NAMES(val) $
            else $
                row_labels = FIELDNAMES
        endelse
        column_labels = [TAG_NAMES(val(0), /structure)]
        COLUMN_MAJOR = 1
        ROW_MAJOR    = 0
        if keyword_set(SWAP) then begin
            tmp1 = column_labels
            column_labels = row_labels
            row_labels = tmp1
            COLUMN_MAJOR = 0
            ROW_MAJOR    = 1
        endif
        RETURN, WIDGET_TABLE( $
            abase, $
            value         = val, $
            ROW_LABELS    = row_labels, $
            COLUMN_LABELS = column_labels, $
            COLUMN_WIDTHS = COLUMN_WIDTHS, $
            /RESIZEABLE_COLUMNS, $
            /EDIT, $
            COLUMN_MAJOR  = COLUMN_MAJOR, $
            ROW_MAJOR     = ROW_MAJOR, $
            X_SCROLL_SIZE = XSCROLL_SIZE, $
            Y_SCROLL_SIZE = YSCROLL_SIZE $
            )
    ENDIF ELSE BEGIN
        RETURN, WIDGET_TABLE( $
            abase, $
            value = val, $
            /RESIZEABLE_COLUMNS, $
            /EDIT, $
            ALIGNMENT    = 1, $
            X_SCROLL_SIZE = XSCROLL_SIZE, $
            Y_SCROLL_SIZE = YSCROLL_SIZE $
            )
    ENDELSE
ENDIF

IF(varsize[0] GT 1) THEN BEGIN
  moduli = LONARR(varsize[0]-1) + 1
  FOR i = varsize[0], 2,-1 DO BEGIN
    FOR j = 1,i-1 DO $
      moduli[i - 2] = moduli[i - 2] * varsize[j]
  ENDFOR
ENDIF

IF N_ELEMENTS(total_n_elements) EQ 0 THEN BEGIN
    total_n_elements = Dialog_Fields__n_elements(val)
END

FOR element = 0L, numelements - 1 DO BEGIN       ;for each array element

  IF(numelements NE 1) THEN BEGIN           ;use array subscripting
    indexname = "("
    indexname = indexname + $
        strtrim(element mod varsize[1],2)
    IF(varsize[0] GT 1) THEN BEGIN
      indexarr = lonarr(varsize[0] - 1)
      flatindex = element
      FOR i = varsize[0] - 2, 0, -1 DO BEGIN
    indexarr[i] = flatindex / moduli[i]
    flatindex = flatindex mod moduli[i]
      ENDFOR
      FOR i = 0, varsize[0] - 2 DO $
    indexname = indexname + ", " + $
        strtrim(indexarr[i], 2)
    ENDIF
    indexname = indexname + ")"
    thename = RECNAME + indexname
  ENDIF ELSE BEGIN
    thename = RECNAME
  ENDELSE

  ;depending on the type, build a string variable with proper formatting
  CASE type OF
    0: thevalue = "Undefined Variable"          ;Undefined

    1: thevalue = string(val[element], $        ;Byte
        FORMAT = '(I3)')

    7: thevalue = val[element]              ;String

    8: BEGIN                        ;Structure
        tags = TAG_NAMES(val[element])
        FOR i = 0, N_ELEMENTS(tags) - 1 DO BEGIN
            error = EXECUTE("fieldvalue = val[element]." + tags[i])
            fldsize = size(fieldvalue)
            flddims = N_ELEMENTS(fldsize) - 2
            id = Dialog_FieldsField( $
                abase, $
                fieldvalue, $
                usetable, $
                entries, $
                nentries, $
                TOTAL_N_ELEMENTS = total_n_elements, $
                NAME = tags[i], $
                RECNAME = thename + "." + tags[i], $
                X_SCROLL_SIZE = XSCROLL_SIZE, $
                Y_SCROLL_SIZE = YSCROLL_SIZE, $
                COLUMN_WIDTHS = COLUMN_WIDTHS $
                )
        ENDFOR
    END
    10: thevalue = ''
    11: thevalue = ''
    ELSE: thevalue = strtrim(val[element], 2)
  ENDCASE

  IF(type NE 8) THEN BEGIN
    Dialog_Fields__AddEditEntry, $
        entries, $
        nentries, $
        thename, $
        type, $
        thevalue, $
        total_n_elements
  END

ENDFOR

table = 0
IF (NOT recurse) THEN BEGIN
    IF (N_ELEMENTS(entries.value) GT 1) THEN BEGIN
        table = WIDGET_TABLE( $
            abase, $
            VALUE = TRANSPOSE((entries.value)[0:nentries-1]), $
            ROW_LABELS = TRANSPOSE((entries.name)[0:nentries-1]), $
            COLUMN_LABELS = '', $
            COLUMN_WIDTHS = COLUMN_WIDTHS, $
            /RESIZEABLE_COLUMNS, $
            /EDIT, $
            Y_SCROLL_SIZE = YSCROLL_SIZE $
            )
    ENDIF ELSE BEGIN
        table = WIDGET_TABLE( $
            abase, $
            VALUE = [entries.value], $
            ROW_LABELS = [entries.name], $
            COLUMN_LABELS = '', $
            COLUMN_WIDTHS = COLUMN_WIDTHS, $
            /RESIZEABLE_COLUMNS, $
            /EDIT, $
            Y_SCROLL_SIZE = YSCROLL_SIZE $
            )
    ENDELSE
ENDIF

return, table
END ;============= end of Dialog_Fields event handling routine task =============


;------------------------------------------------------------------------------
;   procedure Dialog_Fields
;------------------------------------------------------------------------------
; this is the actual routine that is called.  It builds up the variable editing
; fields by calling other support routines and then registers the widget
; heiarchy with the XManager.  Notice that the widget is registered as a MODAL
; widget so it will desensitize all other current widgets until it is done.
;------------------------------------------------------------------------------
PRO Dialog_Fields, var, GROUP = GROUP, NAME = NAME, $
              X_SCROLL_SIZE = X_SCROLL_SIZE, Y_SCROLL_SIZE = Y_SCROLL_SIZE, $
              TITLE = TITLE, COLUMN_WIDTHS = COLUMN_WIDTHS, $
              FIELDNAMES = FIELDNAMES, SWAP=SWAP, DISPLAY=DISPLAY, $
              ID=ID

on_error, 2 ; Return to caller on error.

if(n_params() ne 1) THEN $
  MESSAGE, "Must have one parameter"

if n_elements(var) eq 0 then $
  MESSAGE, 'Argument is undefined.'

if not keyword_set(display) then display=0

if n_elements(ID) ne 0 then begin
    ; get geometry, iconified status
    widget_control, ID, Bad_Id=Bad_Id
    if Bad_Id eq 0 and ID ne 0 then begin
        Geometry = widget_info(ID, /geometry)
        Active   = widget_info(ID, /active)
        widget_control, ID, /destroy
    endif
endif

; Create parent of modal base if needed
if (N_ELEMENTS(GROUP) NE 1) then begin
  GROUP_ID = WIDGET_BASE(MAP=0)
endif else begin
  GROUP_ID = GROUP
endelse

if (not(keyword_set(TITLE))) then TITLE="Dialog_Fields"

if xregistered("Dialog_Fields") ne 0 and n_elements(ID) eq 0 then begin
  print, "Dialog_Fields: is already active. Please close the other Dialog (Table) first"
  return
endif

Dialog_Fieldsbase = WIDGET_BASE(TITLE = TITLE, $    ;create the main base
        /COLUMN, GROUP_LEADER=GROUP_ID)

WIDGET_CONTROL, /HOURGLASS
entries = 0
nentries = 0
table = Dialog_FieldsField(Dialog_Fieldsbase, var, usetable, entries, nentries, $
                      NAME = NAME, X_SCROLL_SIZE = X_SCROLL_SIZE, $
                      Y_SCROLL_SIZE = Y_SCROLL_SIZE, $
                      COLUMN_WIDTHS = COLUMN_WIDTHS, $
                      FIELDNAMES = FIELDNAMES, SWAP=SWAP)



Dialog_FieldsStat = {var:var, $
                entries:entries, $
                modified:0, $
                table: table, $
                usetable: usetable, $
                display:display}
pDialog_FieldsStat = PTR_NEW(Dialog_FieldsStat)
WIDGET_CONTROL, Dialog_Fieldsbase, SET_UVALUE=pDialog_FieldsStat

if display then WIDGET_CONTROL, table, sensitive=0, alignment=1

tmp1 = widget_base(Dialog_Fieldsbase, /row)
tmp1 = widget_base(Dialog_Fieldsbase, /align_center)

if not display then $
    buttons = ['Cancel', 'Accept'] $
else $
    buttons = ['OK']

menu = Cw_Bgroup( $
    tmp1, $
    buttons, $
    /ROW, $
    IDS=IDS, $
    UVALUE="THEBUTTON" $
    )

if not arg_present(var) and n_elements(ids) gt 1 then begin
    widget_control, ids[1], sensitive=0
end

if n_elements(ID) ne 0 and n_elements(Geometry) ne 0 then begin
    WIDGET_CONTROL, Dialog_Fieldsbase, xoffset=Geometry.xoffset-2*Geometry.xpad, yoffset=Geometry.yoffset-9*Geometry.ypad
end

WIDGET_CONTROL, Dialog_Fieldsbase, /REALIZE

if n_elements(ID) ne 0 then begin
    ID = Dialog_Fieldsbase
    XManager, "Dialog_Fields"+title, Dialog_Fieldsbase    , /just_reg, /no_block, event_handler='Dialog_Fields_event'
endif else begin
    ID = Dialog_Fieldsbase
    XManager, "Dialog_Fields", Dialog_Fieldsbase , event_handler='Dialog_Fields_event'
    ; Get the return value
    IF ((*pDialog_FieldsStat).modified) THEN var = (*pDialog_FieldsStat).var
endelse
PTR_FREE, pDialog_FieldsStat

; Destroy parent of modal base
if (N_ELEMENTS(GROUP) NE 1) then begin
  WIDGET_CONTROL, GROUP_ID, /DESTROY
endif

END ;================== end of Dialog_Fields main routine =======================

;***************************************************************
;** Project: Light/Lamp/George
;** File:    TagFile.pro
;** Version: 0.1
;** Date:    Jan, 23rd, 2002
;** Author:  D. Richard, E. Farhi
;** Object:  Read/Write configuration files containing lines
;**          [tag] = [value]
;**          Lines starting with '#', ';' or '%' are ignored and
;**          are part of the file header.
;
;** Require: <none>
;
; Procedures:
;   TagFile, file, TAG=utag, GET=valg , SET=vals, HEADER=header
;       can GET or SET (and sort in alpha order) the TAGS given as
;       parameters. Values may be scalar and arrays of type string
;       and numerical (floating).
;       In GET mode, if TAGS is a variable equal to '', then
;       utag/valg will contain all fields
;       The file HEADER can be written or read
;***************************************************************
function TagFile_String, val
;** Recursive function to build string equivalence of values
    if n_elements(val) gt 1 then begin
      Array2Str = '[ ';
      for tmp1=0, n_elements(val)-1 do begin
          if tmp1 eq 0 then $
            Array2Str = Array2Str + TagFile_String(val(tmp1)) $
          else $
            Array2Str = Array2Str + ', ' + TagFile_String(val(tmp1))
      endfor
      Array2Str = Array2Str + ' ]'
    endif else begin
      varsize = size(val)
      vardims = N_ELEMENTS(varsize) - 2
      type = varsize[vardims]
      if type eq 7 then begin
         val = strsplit(val,"'",/extract, /PRESERVE_NULL)
         val = strjoin(val,'"')
         Array2Str = "'"+val+"'"
         ok = 1
      endif else ok = execute('Array2Str = string(val)')
      if not ok then begin
        print, '[TagFile] Can not convert to string'
        help, val
        Array2Str = "'<Could not convert to string>'"
      endif
    endelse
    return, Array2Str
end

pro TagFile, file, TAG=utag, GET=valg , SET=vals, HEADER=header
;** *******
;**
;** Manu's rich idea .....
;** Procedure which sets and retrieves values from an INI file.
;** File is composed by twin elements such as "tag = value" (no comments at this time).
;** Use: tagfile,"filename" ,TAG=["TOTO","TITI"] ,SET=[valueTOTO,valueTITI]
;**      tagfile,"filename" ,TAG=["toto","titi"] ,GET= returnedStringValues

IF n_elements(vals)     gt 0 then $
    IF not((n_elements(utag) eq 1) or (n_elements(utag) eq n_elements(vals))) then begin
        print, '{TagFile}: Wrong number of elements in Values/Tags'
        help, utag, vals
        RETURN
    endif
IF n_elements(file)     ne 1 then file="default"
IF strpos(file,'.')     lt 0 then file= file+".ini"

ON_IOERROR,misget & u=-1 & line='' & ftag=[''] & fval=[''] & valg=''

;READ FILE.INI
;-------------
HeaderInFile = ''
OPENR,u,file,/GET_LUN
  WHILE (not eof(u)) do begin
    READF,u,line
    line = strtrim(line,2)
    FirstChr = strmid(line, 0,1)
    if (FirstChr eq ';') or (FirstChr eq '%') or (FirstChr eq '#') then $
        HeaderInFile = [ HeaderInFile, line] $
    else begin
        idx=strpos(line,'=')
        IF idx gt 0 then begin
          ftag=[ftag,strtrim(strmid(line,0    ,idx(0)),2)]
          fval=[fval,strtrim(strmid(line,idx(0)+1,strlen(line)),2)]
        ENDIF
    ENDELSE
  ENDWHILE
MISGET: IF u gt 0 then FREE_LUN,u else begin
            print,!err_string
            print, '[TagFile] File '+file+' could not be opened for reading. Creating it.'
        endelse

if n_elements(utag) eq 0 then utag = ftag
if n_elements(utag) eq 1 and strlen(utag(0)) eq 0 then utag = ftag

;DO SET OR GET
;-------------
FOR i=0,n_elements(utag)-1 do begin miss=1 & jj=n_elements(ftag)

  WHILE (miss) and (jj gt 0) do begin
    jj=jj-1
    IF strtrim(strupcase(ftag(jj)),2) eq strtrim(strupcase(utag(i)),2) then miss=0
  ENDWHILE
  IF n_elements(vals) gt 0 then begin   ; SET
    if n_elements(utag) eq 1 then val = TagFile_String(vals) $
    else  val = TagFile_String(vals(i))
    IF not miss then fval(jj) = val  $
    ELSE    begin
        fval=[fval, val]
        ftag=[ftag, utag(i)]
    ENDELSE
  ENDIF   ELSE $                        ; GET
    IF jj ge 0 then  valg=[valg,fval(jj)]  $
    ELSE valg=[valg,'']
ENDFOR

nn  = n_elements(ftag)-1
IF nn eq 0  then RETURN

;RETURN IF GET
;-------------
IF n_elements(vals) eq 0 then begin
  IF n_elements(valg) gt 1 then valg=valg(1:n_elements(valg)-1)
  IF n_elements(valg) eq 1 then valg=valg(0)
  header = HeaderInFile
  RETURN
ENDIF

ON_IOERROR,misput & u=-1

;WRITE FILE.INI IF SET
;---------------------
idx=SORT(ftag) & ftag=ftag(idx) & fval=fval(idx)

;** default header if not given
if n_elements(header) eq 0 then $
    header =[ '# Configuration file: '+file,$
              '# Date:               '+systime(0)]

OPENW,u,file,/GET_LUN
for i=0,n_elements(header)-1 do printf,u,header(i)
FOR i=1,nn do  PRINTF,u,ftag(i)+' = '+fval(i)

MISPUT: IF u gt 0 then FREE_LUN,u else print,!err_string

end
;***************************************************************
;** Project: Light
;** File:    Tools.pro
;** Version: 0.1
;** Date:    Jan, 23rd, 2002
;** Author:  E. Farhi
;** Object:  Tools for handling Structures, Variables, etc...
;
;** Require: <none>
;
; Procedures:
;   Tools_StructSetValue, struct=S, tag=Tag, val=Val
;       operates S.Tag = Val.
;       Recursive for structures of structures (a.b.c=value)
;***************************************************************

;***************************************************************
pro Tools_StructSetValue, struct=S, tag=Tag, val=Val
;** Procedure that operates S.Tag = Val
;** even if dimension or type does not match
;** It can also add a tag to the structure
;** ex: Tools_StructSetValue, struct=DialVars.Global, Tag='LogText', val=LogText

  idx = strpos(Tag, '.')
  if idx ge 0 then begin
    RecUpperStruct = strtrim(strmid(Tag,0, idx(0)),2)
    RecLowerStruct = strtrim(strmid(Tag,idx(0)+1, strlen(Tag)),2)
    ok = execute('RecUpperStructVal = S.'+RecUpperStruct)
    Tools_StructSetValue, struct=RecUpperStructVal, Tag=RecLowerStruct, Val=val
    Tools_StructSetValue, struct=S, Tag=RecUpperStruct, Val=RecUpperStructVal
  endif else begin
    sv =size(Val)
    if strlen(Tag) eq 0 then Tag='VALUE' else Tag=strupcase(Tag)
    TagList=strupcase(tag_names(S))
    Index  =where(TagList eq Tag)
    sz     =[0,0,0]
    vardims = N_ELEMENTS(sv) - 2
    type = sv[vardims]
    if Index(0) ge 0 then dummy=execute('sz=SIZE(S.'+Tag+')')
    if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(0) ne sv(0)) $
        or (sz(sz(0)+2) ne sv(sv(0)+2)) $
        or type eq 8 then begin
      EvalStr = ''
      for k=0,n_elements(TagList)-1 do begin
        case TagList(k) of
          Tag:
          else: EvalStr =EvalStr+','+TagList(k)+':S.'+TagList(k)
        endcase
      endfor
      dummy=execute('S={'+TAG+':Val'+ EvalStr +'}')
    endif else dummy=execute('S.' +Tag+'=Val')
  endelse

end; PRO Tools_StructSetValue
;***************************************************************
function tstnewvalue, TYPE=type, SETVALUE=setvalue, COMMENT=comment
;******* ***********
;**
common gogo, mono1,mono2,mono3,myval,curmon,monot

if n_elements(type) eq 1 then if type eq 'status' then return, 'Idle' $
                         else if type eq 'wave'   then return, 4.14
return,myval
end



function tstcontrol , cmd, CHECK=check
;******* **********
;**
common gogo, mono1,mono2,mono3,myval,curmon,monot

if n_elements(mono1) le 1 then begin 
   hw1  =15. ;Half width
   h    =10.  ;Hight
   n1   =200.
   mono1= h*exp(-(((findgen(n1)-n1/2)/hw1)^2)/2)
   mono1=mono1+sqrt(mono1)*(randomu(s,n1)-.5)*2./10.
   mono1=shift(mono1,-n1/2)
   hw1  =19. ;Half width
   h    =20.  ;Hight
   n1   =200.
   mono2= h*exp(-(((findgen(n1)-n1/2)/hw1)^2)/2)
   mono2=mono2+sqrt(mono2)*(randomu(s,n1)-.5)*2./10.
   mono2=shift(mono2,-n1/2)
   hw1  =22. ;Half width
   h    =30.  ;Hight
   n1   =200.
   mono3= h*exp(-(((findgen(n1)-n1/2)/hw1)^2)/2)
   mono3=mono3+sqrt(mono3)*(randomu(s,n1)-.5)*2./10.
   mono3=shift(mono3,-n1/2)
   
   monot=fltarr(n1) & curmon=0 & myval=0
endif

com=strsplit(cmd,'. ',/extract)
; print, cmd

case com(0) of
'raz':   begin  mono1=0 & curmon=0 & end
'mono1': begin	if curmon ne 1 then begin curmon=1 & monot=monot+mono1 & endif
		pos=long(com(1)) & myval=monot(abs(pos-(3800-2)))
	 end
'mono2': begin	if curmon ne 2 then begin curmon=2 & monot=monot+mono2 & endif
		pos=long(com(1)) & myval=monot(abs(pos-(3960+2)))
	 end
'mono3': begin	if curmon ne 3 then begin curmon=3 & monot=monot+mono3 & endif
		pos=long(com(1)) & myval=monot(abs(pos-(4220-4)))
	 end
'count':
else:
endcase

return,myval
end
;-------------------------------------------------------------
;+
; NAME:
;       XLIST
; PURPOSE:
;       Pop-up list selection widget.
; CATEGORY:
; CALLING SEQUENCE:
;       out = xlist(list)
; INPUTS:
;       list = string array of possible selections.  in
; KEYWORD PARAMETERS:
;       Keywords:
;         TITLE=txt  title text or text array (def=Select item).
;         MAXSCROLL=n Max allowed lines before scrolling list used
;           (def=20).
;         HIGHLIGHT=i Line to highlight (def=none).
;         TOP=j       Line to make be the top of the list.
;         INDEX=indx  Returned index of selected item.
;         /WAIT  means wait for a selection before returning.
;           Needed if called from another widget routine.
; OUTPUTS:
;       out = selected element.                      out
;         Null if Cancel button pressed.
; COMMON BLOCKS:
; NOTES:
; MODIFICATION HISTORY:
;       R. Sterner, 11 Nov, 1993
;
; Copyright (C) 1993, Johns Hopkins University/Applied Physics Laboratory
; This software may be used, copied, or redistributed as long as it is not
; sold and this copyright notice is reproduced on each copy made.  This
; routine is provided as is without any express or implied warranties
; whatsoever.  Other limitations apply as described in the file disclaimer.txt.
;-
;-------------------------------------------------------------
 
	pro xlist_event, ev
 
	widget_control, ev.id, get_uval=cmd	; Get command (or list entry).
	widget_control, ev.top, get_uval=res	; Get result address.
 
	if cmd(0) eq 'CANCEL' then begin	; CANCEL button.
	  widget_control, res, set_uval={t:'',i:0}	; Return null string.
	  widget_control, ev.top, /dest		; Destroy list widget.
	  return
	endif
 
	txt = cmd(ev.index)			; Selected list entry.
	widget_control, res, set_uval={t:txt,i:ev.index}	; Return it.
	widget_control, ev.top, /dest		; Destroy list widget.
	return
 
	end 
 
 
;===================================================================
;	xlist.pro = Pop-up list selection widget.
;	R. Sterner, 11 Nov, 1993
;===================================================================
 
	function xlist, list, title=title, help=hlp, maxscroll=maxs, $
	  index=indx, wait=wait, highlight=hi, top=ltop
 
	if (n_params(0) eq 0) or keyword_set(hlp) then begin
	  print,' Pop-up list selection widget.'
	  print,' out = xlist(list)'
	  print,'   list = string array of possible selections.  in'
	  print,'   out = selected element.                      out' 
	  print,'     Null if Cancel button pressed.'
	  print,' Keywords:'
	  print,'   TITLE=txt  title text or text array (def=Select item).'
	  print,'   MAXSCROLL=n Max allowed lines before scrolling list used'
	  print,'     (def=20).'
	  print,'   HIGHLIGHT=i Line to highlight (def=none).'
	  print,'   TOP=j       Line to make be the top of the list.'
	  print,'   INDEX=indx  Returned index of selected item.'
	  print,'   /WAIT  means wait for a selection before returning.'
	  print,'     Needed if called from another widget routine.'
	  return,''
	endif
 
	;--------  Set defaults  ------------
	if n_elements(maxs) eq 0 then maxs=20
	if n_elements(title) eq 0 then title = 'Select item'
 
	;--------  Set up widget  ----------------
	result = widget_base(modal=wait)
	widget_control, result, set_uval=''
	top = widget_base(/column, uvalue=result, title=' ')
	for i=0, n_elements(title)-1 do t = widget_label(top,val=title(i))
	b = widget_base(top, /row)
	t = widget_button(b, val='Cancel', uval='CANCEL')
	lst = widget_list(top, val=list, uval=list,ysize=n_elements(list)<maxs)
	widget_control, top, /real
	if n_elements(hi) ne 0 then widget_control,lst,set_list_select=hi
	if n_elements(ltop) ne 0 then widget_control,lst,set_list_top=ltop
 
	;--------- Register  ---------
	if n_elements(wait) eq 0 then wait=0
	xmanager, 'xlist', top
	widget_control, result, get_uvalue=out
  if size(out, /type) ne 8 then return, ''
	indx = out.i
	txt = out.t
 
	return, txt
	end
