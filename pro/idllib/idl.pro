;$Id: a_correlate.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       A_CORRELATE
;
; PURPOSE:
;       This function computes the autocorrelation Px(L) or autocovariance
;       Rx(L) of a sample population X as a function of the lag (L).
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = A_correlate(X, Lag)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;     LAG:    A scalar or n-element vector, in the interval [-(n-2), (n-2)],
;             of type integer that specifies the absolute distance(s) between 
;             indexed elements of X.
;
; KEYWORD PARAMETERS:
;       COVARIANCE:    If set to a non-zero value, the sample autocovariance
;                      is computed.
;
; EXAMPLE
;       Define an n-element sample population.
;         x = [3.73, 3.67, 3.77, 3.83, 4.67, 5.87, 6.70, 6.97, 6.40, 5.57]
;
;       Compute the autocorrelation of X for LAG = -3, 0, 1, 3, 4, 8
;         lag = [-3, 0, 1, 3, 4, 8]
;         result = a_correlate(x, lag)
;
;       The result should be:
;         [-0.0303311, 1.00000, 0.784758, -0.0303311, -0.350930, -0.112325]
;
; PROCEDURE:
;       See computational formula published in IDL manual.
;
; REFERENCE:
;       INTRODUCTION TO STATISTICAL TIME SERIES
;       Wayne A. Fuller
;       ISBN 0-471-28715-6
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, October 1994
;
;-

function auto_cov, x, m, nx
  ;Sample autocovariance function.

  xmean = total(x) / nx
  t = lindgen(nx - m - 1L)
  return, total((x(t) - xmean) * (x(t + m) - xmean))

end


function a_correlate, x, lag, covariance = covariance

  ;Compute the sample-autocorrelation or autocovariance of (Xt, Xt+l)
  ;as a function of the lag (l).

  on_error, 2

  nx = n_elements(x)

  if nx lt 2 then $
    message, 'x must be a vector of two or more elements.'
  
  nlag = n_elements(lag)

  if nlag eq 1 then lag = [lag] ;Create a 1-element vector.

  type = size(x)
  if type(2) eq 5 then auto = dblarr(nlag) $
  else auto = fltarr(nlag)

  if keyword_set(covariance) eq 0 then begin ;Compute Autocorrelation.
    for k = 0, nlag-1 do $
      auto(k) = auto_cov(x, abs(lag(k)), nx) / auto_cov(x, 0L, nx)
  endif else begin ;Compute Autocovariance.
    for k = 0, nlag-1 do $ 
      auto(k) = auto_cov(x, abs(lag(k)), nx) / nx
  endelse

  return, auto

end
; $Id: mp_widgets.pro,v 1.2 1994/01/13 23:58:07 ali Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;
;+
; NAME:
;	AIDE
;
; PURPOSE:
;	Provide a graphical user interface to the online documentation.
;	The topic is selected by pressing a button at the top.
;	Subtopics a displayed in a scrolling list on the left side.  Pressing
;	a mouse button while pointing at a subtopic causes the information
;	on that topic to be displayed in the large text region on the right.
;
;	It is expected that this routine will only be called by MAN_PROC.
;
; CATEGORY:
;	Help, documentation, widgets.
;
; CALLING SEQUENCE:
;	AIDE [, Request]
;
; INPUTS:
;     Request:	A scalar string containing the item on which help is desired.
;		This string can contain 1 or two (whitespace separated) words.
;		The first word is taken as the global topic and the second
;		as the topic within the scope of the first.
;
; OUTPUTS:
;	None.  A widget interface is used to allow reading the help text.
;
; COMMON BLOCKS:
;	MPW_COM: This common block is private to MP_WIDGETS, and
;		 should not be referenced by other modules.
;
; RESTRICTIONS:
;	The basic version of the help facility (MP_BASIC) can accept
;	ambiguous requests, and if a request maches more than a single
;	subtopic, they are all shown.  This version can also accept
;	ambiguous requests, but only the first subtopic matched is shown.
;	This feature is not as important as it was in MP_BASIC because the 
;	widget interface allows multiple subjects to be viewed easily.
;
;	This routine uses a COMMON block to keep its internal state, so only 
;	one copy of this routine can run at a time.
;
; MODIFICATION HISTORY:
;	AB, August, 1990
;	28 December 1990	Rewritten to take advantages in changes to 
;				the widget facility, to use XMANAGER, and to 
;				accept the REQUEST argument.
;	31 December 1992	Modified to ignore the optional %TITLE
;				line at the top of the file. There's no
;				reason to handle it, since this routine is
;				obsolete. The builtin online help system
;				*does* handle it.
;-




function mpw_set_lv1, topic_idx, lv2_topics
; Open a new level 1 help file. Close the old one if one exists.
; Update the common block to reflect the change. lv2_topics is the
; array of level 2 topics found in the file. Returns TRUE if the topic
; was changed, FALSE otherwise.

common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  if (topic_idx ne cur_lv1_topic_idx) then begin   ; Only if the topic changed.
    if (unit ne 0) then FREE_LUN, unit
    openr, unit, lv1_files(topic_idx), /get_lun
    cur_lv1_topic_idx = topic_idx
    n = 0L
    tmp = ''
    readf, unit, tmp
    ; If it's the version tag, parse it.
    version = 1L					; Assume old format
    if (strmid(tmp, 0, 9) eq '%VERSION:') then begin
      reads, tmp, version, format='(9X, I0)'
      readf,unit,tmp				; Read next line.
    endif
    if (strmid(tmp, 0, 7) eq '%TITLE:') then readf, unit, tmp	; Skip title
    n = long(tmp)				; # of records
    if (version ne 1) then begin
      ; Version 2 format has the number of characters used by all the
      ; subtopics on the next line. We don't use it, but have to read it
      readf,unit,tmp				; Read next line.
    endif
    lv2_topics = strarr(n)			;Make names
    readf, unit, lv2_topics			;Read entire string from unit
    if (version eq 1) then begin
      offsets = long(strmid(lv2_topics, 15, 30))	;Extract starting bytes
      lv2_topics = strmid(lv2_topics,0,15)		;Isolate names
    endif else begin
      offsets = lonarr(n)
      for i = 0, n-1 do begin
        tmp = lv2_topics(i)
        colon = strpos(tmp, ':') + 1		; Find delimiter
        offsets(i) = long(strmid(tmp, 0, colon))
        lv2_topics(i) = strmid(tmp, colon, 10000000)
      endfor
    endelse

    ; Determine the base of the help text
    tmp = fstat(unit)
    text_base = tmp.cur_ptr
    cur_lv2_idx=-1
    r = 1
  endif else r = 0

  return, r
end







pro mpw_update_display, lv2_topics
; Update the topic label and list elements to reflect the current state
; as determined by mpw_set_lv1. lv2_topics is the array of level 2 topics
; returned by mpw_set_lv1.

  common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  WIDGET_CONTROL, list, set_value=lv2_topics
  WIDGET_CONTROL,title,set_value='Current Topic: ' $
	+ lv1_topics(cur_lv1_topic_idx)
  WIDGET_CONTROL,text,set_value='', /NO_NEWLINE

end







pro mpw_set_lv2, index
; Given an index, display the text associated with it in the current
; help file.

  common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  if (cur_lv2_idx ne index) then begin
    str = ''
    POINT_LUN, unit, text_base + offsets(index)
    readf, unit, str                ; Skip the ";+"
    ; Remember this position
    start = fstat(unit)
    start = start.cur_ptr
    ; Find the end
    while (str NE ";-") do readf, unit, str
    ; How long is the selection?
    tmp = fstat(unit)
    len = tmp.cur_ptr - start - 3
    ; Read the text using binary I/O into a single byte array for efficiency
    str = bytarr(len)
    point_lun, unit, start
    readu, unit, str
    WIDGET_CONTROL, text, SET_VALUE=string(str), /NO_NEWLINE
    cur_lv2_idx = index
  endif

end







pro mpw_event, ev

common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  case (tag_names(ev, /STRUCTURE_NAME)) of
  "WIDGET_BUTTON": begin
	  WIDGET_CONTROL, get_uvalue=uv, ev.id
	  if (uv eq -2) then begin
	    WIDGET_CONTROL, /DESTROY, ev.top
	    if (unit ne 0) then FREE_LUN, unit
	    return
	  endif else begin
	    if (mpw_set_lv1(uv,lv2_topics)) then mpw_update_display,lv2_topics
	  endelse
	end
  "WIDGET_LIST": mpw_set_lv2, ev.index
  endcase


end







function MPW_TM, KEY, TOPIC_ARRAY
; Topic Matcher. Given KEY, this routine returns an index into TOPIC_ARRAY
; that matches KEY. If there is an exact match, that index is returned.
; otherwise the first element with the same prefix is returned.
; On error, MESSAGE is used to report the problem and terminate execution.

  found = where(STRTRIM(TOPIC_ARRAY) eq KEY, count) ; Match exact string
  if (count le 0) then begin	; No exact match, try to match the prefix
    FOUND = where(strpos(TOPIC_ARRAY, KEY) eq 0, count)
    if (count le 0) then begin
      message, /NONAME, 'Unknown topic: ' + KEY
    endif else begin
      if (count ne 1) then begin
	message, /INFO, /NONAME, 'Ambiguous topic "' + KEY $
		+ '" matches: ' + string(format='(i0, " ")', count) $
		+ 'items. ' + strcompress(topic_array(found(0)), /remove) $
		+ ' used.'
      endif
    endelse
  endif

  return, found(0)
end







pro AIDE, request

  common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  if (XREGISTERED('MP_WIDGETS')) then return	; Only one copy at a time

  on_error, 1		; On error, return to main level
  unit = 0		; No help file is open yet

  ; lv1_files recieves all help files found through !HELP_PATH.
  lv1_dirs = EXPAND_PATH(!HELP_PATH, /ARRAY, COUNT=cnt)
  if (cnt eq 0) then message, 'No online help files found.'
  for i = 0, cnt-1 do begin
    tmp = STRLOWCASE(findfile(filepath('*.help', root_dir=lv1_dirs(i))))
    if (i eq 0) then lv1_files = TEMPORARY(tmp) $
    else lv1_files=[lv1_files, TEMPORARY(tmp)]
  endfor

  ; lv1_topics gets uppercase version of just the names.
  lv1_topics = STRUPCASE(lv1_files)
  if !version.os ne 'windows' then begin
    tail = STRPOS(lv1_topics, '.HELP')
  endif else begin
    tail = STRPOS(lv1_topics, '.HEL')
  endelse
  n = n_elements(lv1_topics)
  for i = 0, n-1 do $
	lv1_topics(i) = strmid(lv1_topics(i), 0, tail(i))
  for i = 0, n-1 do begin	; Strip path part off lv1_topics
    case !version.os of
      'vms': begin
           j = STRPOS(lv1_topics(i), ']')
           while (j ne -1) do begin
             lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
             j = STRPOS(lv1_topics(i), ']')
           endwhile
      end
      'windows': begin
        j = STRPOS(lv1_topics(i), '\')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), '\')
        endwhile
      end
      'MacOS': begin
        j = STRPOS(lv1_topics(i), ':')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), ':')
        endwhile
      end
      else:  begin      ; Unix otherwise
        j = STRPOS(lv1_topics(i), '/')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), '/')
        endwhile
      end
    endcase
  endfor

  ; Sort the topics into alphabetical order.
  tmp = sort(lv1_topics)
  lv1_files = lv1_files(tmp)
  lv1_topics = lv1_topics(tmp)


  ; Check the request (if any) for validity before any widgets are created.
  ; If it is empty, act as if it isn't present.
  REQ_PRESENT = N_ELEMENTS(REQUEST) ne 0
  if (REQ_PRESENT) then begin
    temp = size(request)
    if (temp(0) NE 0) then message, 'Argument must be scalar.'
    if (temp(1) NE 7) then message, 'Argument must be of type string.'
    if (STRLEN(STRCOMPRESS(REQUEST, /REMOVE_ALL)) eq 0) then REQ_PRESENT = 0
  endif

  ; Choose initial display using first option in this list that fits:
  ;  - Request on the command line.
  ;  - The topic used last time this routine was run.
  ;  - Topic is ROUTINES, subtopic is empty
  if (REQ_PRESENT) then begin
    ; Parse into 1 or two strings
    lv1_topic_idx = STRUPCASE(STRTRIM(STRCOMPRESS(REQUEST), 2))
    if (((blank_pos = STRPOS(lv1_topic_idx, ' '))) ne -1) then begin
      lv2_topic = STRMID(lv1_topic_idx, blank_pos+1, 10000L)
      lv1_topic_idx = STRMID(lv1_topic_idx, 0, blank_pos)
    endif else begin
      lv2_topic=''
    endelse
    ; Make sure its legitimate.
    lv1_topic_idx = MPW_TM(lv1_topic_idx, lv1_topics)
    cur_lv1_topic_idx = -1
    junk = mpw_set_lv1(lv1_topic_idx, lv2_topics)
    if (lv2_topic ne '') then lv2_index = MPW_TM(lv2_topic, lv2_topics) $
      else lv2_index = -1
  endif else begin			; No request is present
    if (n_elements(cur_lv1_topic_idx) eq 0) then begin	; Default to ROUTINES
      lv1_topic_idx=MPW_TM("ROUTINES", lv1_topics)	; No sub-topic
      lv2_index = -1
    endif else begin					; Use previous state
      lv1_topic_idx=cur_lv1_topic_idx
      lv2_index = cur_lv2_idx
    endelse
    cur_lv1_topic_idx = -1
    junk = mpw_set_lv1(lv1_topic_idx, lv2_topics)
  endelse
  cur_lv2_idx = -1				; Forget the old state

  ; The request (if any) is OK. Create and realize the widgets.
  base = WIDGET_BASE(title='Aide Speciale Didier Richard', /COLUMN)
  cntl1 = WIDGET_BASE(base, /FRAME, /ROW, space=30)
  if (!version.os eq 'sunos') then tmp = 10 else tmp = 5
  cntl2 = WIDGET_BASE(base, column=tmp, /FRAME, /exclusive)
    pb_quit = WIDGET_BUTTON(value='Quit', cntl1, uvalue = -2)
    topic_but_ids = lonarr(n, /nozero)
    for i = 0, n-1 do $
      topic_but_ids(i) = WIDGET_BUTTON(value=lv1_topics(i), cntl2, $
				    uvalue = i, /NO_RELEASE)
  title=WIDGET_LABEL(cntl1, value='Current Topic:')
  bottom=WIDGET_BASE(base, /ROW)
  list = WIDGET_LIST(bottom,ysize=20,value = string(bytarr(20) + 45B),/frame)
  text = WIDGET_TEXT(bottom, /SCROLL, xsize = 70, ysize=20)

  WIDGET_CONTROL, base, /REALIZE

  mpw_update_display, lv2_topics

  ; Set the proper button
  if (cur_lv1_topic_idx ne -1) then $
    WIDGET_CONTROL, topic_but_ids(cur_lv1_topic_idx), /SET_BUTTON

  lv2_topics = 0		; Free the dynamic memory
  if (lv2_index ne -1) then mpw_set_lv2, lv2_index

  XMANAGER, 'MP_WIDGETS', base, event_handler='MPW_EVENT'
end
; $Id: annotate.pro,v 1.10 1995/01/25 21:58:05 billo Exp $
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
; Parameter definitions:
; For all objects:
; 0	p0_x
; 1	p0_y
; 2	p1_x
; 3	p1_y
; 4	color index
; 5	thickness
; 6	linestyle
; 7	size
; 8	fill style (0=none, 1 = solid, 2 = lines
; 9	fill space
; 10	fill angle
; 11	npoints / nchars
; 12	alignment
; 13    font
; 14	orientation
; 15	head size
; 17    line/arrow/solid_arrow
; 18	eccen
; 19    object type
; 20    interpolation
;
; Modes:
;	0 Text
;	1 Lines/Arrows
;	2 Polylines/Polygons, Drag
;	3 Circles
;	4 Squares



pro xmgr_fake, top, window
; simulate the xmanager routine for a non-widgetized environment.
; deliver events from the ann widget as well as motion and button
; events from the selected idl window.

buttons = 0
ix0 = -1
iy0 = -1

while 1 do begin
    ev = widget_event(top, BAD_ID = bad, /NOWAIT)   ;Widget event?
    if bad ne 0L then return			;Gone? Done.
    if ev.id ne 0L then annotate_event, ev $	;Dispatch it.
    else begin				;Check for mouse
	if !d.window ne window then wset, window
	CURSOR, ix, iy, /DEV, /NOWAIT
        if (ix < iy) ge 0 then begin    ;In window?
	    j = !err			;New buttons
	    i = j xor buttons		;changed buttons
	    if i ne 0 then $		;Button change...
	        ANN_DRAW_EVENT, { ANN_FAKE_EVENT, $
		    x:ix, y:iy, press: i and j, release: i and buttons }, top $
	    else if ((ix ne ix0) or (iy ne iy0)) then $
	        ANN_DRAW_EVENT, { ANN_FAKE_EVENT, $
		    x:ix, y:iy, press: 0L, release: 0L }, top
	    ix0 = ix
	    iy0 = iy
	    buttons = j
            endif               ;ix, iy >= 0
    endelse                 ;no widget event
  endwhile
end



function b_button, a	;Return a 1 bit deep bitmap given a byte image.
			;width of image MUST be a multiple of 8.
s = size(a)
b = bytarr(s(1)/8, s(2))
if (s(1) and 7) ne 0 then $
	message, 'B_BUTTON: image width must be a multiple of 8.'
subs = lindgen(n_elements(b)) * 8
for ibit = 0,7 do b = b or byte(2^ibit) * (a(subs+ibit) ne 0b)
return, reverse(b,2)
end


FUNCTION ann_closest, xy, n, pos	;return index of closest point
d = (xy(0,0:n-1)-pos(0))^2 + (xy(1,0:n-1)-pos(1))^2
junk = min(d, i)
return, i
end

FUNCTION ann_closest_obj, st
WIDGET_CONTROL, st.objlist, GET_UVALUE=l  ;Object list
dmin = 1e6
pos = st.pos
psize = n_elements(st.p)			;Elements/object
nrows = n_elements(l)/psize
if n_elements(l) le 1 then return, 0
for i=0L, nrows-1 do begin  ;Each object
    p = l(*,i)			;Ith object
    k = i
    n = long(p(11))
    case p(19) of			;Which object?
0:  BEGIN			;A mess...
	x = p(2)		;Text width
	dx = cos(p(14)* !dtor) * x
	dy = sin(p(14)* !dtor) * x
        q = [p(0) + dx * (0.5-p(12)), p(1) + dy * (0.5-p(12))]
	i = i + (n + psize - 1)/psize	;Next object
    ENDCASE
1:  q = [p(0)+p(2), p(1)+p(3)]/2.   ;Lines
2:  BEGIN			;Polygon
	j = psize * (i+1)
	xy = reform(l(j: j+2*n-1), 2, n)  ;Extract points
	xmin=min(xy(0,*), max=xmax)
	ymin=min(xy(1,*), max=ymax)
	q = [xmin+xmax, ymin+ymax]/2.
	i = i + (2*n+psize-1)/psize	;Next element
    ENDCASE
3:  q = p([2,3])		;Circle
4:  q = [p(0)+p(2), p(1)+p(3)]/2.   ;box
else: q = pos + 10		;Unknown obj, dist = big
    ENDCASE
    d = total((pos - q)^2)	;Distance...
    if d lt dmin then begin dmin = d & imin = k & endif
ENDFOR

if dmin lt 0.04 then return, imin else return, -1
END				;Ann_closest_obj



PRO ANN_GET_NUM_EVENT, ev
on_ioerror, bad_again
widget_control, ev.id, get_value=v
widget_control, ev.top, get_uvalue=u
val = float(v(0))
if val lt u.minv or val gt u.maxv then goto, bad_again
WIDGET_CONTROL, u.id, SET_VALUE=v(0)	;Save the correct value
WIDGET_CONTROL, ev.top, /DESTROY	;Done
return
bad_again:  WIDGET_CONTROL, ev.id, SET_VALUE=''
return
END


pro CW_CONF_EVENT, ev	;On any event, save the value and kill it
WIDGET_CONTROL, ev.id, GET_UVALUE=i	;Button index
WIDGET_CONTROL, ev.top, GET_UVALUE=temp ;Temp storage location
WIDGET_CONTROL, temp, SET_UVALUE=i	;save choice
WIDGET_CONTROL, ev.top, /DESTROY	;Kill it
return
END


FUNCTION CW_CONFIRM, message, choices
; Make a Modal widget with the given message as text, and with buttons
;   corresponding to the choices.  Return the index of the button pressed.
;
    temp = WIDGET_BASE()
    a = WIDGET_BASE(title='Confirmation',/COLUMN, UVALUE=temp)
    for i=0, N_ELEMENTS(message)-1 DO junk = widget_label(a, value=message(i))
    b = WIDGET_BASE(a, /ROW)
    for i=0,n_elements(choices)-1 do $
	junk = WIDGET_BUTTON(b, VALUE=choices(i), /NO_REL, UVALUE=i)
    WIDGET_CONTROL, a, /REALIZE
    XMANAGER, 'Confirmation', a, /MODAL, EVENT_HANDLER='CW_CONF_EVENT'
    WIDGET_CONTROL, temp, GET_UVALUE=u, /DESTROY
return, u
end


FUNCTION ann_get_num, str, id, minv, maxv
; Get & check  a numeric value from a text widget.  If illegal format,
; use a modal widget to get a correct value.
	
on_ioerror, bad			;1st level call
v = float(str(0))
if v lt minv or v gt maxv then goto, bad
return, v			;OK

bad:  t = widget_base(title='Invalid Number', /column)
WIDGET_CONTROL, t, set_uvalue = { id:id, minv: minv, maxv: maxv} ;Save params
b = WIDGET_LABEL(t, value= 'An invalid number was entered')
b = WIDGET_LABEL(t, value = 'Range = '+string(minv)+' to '+string(maxv))
b = WIDGET_LABEL(t, value= 'Please enter the correct value')
j = WIDGET_TEXT(t, /frame, xsize=10, ysize=1, /EDIT)
WIDGET_CONTROL, t, /REAL
xmanager, 'Invalid Number', t, /MODAL, EVENT_HANDLER = 'ann_get_num_event'
WIDGET_CONTROL, id, GET_VALUE=v	;The correct value
return, float(v(0))
end



PRO ann_reset_mode, st, mode, submode, NOCLEAN = noclean
;Clean out the current object, reset mode

if n_elements(mode) le 0 then mode = st.mode	;Save old mode
if n_elements(submode) le 0 then submode = 0
newmode = st.mode ne mode

if newmode then begin
    m = st.mode_bases
    WIDGET_CONTROL, m(n_elements(m)-1), MAP=0	;Options base
    WIDGET_CONTROL, m(st.mode), MAP=0   ;Unmap old
    WIDGET_CONTROL, st.mode_buttons(mode), SET_BUTTON=1
    if mode ge 2 then begin		;Set polyfill controls?
	p = st.p
	WIDGET_CONTROL, st.spline_id, SET_VALUE=p(20)
        WIDGET_CONTROL, st.poly_style(mode), SET_VALUE=p(8)
	WIDGET_CONTROL, st.poly_angle(mode), SET_VALUE=p(10)
	WIDGET_CONTROL, st.poly_spacing(mode), SET_VALUE=p(9)
	endif
    st.mode = mode
    WIDGET_CONTROL, m(mode), MAP=1
    wset, st.draw_win		;Redraw the view window
    device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, st.backing(1)]
    endif

if keyword_set(noclean) eq 0 then begin	;Remove current object
    st.p(11) = 0
    endif

st.open = 0
st.minor_mode = submode
st.p(19) = st.mode
WIDGET_CONTROL, st.minor_mode_id, SET_VALUE=submode
end


PRO ann_add_object, st			;Add current object to list
wset, st.backing(1)			;Make it permanent
p = st.p
ann_draw_object, st, p			;Draw obj in backing store
wset, st.draw_win
device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, st.backing(1)] ;To draw window

psize = n_elements(p)
if p(19) eq 0 then begin		;text?
	n = strlen(st.txt)		;# of chars, Save in an array
	if n eq 0 then return		;Nothing to save
	p(11) = n
	a = bytarr(psize, (n+psize-1)/psize) ; Addtl bytes
	a(0) = byte(st.txt)
	p = [[p],[float(a)]]
endif else if p(19) eq 2 then begin	;Polygon?
	n = long(p(11))*2		;# of pnts required
	a = fltarr(psize, (n+psize-1)/psize)  ;Array into which to insert
	WIDGET_CONTROL, st.xy, GET_UVALUE=xy, /NO_COPY
	a(0) = xy(0:n-1)		;Insert it
	p = [[p], [a]]
endif	
	
WIDGET_CONTROL, st.objlist, GET_UVALUE = l, /NO_COPY
if n_elements(l) gt 1 then p = [[l], [p]]  ;Add to end of list
WIDGET_CONTROL, st.objlist, SET_UVALUE = p, /NO_COPY  ;Add to list
ann_reset_mode, st		;Reset mode
end				;Ann_add_object



pro ann_set_controls, st, p	;Set controls to corresp to object
WIDGET_CONTROL, st.color_id, SET_VALUE=p(4)
WIDGET_CONTROL, st.thick_id, SET_VALUE=p(5)*10.
WIDGET_CONTROL, st.linestyle_id, SET_VALUE=p(6)

case p(19) of
0:	BEGIN		;Text
	WIDGET_CONTROL, st.txt_size_id, SET_VALUE=p(7)*10.
	WIDGET_CONTROL, st.txt_id, SET_VALUE=st.txt
	WIDGET_CONTROL, st.ori_id, SET_VALUE=(p(14) + 360) mod 360
	WIDGET_CONTROL, st.txt_ali_id, SET_VALUE=p(12)*2
	WIDGET_CONTROL, st.txt_font_id, SET_VALUE=p(13)
	ENDCASE
1:	BEGIN		;Line/arrow
	WIDGET_CONTROL, st.line_arrow_id, SET_VALUE=p(17)
	WIDGET_CONTROL, st.head_size_id, SET_VALUE=p(15)*10.
	ENDCASE
2:	BEGIN	
	WIDGET_CONTROL, st.spline_id, SET_VALUE=p(20)
do_poly: i = long(p(19))
        WIDGET_CONTROL, st.poly_style(i), SET_VALUE=p(8)
	WIDGET_CONTROL, st.poly_angle(i), SET_VALUE=p(10)
	WIDGET_CONTROL, st.poly_spacing(i), SET_VALUE=p(9)
	ENDCASE
3: 	BEGIN		;Circle
	WIDGET_CONTROL, st.ecc_id, SET_VALUE=(p(18)-1.)*10.
	goto, do_poly
	ENDCASE
4:	goto, do_poly	;Rectangle
ENDCASE
END




pro ann_refresh_list, st, FROM_SCRATCH=redraw, WINDOW=window, MONO = mono
; FROM_SCRATCH = redraw from backing store(0)
; WINDOW = destination window
; MONO = color index to gray scale translation table

if n_elements(mono) le 0 then mono = 0
if n_elements(window) eq 1 then WSET, window

if keyword_set(redraw) then $	;Redraw from scratch?
    device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, st.backing(0)]

WIDGET_CONTROL, st.objlist, GET_UVALUE=l, /NO_COPY
if n_elements(l) le 1 then goto, done	;Nothing...
s = size(l)
psize = s(1)			;# of columns
n = n_elements(l) / psize	;# of rows
for i=0L, n-1 do begin		;Do each object....
    p = l(*,i)			;The object
    m = 0			;# of addtl elements
    k = (i+1) * psize		;Next row
    if p(19) eq 0 then begin	;Text
	m = long(p(11))
	ann_draw_object, { txt: string(byte(l(k:k+m-1)))} , p, MONO = mono
    endif else if p(19) eq 2 then begin  ;polygon?
	m = long(p(11))*2
	xy = reform(l(k:k+m-1), 2, m/2)
	ann_draw_object, st, p, xy=xy, MONO= mono
    endif else ann_draw_object, st, p, MONO= mono
    i = i + (m+psize-1)/psize	;Next row
    endfor
done:  WIDGET_CONTROL, st.objlist, SET_UVALUE=l, /NO_COPY
end



function ann_load_obj, st, obj	;Load nth object from list.  Remove
; the object from the list.  return 0 if error, 1 if ok.
; reload st with object.

WIDGET_CONTROL, st.objlist, GET_UVALUE = l, /NO_COPY
if n_elements(l) le 1 then begin
quit:   WIDGET_CONTROL, st.objlist, SET_UVALUE=l, /NO_COPY
   return, 0
   endif
psize = n_elements(st.p)
n = n_elements(l) / psize	;# of objects
if obj lt 0 or obj ge n then goto, quit  ;There?
p = l(*,obj)
k = (obj+1) * psize
m = 0
mode = fix(p(19))
if mode eq 0 then begin		;Text?
    m = long(p(11))
    st.txt = string(byte(l(k:k+m-1)))  ;fetch the text
endif else if mode eq 2 then begin	;Polygon?
    j = long(p(11))
    m = j*2				;# of elements
    xy = reform(l(k:k+m-1), 2, j)
    WIDGET_CONTROL, st.xy, SET_UVALUE=xy, /NO_COPY
endif else m = 0

st.p = p			;Get the object...

m = (m+psize-1)/psize		;# of addtl rows
; print, 'loaded',obj,', rows ',m,', n =',n
if n eq (m+1) then l = 0 $	;last object
else BEGIN			;Remove this object
    v = replicate(1,n)
    v(obj:obj+m) = 0		;Rows we remove
    l = l(*,where(v))
ENDELSE

WIDGET_CONTROL, st.objlist, SET_UVALUE = l, /NO_COPY  ;Restore list
ann_refresh_list, st, window=st.backing(1), /FROM_SCRATCH
ann_set_controls, st, p		;Reset the controls
return, 1
end

	

pro ann_xfer_file, st, file, SAVE=save, LOAD=load
; Transfer an annotate load/save file.

WIDGET_CONTROL, st.objlist, GET_UVALUE=l, /NO_COPY	;Current object list
psize = n_elements(st.p)
n = n_elements(l) / psize
magic = '414e4e00'XL

if keyword_set(save) then begin	;Save??
    if n eq 0 then begin
	i = CW_CONFIRM('There is nothing to save.', 'OK')
	WIDGET_CONTROL, st.objlist, SET_UVALUE=l, /NO_COPY
	return
	endif

    openw, unit, /GET_LUN, file, /XDR  ;Make the file
    writeu, unit, magic, psize	;Magic number, # of columns
    p = float([ !d.x_size, !d.y_size, !d.x_ch_size, !d.y_ch_size ])  ;Params
    writeu, unit, p

    for i=0L, n-1 do begin		;Write each object
	p = l(*,i)			;The object
	m = 0				;# of addtl elements
	k = (i+1) * psize		;Next row
	writeu, unit, p			;The array
	if p(19) eq 0 then begin	;Text?
	    m = long(p(11))		;Strlen
	    writeu, unit, byte(l(k:k+m-1))  ;The characters
	endif else if p(19) eq 2 then begin  ;Polygon?
	    m = long(p(11))*2
	    writeu, unit, l(k:k+m-1)	;The points
	endif
	i = i + (m+psize-1)/psize
	endfor
    writeu, unit, replicate(-1.0, psize)
    free_lun, unit
    WIDGET_CONTROL, st.objlist, SET_UVALUE=l, /NO_COPY  ;Restore

endif else begin				;LOAD
    openr,unit, /GET_LUN, file, /XDR, ERROR=i  ;Try to open it...
    if i lt 0 then begin		;No file..
	i = CW_CONFIRM(['File not found or unreadable', file], 'OK')
	return
	endif
    i = 0L			;Read magic
    columns = 0L
    readu, unit, i, columns
    if i ne magic then begin
	i = CW_CONFIRM(['File is not an annotate data file.', file], 'OK')
	return
	endif
    params = fltarr(4)
    readu, unit, params

    while 1 do begin		;Read each record
	p = fltarr(columns)
	readu, unit, p
;	print, p(19)
	if p(19) eq -1 then begin	;Done....
	    free_lun, unit
	    WIDGET_CONTROL, st.objlist, SET_UVALUE = l, /NO_COPY ;save list
	    ann_refresh_list, st, WINDOW=st.backing(1), /FROM_SCRATCH
	    wset, st.draw_win
	    device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, st.backing(1)]
	    return
	    endif
	m = 0L
	if p(19) eq 0 then begin	;string
	    m = long(p(11))		;# of addtl elements
	    a = bytarr(m)
	    readu, unit, a
	    p = [[p], [fltarr(psize, (m+psize-1)/psize)]]  ;what we add
	    p(psize) = a		;Insert chars....
	endif else if p(19) eq 2 then begin	;polygon
	    m = long(p(11))*2		;# of addtl elements
	    a = fltarr(m)
	    readu, unit, a
	    p = [[p], [fltarr(psize, (m+psize-1)/psize)]]  ;what we add
	    p(psize) = a
	endif
;		Adjust size for possible expansion....
	if columns lt psize then p = [p, fltarr(columns-psize)] $
	else if psize lt columns then p = p(0:psize-1)

	if n_elements(l) gt 1 then l = [[temporary(l)], [p]] $
	else l = p
	endwhile
endelse
end

pro annotate_ps, st, draw_ps, include_image

tvlct, r,g,b, /get              ;current color table
old = !d.name			;Current device name

if include_image then begin
    file = PICKFILE(FILE='annotate.ps', /WRITE, FILTER='*.ps', /NOCONF)
    if draw_ps then WSET, st.backing(0) $ ;Original image
    else WSET, st.backing(1)	;image + our annotations
    a = tvrd()
    endif

width = st.ps_width		;Output width
ch = [!d.x_ch_size, !d.y_ch_size] / float([!d.x_size, !d.y_size])
if st.ps_units then width = width / 2.54	;From cm to inches
height = width * !d.y_size / !d.x_size	;Height	
SET_PLOT,'PS'

if include_image then begin	;Include image with new file?
    DEVICE, file=file, COLOR=st.ps_color
    if st.ps_orien then DEVICE, /LANDSCAPE $
    else DEVICE, /PORTRAIT
    DEVICE, XSIZE = width, YSIZE=height, /INCHES	;Set size
    tvlct,r,g,b
    if st.ps_color eq 0 then begin	;To BW from RGB
	l = bytscl(r * .3 + .6 * g + .11 * b)
	a = l(a)
	endif
    tv, a                   ;Output image
    endif

if draw_ps then begin
    device, set_char = ch * !d.x_size  ;Proportional char size (aspect = same)
    ann_refresh_list, st, MONO = l
    endif

if include_image then device, /close
set_plot, old               ;done
end


pro annotate_event, ev

WIDGET_CONTROL, ev.top, GET_UVALUE = st, /NO_COPY   ;Our data structure
WIDGET_CONTROL, ev.id, GET_UVALUE = u		;The object uvalue

ldr = strmid(u, 0, 1)
IF ldr eq 'M' THEN BEGIN		;New mode?
    ann_reset_mode, st, fix(strmid(u,1,2)), 0
    goto, done
    ENDIF

IF ldr eq '#' THEN BEGIN
    WIDGET_CONTROL, ev.id, GET_VALUE = v
    ldr = '@'
ENDIF

IF ldr eq '@' THEN BEGIN		;Execute string?
	i = EXECUTE(strmid(u,2,100))	;Execute the string....
	IF strmid(u, 1, 1) eq 'R' THEN BEGIN ;Redraw?
redraw:   if st.open then begin
	    wset, st.draw_win
	    handle = st.minor_mode eq 1
	    p = st.p
	    ANN_DRAW_OBJECT, st, p, handle, REFRESH=st.backing(1)
	    st.p = p
	    st.handle = handle
	    ENDIF
	ENDIF		;Redraw
ENDIF ELSE IF u eq 'Help' THEN BEGIN	;ldr eq '@'
	xdisplayfile, filepath("annotate.txt", subdir=['help', 'widget']), $
;	xdisplayfile, 'annotate.txt', $
		title = "Annotate Help", $
		group = ev.top, $
		width = 72, height = 24
ENDIF else if u eq 'Options' THEN BEGIN
	m = st.mode_bases
	WIDGET_CONTROL, m(st.mode), MAP=0
	WIDGET_CONTROL, m(n_elements(m)-1), /MAP
ENDIF else if u eq 'Dismiss' THEN BEGIN
	m = st.mode_bases
	WIDGET_CONTROL, m(n_elements(m)-1), MAP=0
	WIDGET_CONTROL, m(st.mode), MAP=1
ENDIF ELSE IF u eq 'TOPROW' THEN BEGIN
    WIDGET_CONTROL, ev.top, /HOURGLASS
    case ev.value of
   'Exit' : BEGIN
	    for i=0,1 do wdelete, st.backing(i)
	    widget_control, ev.top, /DESTROY
	    return
	    ENDCASE
    'Save' : BEGIN
    save_file:	   if st.open then ann_add_object, st	;Add current object?
	   ann_xfer_file, st, st.file, /SAVE
	   ENDCASE
    'Save As': BEGIN
	st.file = PICKFILE(FILE=st.file, /WRITE)
	goto, save_file
	ENDCASE
    'Load': BEGIN
	st.file = PICKFILE(FILE=st.file, /READ, /MUST_EXIST, FILTER='*.dat')
	ann_xfer_file, st, st.file, /LOAD
	ENDCASE
    'TIFF': BEGIN
	file = PICKFILE(FILE='annotate.tif', /WRITE, FILTER='*.tif', /NOCONF)
	WSET, st.backing(1)
	tvlct, red, green, blue, /GET
	TIFF_WRITE, file, tvrd(/ORDER), 1, RED=red, GREEN=green, BLUE=blue
	ENDCASE
    'GIF': BEGIN
	file = PICKFILE(FILE='annotate.gif', /WRITE, FILTER='*.gif', /NOCONF)
	WSET, st.backing(1)
	WRITE_GIF, file, tvrd(ORDER=0)
	ENDCASE
    'PostScript': annotate_ps, st, 0, 1		;Postscript bitmap
    'Everything': annotate_ps, st, 1, 1		;do it with PS commands
    'Objects only': annotate_ps, st, 1, 0
    'Clear': BEGIN
	    WIDGET_CONTROL, st.objlist, SET_UVALUE=0  ;Clean up object list
	    wset, st.backing(1)		;redraw all objects except this one
	    device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, st.backing(0)]
	    wset, st.draw_win
	    device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, st.backing(0)]
	    ann_reset_mode, st, st.mode, 0
	ENDCASE
    ENDCASE
ENDIF ELSE IF u eq 'Save' THEN BEGIN
    if st.open THEN ann_add_object, st
ENDIF ELSE help, /st, u, ev


done: WIDGET_CONTROL, ev.top, SET_UVALUE = st, /NO_COPY
end


PRO ANN_MOVE_RESIZE, st, mode, first, last

if st.open eq 0 then return
handle = st.handle
pos = st.pos
p = st.p
if first then begin		;Initial hit?
    np = ([2,2,4,4,4])(mode)	;# of points
		;distances from handle points and midpoint
    h = handle(*,0:np-1)
    d = [[h], [total(h,2)/np]] - (pos # replicate(1.,np+1))
    d = min(total(d^2, 1), i)	;Dist squared, get closest
    if i eq np then i = 5	;always use 5 for last point
    if d lt 0.01 then begin	;Close enough?
	st.ihandle = i
	if mode eq 0 then begin	;Text mode?
	    if p(7) eq 0.0 then p(7) = 1.0	;Size
	    st.temp(0) = p(7) / p(2)		;1./(Length of siz=1)
	 endif else if mode eq 3 then begin	;Circle?  Save params.
	    c = p(2:3)
	    st.temp = [p(0:1) - c, total((pos - c)^2)]  ;dx,dy, len
	endif
        if i ne 5 then st.orig = handle(*,np-1-i) $  ;Anchor point
	else st.orig = pos
    endif else st.ihandle = -1
endif					;First

ihandle = st.ihandle
if ihandle lt 0 then return		;A hit?
d = pos - st.orig		;Movement
; if d(0) eq 0.0 and d(1) eq 0.0 and first eq 0 then goto, no_move

if ihandle eq 5 then begin		;Move?
    st.orig = pos		;Reset it
    if mode eq 2 then begin	;Polygons?
	if p(11) gt 1 THEN BEGIN   ;Polygons
	    WIDGET_CONTROL, st.xy, GET_UVALUE=xy, /NO_COPY
	    xy = xy + (d # replicate(1, p(11)))  ;Translate
	    WIDGET_CONTROL, st.xy, SET_UVALUE=xy, /NO_COPY
	    ENDIF
    endif else p(0) = p(0:3) + [d,d]  ;Just move origin
ENDIF ELSE BEGIN			;Sizing handle
    if (mode gt 1) then begin		;Need scale factor?
	s = handle(*,ihandle) - st.orig	;stretch factor
	if min(abs(s)) lt 0.001 then goto, no_move
	s = (pos - st.orig) / s	  ;Scale factor
	if min(abs(s)) lt 0.001 then goto, no_move
    endif
    case mode of
0:	BEGIN			;Text
	r = sqrt(total(d^2))		;Length of line
	if r lt 0.001 then goto, no_move
	p(14) = atan(d(1), d(0)) * !radeg	;New orientation
	if ihandle eq 0 then p(14) = p(14) + 180.
	p(7) = r * st.temp(0)		;New size
	k = long(3 * ihandle + 2 * p(12)) ;Subs from 0 to 5.
	p(0) = pos + ([0, -0.5, -1., -1, -0.5, 0])(k) * d
	ENDCASE
1:	p(ihandle * 2) = pos		;Line, just move vertex
2:	if p(11) gt 1 THEN BEGIN	;Polygon, Scale all verts
	    WIDGET_CONTROL, st.xy, GET_UVALUE=xy, /NO_COPY
	    xy0 = st.orig # replicate(1.0,p(11))
	    xy = (xy - xy0) * (s # replicate(1.0,p(11))) + xy0
	    WIDGET_CONTROL, st.xy, SET_UVALUE=xy, /NO_COPY
	    ENDIF
3:	BEGIN			;Circle
	    c = p(2:3)		;Center
	    r = sqrt(total((pos - c)^2)/st.temp(2))  ;Dist from ctr
	    p(0) = st.temp(0:1) * r + c
	ENDCASE
4:	BEGIN			;Rectangle
	    x0 = [st.orig, st.orig]
	    p(0) = (p(0:3) - x0) * s([0,1,0,1]) + x0
	ENDCASE
    ENDCASE
ENDELSE

no_move:
    ANN_DRAW_OBJECT, st, p, handle, REFRESH=st.backing(1)  ;Refresh
    st.p = p
    st.handle = handle
END			;ANN_MOVE_RESIZE




PRO ANN_DRAW_EVENT, ev, ann_base	;Handle events from drawable

if n_elements(ann_base) eq 0 then $
	WIDGET_CONTROL, ev.id, GET_UVALUE = ann_base
WIDGET_CONTROL, ann_base, GET_UVALUE=st, /NO_COPY
mode = st.mode

WSET, st.draw_win
if ev.press eq 4 then begin	;Right button to close object
	if st.open then ann_add_object, st
	goto, skip_it
endif else if ev.press eq 2 then begin
	if st.open eq 0 then goto, skip_it
	i = st.minor_mode eq 0	;Switch modes
        st.minor_mode = i	;Reset minor mode
	WIDGET_CONTROL, st.minor_mode_id, SET_VALUE=i
	p = st.p
	ANN_DRAW_OBJECT, st, p, i, REFRESH=st.backing(1)
	st.handle = i
	goto, skip_it
endif

pos = [ev.x, ev.y]

first = 0
drag = 0
last = 0
if st.buttons eq 0 then begin	;First time?
  if ev.press ne 1 then begin	;Move?
	if !x.s(1) ne 0 then pos = convert_coord(pos, /DEVICE, /TO_DATA)
	WIDGET_CONTROL, st.instruct, SET_VALUE=string(pos(0:1))
	goto, skip_it
  endif else begin
	first = 1
	WIDGET_CONTROL, st.instruct, SET_VALUE='Right button to close'
	st.buttons = 1
  endelse
endif else begin		;Not first
  if ev.release ne 1 then drag = 1 $
  else begin
	last = 1
	st.buttons = 0
  endelse
endelse


g = st.granularity
pos = round(pos/g)*g / [!d.x_size, !d.y_size]
if drag and (st.pos(0) eq pos(0)) and (st.pos(1) eq pos(1)) then goto, skip_it
st.pos = pos


if st.minor_mode eq 1 then begin	;MOVE/RESIZE
    ANN_MOVE_RESIZE, st, mode, first, last
    goto, skip_it
ENDIF ELSE if st.minor_mode eq 2 then begin	;Select
    if first then begin
	ann_reset_mode, st, st.mode, 2
	k = ann_closest_obj(st)
	if k ge 0 then begin		;Found one?
	   st.temp(0) = k
	   if ann_load_obj(st, k) then begin	;Find it?
		p = st.p
		st.minor_mode = 1	;Now in move/resize
		ann_reset_mode, st, p(19), 1, /NOCLEAN
		st.open = 1
		h = 1
		wset, st.draw_win
		ANN_DRAW_OBJECT, st, p, h, REFRESH=st.backing(1)
		st.handle = h
		ANN_MOVE_RESIZE, st, st.mode, first, last
		endif
	endif
    endif
    goto, skip_it
ENDIF			;Minor = 2

p = st.p

if st.open eq 0 then begin	;First time
	p(11) = 0
	WIDGET_CONTROL, st.fill_mode_id, SET_VALUE=0
	WIDGET_CONTROL, st.minor_mode_id, SET_VALUE=0
	st.fill_mode = 0
	st.minor_mode = 0
	ENDIF
st.open = 1

case mode of
0: BEGIN			;Text
    IF first THEN BEGIN
	WIDGET_CONTROL, st.txt_id, GET_VALUE=h
	st.txt = h(0)
	ENDIF
no_name_label:
    if first then p(2) = pos
    p(0) = pos
    h = last
    ANN_DRAW_OBJECT, st, p, h, REFRESH=st.backing(1)
    if last then begin
	st.handle = h
	st.minor_mode = 1		;Go to move resize mode
	WIDGET_CONTROL, st.minor_mode_id, SET_VALUE=1
	endif
   ENDCASE

1: goto, no_name_label		;Dragging line or arrow


2:  BEGIN			;Polygon/polyline
    n = long(p(11))
    if n eq 0L THEN BEGIN	;Initialize line buffer?
	xy = FLTARR(2,256)
	ENDIF ELSE WIDGET_CONTROL, st.xy, GET_UVALUE=xy, /NO_COPY
   case st.fill_mode of		;What are we doing?
   0: BEGIN		;Vector /drag mode
	if n_elements(xy) le n*2 then xy = [[xy], [FLTARR(2,n)]]  ;Extend it
	xy(0,n) = st.pos	;Last point
	if st.buttons then p(11) = n+1 	;Dragging
      ENDCASE		;Vector	
   1: BEGIN		;Edit mode
	if n eq 0 then goto, skip_it1
	if first then begin
		if n_elements(xy) le n*2 then xy = [[xy], [FLTARR(2,n)]]
		j = ann_closest(xy, n, pos)
		xy(0,n) = j
	endif else j = xy(0,n)
	xy(0,j) = pos		
      ENDCASE
   2: BEGIN		;Delete
	if (n le 0) or (last eq 0) then goto, skip_it1
	j = ann_closest(xy, n, pos)	;Point to delete
	p(11) = n-1
	if n eq 1 then goto, skip_it
	if j eq 0 then xy = xy(*,1:*) $
	else if j eq n-1 then xy = xy(*, 0:n-2) $
	else xy = [[xy(*,0:j-1)], [xy(*, j+1:*)]]
      ENDCASE		;delete
  ENDCASE		;st.fill_mode
  WIDGET_CONTROL, st.xy, SET_UVALUE=xy, /NO_COPY
  ANN_DRAW_OBJECT, st, p, REFRESH=st.backing(1)
 ENDCASE		;2

3: goto, no_name_label		;Circle


4: goto, no_name_label		;Box
ENDCASE

skip_it:
    if n_elements(p) gt 1 then st.p = p
    WIDGET_CONTROL, ann_base, SET_UVALUE=st, /NO_COPY
    return
skip_it1:
    WIDGET_CONTROL, st.xy, SET_UVALUE=xy, /NO_COPY
    goto, skip_it
end



pro ANN_DRAW_OBJECT, st, p, handle, REFRESH = refresh, XY=xy, MONO = mono

c = long(p(4))			;Color index
if keyword_set(mono) then c = mono(c)	;Outputting Postscript for BW?

if n_elements(refresh) gt 0 then $  ;Refresh?
	device, copy = [0,0, !d.x_size, !d.y_size, 0, 0, refresh]

case p(19) of		;What type of object
0: BEGIN		;Text
	str = '!' + strtrim(fix(p(13))>3,2) + st.txt + '!3'
	xyouts, p(0), p(1), /NORM, str, $
		COLOR = c, CHARSIZE = p(7), $
		ALI = p(12), ORI=p(14), CHARTHICK = p(5), WIDTH=x
	p(2) = x 		;Save width
	if keyword_set(handle) then begin
	    dx = cos(p(14)* !dtor) * x
	    dy = sin(p(14)* !dtor) * x
	    handle = [[ p(0)-p(12) * dx, p(1)-p(12) * dy], $
		[p(0) + (1.-p(12)) * dx, p(1) + (1.-p(12)) * dy]]
	    n = 2
do_handle:  PLOTS, handle, /NORM, PSYM=6
	    PLOTS, total(handle,2)/n, /NORM, PSYM=6  ;The center
	    ENDIF
   ENDCASE

1: BEGIN
    if p(17) ne 0 THEN BEGIN	;Lines/Arrows
	if p(15) le 0.0 then p(15) = 1.0
	ARROW, p(2), p(3), p(0), p(1), /NORM, $
		COLOR = c, THICK = p(5), SOLID=p(17) eq 2, $
		HSIZE = p(15) * !D.X_SIZE/20.
    ENDIF ELSE PLOTS, p([2,0]), p([3,1]), /NORM, COLOR=c, THICK=p(5), $
		LINESTYLE=p(6)
    if keyword_set(handle) then begin
	n = 2
	handle = [[p(0), p(1)], [p(2), p(3)]]
	goto, do_handle
	ENDIF
   ENDCASE

2: BEGIN		;Polygon
	n = p(11)
do_fill:
	if n gt 1 THEN BEGIN
	   if n_elements(xy) le 1 then WIDGET_CONTROL, st.xy, GET_UVALUE = xy
	   if (p(19) eq 2) and (p(20) eq 1) and (n gt 2) then $  ;Splines?
	       spline_p, reform(xy(0,0:n-1)), reform(xy(1,0:n-1)), $
			x, y, INTERV= 0.01 $
	   else begin			;Not splines
		x = xy(0,0:n-1)
		y = xy(1,0:n-1)
	   endelse
	   if (p(8) ne 1) or (n eq 2) THEN BEGIN   ;Outline it?
		plots, x, y, /NORM, COLOR = c, $  ;Draw outline
		    THICK = p(5), LINESTYLE = p(6)
		if p(8) eq 2 THEN BEGIN  ;line fill?
		   plots, x([n-1,0]), y([n-1,0]), /NORM, COLOR = c, $ ;Close it
		    THICK = p(5), LINESTYLE = p(6)
		   if n ge 3 THEN POLYFILL, x, y, /NORM, COLOR = c, $
			THICK = p(5), ORI = p(10), SPACING = p(9)/100.
		ENDIF
	  ENDIF ELSE IF N GE 3 THEN $		;Solid fill
		POLYFILL, x,y, /NORM, COLOR = c
	  ENDIF
	if keyword_set(handle) then begin	;Draw resizing handles
	   xmin=min(x, max=xmax)
	   ymin=min(y, max=ymax)
	   n = 4
	   handle = [[xmin, ymin], [xmin, ymax], [xmax,ymin],[xmax, ymax]]
	   goto, do_handle
	   ENDIF
   ENDCASE
3: BEGIN		;Circle/ Ellipse
	a = !d.x_size / float(!d.y_size)	;Aspect ratio
	dx = p(0) - p(2)
	dy = p(1) - p(3)
	r = sqrt(dx^2 + dy^2)
	if r eq 0.0 then return
	dx = dx/r
	dy = dy/r
	n = 128
	t = findgen(n) * (( 2 * !pi)/ (n-1))	;Angles..
;			The whole ball of wax
	xy = [[cos(t) * r], [sin(t) * r/p(18)]] # [[dx, -dy],[dy, dx]]
	xy = reform([p(2) + xy(*,0), p(3) + a*xy(*,1)], n,2,/OVER)
	xy = transpose(xy)
	goto, do_fill
   ENDCASE	;Circle
4: BEGIN	;Box
	xy = p([[0,1],[0,3],[2,3],[2,1],[0,1]])
	n = 5
	goto, do_fill
   ENDCASE
else: print,'Unknown object'
ENDCASE

end



pro ann_make_draw_button, st
; Make mode buttons
a = widget_base(st.base, /ROW, Exclusive=!version.os ne 'Win32')
id = lonarr(n_elements(st.mode_buttons))	;Id arrays

wsize = 32
window, xsize=wsize, ysize=wsize, /pix, /free
w2 = wsize/2			;Handy constants
w9 = 9*wsize/10
w1 = wsize/10
w3 = wsize/3

xyouts, w1, wsize/4, 'Abc', /dev, chars= wsize/(3.2* !d.x_ch_size)	;Text
id(0) = WIDGET_BUTTON(a, /NO_REL, value= b_button(tvrd()))
erase

arrow, w1, w3, w9, w3, /device, hsize = 10	;Arrows/ lines
plots, [w1, w9], wsize - [w3, w3], lines=3, /DEV
id(1) = WIDGET_BUTTON(a, /NO_REL, value= b_button(tvrd()))
erase

polyfill, [w1,w2,w1], [w1, w9, w9], /dev	;Polygons
plots, [ 2, 4, 6, 8, 10, 12, 10, 8, 8]*wsize/16, $	;Drag/Draw
       [ 1, 3, 7, 9, 9,  11, 16, 14, 6]*wsize/20, /dev
id(2) = WIDGET_BUTTON(a, /NO_REL, value= b_button(tvrd()))
erase


n = 32				;Circles
t = findgen(n) *(2 * !pi / (n-1))
plots, wsize/3 * cos(t) + (w2), wsize/3 * sin(t) + w2, /dev
id(3) = WIDGET_BUTTON(a, /NO_REL, value= b_button(tvrd()))
erase

plots, [w1,w1, w9, w9, w1], [w1, w9, w9, w1, w1], /dev   ;Squares
id(4) = WIDGET_BUTTON(a, /NO_REL, value= b_button(tvrd()))
erase

for i=0, n_elements(id)-1 do $		;Set up uv = Mn
	WIDGET_CONTROL, id(i), SET_UVALUE='M'+strtrim(i,2)
WIDGET_CONTROL, id(0), /SET_BUTTON	;Set initial choice
wdelete
st.mode_buttons = id
end





PRO ANNOTATE, DRAWABLE = draw, WINDOW = window, LOAD_FILE=load_file, $
	COLOR_INDICES=color_indices, TEK_COLORS = tek_colors

;+
; NAME:
;	ANNOTATE
;
; PURPOSE:
;	This procedure is a general purpose drawing program/widget to
;	annotate displays. Drawing objects include text, lines, arrows,
;	polygons, rectangles, circles, and ellipses.
;
; CATEGORY:
;	Widgets.  Will also work with plain windows.
;
; CALLING SEQUENCE:
;	ANNOTATE
;
; INPUTS:
;	No required inputs.
;
; KEYWORD PARAMETERS:
;	COLOR_INDICES:	an array of color indices from which the user
;			can choose colors. For example, to allow the user
;			to choose 10 colors, spread evenly over the
;			available indices, set the keyword as folows:
;			COLOR_INDICES = INDGEN(10) * (!D.N_COLORS-1) / 9
;	DRAWABLE:	the widget ID of the draw widget for the annotations.
;			This is mutually exclusive with WINDOW.
;	LOAD_FILE:	the name of an annotation format file to load after
;			initialization.
;	TEK_COLORS:	if set, the Tektronix color table is loaded
;			starting at color index TEK_COLORS(0), with
;			TEK_COLORS(1) color indices. The Tektronix color
;			table contains up to 32 distinct colors suitable
;			for graphics.
;	WINDOW:		the window index number of the window to receive the
;			annotations.
;
; OUTPUTS:
;	This procedure has no explicit outputs. Menu choices exist to
;	write TIFF, GIF, or PostScript bitmap files. Encapsulated
;	or standalone PostScript files may also be created.
;
; SIDE EFFECTS:
;	Annotations are made in the designated window or draw widget.
;
; RESTRICTIONS:
;	This is a simple drawing program.
;
; PROCEDURE:
;	If neither TEK_COLORS or COLOR_INDICES are specified, the default
;	is to load 10 colors, evenly distributed over those available.
;
;	If neither WINDOW or DRAWABLE are specified, the current window
;	is used.
;
; EXAMPLE:
;	TVSCL, HANNING(300,200)	;Output an image in the current window
;	ANNOTATE		;Annotate it
;
; MODIFICATION HISTORY:
;	DMS, RSI, July, 1993.  Original version.
;-



nmodes = 5
sl_width = 128

st = { ANN_STATE, $
    mode : 0, $
    minor_mode_id: 0L, $
    minor_mode: 0, $
    p: fltarr(21), $		;General params
    open : 0, $			;NE 0 if an object is open
    base : 0L, $
    current: 0L, $		;Current object if saved on list
    objlist : 0L, $		;object container
    xy: 0L, $
    pos:  fltarr(2), $		;Current position
    orig: fltarr(2), $		;Beginning of drag
    txt: 'Text',$		;Current contents of text widget
    mode_buttons: lonarr(nmodes), $
    mode_bases : lonarr(nmodes+1), $
    draw_win : 0L, $
    backing : lonarr(2), $	;0 = original bitmap, 1 = with closed objects
    color_id: 0L, $
    thick_id: 0L, $
    txt_id: 0L, $
    txt_size_id: 0L, $
    txt_ali_id: 0L, $
    txt_font_id: 0L, $
    ori_id: 0L, $
    linestyle_id : 0L, $
    buttons: 0L, $
    granularity : 1.0, $
    instruct: 0L, $
    line_arrow_id: 0L, $
    head_size_id: 0L, $
    fill_mode_id: 0L, $
    fill_mode: 0, $
    handle: fltarr(2,4), $
    temp: fltarr(3), $
    poly_style: lonarr(nmodes), $
    poly_angle: lonarr(nmodes), $
    poly_spacing: lonarr(nmodes), $
    ecc_id: 0L, $
    spline_id: 0L, $
    file: 'annotate.dat', $
    ihandle: 0, $
    ps_encap: 0, $
    ps_color: 0, $
    ps_orien: 0, $
    ps_width: 5.0, $
    ps_units: 0 }

st.p(18) = 1.0	;Eccent

ann_base = WIDGET_BASE(title='Annotate', /COLUMN)	;Our base
st.base = ann_base

win = !d.window		;Default window
use_xmgr = 0
if n_elements(window) eq 1 then win = window $
else if n_elements(draw) eq 1 then begin
	widget_control, draw, get_value = win, EVENT_PRO = 'ANN_DRAW_EVENT', $
	    SET_UVALUE = ann_base
	use_xmgr = 1
	endif
if win lt 0 then message,'No draw window active'
st.draw_win = win


wset, win
nx = !d.x_size
ny = !d.y_size

for i=0,1 do begin		;Get 2 backing pixmaps.
    window, /FREE, /PIXMAP, xs = nx, ys = ny
    device, copy = [0,0,nx, ny, 0, 0, win]  ;Copy original window
    st.backing(i) = !d.window
    endfor


st.objlist = WIDGET_BASE(ann_base, UVALUE = 0, $	;Object list holder
    xsize = 2, ysize=2)
st.xy = WIDGET_BASE(ann_base, UVALUE = 0, $	;Polygon points holder
    xsize = 2, ysize=2)

junk = WIDGET_BASE(ann_base, /ROW)
tmp = CW_PDMENU(junk, /RETURN_NAME, UVALUE='TOPROW', [ $
	{CW_PDMENU_S, flags: 1, name: 'File'}, $
	{CW_PDMENU_S, flags: 0, name: 'Load'}, $
	{CW_PDMENU_S, flags: 0, name: 'Save'}, $
	{CW_PDMENU_S, flags: 0, name: 'Save As'}, $
	{CW_PDMENU_S, flags: 1, name: 'Write PostScript'}, $
	{CW_PDMENU_S, flags: 0, name: 'Everything'}, $
	{CW_PDMENU_S, flags: 2, name: 'Objects only'}, $
	{CW_PDMENU_S, flags: 1, name: 'Export Bitmap'}, $
	{CW_PDMENU_S, flags: 0, name: 'GIF'}, $
	{CW_PDMENU_S, flags: 0, name: 'PostScript'}, $
	{CW_PDMENU_S, flags: 2, name: 'TIFF'}, $
	{CW_PDMENU_S, flags: 0, name: 'Clear'}, $
	{CW_PDMENU_S, flags: 2, name: 'Exit'}])

tmp = WIDGET_BUTTON(junk, value='Help', UVALUE='Help', /NO_REL)
tmp = WIDGET_BUTTON(junk, value='Options', UVALUE='Options', /NO_REL)

junk = WIDGET_BASE(ann_base, /ROW)
tmp = WIDGET_BUTTON(junk, VALUE='Save', UVALUE='Save', /NO_REL)
st.minor_mode_id = CW_BGROUP(junk, /EXCLUSIVE, /ROW, /NO_REL, $
	LABEL_LEFT = 'Mode:', $
	['Draw', 'Edit','Select'], $
        UVALUE='@Rst.minor_mode = ev.value', SET_VALUE=0)

ann_make_draw_button, st

scolor = 0
ncolors = 10
if n_elements(tek_colors) ge 1 then begin
    scolor = tek_colors(0)
    if n_elements(tek_colors) ge 2 then ncolors = tek_colors(1) else ncolors=8
    color_indices = indgen(ncolors) + scolor
endif else if n_elements(color_indices) gt 0 then begin
	ncolors = n_elements(color_indices)
endif else begin
	color_indices = (!d.n_colors-1) * lindgen(ncolors) / (ncolors-1)
endelse

st.color_id = CW_CLR_INDEX(ann_base, LABEL = 'Color:', XSIZE=160, $
	NCOLORS = ncolors, START_COLOR = scolor, $
	COLOR_VALUES=color_indices, uvalue = '@Rst.p(4) = ev.value')
st.p(4) = color_indices(ncolors-1)	;Init color

junk = WIDGET_BASE(ann_base, /ROW)
st.linestyle_id = CW_BSELECTOR(junk, LABEL_TOP = 'Linestyle:', $
	['Solid', 'Dots', 'Dashes', 'Dash-Dot', 'Dash-3 Dots', $
	'Long Dash'], uvalue = '@Rst.p(6) = ev.value')
st.thick_id = WIDGET_SLIDER(junk, XSIZE = sl_width, MIN=0, $
	MAX=200, TITLE = 'Thickness', /DRAG, $
	UVALUE='@Rst.p(5) = ev.value/10.')

st.instruct = WIDGET_TEXT(ann_base, value = ' ', xsize=32, ysize=1, /FRAME)

tmp_base = WIDGET_BASE(ann_base, /FRAME)
for i=0, nmodes do BEGIN
	base = WIDGET_BASE(tmp_base, /COLUMN)
	st.mode_bases(i) = base
	WIDGET_CONTROL, base, map = i eq 0
	ENDFOR

;
; Text widget
top = st.mode_bases(0)
junk = WIDGET_BASE(top, /ROW)
junk1 = WIDGET_LABEL(junk, Value = 'Text: ')
st.txt_id = WIDGET_TEXT(junk, xs = 32, ys = 1, /frame, /edit, $
	uvalue = '#Rst.txt=v(0)', value=st.txt)
junk = WIDGET_BASE(top, /ROW)
st.txt_size_id = WIDGET_SLIDER(junk, TITLE='Size', Value=0, XSIZE = sl_width, $
	MAX=100, MIN=0, /DRAG, UVALUE = '@Rst.p(7) = ev.value/10.')
st.ori_id = WIDGET_SLIDER(junk, TITLE='Orientation', Value = 0, $
	MAX = 360, min = 0, /DRAG, UVALUE = '@Rst.p(14) = ev.value', $
	XSIZE = sl_width)

st.txt_ali_id = CW_BGROUP(top, LABEL_LEFT='Alignment:', /EXCLUSIVE, /ROW, $
	['Left', 'Center', 'Right' ], SET_VALUE=0, /NO_REL, $
	UVALUE='@Rst.p(12) = ev.value/2.')
fonts = ['Simplex Roman  ', 'Simplex Greek', 'Duplex Roman', $
	'Complex Roman', 'Complex Greek', 'Complex Italic', $
	'Math & Special', 'Special', 'Gothic', 'Script', 'Complex Script', $
	'Gothic Italian', 'Gothic German', 'Cyrillic', 'Triplex Roman', $
	'Triplex Italic']
junk = WIDGET_BASE(top, /ROW)
junk1 = WIDGET_LABEL(junk, VALUE = 'Font:')
st.txt_font_id = CW_BSELECTOR(junk, fonts, $
	uvalue = '@Rst.p(13) = ev.value + 3')

; Arrow Widget
top = st.mode_bases(1)
junk = WIDGET_BASE(top, /ROW)
st.line_arrow_id = CW_BGROUP(junk, /EXCLUSIVE, /ROW, /NO_REL, $
	['Line','Arrow', 'Solid Arrow'],  $
	UVALUE='@Rst.p(17)=ev.value', SET_VALUE=0, LABEL_LEFT='Mode:')
st.head_size_id = WIDGET_SLIDER(top, TITLE='Head Size', VALUE = 0, $
	XSIZE=sl_width, MAX=100, /DRAG, UVALUE='@Rst.p(15) = ev.value/10.')


	
; Polygon Widget
top = st.mode_bases(2)
st.fill_mode_id = CW_BGROUP(top, /EXCLUSIVE, /ROW, LABEL_LEFT = 'Mode:', $
	['Draw', 'Edit', 'Delete'], /NO_REL, $
        UVALUE='@Rst.fill_mode = ev.value', SET_VALUE=0)


; Circle widget
top = st.mode_bases(3)
st.ecc_id = WIDGET_SLIDER(top, TITLE='Eccentricity', VALU=0, /DRAG, $
        XSIZE=sl_width, MIN=0, MAX=100, UVALUE='@Rst.p(18)=ev.value/10.+1')

; Square Widget  has nothing unique


for i=2, nmodes-1 do  begin	;Make polyfill controls for the bases
    top = st.mode_bases(i)
    st.poly_style(i) = CW_BGROUP(top, /EXCLUSIVE, /ROW, $
	LABEL_LEFT = 'Fill: ', /NO_REL, $
	['None', 'Solid', 'Lines'],  $
        UVALUE='@Rst.p(8)=ev.value', SET_VALUE=0)
    if i eq 2 then $
	st.spline_id = CW_BGROUP(top, /EXCLUSIVE, /ROW, /NO_REL, $
		LABEL_LEFT='Interpolation:', ['None', 'Spline'], $
		UVALUE='@Rst.p(20)=ev.value', SET_VALUE=0)
    junk = WIDGET_BASE(top, /ROW)
    st.poly_angle(i) = WIDGET_SLIDER(junk, TITLE='Line Angle', VALU=0, /DRAG, $
        MIN=0, MAX=180, UVALUE='@Rst.p(10)=ev.value', XSIZE=sl_width)
    st.poly_spacing(i) = WIDGET_SLIDER(junk, TITLE='Line Spacing', $
	VALU=0, /DRAG, MIN=0, MAX=50, UVALUE='@Rst.p(9)=ev.value', $
	XSIZE=sl_width)
    endfor



;*******************************************



; Options Widget
top = st.mode_bases(nmodes)
junk = WIDGET_BASE(top, /ROW)
junk1 = WIDGET_LABEL(junk, value = 'Grid granularity:')
junk1 = WIDGET_TEXT(junk, /EDIT, /FRAME, xsize=4, ysize=1, value='1', $
	UVALUE = '# st.granularity=ann_get_num(v(0), ev.id, 1, 128)')

junk = WIDGET_BASE(top, /COLUMN, /FRAME)
junk1 = WIDGET_LABEL(junk, VALUE= 'PostScript Options')
junk1 = WIDGET_BASE(junk, /ROW)
junk2 = CW_BGROUP(junk1, /EXCLUSIVE, /ROW, /NO_REL, $
	['Std', 'Encapsulated'], $
	UVALUE='@ st.ps_encap=ev.value', SET_VALUE=0)
junk2 = CW_BGROUP(junk1, /EXCLUSIVE, /ROW, /NO_REL, $
	['Mono', 'Color'], $
	UVALUE='@ st.ps_color=ev.value', SET_VALUE=0)
junk1 = CW_BGROUP(junk, /EXCLUSIVE, /ROW, /NO_REL, $
	['Portrait', 'Landscape'], $
	UVALUE='@ st.ps_orien=ev.value', SET_VALUE=0)
junk1 = WIDGET_BASE(junk, /ROW)
junk2 = WIDGET_LABEL(junk1, VALUE='Width:')
junk2 = WIDGET_TEXT(junk1, /EDIT, /FRAME, xsize=5, ysize=1, value='5.0', $
	UVALUE='# st.ps_width=ann_get_num(v(0), ev.id, .1, 200)')
junk2 = CW_BGROUP(junk1, /EXCLUSIVE, /ROW, /NO_REL, $
	['In', 'Cm'], UVALUE='@ st.ps_units=ev.value', SET_VALUE=0)

junk = WIDGET_BUTTON(top, VALUE='Dismiss', UVALUE='Dismiss')


wset, win
wshow, win

if n_elements(tek_colors) ge 1 then tek_color, scolor, ncolors

widget_control, ann_base, /REAL
WIDGET_CONTROL, st.color_id, SET_VALUE = color_indices(ncolors-1)   ;Set color

if keyword_set(load_file) then $	;Load a file?
	ann_xfer_file, st, load_file, /LOAD
WIDGET_CONTROL, ann_base, SET_UVALUE = st, /NO_COPY

if use_xmgr then xmanager, 'annotate', ann_base $
else xmgr_fake, ann_base, win
end

; $Id: arrow.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO ARROW, x0, y0, x1, y1, HSIZE = hsize, COLOR = color, HTHICK = hthick, $
	THICK = thick, DATA = data, DEVICE = device, NORMALIZED = norm, $
	SOLID = solid
;+
; NAME:				ARROW
; PURPOSE:	Draw a vector(s) with an arrow head
; CATEGORY:	Graphics
; CALLING SEQUENCE:
;	ARROW, x0, y0, x1, y1
; INPUTS:
;	(x0, y0) = coordinates of beginning of vector(s).  May be arrays
;		or scalars. Coordinates are in DEVICE coordinates
;		unless otherwise specified.
;	(x1, y1) = coordinates of endpoint (head) of vector.  
;		x0, y0, x1, y1 must all have the same number of elements.
; KEYWORD PARAMETERS:
;	DATA - if set, implies that coordinates are in data coords.
;	NORMALIZED - if set, coordinates are specified in normalized coords.
;	HSIZE = size of arrowhead.  Default = 1/64th the width of the device,
;		(!D.X_SIZE / 64.).
;		If the size is positive, it is assumed to be in device
;		coordinate units.  If it is NEGATIVE, then the head length
;		is set to the vector length * abs(hsize), giving heads
;		proportional in size to the bodies.  The size is defined as
;		the length of each of the lines (separated by 60 degrees) 
;		that make the head.
;	COLOR = drawing color.  Default = highest color index.
;	HTHICK = thickness of heads.  Default = 1.0.
;	SOLID = if set, make a solid arrow, using polygon fills, looks better
;		for thick arrows.
;	THICK = thickness of body.    Default = 1.0.
;	
; OUTPUTS:
;	No explicit outputs.
; SIDE EFFECTS:
; RESTRICTIONS:
; PROCEDURE:
;	Straightforward.
;	Examples:
;  		Draw an arrow from (100,150) to (300,350) in DEVICE units.
;	ARROW, 100, 150,  300, 350
;
;		Draw a sine wave with arrows from the line Y=0 to
;		sin(x/4).
;	X = FINDGEN(50)
;	Y = SIN(x/4)		;Make sin wave
;	PLOT, X, Y
;	ARROW, X, REPLICATE(0,50), X, Y, /DATA
; MODIFICATION HISTORY:
;	DMS, Feb, 1992.
;	DMS, Sept, 1992.  Added /SOLID.
;-

;  Draw an arrow with a head from (x0,y0) to (x1, y1).  Params may be
;		vectors.

;  Set up keyword params

if n_elements(thick) eq 0 then thick = 1.
if n_elements(hthick) eq 0 then hthick = thick

				;Head size in device units
if n_elements(hsize) eq 0 then arrowsize = !d.x_size/64. * (hthick/2. > 1) $
    else arrowsize = float(hsize)
if n_elements(color) eq 0 then color = !P.color

mcost = -.866		;We use 30 degrees for head angle
sint = .500
msint = - sint

for i = 0, n_elements(x0)-1 do begin		;Each vector
	if keyword_set(data) then $		;Convert?
	    p = convert_coord([x0(i),x1(i)],[y0(i),y1(i)], /data, /to_dev) $
	else if keyword_set(norm) then $
	    p = convert_coord([x0(i),x1(i)],[y0(i),y1(i)], /norm, /to_dev) $
	else p = [[x0(i), y0(i)],[x1(i), y1(i)]]

	xp0 = p(0,0)
	xp1 = p(0,1)
	yp0 = p(1,0)
	yp1 = p(1,1)

	dx = float(xp1-xp0)
	dy = float(yp1-yp0)
	zz = sqrt(dx^2 + dy^2)	;Length

	if zz gt 1e-6 then begin
		dx = dx/zz		;Cos th
		dy = dy/zz		;Sin th
	endif else begin
		dx = 1.
		dy = 0.
		zz = 1.
	endelse
	if arrowsize gt 0 then a = arrowsize $  ;a = length of head
	else a = -zz * arrowsize

	xxp0 = xp1 + a * (dx*mcost - dy * msint)
	yyp0 = yp1 + a * (dx*msint + dy * mcost)
	xxp1 = xp1 + a * (dx*mcost - dy * sint)
	yyp1 = yp1 + a * (dx*sint  + dy * mcost)

	if keyword_set(solid) then begin	;Use polyfill?
	  b = a * mcost*.9	;End of arrow shaft (Fudge to force join)
	  plots, [xp0, xp1+b*dx], [yp0, yp1+b*dy], /DEVICE, $
		COLOR = color, THICK = thick
	  polyfill, [xxp0, xxp1, xp1, xxp0], [yyp0, yyp1, yp1, yyp0], $
		/DEVICE, COLOR = color
	endif else begin
	  plots, [xp0, xp1], [yp0, yp1], /DEVICE, COLOR = color, THICK = thick
	  plots, [xxp0,xp1,xxp1],[yyp0,yp1,yyp1], /DEVICE, COLOR = color, $
			THICK = hthick
	endelse
	ENDFOR
end
; $Id: bar_plot.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro bar_plot,values,baselines=baselines,colors=colors,barnames=barnames, $
          title=title,xtitle=xtitle,ytitle=ytitle,baserange=baserange, $
          barwidth=barwidth,barspace=barspace,baroffset=baroffset, $
          outline=outline,overplot=overplot,background=background, $
          rotate=rotate
;+
; NAME:  
;	BAR_PLOT
;
; PURPOSE:
;	Create a bar graph, or overplot on an existing one.
;
; CATEGORY:
;	Graphics.
;
; CALLING SEQUENCE:
;	BAR_PLOT, Values
;
; INPUTS:
;	Values:	A vector containing the values to be represented by the bars.
;		Each element in VALUES corresponds to a single bar in the
;		output.
;
; KEYWORD PARAMETERS:
;   BASELINES:	A vector, the same size as VALUES, that contains the
;		base value associated with each bar.  If not specified,
;		a base value of zero is used for all bars.
;
;      COLORS:	A vector, the same size as VALUES, containing the color index
;		to be used for each bar.  If not specified, the colors are
;		selected based on spacing the color indices as widely as 
;		possible within the available colors (specified by D.N_COLORS).
;
;    BARNAMES:	A string array, containing one string label per bar.
;		If the bars are vertical, the labels are placed beneath
;		them.  If horizontal (rotated) bars are specified, the labels
;		are placed to the left of the bars.
;
;	TITLE:	A string containing the main title to for the bar plot.
;
;	XTITLE:	A string containing the title for the X axis.
;
;	YTITLE:	A string containing the title for the Y axis.
;
;   BASERANGE:	A floating-point scalar in the range 0.0 to 1.0, that
;		determines the fraction of the total available plotting area
;		(in the direction perpendicular to the bars) to be used.
;		If not specified, the full available area is used.
;
;    BARWIDTH:	A floating-point value that specifies the width of the bars
;		in units of "nominal bar width".  The nominal bar width is
;		computed so that all the bars (and the space between them, 
;		set by default to 20% of the width of the bars) will fill the 
;		available space (optionally controlled with the BASERANGE 
;		keyword).
;
;    BARSPACE: 	A scalar that specifies, in units of "nominal bar width",
;		the spacing between bars.  For example, if BARSPACE is 1.0,
;		then all bars will have one bar-width of space between them.
;		If not specified, the bars are spaced apart by 20% of the bar
;		width.
;
;   BAROFFSET:	A scalar that specifies the offset to be applied to the
;		first bar, in units of "nominal bar width".  This keyword 
;		allows, for example, different groups of bars to be overplotted
;		on the same graph.  If not specified, the default offset is
;		equal to BARSPACE.
;
;     OUTLINE:	If set, this keyword specifies that an outline should be 
;		drawn around each bar.
;
;    OVERPLOT:	If set, this keyword specifies that the bar plot should be
;		overplotted on an existing graph.
;
;  BACKGROUND:	A scalar that specifies the color index to be used for
;		the background color.  By default, the normal IDL background
;		color is used.
;
;	ROTATE:	If set, this keyword indicates that horizontal rather than
;		vertical bars should be drawn.  The bases of horizontal bars
;		are on the left, "Y" axis and the bars extend to the right.
;
; OUTPUTS:
;	A bar plot is created, or an existing one is overplotted.
;
; EXAMPLE:
;	By using the overplotting capability, it is relatively easy to create
;	stacked bar charts, or different groups of bars on the same graph.
;
;	For example, if ARRAY is a two-dimensional array of 5 columns and 8
;	rows, it is natural to make a plot with 5 bars, each of which is a
;	"stacked" composite of 8 sections.  First, create a 2D COLORS array,
;	equal in size to ARRAY, that has identical color index values across
;	each row to ensure that the same item is represented by the same color
;	in all bars.
;
;	With ARRAYS and COLORS defined, the following code fragment
;	illustrates the creation of stacked bars (note that the number of rows
;	and columns is arbitrary):
;
;	!Y.RANGE = [0,ymax] ; Scale range to accommodate the total bar lengths.
;	BASE = INTARR(NROWS)
;	FOR I = 0, NROWS-1 DO BEGIN
;	   BAR_PLOT, ARRAY(*,I), COLORS=COLORS(*,I), BASELINES=BASE, $
;	             BARWIDTH=0.75, BARSPACE=0.25, OVER=(I GT 0)
;	   BASE = BASE + ARRAY(*,I)
;	ENDFOR
;
;	To plot each row of ARRAY as a clustered group of bars within the same
;	graph, use the BASERANGE keyword to restrict the available plotting
;	region for each set of bars.  The sample code fragment below
;	illustrates this method:
;
;	FOR I = 0, NROWS-1 DO $
;	   BAR_PLOT, ARRAY(*,I), COLORS=COLORVECT, BARWIDTH=0.8,BARSPACE=0.2, $
;	     BAROFFSET=I*((1.0+BARSPACE)*NCOLS), OVER=(I GT 0), BASERANGE=0.19
;
;	where NCOLS is the number of columns in ARRAY, and COLORVECT is a
;	vector containing the color indices to be used for each group of
;	bars.  (In this example, each group uses the same set of colors, but
;	this could easily be changed.)
;
; MODIFICATION HISTORY:
;	August 1990, T.J. Armitage, RSI, initial programming.  Replacement
;	for PLOTBAR and OPLOTBAR routines written by William Thompson.
;
;	September 1990, Steve Richards, RSI, changed defaults to improve the
;	appearance of the bar plots in the default mode. Included
;	spacing the bars slightly.
;-
if (n_params(d) eq 0) then begin  ;Print call & return if no parameters
  print,'bar_test,values,baselines=baselines,colors=colors,barnames=barnames,$'
  print,' title=title,xtitle=xtitle,ytitle=ytitle,baserange=baserange, $'
  print,' barwidth=barwidth,barspace=barspace,baroffset=baroffset, $'
  print,' outline=outline,overplot=overplot,background=background, $'
  print,' rotate=rotate'
  return
endif

nbars=n_elements(values)		; Determine number of bars
; Baselines (bars extend from baselines through values); default=0
if not(keyword_set(baselines)) then baselines=intarr(nbars)
; Default colors spaced evenly in current color table
if not(keyword_set(colors)) then $
   colors=fix((!d.n_colors/float(nbars))*(indgen(nbars)+0.5))
; Labels for the individual bars; none by default
if not(keyword_set(barnames)) then barnames=strarr(nbars)+' '
; Main title
if not(keyword_set(title)) then title=''
; Centered title under X-axis
if not(keyword_set(xtitle)) then xtitle=''
; Title for Y-axis
if not(keyword_set(ytitle)) then ytitle=''             
; Fraction (0-1) of full X range to use
if not(keyword_set(baserange)) then baserange=1.0
; Space betw. bars, taken from nominal bar widths; default is none
If not(keyword_set(barspace)) then barspace=0.2
; Bar width scaling factor, relative to nominal
if not(keyword_set(barwidth)) then barwidth=1.0 - barspace - barspace / nbars
; Initial X offset, in scaled bar widths; default is none
if not(keyword_set(baroffset)) then baroffset=barspace/barwidth
; Outline of bars; default is none
outline = keyword_set(outline)
; Overplot (do not erase the existing display); default is to create new plot
overplot = keyword_set(overplot)
; Background color index; defaults to 0 (usually black) if not specified
if not(keyword_set(background)) then background=0
; Rotate (make horizontal bars); default is vertical bars
rotate = keyword_set(rotate)

if (rotate) then begin				   ;Horizontal bars
   if (!x.range(0) eq 0) and (!x.range(1) eq 0) $  ;Determine range for X-axis
      then $
        xrange=[(min(baselines)<min(values)), $    ;Minimum of bases & values
                (max(baselines)>max(values))] $    ;Maximum of bases & values
      else xrange=!x.range			   ;Or, use range specified
   yrange=!y.range				   ;Axis perpend. to bars
   yticks=1					   ;Suppress ticks in plot
   ytickname=strarr(2)+' '
   xticks=0
   xtickname=strarr(1)+''
endif else begin				   ;Vertical bars
   if (!y.range(0) eq 0) and (!y.range(1) eq 0) $  ;Determine range for Y-axis
      then $
        yrange=[(min(baselines)<min(values)), $    ;Minimum of bases & values
                (max(baselines)>max(values))] $    ;Maximum of bases & values
      else yrange=!y.range	           	   ;Or, use range specified
   xrange=!x.range				   ;Axis perpend. to bars
   xticks=1					   ;Suppress ticks in plot
   xtickname=strarr(2)+' '
   yticks=0
   ytickname=strarr(1)+''
endelse
if (overplot eq 0) then $			   ;Create new plot, no data
plot,[values],/nodata,title=title,xtitle=xtitle,ytitle=ytitle, $
   noerase=overplot,xrange=xrange,yrange=yrange,xticks=xticks, $
   xtickname=xtickname,yticks=yticks,ytickname=ytickname, $
   xstyle=1,ystyle=1,/data,background=background
if (rotate) then begin				   ;Horizontal bars
   base_win=!y.window				   ;Window range in Y
   scal_fact=!x.s				   ;Scaling factors
   tick_scal_fact=!y.s				   ;Tick scaling factors
endif else begin				   ;Vertical bars
   base_win=!x.window				   ;Window range in X
   scal_fact=!y.s				   ;Scaling factors
   tick_scal_fact=!x.s				   ;Tick scaling factors
endelse
winrange=baserange*(base_win(1)-base_win(0))	   ;Normal. window range
barsize=barwidth*winrange/nbars			   ;Normal. bar width
winoffset=base_win(0)+(baroffset*barsize)	   ;Normal. first offset
bases=scal_fact(0)+(scal_fact(1)*baselines)	   ;Baselines, in normal coor.
normal=scal_fact(0)+(scal_fact(1)*values)	   ;Values, in normal coor.
barstart=indgen(nbars)*(barsize+barspace*(winrange/nbars)) ;Coor. at left edges
tickv=winoffset+barstart+(0.5*barsize)		   ;Tick coor. (centered)
for i=0,nbars-1 do begin			   ;Draw the bars
   width=winoffset+[barstart(i),barstart(i), $     ;Compute bar width
     (barstart(i)+barsize),(barstart(i)+barsize)]
   length=[bases(i),normal(i),normal(i),bases(i)]  ;Compute bar length
   if (rotate) then begin			   ;Horizontal bars
      x=length					   ;X-axis is "length" axis
      y=width					   ;Y-axis is "width" axis
   endif else begin				   ;Vertical bars
      x=width					   ;X-axis is "width" axis
      y=length					   ;Y-axis is "length" axis
   endelse
   polyfill,x,y,color=colors(i),/normal		   ;Polyfill with color
   if (outline) then plots,x,y,/normal		   ;Outline using !p.color
endfor

tickv=(tickv-tick_scal_fact(0))/tick_scal_fact(1)  ;Locations of the ticks
if (rotate) then $				   ;Label the bars (Y-axis)
  axis,yaxis=0,ystyle=1,yticks=(nbars-1),ytickv=tickv,ytickname=barnames, $
  yticklen=0.0 $
else $						   ;Label the bars (X-axis)
  axis,xaxis=0,xstyle=1,xticks=(nbars-1),xtickv=tickv,xtickname=barnames, $
  xticklen=0.0
return
end
;
; $Id: base_alloc.pro,v 1.7 1994/06/01 23:08:48 ali Exp $
;
;  WidBase
;   Base object class definition.
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;


;
;  BASE_Icon
;       Return the base toolbar icon
;
FUNCTION BASE_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 60b, 207b, 243b, 60b ], $
    [ 60b, 207b, 243b, 60b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 204b, 49b, 239b, 49b ], $
    [ 76b, 74b, 33b, 48b ], $
    [ 204b, 121b, 239b, 48b ], $
    [ 76b, 74b, 40b, 48b ], $
    [ 204b, 73b, 239b, 49b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 60b, 207b, 243b, 60b ], $
    [ 60b, 207b, 243b, 60b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  BASE_Copy
;       Copy the given base object.  Remember to copy contents (children)
;   as well.
;
PRO BASE_Copy, Ptr, Copy
  COMMON WidEd_Comm

    Copy    = WIDGET_BASE(GROUP=TopDlg)    ; Make a pointer
    Ptr2Obj, Ptr, Obj, /COPY        ; Copy original pointer contents

    Child   = Obj.Children          ; Child list of original

    Obj.Children    = 0             ; Clear copy's child list
    Obj.LastChild   = 0
    Obj2Ptr, Obj, Copy              ; Store copy object into pointer

    ;   Now copy child list
    ;   Due to the nature of the copy routines, we need to make sure
    ;   NewChild is <UNDEFINED>. (C.f. XXX_Copy)

    WHILE Child NE 0 DO BEGIN

        GetType, Child, Type        ; Get object class name
        ClearVar, NewChild          ; make NewChild of type <UNDEFINED>

        CALL_PROCEDURE, Type+"_Copy", Child, NewChild       ; Make Copy
        AddChild, Copy, NewChild, /NO_UPDATE, /NO_CANCEL

        Child   = NextPtr(Child)    ; Get the next child in list
    ENDWHILE
END

;
;  BASE_Destroy
;   Release resources associated with the given object.  Recursively
;   remove children objects as well.
;
PRO BASE_Destroy, Ptr
    Ptr2Obj, Ptr, Obj                       ; Get the object
    DoList, Obj.Children, "Destroy"         ; Destroy children

    ;   Destroy dialog boxes associated with the object. They are
    ;   no longer useable

    IF WIDGET_INFO(Obj.Dialog, /VALID) THEN $
        WIDGET_CONTROL, Obj.Dialog, /DESTROY
    IF WIDGET_INFO(Obj.AttrDlg, /VALID) THEN $
        WIDGET_CONTROL, Obj.AttrDlg, /DESTROY

    ;   Destroy the pointer
    WIDGET_CONTROL, Ptr, /DESTROY

    ;   Object is in local variable and goes away as we return
END


;
;  BASE_BarEvent
;   Events from the pull down menu don't have a <STRING> type UVALUE to
;   use.  Thus we have a separate event routine to handle the menu items.
;
;   All base menubar events consist of adding child object
;
PRO BASE_BarEvent, Event

  COMMON WidEd_Comm

    ;   We will need the pointer for the Object associated with this
    ;   dialog box (the parent for the children we are about to create)

    WIDGET_CONTROL, Event.top, GET_UVALUE=Binfo, /NO_COPY

    IF Event.Value EQ 'Add.Hide Tool Bar' THEN BEGIN

        WIDGET_CONTROL, Binfo.ToolBar, MAP=0
        WIDGET_CONTROL, Binfo.ToolId, SET_VALUE='Show Tool Bar'
        WIDGET_CONTROL, Binfo.ToolId, SET_UVALUE='Add.Show Tool Bar' ; Hack
        SetTag, Binfo.ObjPtr, "TB_Showing", 0

    ENDIF ELSE IF Event.Value EQ 'Add.Show Tool Bar' THEN BEGIN

        WIDGET_CONTROL, Binfo.ToolBar, MAP=1
        WIDGET_CONTROL, Binfo.ToolId, SET_VALUE='Hide Tool Bar'
        WIDGET_CONTROL, Binfo.ToolId, SET_UVALUE='Add.Hide Tool Bar' ; Hack
        
        SetTag, Binfo.ObjPtr, "TB_Showing", 1

    ENDIF ELSE BEGIN

        IF STRMID(Event.Value,0,4) EQ "Add." THEN BEGIN
            Idx     = WHERE(STRMID(Event.Value,4,100) EQ AddList.Menu)
            Build   = AddList(Idx).Class
        ENDIF ELSE MESSAGE, 'Unprocessed event: ' + Event.Value

        ;   Allocate object and create a dialog box as well
        CALL_PROCEDURE, Build+'_Build', Ptr, Binfo.ObjPtr

        ;   Add child to our child list.  Note that Base object
        ;   do not get added to the active dialog box list
        AddChild, Binfo.ObjPtr, Ptr, NO_CANCEL=(Build EQ 'Base')

    ENDELSE

    ;   Restore dialog box information
    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
END

;
;  BASE_Event
;   Normal event handling routine for a base object
;
PRO BASE_Event, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'Bbs':      BEGIN                               ; Base is a Bulletin Board
        Obj.BaseType        = 0
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=0
        END
    'Row':                BEGIN                     ; Base is a row
        Obj.BaseType        = 1
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END
    'Column':        BEGIN                          ; Base is a column
        Obj.BaseType        = 2
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END

    ;   user has set some characteristic of the object to a new value

    'NROW':         Obj.NRowCol     = Event.Value
    'SPACE':        Obj.Space       = Event.Value
    'XPAD':         Obj.XPad        = Event.Value
    'YPAD':         Obj.YPad        = Event.Value
    'NAME':         Obj.Name        = Event.Value
    'FRAME':        Obj.FrameSize   = Event.Value
    'XSCROLL':      Obj.XScrollSize = Event.Value
    'YSCROLL':      Obj.YScrollSize = Event.Value

    ;   User wants to see the 'Additional attributes' dialog
    'ATTR':     BASE_BuildAttr, Event.Top, Binfo.ObjPtr, Obj

    ;   Additional Attribute Events
    'XSIZE':        Obj.XSize       = Event.Value
    'YSIZE':        Obj.YSize       = Event.Value
    'XOFFSET':      Obj.XOffset     = Event.Value
    'YOFFSET':      Obj.YOffset     = Event.Value
;   'EVENT_FUNC':   Obj.EventFunc   = Event.Value
    'EVENT_PROC':   Obj.EventProc   = Event.Value
    'GETFUNC':      Obj.GetFunc     = Event.Value
    'SETPROC':      Obj.SetProc     = Event.Value
    'KILLPROC':     Obj.KillProc    = Event.Value
    'DO_TLB':       Obj.TLBEvents   = 1 - Obj.TLBEvents
    'MAPPED':       Obj.BaseMapped  = 1 - Obj.BaseMapped

    'DONE':         BEGIN
                    Obj2Ptr, Obj, Binfo.ObjPtr
                    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
                    WIDGET_CONTROL, Event.Top, /DESTROY
                    RETURN
                    END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  BASE_Build
;   Create a dialog for a new/existing base object
;
PRO BASE_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    BASE_Alloc, ParPtr, Ptr                 ; Allocate object if necessary
    MgrName = 'WE_BASE' + STRTRIM(Ptr,2)    ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if we already have one

    Title= GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj
    Base            = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    Foci            = LONARR(8)

    ;   Menu bar contents

    Menu            = MakeAddMenu()
    Menu(N_ELEMENTS(Menu)-1).flags  = 2
;    MenuBarDesc     = [ { CW_PDMENU_S, 3, 'Add' }, $
;                        { CW_PDMENU_S, 0, 'Hide Tool Bar' }, $
;                        Menu ]
    If Obj.TB_Showing EQ 0 THEN MenuBarDesc(1).name = 'Show Tool Bar'
    MenuBar         = CW_PDMENU(Base, MenuBarDesc, IDS=Ids, /RETURN_FULL_NAME)
    ToolId          = Ids(1)

    BuildToolBar, Base, ToolBar

    BuildBaseType, Base, Obj, Foci, 0, RowColId, Btns
    Base1   = WIDGET_BASE(Base, /COLUMN, EVENT_PRO='BASE_Event')
    Foci(4) = Field(Base1, "Name:", Obj.Name, 'NAME', SIZE=50, /STRING)
    Foci(5) = Field(Base1, "Frame Size:", Obj.FrameSize, "FRAME", /INT)
    BuildXY, Base, Obj, Foci, 6, /SIZE
    Dummy   = WIDGET_BUTTON(Base, VALUE='More Attributes', $
                UVALUE='ATTR', EVENT_PRO='BASE_Event')

    Dummy   = WIDGET_LABEL(Base, VALUE=' ')
    Dummy   = WIDGET_BUTTON(Base, VALUE='Done', UVALUE='DONE', $
            EVENT_PRO='BASE_Event')

    Obj.Dialog  = Base      ; Save active dialog id in object

    DlgInfo = {                 $
        Foci:       Foci,       $
        RowColId:   RowColId,   $
        ToolBar:    ToolBar,    $
        ToolId:     ToolId,     $
        ObjPtr:     Ptr         $
    }

    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY  ; save dialog info
    WIDGET_CONTROL, Base, /REALIZE                      ; create dialog
    WIDGET_CONTROL, Btns(Obj.BaseType), /SET_BUTTON     ; Set basetype button
    WIDGET_CONTROL, RowColId, SENSITIVE=(Obj.BaseType NE 0)

    WIDGET_CONTROL, ToolBar, MAP=Obj.TB_Showing

    ;   Hand off dialog to window manager
    XMANAGER, MgrName, Base, EVENT_HANDLER='BASE_BarEvent', CLEANUP='DEP_Kill'

    Obj2Ptr, Obj, Ptr       ; Restore pointer
END


;
;  BASE_Save
;   Store object information in a file.
;   Store children as well.  Store the child's type and then the child.
;   End of list is indicated by the type string of "_END_"
;
;   FORMAT:
;       <Base object>
;       "ChildType"     E.g. "LABEL", "BUTTON", "DRAW", "TEXT", "BASE", ...
;       Child
;       ...
;       "_END_"
;
PRO BASE_Save, Unit, Ptr

  COMMON WidEd_Comm

    ON_IOERROR, BadWrite

    Ptr2Obj, Ptr, Obj

    WRITEU, Unit, Obj               ; Save Me

    Child   = Obj.Children          ; Save my children
    WHILE Child NE 0 DO BEGIN
        GetType, Child, Type
        WRITEU, Unit, Type          ; Save child Type as a <STRING>
        CALL_PROCEDURE, Type + "_Save", Unit, Child ; Save child
        Child   = NextPtr(Child)
    ENDWHILE

    WRITEU, Unit, "_END_"           ; Write End-Of-List marker

    Obj2Ptr, Obj, Ptr
    RETURN

  BadWrite:
    Dirty   = 2
END


;
;  urBase_Restore
;       There are 3 different base type objects: MAIN, DEP, and BASE
;   and restoring them has a lot of stuff in common. Thus this common
;   routine for restoring bases.
;
PRO urBASE_Restore, Unit, Parent, Ptr, Type

    ; Allocated a pointer of the corrent type
    CALL_PROCEDURE, Type+"_Alloc", Parent, Ptr

    Ptr2Obj, Ptr, Obj
    READU, Unit, Obj                        ; Read in the object
    Obj.Next        = 0                     ; Clear bogus values
    Obj.Children    = 0
    Obj.LastChild   = 0
    Obj.Dialog      = 0
    Obj.AttrDlg     = 0
    Obj.Parent      = Parent                ; Set true parent ptr
    Obj2Ptr, Obj, Ptr                       ; Store into pointer

    ;   Restore children
    WHILE 1 DO BEGIN
        Type    = ""
        READU, Unit, Type                   ; Get the Type
        IF Type EQ "_END_" THEN RETURN      ; End-Of-List Marker?

        ClearVar, Child
        CALL_PROCEDURE, Type+"_Restore", Unit, Ptr, Child    ; Get Child
        AddChild, Ptr, Child, /NO_UPDATE, /NO_CANCEL
    ENDWHILE
END

;
;  BASE_Restore
;   Read in a base object (and its children) from a file
;
PRO BASE_Restore, Unit, Parent, Ptr
    urBASE_Restore, Unit, Parent, Ptr, "BASE"
END

;
;   BASE_BuildAttr
;       Object contains information about the base.  Ptr is needed
;   for object naming.  Routine builds the 'extra' dialog box that
;   base objects have.
;
PRO BASE_BuildAttr, Leader, Ptr, Obj

    MgrName = 'WidBAttr' + STRTRIM(Ptr,2)       ; Addition Attr Dialog exists?
    IF XRegistered(MgrName) THEN RETURN

    ;   Create one.

    Foci    = LONARR(7)
    Title   = 'BASE ' + STRTRIM(Obj.Id,2) + ' Attributes'
    Base    = WIDGET_BASE(  GROUP_LEADER=Leader, /COLUMN, TITLE=Title)

    ;   Event Related Info

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Event Controls")

    Foci(0) = Field(Base1, "Function Name for GET_VALUE:", Obj.GetFunc, $
                "GETFUNC", SIZE=20, /STRING)
    Foci(1) = Field(Base1, "Procedure Name for SET_VALUE:", Obj.SetProc, $
                "SETPROC", SIZE=20, /STRING)
    Foci(2) = Field(Base1, "Procedure Name for KILL_NOTIFY:", Obj.KillProc, $
                "KILLPROC", SIZE=20, /STRING)

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Window Appearance Controls")
    BuildXY, Base1, Obj, Foci, 3, /SCROLL, /OFFSET
    Base2   = WIDGET_BASE(Base1, /NONEXCLUSIVE, /ROW)
    Btn     = WIDGET_BUTTON(Base2,              $
                VALUE='Base Starts Mapped', $
                UVALUE='MAPPED')
    IF Obj.BaseMapped EQ 1 THEN WIDGET_CONTROL, Btn, /SET_BUTTON
    Dummy   = WIDGET_LABEL(Base, VALUE=' ')
    Dummy   = WIDGET_BUTTON(Base, VALUE='Done', UVALUE='DONE')

    DlgInfo     = {         $
        Foci:       Foci,   $
        ObjPtr:     Ptr     $
    }
    Obj.AttrDlg = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='BASE_Event', CLEANUP='DEP_Kill'
END


;
;  BASE_Generate
;       Create a base object and its children for previewing.
;
PRO BASE_Generate, Base, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj

    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Generate command string

    Cmd = 'Id = WIDGET_BASE(Base'
    Cmd = Cmd + ",/TLB_SIZE_EVENTS"
    SAddCmd, Cmd, Obj.Name, 'TITLE'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'
    IAddCmd, Cmd, Obj.XScrollSize, 'X_SCROLL_SIZE'
    IAddCmd, Cmd, Obj.YScrollSize, 'Y_SCROLL_SIZE'

    ;   Row/Column?

    IF Obj.BaseType EQ 1 THEN           $
        IAddCmd, Cmd, Obj.NRowCol, 'ROW'    $
    ELSE IF Obj.BaseType EQ 2 THEN      $
        IAddCmd, Cmd, Obj.NRowCol, 'COLUMN'

    IAddCmd, Cmd, Obj.Space, 'SPACE'
    IAddCmd, Cmd, Obj.XPad, 'XPAD'
    IAddCmd, Cmd, Obj.YPad, 'YPAD'

    ; Create base by running command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        Obj2Ptr, Obj, Ptr
        MESSAGE,'Could not build base' + VarName(Ptr)
    ENDIF

    ; Create any child widgets

    Child   = Obj.Children
    WHILE Child NE 0L DO BEGIN
        GetType, Child, Type
        CALL_PROCEDURE, Type + "_Generate", Id, Child
        Child   = NextPtr(Child)
    ENDWHILE

    Obj2Ptr, Obj, Ptr
END

;
;  urBase_GenWid
;   Create code for generating any base class widget and children
;
PRO urBase_GenWid, Unit, Ptr, Obj, Name

    ;   Create base information

    ;   Row/Column Base?

    IF Obj.BaseType EQ 1 THEN           $
        ISaveCmd, Unit, Obj.NRowCol, 'ROW'  $
    ELSE IF Obj.BaseType EQ 2 THEN  $
        ISaveCmd, Unit, Obj.NRowCol, 'COLUMN'

    ISaveCmd, Unit, Obj.Space, 'SPACE'
    ISaveCmd, Unit, Obj.XPad, 'XPAD'
    ISaveCmd, Unit, Obj.YPad, 'YPAD'
;    SSaveCmd, Unit, Obj.EventFunc, "EVENT_FUNC"
;    SSaveCmd, Unit, Obj.EventProc, "EVENT_PROC"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, Obj.GetFunc, "FUNC_GET_VALUE"
    SSaveCmd, Unit, Obj.KillProc, "KILL_NOTIFY"
    ISaveCmd, Unit, Obj.BaseMapped, "MAP", /FORCE
    SSaveCmd, Unit, Obj.SetProc, "PRO_SET_VALUE"
    SSaveCmd, Unit, Obj.Name, "TITLE"
    ISaveCmd, Unit, Obj.TLBEvents, "TLB_SIZE_EVENTS"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.XScrollSize, "X_SCROLL_SIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    ISaveCmd, Unit, Obj.YScrollSize, "Y_SCROLL_SIZE"

    XPRINTF, Unit, ')'
    XPRINTF, Unit

    ;   Now generate code for creating children objects.

    Child   = Obj.Children
    WHILE Child NE 0 DO BEGIN
        GetType, Child, Type
        CALL_PROCEDURE, Type+"_GenWid", Unit, Child, Name
        Child   = NextPtr(Child)

        XPRINTF, Unit    ; Put a blank line between each child
    ENDWHILE
END

;
;  BASE_GenWid
;   Generate IDL code for creating a BASE widget
;
PRO BASE_GenWid, Unit, Ptr, Parent
    Name    = VarId(Ptr)
    Ptr2Obj, Ptr, Obj
    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_BASE(",A)', Name, Parent,/NO_EOL
    urBase_GenWid, Unit, Ptr, Obj, Name
    Obj2Ptr, Obj, Ptr
END


;
;  BASE_Alloc
;       Allocate a base object (if Ptr is NULL or just invalid)
;   There are 3 base object classes (MAIN,DEP, and BASE) so they call
;   a common routine to allocate base objects.
;
PRO BASE_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; Ptr already allocated

    Ptr = WIDGET_BASE(GROUP=TopDlg)         ; Make a pointer
    MakeBaseObj, Parent, Obj, "BASE"        ; Make a base object
    Obj2Ptr, Obj, Ptr                       ; Store object in pointer
END
; $Id: beta.pro,v 1.1 1995/07/05 15:33:04 idl Exp $

; Copyright (c) 1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.

;+
; NAME:
;       BETA
; PURPOSE:
;	The introduction of the BETA function as a built in system routine
;	in IDL 4.0 caused inconvenience to customers with existing code
;	in which BETA had been used as a variable, because IDL system
;	routines have precedence over variable names. To minimize this
;	problem, RSI has renamed BETA back to NR_BETA (its old name).
;
;	This wrapper serves to make NR_BETA available under the name
;	BETA as documented in the IDL Reference Manual. However, since
;	IDL library routines have lower precedence than variables, programs
;	that use BETA as a variable name will work as before.
;
;	See the documentation for BETA in the IDL Reference manual for details
;	on arguments, keywords, and results.
; 
;
; MODIFICATION HISTORY:
;	3 July 1995, AB, RSI.
;-

function beta, z, w, _EXTRA=EXTRA_KW

  return, NR_BETA(z, w, _EXTRA=EXTRA_KW)

end
;
; $Id: bgroup_alloc.pro,v 1.8 1995/01/20 19:41:01 tonyh Exp $
;
;  WidBGroup
;   Widget Button Group (CW_BGROUP) class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;


;
;  BGROUP_Icon
;       Return the button group icon
;
FUNCTION BGROUP_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 224b, 0b, 0b, 0b ], $
    [ 176b, 1b, 0b, 0b ], $
    [ 88b, 3b, 0b, 0b ], $
    [ 172b, 6b, 0b, 0b ], $
    [ 86b, 13b, 0b, 0b ], $
    [ 171b, 26b, 0b, 0b ], $
    [ 87b, 29b, 0b, 0b ], $
    [ 175b, 30b, 0b, 0b ], $
    [ 94b, 143b, 255b, 63b ], $
    [ 188b, 135b, 255b, 63b ], $
    [ 248b, 3b, 0b, 0b ], $
    [ 240b, 1b, 0b, 0b ], $
    [ 224b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 224b, 0b, 0b, 0b ], $
    [ 176b, 1b, 0b, 0b ], $
    [ 88b, 3b, 0b, 0b ], $
    [ 172b, 6b, 0b, 0b ], $
    [ 86b, 13b, 0b, 0b ], $
    [ 171b, 26b, 0b, 0b ], $
    [ 87b, 29b, 0b, 0b ], $
    [ 175b, 30b, 0b, 0b ], $
    [ 94b, 143b, 255b, 63b ], $
    [ 188b, 135b, 255b, 63b ], $
    [ 248b, 3b, 0b, 0b ], $
    [ 240b, 1b, 0b, 0b ], $
    [ 224b, 0b, 0b, 0b ]  $
  ]
END


;
;  BGROUP_Copy
;       Copy a Button group. 2 copy methods.
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO BGROUP_Copy, Ptr, Copy
    GenCopy, Ptr, Copy, /HASVALUE
END

;
;  BGROUP_Destroy
;   Release resources for the given button group.
;
PRO BGROUP_Destroy, Ptr
    GenDestroy, Ptr, /HASVALUE
END


;
;  BGROUP_Event
;   Event handling routine for Button group dialogs.
;
PRO BGROUP_Event, Event

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'Bbs':      BEGIN                               ; Base is a Bulletin Board
        Obj.BaseType        = 0
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=0
        END
    'Row':                BEGIN                     ; Base is a row
        Obj.BaseType        = 1
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END
    'Column':        BEGIN                          ; Base is a column
        Obj.BaseType        = 2
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END

    'LITERAL':      BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 0
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=0
        END
    'CODEBASED':    BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 1
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=1
        END

    'MAINTEXT': WIDGET_CONTROL, Obj.Value1, SET_UVALUE=Event.Value

    'VALUETEXT':Obj.Value2      = Event.Value   ; UNIMPLEMENTED
    'NORMAL':   Obj.BaseExcl    = 0             ; Exclusivity of Group
    'EXCL':     Obj.BaseExcl    = 1
    'NONEXCL':  Obj.BaseExcl    = 2
    'TOP':      Obj.TopTitle    = Event.Value   ; Basic Info Values
    'LEFT':     Obj.LeftTitle   = Event.Value

    'NROW':     Obj.NRowCol     = Event.Value   ; Base type Values
    'SPACE':    Obj.Space       = Event.Value
    'XPAD':     Obj.XPad        = Event.Value
    'YPAD':     Obj.YPad        = Event.Value
    'FONT':     Obj.Font        = Event.Value

    'NAME':     Obj.Name        = Event.Value   ; Other values
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value

    'XSIZE':    Obj.XSize       = Event.Value   ; XY Stuff
    'YSIZE':    Obj.YSize       = Event.Value
    'XOFFSET':  Obj.XOffset     = Event.Value
    'YOFFSET':  Obj.YOffset     = Event.Value
    'XSCROLL':  Obj.XScrollSize = Event.Value
    'YSCROLL':  Obj.YScrollSize = Event.Value

    'XFONT':    DoXFont, Obj, Binfo.Foci(6)
    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  BGROUP_Build
;   Create a dialog box a button group object.  If ptr is nil then
;   create the object as well.
;
PRO BGROUP_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    BGROUP_Alloc, ParPtr, Ptr               ; Allocate object if necessary
    MgrName = 'WE_BGROUP' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create Dialog

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(16)

    Base1   = WIDGET_BASE(Base, /COLUMN)
    ; Lab       = WIDGET_LABEL(Base1, VALUE="Basic Information")
    BuildEdit, Base1, Obj, _EditId
    BuildBaseType, Base1, Obj, Foci, 0, RowColId, RowColBtns, /ROW

    Base2   = WIDGET_BASE(Base1, /ROW)
    Label   = WIDGET_LABEL(Base2, VALUE="Base Type:")
    Base3   = WIDGET_BASE(Base2, /ROW, /EXCLUSIVE)
    Btns    = LONARR(3)
    Btns(0) = WIDGET_BUTTON(Base3, VALUE='Normal Base', UVALUE='NORMAL')
    Btns(1) = WIDGET_BUTTON(Base3, VALUE='Exclusive', UVALUE='EXCL')
    Btns(2) = WIDGET_BUTTON(Base3, VALUE='Non Exclusive', UVALUE='NONEXCL')

    Base2   = WIDGET_BASE(Base1, /ROW)
    Foci(4) = Field(Base2, 'Top Title:', Obj.TopTitle, 'TOP', SIZE=20, /STRING)
    Foci(5) = Field(Base2, 'Left Title:', Obj.LeftTitle,'LEFT',SIZE=20,/STRING)

    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(6) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")

    BuildOther, Base1, Obj, Foci, 7

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Button Group Appearance Controls")
    BuildXY, Base1, Obj, Foci, 10, /SIZE, /OFFSET, /SCROLL
    BuildOkCancel, Base, Obj

    DlgInfo     = {             $
        Foci:       Foci,       $
        RowColId:   RowColId,   $
        ObjPtr:     Ptr         $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY  ; Save dialog info
    WIDGET_CONTROL, Base, /REALIZE                      ; Create dialog

    ;   Set controls in dialog to show current state
    WIDGET_CONTROL, RowColBtns(Obj.BaseType), /SET_BUTTON
    WIDGET_CONTROL, Btns(Obj.BaseExcl), /SET_BUTTON
    WIDGET_CONTROL, RowColId, SENSITIVE=(Obj.BaseType NE 0)

    ;   Hand off dialog to window manager
    XMANAGER, MgrName, Base, EVENT_HANDLER='BGROUP_Event', CLEANUP='MISC_Kill'

    Obj2Ptr, Obj, Ptr       ; Restore pointer
END

;
;  BGROUP_Save
;   Save button group information in a file.
;   Store value as well: If value is nil, make up a value.
;
;   FORMAT:
;       <bgroup object>
;       <number of elements in value>
;       <value>
;
PRO BGROUP_Save, Unit, Ptr
    GenWrite, Unit, Ptr, DEFAULT="<Nil BGROUP>"
END

;
;  BGROUP_Restore
;   Read in a button group object from a file
;
PRO BGROUP_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "BGROUP", 1
END

;
;  BGROUP_Generate
;   Create a button group object for previewing
;
PRO BGROUP_Generate, Base, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj

    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    GetValue, Obj, Names, "<Nil BGROUP>"        ; Get Value (or use default)

    ;   Generate command string

    Cmd = 'Id = CW_BGROUP(Base,Names'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    SAddCmd, Cmd, Obj.Font, 'FONT'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'
    IAddCmd, Cmd, Obj.XScrollSize, 'X_SCROLL_SIZE'
    IAddCmd, Cmd, Obj.YScrollSize, 'Y_SCROLL_SIZE'
    SAddCmd, Cmd, Obj.TopTitle, 'LABEL_TOP'
    SAddCmd, Cmd, Obj.LeftTitle, 'LABEL_LEFT'

    ;   Row/Column

    IF Obj.BaseType EQ 1 THEN               $
        IAddCmd, Cmd, Obj.NRowCol, 'ROW'    $
    ELSE IF Obj.BaseType EQ 2 THEN          $
        IAddCmd, Cmd, Obj.NRowCol, 'COLUMN'

    ; Normal/Exclusive/Nonexclusive

    IF Obj.BaseExcl NE 0 THEN BEGIN
        IF Obj.BaseExcl EQ 1 THEN       $
            Cmd = Cmd + ',/EXCLUSIVE'       $
        ELSE                    $
            Cmd = Cmd + ',/NONEXCLUSIVE'
    ENDIF ELSE BEGIN
        IAddCmd, Cmd, Obj.Space, 'SPACE'
        IAddCmd, Cmd, Obj.XPad, 'XPAD'
        IAddCmd, Cmd, Obj.YPad, 'YPAD'
    ENDELSE

    Obj2Ptr, Obj, Ptr

    ; Create bgroup by executing command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Button Group ' + VarName(Ptr)
    ENDIF

END

;
;  BGROUP_GenWid
;   Create IDL code for creating a button group (CW_BGROUP)
;
PRO BGROUP_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)                ; Get variable name of object
    Ptr2Obj, Ptr, Obj                   ; Get object info
    BtnName = 'Btns' + STRTRIM(Ptr,2)   ; Create value name
    SaveStr, Unit, Ptr, Obj, BtnName, "<Nil BGROUP>"    ; create value code.

    XPRINTF, FORMAT='("  ",A," = CW_BGROUP( ",A,", ",A)', $
        Unit, Name, Parent, BtnName, /NO_EOL

    ;   Row/Column Base?

    IF Obj.BaseType EQ 1 THEN           $
        ISaveCmd, Unit, Obj.NRowCol, 'ROW'  $
    ELSE IF Obj.BaseType EQ 2 THEN  $
        ISaveCmd, Unit, Obj.NRowCol, 'COLUMN'

    ; Normal/Exclusive/Nonexclusive base?

    IF Obj.BaseExcl NE 0 THEN BEGIN
        IF Obj.BaseExcl EQ 1 THEN BEGIN
            ISaveCmd, Unit, 1, "EXCLUSIVE"
        ENDIF ELSE BEGIN
            ISaveCmd, Unit, 1, "NONEXCLUSIVE"
        ENDELSE
    ENDIF ELSE BEGIN
        ISaveCmd, Unit, Obj.Space, 'SPACE'
        ISaveCmd, Unit, Obj.XPad, 'XPAD'
        ISaveCmd, Unit, Obj.YPad, 'YPAD'
    ENDELSE

    SSaveCmd, Unit, Obj.Font, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, Obj.LeftTitle, "LABEL_LEFT"
    SSaveCmd, Unit, Obj.TopTitle, "LABEL_TOP"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.XScrollSize, "X_SCROLL_SIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    ISaveCmd, Unit, Obj.YScrollSize, "Y_SCROLL_SIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  BGROUP_Alloc
;       Allocate a button group object.  Don't do this if ptr is not NULL
;
PRO BGROUP_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr     = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer
    ValueId = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer for the value too

    ;   Make a Button Group object

    Obj     = {                 $
        WE_BGROUP,              $
        Type:           'BGROUP',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; next pointer (for lists)
        Name:           '',     $ ; object name
        BaseExcl:       0,      $ ; Enum { Normal, Exclusive, Non-Exclusive }
        BaseType:       1,      $ ; Enum { BBS, Row, Col } (Row is dflt)
        FrameSize:      0,      $
        Font:           '',     $
        NRowCol:        1,      $ ; Number of Rows or Columns
        Space:          0,      $
        TopTitle:       '',     $
        LeftTitle:      '',     $
        UValue:         '',     $
        Value1:         ValueId,$
        Value2:         '',     $ ; UNIMPLEMENTED and unused
        ValueType:      0,      $ ; UNIMPLEMENTED and unused
        XPad:           0,      $
        YPad:           0,      $
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        XScrollSize:    0,      $
        YScrollSize:    0       $
    }
    Obj2Ptr, Obj, Ptr                       ; Store object in pointer
END
; $Id: bilinear.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION BILINEAR,P,IX,JY
;+
; NAME:
;	BILINEAR
;
; PURPOSE:
;	Bilinearly interpolate a set of reference points.
;
; CALLING SEQUENCE:
;	Result = BILINEAR(P, IX, JY)
;
; INPUTS:                 
;	P:  A two-dimensional data array.
;
;	IX and JY:  The "virtual subscripts" of P to look up values
;	  for the output.
;  
;	IX can be one of two types:
;	     1)	A one-dimensional, floating-point array of subscripts to look
;		up in P.  The same set of subscripts is used for all rows in
;		the output array.
;	     2)	A two-dimensional, floating-point array that contains both 
;		"x-axis" and "y-axis" subscripts specified for all points in
;		the output array.
;
;	In either case, IX must satisfy the expression,
;		    0 <= MIN(IX) < N0  and 0 < MAX(IX) <= N0
;	where N0 is the total number of subscripts in the first dimension
;	of P.
;
;	JY can be one of two types:
;	     1) A one-dimensional, floating-point array of subscripts to look
;		up in P.  The same set of subscripts is used for all rows in
;		the output array.
;	     2) A two-dimensional, floating-point array that contains both
;               "x-axis" and "y-axis" subscripts specified for all points in
;               the output array.
;
;	    In either case JY must satisfy the expression,
;		    0 <= MIN(JY) < M0  and 0 < MAX(JY) <= M0
;	    where M0 is the total number of subscripts in the second dimension
;	    of P.
;
;  	It is better to use two-dimensional arrays for IX and JY when calling
;  	BILINEAR because the algorithm is somewhat faster.  If IX and JY are 
;  	one-dimensional, they are converted to two-dimensional arrays on
;  	return from the function.  The new IX and JY can be re-used on 
;	subsequent calls to take advantage of the faster, 2D algorithm.  The 
;	2D array P is unchanged upon return.
;
; OUTPUT:
;	The two-dimensional, floating-point, interpolated array.  
;
; SIDE EFFECTS:
;	This function can take a long time to execute.
;
; RESTRICTIONS:
;	None.
;
; EXAMPLE:
;	Suppose P = FLTARR(3,3), IX = [.1, .2], and JY = [.6, 2.1] then
;	the result of the command:
;		Z = BILINEAR(P, IX, JY)
;	Z(0,0) will be returned as though it where equal to P(.1,.6) 
;	interpolated from the nearest neighbors at P(0,0), P(1,0), P(1,1)
;	and P(0,1).
;
; PROCEDURE:
;	Uses bilinear interpolation algorithm to evaluate each element
;	in the result  at virtual coordinates contained in IX and JY with 
;	the data in P.                                                          
;
; REVISION HISTORY:
;       Nov. 1985  Written by L. Kramer (U. of Maryland/U. Res. Found.)
;	Aug. 1990  TJA simple bug fix, contributed by Marion Legg of NASA Ames
;	Sep. 1992  DMS, Scrapped the interpolat part and now use INTERPOLATE
;-
	ON_ERROR,2              ;Return to caller if an error occurs	
	IF((N_ELEMENTS(IX) EQ 0) AND (N_ELEMENTS(JY) EQ 0)) THEN BEGIN
	  I=FIX(IX) & J=FIX(JY) & IP=I+1 & JP=J+1
	  DX=IX-FLOAT(I) & DY=JY-FLOAT(J)
	  DX1=(1.-DX) & DY1=(1.-DY) 
	  RETURN,( P(I,J)*DX1*DY1 + P(I,JP)*DX1*DY $
	  	+ P(IP,J)*DX*DY1 + P(IP,JP)*DX*DY)
	ENDIF

	A=SIZE(IX)  & B=SIZE(JY)
	NX=A(1)
	IF(B(0) EQ 1) THEN BEGIN
	  NY=B(1)
	ENDIF ELSE BEGIN
	  NY=B(2)
	ENDELSE                                                   
        IF(A(0) EQ 1) THEN BEGIN
	  TEMP=IX
	  IX=FLTARR(NX,NY)
	  FOR I=0,NY-1 DO IX(0,I)=TEMP
	ENDIF
	IF(B(0) EQ 1) THEN BEGIN
	  TEMP=JY
	  JY=FLTARR(NY,NX)
	  FOR I=0,NX-1 DO JY(0,I)=TEMP
	  JY=TRANSPOSE(JY)
	ENDIF
	return, interpolate(p, ix, jy)	;Use new interpolate function
;	I=FIX(IX) & J=FIX(JY)
;	IP=I+1   &  JP=J+1
;	DX=IX-I & DY=JY-J
;	DX1=1.-DX & DY1=1.-DY
;	Z=FLTARR(N_ELEMENTS(I(*,0)),N_ELEMENTS(J(0,*)))
;	NUMX=N_ELEMENTS(I)
;	PZ=FLTARR(N_ELEMENTS(P(*,0))+1,N_ELEMENTS(P(0,*))+1)
;	PZ(0,0)=P(0:*,0:*)
;	FOR N=0L,NUMX-1 DO BEGIN
;	  Z(N)=  PZ(I(N), J(N)) *DX1(N)*DY1(N)	$
;	+        PZ(I(N),JP(N)) *DX1(N)*DY(N)	$
;	+        PZ(IP(N),J(N)) *DX(N) *DY1(N)	$
;	+        PZ(IP(N),JP(N))*DX(N) *DY(N)
;	ENDFOR 
;	RETURN,Z
END			
; $Id: bin_date.pro,v 1.2 1993/10/04 18:45:20 doug Exp $

function bin_date, ascii_time
;+
; NAME:
;	BIN_DATE
;
; PURPOSE:
;	This function converts a standard form ascii date/time string
;	to a binary string.
;
; CATEGORY:
;	Date/time functions.
;
; CALLING SEQUENCE:
;	Result = BIN_DATE(Asc_time)
;
; INPUTS:
;	Asc_time: the date/time to convert in standard ascii format.
;		  If omitted, use the current date/time.  
;	  	  Standard form is a 24 character string:
;			DOW MON DD HH:MM:SS YYYY
;		  where: DOW = day of week, MON = month, DD=day of month,
;			HH:MM:SS = hour/minute/second, YYYY = year.
;
; OUTPUTS:
;	This function returns a 6 element integer array containing:
; 	Element 0 = year	e.g. 1992
;		1 = month	1-12
;		2 = day		1-31
;		3 = hour	0-23
;		4 = minute	0-59
;		5 = second	0-59
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
; 	Written by:	DMS /RSI, Jul, 1992.
;-


if n_elements(ascii_time) eq 0 then ascii_time = systime(0)	;Current time
m = strmid(ascii_time,4,3)	;Month
m = where(strupcase(m) eq $
 ['JAN','FEB','MAR','APR', 'MAY', 'JUN', 'JUL', 'AUG','SEP','OCT','NOV','DEC'])
return, [ strmid(ascii_time, 20,4), $	;year
	m(0) + 1, $			;Month
	strmid(ascii_time, 8,2), $	;day
	strmid(ascii_time, 11,2), $	;Hour
	strmid(ascii_time, 14,2),$	;minute
	strmid(ascii_time, 17,2)]	;second
end

;$Id: binomial.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       BINOMIAL
;
; PURPOSE:
;       This function computes the probabilty (bp) such that:
;                   Probability(X => v) = bp 
;       where X is a random variable from the cumulative binomial distribution
;       (Bernouli distribution).
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Binomial(V, N, P)
;
; INPUTS:
;       V:    A non-negative integer specifying the minimal number of 
;             times an event E occurs in (N) independent performances.
;
;       N:    A non-negative integer specifying the number of performances.
;             If the number of performances exceeds 25, the Gaussian 
;             distribution is used to approximate the cumulative binomial 
;             distribution.
;
;       P:    A non-negative scalar, in the interval [0.0, 1.0],  of type 
;             float or double that specifies the probability of occurance 
;             or success of a single independent performance.
;
; EXAMPLES:
;       Compute the probability of obtaining at least two 6s in rolling a
;       die four times. The result should be 0.131944
;         result = binomial(2, 4, 1./6.)
;
;       Compute the probability of obtaining exactly two 6s in rolling a
;       die four times. The result should be 0.115741
;         result = binomial(2, 4, 1./6.) - binomial(3, 4, 1./6.)
;
;       Compute the probability of obtaining three or fewer 6s in rolling
;       a die four times. The result should be 0.999228
;         result = (binomial(0, 4, 1./6.) - binomial(1, 4, 1./6.)) + $
;                  (binomial(1, 4, 1./6.) - binomial(2, 4, 1./6.)) + $
;                  (binomial(2, 4, 1./6.) - binomial(3, 4, 1./6.)) + $
;                  (binomial(3, 4, 1./6.) - binomial(4, 4, 1./6.))
;
; PROCEDURE:
;       BINOMIAL computes the probability that an event E occurs at least
;       (V) times in (N) independent performances. The event E is assumed
;       to have a probability of occurance or success (P) in a single 
;       performance.
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. Rewrote documentation header.
;-

function N_BANG, n, min, fac1
  ;If min and fac1 are undefined, then N_BANG returns n!.
  ;Otherwise, fac1 * min * (min+1)....n is returned.
  if n_elements(min) eq 0 then min = 2
  if n_elements(fac1) eq 0 then fac = 1. $
    else fac = fac1
  if min gt n then return, fac
  n1 =  n < 10
  if min lt 11 then  $
    for i = min, n1 do fac = i*fac
  if (n lt 11.) then return, fac
  n1 = 11 > min
  ;Use logarithms to preserve precision.
  return, fac * exp(total(alog(findgen(n-n1+1) + n1)))
end

function binomial, v, n, p

  on_error, 2  ;Return to caller if error occurs.

  if p lt 0. or p gt 1. then message, $
    'p must be in the interval [0.0, 1.0]'

  if v lt 0 then message, $
    'v must be nonnegative.'

  if n lt 0 then message, $
    'n must be nonnegative.'

  if v eq 0 then return,  1.0 $
  else if n gt 25 then return, $
                  1.0 - gauss_pdf((v-n*p)/sqrt(n*p*(1-p))) $
  else if v gt n then return,  0.0

  nn = fix(n)
  vv = fix(v)
  n2 = vv < (nn - vv)
  n3 = vv > (nn - vv)
  n1 = N_BANG(nn, n3+1, p)
  n1 =  n1/N_BANG(n2)
  sum = n1 * p^(vv-1) * (1-p)^(nn-vv)
  for i = vv+1, nn do begin
    n1 = (nn-i+1) * n1/float(i)
    sum = sum + n1 * p^(i-1) * (1-p)^(nn-i)
  endfor
  return, sum
end
;$Id: bisect_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       BISECT_PDF
;
; PURPOSE:
;       This function computes the cutoff value x such that the probabilty
;       of an observation from the given distribution, less than x, is a(0).
;       u and l are the upper and lower limits for x, respectively.
;       a(1) and a(2) are degrees of freedom, if appropriate.
;       funct is a string specifying the probability density function.
;       BISECT_PDF is not intended to be a user-callable function.
;-

function bisect_pdf, a, funct, u, l, del
  sa = size(a)
  if (n_elements(del) eq 0) then del = 1.0e-6
  p = a(0)
  if (p lt 0 or p gt 1) then return, -1
  up = u
  low = l
  mid = l + (u - l) * p
  count = 1
  while (abs(up - low) gt del*mid) and (count lt 100) do begin
   if n_elements(z) ge 1 then begin 
     if z gt p then  up = mid else low = mid
     mid = (up + low)/2.
   endif
  case n_elements(a) of
    1: z = call_function(funct, mid)
    2: z = call_function(funct, mid, a(1))
    3: z = call_function(funct, mid, a(1), a(2))
    else: return, -1
  endcase
  count = count + 1
  endwhile
  return, mid
end



  
;$Id: blk_con.pro,v 1.5 1994/11/29 18:30:12 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       BLK_CON
;
; PURPOSE:
;       This function computes a "fast convolution" of a digital signal 
;       and an impulse-response sequence.
;
; CATEGORY:
;       Digital Signal Processing
;
; CALLING SEQUENCE:
;       Result = BLK_CON(Filter, Signal, B_length = B_length)
;
; INPUTS:
;       Filter = A P-element floating-point vector containing the impulse-
;                response sequence of the digital filter.
;       Signal = An N-element floating-point vector containing the discrete 
;                signal samples.
;                
; KEYWORD PARAMETERS:
;       B_length = (Block Length) An integer specifying the length of
;                  the subdivided signal segments. If this paramter is
;                  not specified, a near-optimal value is chosen by the 
;                  algorithm based upon the length of the impulse-response 
;                  sequence, P. If P is a value less than 11 or greater 
;                  than 377, then B_length must be specified.
;
; RESTRICTIONS:
;       1) The block length must be greater than the filter length.
;          B_length > P
;       2) The block length must be less than the number of signal samples.
;          B_length < N_elements(Signal)
;
; EXAMPLE:
;       Create an impulse-response sequence of length P = 32. 
;         filter = replicate(1.0, 32) ;Set all points to 1.0
;         filter(2*indgen(16)) = 0.5  ;Set even points to 0.5
;
;       Create a sampled signal with random noise.
;         signal = sin((findgen(1000)/35.0)^2.5)
;         noise  = (randomu(SEED,1000)-0.5)/2
;         signal = signal + noise
;
;       Convolve the filter and signal using block convolution.
;         result = BLK_CON(filter, signal)
;
; PROCEDURE:
;       Implementation of the "overlap-save" method in the frequency domain.
;       The discrete signal samples are divided into overlapping segments of
;       a length specified by the parameter B_length. B_length may be supplied
;       by the user as an optional keyword parameter or determined by the
;       algorithm to a near-optimal value. Each input segment consists of P-1
;       samples from the previous input segment and (B_length-P+1) new signal
;       samples, where P is the length of the filter. Each of these segments
;       is processed in the frequency domain and then 'reassembled' in the
;       time domain. The first and last input segments are handled differently.
;       The result is an N-element floating-point vector containing the 
;       filtered signal.
;
; REFERENCE:
;       Oppenheim, A.V. and Schafer, R.W.
;       DIGITAL SIGNAL PROCESSING
;       Prentice-Hall, 1975
;
; MODIFICATION HISTORY:
;           Written by:  GGS, RSI, May 1993
;           Modified:    GGS, RSI, June 1994
;                        Added long indexing into vectors. Minor changes in 
;                        the use of intermediate variables reduces memory
;                        allocation in certain instances. Made slight changes
;                        to the documentation header.
;-

function BLK_CON, Filter, Signal, B_length = B_length

  ;Return to caller if an error occurs.
  on_error, 2 

  ;Block length is based upon filter length.
  p = n_elements(filter)
  if n_elements(b_length) eq 0 then begin
    if (p lt 11) then stop, $
      'Block length must be specified as a keyword parameter.' $
    else if (p LE 17)  then blen = 64   $
    else if (p LE 29)  then blen = 128  $
    else if (p LE 52)  then blen = 256  $
    else if (p LE 94)  then blen = 512  $
    else if (p LE 171) then blen = 1024 $
    else if (p LE 377) then blen = 2048 $
    else stop, 'Block length must be specified as a keyword parameter.'
  endif else blen = long(b_length) ;User specified block length.

  ;RESTRICTION:1
  if p ge blen then stop, $
    'Block length must be greater than the filter length.'

  ;Number of discrete signal samples.
  ns = n_elements(signal) 

  ;RESTRICTION:2
  if blen ge ns then stop, $
    'Block length must be less than the number of signal samples.'

  ;Number of signal segments of length, blen-p+1
  k = ns / (blen - P + 1L)

  ;Length of last signal segment.
  rem = ns mod (blen - p + 1L)

  ;Represent the filter in frequency domain.
  z_filter = fft([filter, fltarr(blen-p)], -1)

  ;The first segment is handled differently than the rest.
  ;Forward zero-pad signal segment up to a length of blen.
  lower = 0L
  upper = blen - p
  input = [fltarr(p-1), signal(lower:upper)]
  
  ;Allocate storage for the result.
  result = fltarr(ns, /nozero)

  ;Complex point-wise multiplication and inverse transform.
  output = float(fft((z_filter * fft(input, -1)), 1) *  blen)
  ;The 'blen' term is a scale factor unique to IDL's FFT algorithm.
  ;Discard the first p-1 points to obtain the first output segment.
  result(0) = output(p-1:blen-1)

  ;Next place to store.
  ip = blen - p + 1L

  ;Begin to process the subdivided signal segments.
  loop  = 1L
  lower = upper + 1L
  upper = lower + blen - p  ;upper = lower+(blen-p+1)-1
  while loop le k-1L do begin
    input  = [input(blen-p+1:blen-1), signal(lower:upper)]
    output = float(fft((z_filter * fft(input, -1) ),1) * blen)
    result(ip) = output(p-1:blen-1) ;Next output segment.
    ip = ip + blen - p + 1L
    lower = upper + 1L
    upper = lower + blen - p
    loop  = loop + 1L
  endwhile

  ;Last signal segment is of length, rem. If rem is not zero 
  ;there is a signal segment that is handled differently.
  if rem ne 0L then begin
    output = float(fft((fft([filter, fltarr(p+rem-2)] ,-1) $
             * fft([input(blen-p+1:blen-1), signal(lower:lower+rem-1), $
               fltarr(p-1)], -1)), 1) * (2*p+rem-2))
    ;(2*p+rem-2) is an FFT scale factor.
    result(ip) = output(p-1:p+rem-2)
  endif
  return, result
  ;Clean up intermediate variables.
  z_filter = 0
  input = 0
  output = 0
  result = 0
end
;
; $Id: bmpbtn_alloc.pro,v 1.12 1995/01/20 19:41:01 tonyh Exp $
;
;  WidBmpBtn
;   Widget Bitmap Button class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;


;
;  BMPBTN_Icon
;       Return the bitmapped button toolbar icon
;
FUNCTION BMPBTN_Icon
    RETURN, [ $
        [000B, 000B, 000B, 000B],           $
        [000B, 000B, 000B, 000B],           $
        [000B, 000B, 000B, 000B],           $
        [128B, 255B, 001B, 000B],           $
        [224B, 255B, 007B, 000B],           $
        [240B, 000B, 015B, 000B],           $
        [056B, 000B, 028B, 000B],           $
        [024B, 000B, 024B, 000B],           $
        [028B, 000B, 056B, 000B],           $
        [012B, 000B, 048B, 000B],           $
        [012B, 000B, 048B, 000B],           $
        [012B, 000B, 048B, 000B],           $
        [012B, 000B, 048B, 000B],           $
        [012B, 000B, 240B, 031B],           $
        [012B, 000B, 240B, 031B],           $
        [012B, 000B, 112B, 029B],           $
        [028B, 000B, 184B, 026B],           $
        [024B, 000B, 088B, 029B],           $
        [056B, 000B, 188B, 026B],           $
        [240B, 000B, 095B, 029B],           $
        [224B, 255B, 175B, 026B],           $
        [128B, 255B, 085B, 029B],           $
        [000B, 176B, 170B, 026B],           $
        [000B, 112B, 085B, 029B],           $
        [000B, 176B, 170B, 026B],           $
        [000B, 112B, 085B, 029B],           $
        [000B, 176B, 170B, 026B],           $
        [000B, 240B, 255B, 031B],           $
        [000B, 240B, 255B, 031B],           $
        [000B, 000B, 000B, 000B],           $
        [000B, 000B, 000B, 000B],           $
        [000B, 000B, 000B, 000B]            $
        ]
END


;
;  BMPBTN_Copy
;   Copy a button.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO BMPBTN_Copy, Ptr, Copy
    GenCopy, Ptr, Copy, /HASVALUE
END


;
;  BMPBTN_Destroy
;   Release resources for the given button
;
PRO BMPBTN_Destroy, Ptr
    GenDestroy, Ptr, /HASVALUE
END


PRO BMPBTN_DrawBits, DlgInfo, Obj

    WSET, DlgInfo.WindowId
    ERASE

    Ptr2Obj, Obj.Value1, Bits

    ;   Fill in preview

    IF DlgInfo.Preview NE 0 THEN $
    WIDGET_CONTROL, DlgInfo.Preview, SET_VALUE=Bits

    ;   Fill in Drawable based on size

    NBits   = DlgInfo.NBits
    Delta   = DlgInfo.Delta
    Last    = 389               ; NBits * Delta + 5

    Pix     = BYTARR(NBits, NBits)
    White   = !D.N_COLORS-1
    FOR I=NBits-1,0,-1 DO BEGIN
        FOR J=0,NBits - 1 DO BEGIN
            Mask    = ISHFT(1, J AND 7)
            Offset  = ISHFT(J, -3)
            IF (Bits(Offset, I) AND Mask) EQ 0 THEN Pix(J,I) = White
        ENDFOR
    ENDFOR

    TV, REBIN(Pix, 384, 384, /SAMPLE), 5, 5, /ORDER

    ;   Draw lines

    Gray    = !D.N_COLORS / 2
    FOR I=0,NBits DO BEGIN
        Offset  = I * Delta + 5
        PLOTS, [ 5, Last ], [ Offset, Offset ], /DEVICE, COLOR=Gray
        PLOTS, [ Offset, Offset ], [ 5, Last ], /DEVICE, COLOR=Gray
    ENDFOR

    Obj2Ptr, Bits, Obj.Value1
END


;
;  BMPBTN_Event
;   Event handling routine for a button dialog.
;
PRO BMPBTN_Event, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev               ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                            ; Get Object

    IDirty  = 1

    CASE Ev OF

    'NAME':     Obj.Name        = Event.Value
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'XOFFSET':  Obj.XOffset     = Event.Value
    'YOFFSET':  Obj.YOffset     = Event.Value
    'DRAW':     BEGIN
        IDirty  = 0
        IF Event.Press NE 0 AND Binfo.Press EQ 0 THEN BEGIN

            IF Event.Press EQ 1 THEN            Binfo.Clear = -1 $
            ELSE IF Event.Press EQ 2 THEN       Binfo.Clear = 1 $
            ELSE                                Binfo.Clear = 0

            Binfo.Press     = 1;
            Binfo.CurrX     = -1;
            Binfo.CurrY     = -1;
            WSET, BInfo.WindowId
        ENDIF

        IF Event.Release NE 0 THEN BEGIN
            Binfo.Press     = 0;
            Ptr2Obj, Obj.Value1, Bits
        IF Binfo.Preview NE 0 THEN $
            WIDGET_CONTROL, Binfo.Preview, SET_VALUE=Bits
            Obj2Ptr, Bits, Obj.Value1
        ENDIF

        IF Binfo.Press AND $
           Event.X GE 5 AND Event.X LT 389 AND $
           Event.Y GE 5 AND Event.Y LT 389 THEN BEGIN

            X       = (Event.X - 5) / Binfo.Delta;
            Y       = Binfo.NBits - 1 - (Event.Y - 5) / Binfo.Delta;

            ;       Has to be a new square
            IF X NE Binfo.CurrX OR Y NE Binfo.CurrY THEN BEGIN

                Binfo.CurrX     = X
                Binfo.CurrY     = Y

                ;       convert back to device coords

                Ptr2Obj, Obj.Value1, Bits

                Mask    = ISHFT(1, X AND 7)
                Offset  = ISHFT(X, -3)

                ;       Determine what we are doing if initial event
                IF Binfo.Clear EQ -1 THEN $
                    Binfo.Clear = (Bits(Offset, Y) AND Mask) NE 0

                IF Binfo.Clear THEN BEGIN
                    Color           = 255
                    Bits(Offset,Y)  = Bits(Offset, Y) AND (NOT Mask)
                ENDIF ELSE BEGIN
                    Color           = 0
                    Bits(Offset,Y)  = Bits(Offset, Y) OR Mask
                ENDELSE

                X1      = X * Binfo.Delta + 6
                X2      = X1 + Binfo.Delta - 1
                Y1      = (Binfo.NBits - 1 - Y) * Binfo.Delta + 5
                Y2      = Y1 + Binfo.Delta - 1
                POLYFILL, /DEVICE, [X1, X2, X2, X1], [Y1, Y1, Y2, Y2], $
                    COLOR=Color
                Obj2Ptr, Bits, Obj.Value1
                IDirty  = 1
            ENDIF
        ENDIF
        END
    'BMP16':        BEGIN
        Obj.Size        = 0
        Binfo.NBits     = 16
        Binfo.Delta     = 24
        Obj2Ptr, BYTARR(2,16), Obj.Value1
        BMPBTN_DrawBits, Binfo, Obj
        ENDIF
    'BMP32':        BEGIN
        Obj.Size        = 1
        Binfo.NBits     = 32
        Binfo.Delta     = 12
        Obj2Ptr, BYTARR(4,32), Obj.Value1
        BMPBTN_DrawBits, Binfo, Obj
        ENDIF
    'BMP64':        BEGIN
        Obj.Size        = 2
        Binfo.NBits     = 64
        Binfo.Delta     = 6
        Obj2Ptr, BYTARR(8,64), Obj.Value1
        BMPBTN_DrawBits, Binfo, Obj
        ENDIF
    'INVERT':   BEGIN
        Ptr2Obj, Obj.Value1, Bits
        Obj2Ptr, (NOT Bits), Obj.Value1
        BMPBTN_DrawBits, Binfo, Obj
        END
    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END
    'IGNORE':   ; Ignore

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = Dirty OR IDirty

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  BMPBTN_Build
;   Create a dialog box a bitmap button object.  If ptr is nil then
;   create the object as well.
;
PRO BMPBTN_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    BMPBTN_Alloc, ParPtr, Ptr               ; Allocate object if necessary
    MgrName = 'WE_BMPBTN' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(5)

    ;   Basic information Related Info

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    Base2   = WIDGET_BASE(Base1, /ROW, SPACE=30 )
    Draw    = WIDGET_DRAW(Base2, RETAIN=2, /BUTTON_EVENTS, /MOTION_EVENTS, $
                              UVALUE='DRAW', XSIZE=64*6+11, YSIZE=64*6+11 )
    Base3   = WIDGET_BASE(Base2)

    ;  No preview on Mac/PC because can't resize button

;
;   Preview works fine on a Mac now. (It ought to pork on Windows too, so we'll
;   build the button on all platforms.
;

 ;   IF !Version.OS EQ 'MacOS' OR !Version.OS EQ 'Win32' THEN BEGIN
 ;   Preview = 0
 ;   ENDIF ELSE BEGIN
    Preview = WIDGET_BUTTON(Base3, VALUE=BYTARR(8,64),YOFFSET=160, $
                        UVALUE='IGNORE')
 ;   ENDELSE
    Base2   = WIDGET_BASE(Base1, /ROW)
    Base3   = WIDGET_BASE(Base2, /FRAME, /ROW)
    Label   = WIDGET_LABEL(Base3, VALUE="Bitmap Size:")
    Btns    = LONARR(3)
    Btns(0) = WIDGET_BUTTON(Base3, VALUE='16x16', UVALUE="BMP16", /NO_REL)
    Btns(1) = WIDGET_BUTTON(Base3, VALUE='32x32', UVALUE="BMP32", /NO_REL)
    Btns(2) = WIDGET_BUTTON(Base3, VALUE='64x64', UVALUE="BMP64", /NO_REL)

    Dummy   = WIDGET_LABEL(Base2, VALUE="  ")
    Dummy   = WIDGET_BUTTON(Base2, VALUE="Invert", UVALUE="INVERT" )

    ;       Fill in Drawable based on size
    NBits   = ISHFT(1, 4 + Obj.Size)

    BuildOther, Base, Obj, Foci, 0, /FRAME

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Button Appearance Controls")
    BuildXY, Base1, Obj, Foci, 3, /OFFSET
    BuildOkCancel, Base, Obj

    DlgInfo     = {         $
        Foci:       Foci,   $
        ObjPtr:     Ptr,    $
        Delta:      6*64/NBits, $
        NBits:      NBits,  $
        Preview:    Preview,$
        WindowId:   0,      $
        Press:      0,      $
        Clear:      0,      $
        CurrX:      -1,     $
        CurrY:      -1      $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='BMPBTN_Event', $
        CLEANUP='MISC_Kill'
    WIDGET_CONTROL, Btns(Obj.Size), /SET_BUTTON ; Set button size
    WIDGET_CONTROL, Draw, GET_VALUE=WindowId
    DlgInfo.WindowId        = WindowId

    BMPBTN_DrawBits, DlgInfo, Obj

    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    Obj2Ptr, Obj, Ptr
END


;
;  BMPBTN_Save
;   Save button information to a file.
;   This is a simple object to save.
;
PRO BMPBTN_Save, Unit, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Ptr2Obj, Obj.Value1, Value

    ON_IOERROR, BadWrite

    WRITEU, Unit, Obj
    WRITEU, Unit, Value
    Obj2Ptr, Value, Obj.Value1
    Obj2Ptr, Obj, Ptr
    RETURN

  BadWrite:
    Dirty   = 2
    Obj2Ptr, Value, Obj.Value1
    Obj2Ptr, Obj, Ptr
END


;
;  BMPBTN_Restore
;   Read in a button object from a file
;
PRO BMPBTN_Restore, Unit, Parent, Ptr

    BMPBTN_Alloc, Parent, Ptr
    Ptr2Obj, Ptr, Obj

    SaveV1  = Obj.Value1        ; Save value pointer (crushed by read)
    READU, Unit, Obj            ; Read in object

    NBits   = ISHFT(1, 4+Obj.Size)
    Value   = BYTARR(NBits/8, NBits)
    READU, Unit, Value

    Obj.Value1  = SaveV1        ; Restore saved value pointer
    Obj2Ptr, Value, Obj.Value1  ; Store names in value pointer

    Obj.Dialog  = 0             ; Clear old (and invalid) value
    Obj.Next    = 0             ; Clear old (and invalid) value
    Obj.Parent  = Parent        ; Parent changes every run
    Obj2Ptr, Obj, Ptr           ; Save what we've read
END


;
;  BMPBTN_Generate
;   Create a button object for previewing
;
PRO BMPBTN_Generate, Base, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Build a command string

    Cmd = 'Id = WIDGET_BUTTON(Base'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'
    Ptr2Obj, Obj.Value1, Bits, /COPY
    Cmd = Cmd + ',VALUE=Bits'
    Obj2Ptr, Obj, Ptr

    ; Create button by executing the command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Button ' + VarName(Ptr)
    ENDIF
END


;
;  BMPBTN_GenWid
;   Create IDL code for creating a BUTTON
;
PRO BMPBTN_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)            ; Get variable name of object
    Ptr2Obj, Ptr, Obj               ; Get Object info

    ValueName       = 'BMP' + STRTRIM(Ptr,2)    ; Create value name


    Ptr2Obj, Obj.Value1, Bits
    XPRINTF, Unit, '  ', ValueName, ' = [ $'

    Sz      = SIZE(Bits)
    FOR I=0,Sz(2)-2 DO BEGIN
        XPRINTF, Unit, FORMAT='("    [ ",100(I0,"b, "))', $
            Bits(0:Sz(1)-2,I), /NO_EOL
        XPRINTF, Unit, FORMAT='(I0, "b ], $")', Bits(Sz(1)-1,I)
    ENDFOR

    XPRINTF, Unit, FORMAT='("    [ ",100(I0,"b, "))', $
        Bits(0:Sz(1)-2,Sz(2)-1), /NO_EOL

    ; Can't do multiple lines using XPRINTF
    XPRINTF, Unit, FORMAT='(I0, "b ]  $")', Bits(Sz(1)-1, Sz(2)-1)
    PRINTF, Unit, "  ]"

    XPRINTF, FORMAT='("  ", A, " = WIDGET_BUTTON( ",A,",VALUE=",A)', $
        Unit, Name, Parent, ValueName, /NO_EOL
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    XPRINTF, Unit, ')'

    Obj2Ptr, Bits, Obj.Value1
    Obj2Ptr, Obj, Ptr
END


;
;  BMPBTN_Alloc
;       Allocate a bitmap button object. Don't allocate if ptr is non-nil
;
PRO BMPBTN_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr     = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer
    ValueId = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer for value too
    Value   = BYTARR(2,16)
    Obj2Ptr, Value, ValueId                 ; Default value is all zeros

    ;   Make a Bitmap Button object

    Obj = {                     $
        WE_BMPBTN,              $
        Type:       'BMPBTN',   $
        Parent:     Parent,     $ ; Pointer to parent
        Id:         NewId(),    $ ; Permanent Id
        Dialog:     0L,         $ ; Save Dialog ID (need for Cut consistency)
        Next:       0L,         $ ; index of next child/free/top
        Name:       '',         $ ; object name
        FrameSize:  0,          $
        XOffset:    0,          $
        YOffset:    0,          $
        UValue:     '',         $
        Size:       0,          $ ; Dflt: 16x16.  Enum Size {16x16,32x32,64x64}
        Value1:     ValueId     $
    }

    Obj2Ptr, Obj, Ptr
END
; $Id: box_cursor.pro,v 1.2 1993/07/22 18:04:56 Moglie Exp $

pro box_cursor, x0, y0, nx, ny, INIT = init, FIXED_SIZE = fixed_size, $
	MESSAGE = message
;+
; NAME:
;	BOX_CURSOR
;
; PURPOSE:
;	Emulate the operation of a variable-sized box cursor (also known as
;	a "marquee" selector).
;
; CATEGORY:
;	Interactive graphics.
;
; CALLING SEQUENCE:
;	BOX_CURSOR, x0, y0, nx, ny [, INIT = init] [, FIXED_SIZE = fixed_size]
;
; INPUTS:
;	No required input parameters.
;
; OPTIONAL INPUT PARAMETERS:
;	x0, y0, nx, and ny give the initial location (x0, y0) and 
;	size (nx, ny) of the box if the keyword INIT is set.  Otherwise, the 
;	box is initially drawn in the center of the screen.
;
; KEYWORD PARAMETERS:
;	INIT:  If this keyword is set, x0, y0, nx, and ny contain the initial
;	parameters for the box.
;
;	FIXED_SIZE:  If this keyword is set, nx and ny contain the initial
;	size of the box.  This size may not be changed by the user.
;
;	MESSAGE:  If this keyword is set, print a short message describing
;	operation of the cursor.
;
; OUTPUTS:
;	x0:  X value of lower left corner of box.
;	y0:  Y value of lower left corner of box.
;	nx:  width of box in pixels.
;	ny:  height of box in pixels. 
;
;	The box is also constrained to lie entirely within the window.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A box is drawn in the currently active window.  It is erased
;	on exit.
;
; RESTRICTIONS:
;	Works only with window system drivers.
;
; PROCEDURE:
;	The graphics function is set to 6 for eXclusive OR.  This
;	allows the box to be drawn and erased without disturbing the
;	contents of the window.
;
;	Operation is as follows:
;	Left mouse button:   Move the box by dragging.
;	Middle mouse button: Resize the box by dragging.  The corner
;		nearest the initial mouse position is moved.
;	Right mouse button:  Exit this procedure, returning the 
;			     current box parameters.
;
; MODIFICATION HISTORY:
;	DMS, April, 1990.
;	DMS, April, 1992.  Made dragging more intutitive.
;	June, 1993 - Bill Thompson
;			prevented the box from having a negative size.
;-

device, get_graphics = old, set_graphics = 6  ;Set xor
col = !d.n_colors -1

if keyword_set(message) then begin
	print, "Drag Left button to move box."
	print, "Drag Middle button near a corner to resize box."
	print, "Right button when done."
	endif

if keyword_set(init) eq 0 then begin  ;Supply default values for box:
	if keyword_set(fixed_size) eq 0 then begin
		nx = !d.x_size/8   ;no fixed size.
		ny = !d.x_size/8
		endif
	x0 = !d.x_size/2 - nx/2
	y0 = !d.y_size/2 - ny/2
	endif

button = 0
goto, middle

while 1 do begin
	old_button = button
	cursor, x, y, 2, /dev	;Wait for a button
	button = !err
	if (old_button eq 0) and (button ne 0) then begin
		mx0 = x		;For dragging, mouse locn...
		my0 = y		
		x00 = x0	;Orig start of ll corner
		y00 = y0
		endif
	if !err eq 1 then begin  ;Drag entire box?
		x0 = x00 + x - mx0
		y0 = y00 + y - my0
		endif
	if (!err eq 2) and (keyword_set(fixed_size) eq 0) then begin ;New size?
		if old_button eq 0 then begin	;Find closest corner
			mind = 1e6
			for i=0,3 do begin
				d = float(px(i)-x)^2 + float(py(i)-y)^2
				if d lt mind then begin
					mind = d
					corner = i
					endif
			   endfor
			nx0 = nx	;Save sizes.
		   	ny0 = ny
			endif
		dx = x - mx0 & dy = y - my0	;Distance dragged...
		case corner of
		0: begin x0 = x00 + dx & y0 = y00 + dy
			nx = nx0 -dx & ny = ny0 - dy & endcase
		1: begin y0 = y00 + dy
			nx = nx0 + dx & ny = ny0 - dy & endcase
		2: begin nx = nx0 + dx & ny = ny0 + dy & endcase
		3: begin x0 = x00 + dx
			nx = nx0 -  dx & ny = ny0 + dy & endcase
		endcase
		endif
	plots, px, py, col=col, /dev, thick=1, lines=0	;Erase previous box
	empty				;Decwindow bug

	if !err eq 4 then begin  ;Quitting?
		device,set_graphics = old
		return
		endif
middle:

	if nx lt 0 then begin
		x0 = x0 + nx
		nx = -nx
	endif
	if ny lt 0 then begin
		y0 = y0 + ny
		ny = -ny
	endif

	x0 = x0 > 0
	y0 = y0 > 0
	x0 = x0 < (!d.x_size-1 - nx)	;Never outside window
	y0 = y0 < (!d.y_size-1 - ny)

	px = [x0, x0 + nx, x0 + nx, x0, x0] ;X points
	py = [y0, y0, y0 + ny, y0 + ny, y0] ;Y values

	plots,px, py, col=col, /dev, thick=1, lines=0  ;Draw the box
	wait, .1		;Dont hog it all
	endwhile
end
;
; $Id: button_alloc.pro,v 1.8 1995/01/20 19:41:01 tonyh Exp $
;
;  WidButton
;   Widget Button class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;


;
;  BUTTON_Icon
;       Return the button toolbar icon
;
FUNCTION BUTTON_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 168b, 170b, 170b, 42b ], $
    [ 84b, 85b, 85b, 53b ], $
    [ 168b, 170b, 170b, 58b ], $
    [ 20b, 0b, 0b, 56b ], $
    [ 8b, 0b, 0b, 56b ], $
    [ 20b, 0b, 0b, 56b ], $
    [ 8b, 128b, 1b, 56b ], $
    [ 20b, 128b, 1b, 56b ], $
    [ 8b, 128b, 1b, 56b ], $
    [ 20b, 64b, 3b, 56b ], $
    [ 8b, 64b, 3b, 56b ], $
    [ 20b, 64b, 3b, 56b ], $
    [ 8b, 32b, 6b, 56b ], $
    [ 20b, 32b, 6b, 56b ], $
    [ 8b, 32b, 6b, 56b ], $
    [ 20b, 16b, 12b, 56b ], $
    [ 8b, 240b, 15b, 56b ], $
    [ 20b, 16b, 12b, 56b ], $
    [ 8b, 8b, 24b, 56b ], $
    [ 20b, 8b, 24b, 56b ], $
    [ 8b, 8b, 24b, 56b ], $
    [ 20b, 28b, 60b, 56b ], $
    [ 8b, 0b, 0b, 56b ], $
    [ 20b, 0b, 0b, 56b ], $
    [ 8b, 0b, 0b, 56b ], $
    [ 244b, 255b, 255b, 63b ], $
    [ 248b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  BUTTON_Copy
;   Copy a button.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO BUTTON_Copy, Ptr, Copy
    GenCopy, Ptr, Copy
END


;
;  BUTTON_Destroy
;   Release resources for the given button
;
PRO BUTTON_Destroy, Ptr
    GenDestroy, Ptr
END


;
;  BUTTON_Event
;   Event handling routine for a button dialog.  Shares common code
;   (c.f. widbuild.pro)
;
PRO BUTTON_Event, Event
    MISC_Event, Event, 1    ; constant is Font Offset in Foci
END


;
;  BUTTON_Build
;   Create a dialog box a button object.  If ptr is nil then
;   create the object as well.
;
PRO BUTTON_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    BUTTON_Alloc, ParPtr, Ptr               ; Allocate object if necessary
    MgrName = 'WE_BUTTON' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(9)

    ;   Event Related Info

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    Foci(0) = Field(Base1, "Button Text:", Obj.Value, 'VALUE', SIZE=50, /STRING)
    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(1) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")


;   Base1   = WIDGET_BASE(Base, /FRAME)
    BuildOther, Base, Obj, Foci, 2, /FRAME
;   Base2   = WIDGET_BASE(Base1, /ROW, /NONEXCLUSIVE)
;   Button  = WIDGET_BUTTON(Base2, VALUE='Generate Release Events', $
;                           UVALUE='DO_RELEASE')
;   IF Obj.ButtonRelease THEN WIDGET_CONTROL, Button, /SET_BUTTON

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Button Appearance Controls")
    BuildXY, Base1, Obj, Foci, 5, /SIZE, /OFFSET
    BuildOkCancel, Base, Obj

    DlgInfo     = { $
        Foci:       Foci, $
        ObjPtr:     Ptr $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='BUTTON_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  BUTTON_Save
;   Save button information to a file.
;   This is a simple object to save.
;
PRO BUTTON_Save, Unit, Ptr
    GenWrite, Unit, Ptr
END


;
;  BUTTON_Restore
;   Read in a button object from a file
;
PRO BUTTON_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "BUTTON", 0
END


;
;  BUTTON_Generate
;   Create a button object for previewing
;
PRO BUTTON_Generate, Base, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Build a command string

    Cmd = 'Id = WIDGET_BUTTON(Base'
    SAddCmd, Cmd, Obj.Font, 'FONT'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    SAddCmd, Cmd, Obj.Value, 'VALUE'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'

    Obj2Ptr, Obj, Ptr

    ; Create button by executing the command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Button ' + VarName(Ptr)
    ENDIF
END


;
;  BUTTON_GenWid
;   Create IDL code for creating a BUTTON
;
PRO BUTTON_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)            ; Get name for button
    Ptr2Obj, Ptr, Obj               ; Get object information

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_BUTTON( ",A)', $
        Name, Parent, /NO_EOL
    SSaveCmd, Unit, Obj.Font, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    SSaveCmd, Unit, Obj.Value, "VALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  BUTTON_Alloc
;       Allocate a button group object.  Don't allocate if ptr is non-nil
;
PRO BUTTON_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr = WIDGET_BASE(GROUP=TopDlg)         ; Make a pointer

    ;   Make a Button object

    Obj = {                     $
        WE_BUTTON,              $
        Type:           'BUTTON',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; object name
        FrameSize:      0,      $
        Font:           '',     $
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        UValue:         '',     $
        Value:          ''      $
    }

;   Buttons support the 'NO_RELEASE' option but we don't
;       ButtonRelease:  1       $ ; 1 = NO_RELEASE (default)

    Obj2Ptr, Obj, Ptr
END
; $Id: caldat.pro,v 1.2 1993/04/28 14:14:12 dave Exp $

pro CALDAT, Julian, Month, Day, Year
;+
; NAME:
;	CALDAT
;
; PURPOSE:
;	Return the month, day and year corresponding to a given julian date.
;	This is the inverse of the function JULDAY.
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	CALDAT, Julian, Month, Day, Year
;	See also: julday, the inverse of this function.
;
; INPUTS:
;	JULIAN contains the Julian Day Number (which begins at noon) of the 
;	specified calendar date.  It should be a long integer.
; OUTPUTS:
;	MONTH:	Number of the desired month (1 = January, ..., 12 = December).
;
;	DAY:	Number of day of the month.
;
;	YEAR:	Number of the desired year.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; MODIFICATION HISTORY:
;	Translated from "Numerical Recipies in C", by William H. Press,
;	Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling.
;	Cambridge University Press, 1988 (second printing).
;
;	DMS, July, 1992.
;-
;
ON_ERROR, 2		; Return to caller if errors

IGREG = 2299161L	;Beginning of Gregorian calendar

julian = long(julian)	;Better be long

if julian ge igreg then begin
	jalpha = long(((julian - 1867216) - 0.25d0) / 36524.25)
	ja = julian + 1 + jalpha - long(0.25d0 * jalpha)
endif else ja = julian

jb = ja + 1524
jc = long(6680.0 + ((jb-2439870)-122.1)/365.25)
jd = long(365 * jc + (0.25 * jc))
je = long((jb - jd) / 30.6001)

day = jb - jd - long(30.6001 * je)
month = je -1
if (month gt 12) then month = month - 12
year = jc - 4715
if month gt 2 then year = year - 1
if year le 0 then year = year - 1
end
; $Id: calendar.pro,v 1.2 1993/10/18 16:13:29 doug Exp $

;+
; NAME:
;	CALENDAR
;
; PURPOSE:
;	Display a calandar for a month or an entire year using IDL's
;	plotting subsystem. This IDL routine imitates the Unix cal
;	command.
;
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	CALENDAR
;	CALENDAR, YEAR
;	CALENDAR, MONTH, YEAR
;
; INPUTS:
;	If called without arguments, CALENDAR draws a calendar for the
;	current month.
;
;	MONTH:  The number of the month for which a calandar is
;		desired (1 is January, 2 is February, ..., 12 is December).
;
;	YEAR:   The number of the year for which a calendar should be
;		drawn. If YEAR is provided without MONTH, a calendar
;		for the entire year is drawn.
;
; OPTIONAL INPUT PARAMETERS:
;	None.
;
; OUTPUTS:
;	The specified calandar is drawn on the current graphics device.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; MODIFICATION HISTORY:
;	AB, September, 1988
;-
;


pro CAL_INFO, MONTH, YEAR, START_SQUARE, NUM_DAYS

L_MONTH = MONTH - 1
MONTHS = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

DAY = (JULDAY(1, 1, YEAR) + 1) MOD 7
DAY1_NEXT_YEAR = (JULDAY(1, 1, YEAR+1) + 1) MOD 7

case ((DAY1_NEXT_YEAR + 7 - DAY) mod 7) of
	2 :
	1 : MONTHS(1) = 28	; Not a leap year
	else: MONTHS(8) = 19	; 1752
	endcase

for I = 0, L_MONTH - 1 do DAY = DAY + MONTHS(I)
START_SQUARE = (DAY MOD 7)
NUM_DAYS = MONTHS(L_MONTH)
end






pro DRAW_CAL, XR, YR, MONTH, YEAR, SMALL

MONTHS = ['January','February','March','April','May','June','July','August', $
	  'September','October','November','December']

x_range = xr(1) - xr(0)
y_range = yr(1) - yr(0)
if (SMALL) then y_div = 7. else y_div = 6.
x_delta = x_range / 7.
y_delta = y_range / y_div

TSIZE = 2.5 * x_range
if (SMALL) then TSIZE = TSIZE * 1.75

if (not SMALL) then begin
    ; Frame
    plots,/norm,[xr(0),xr(1),xr(1),xr(0),xr(0)],[yr(0),yr(0),yr(1),yr(1),yr(0)]
    ; Draw Vertical lines
    y = yr(1) - y_delta
    for i = 1,6 do begin x=xr(0)+ i*x_delta & plots,[x,x],[yr(0),y],/norm & end
    ; Draw Horizontal lines
    for i=0,y_div do begin y=yr(0)+i*y_delta & plots,[xr(0),xr(1)],[y,y], $
	/norm & end
    endif

; Month and year title
if (SMALL) then begin
	x = xr(0) + 3.5 * x_delta
	y = yr(0) + 6.6 * y_delta
	xyouts,/norm,size=TSIZE*1.6, align=.5, x, y, MONTHS(MONTH-1)
    endif else begin
	x = xr(0) + 1.5 * x_delta
	y = yr(0) + 5.5 * y_delta
	xyouts,/norm,size=TSIZE*.9, align=.5, x, y, MONTHS(MONTH-1)
	x = xr(0) + 5.5 * x_delta
	xyouts,/norm,size=TSIZE*.9,align=.5, x, y, $
		strcompress(string(YEAR),/rem)
    endelse

; Day titles
if (SMALL) then begin
	DAYS = ['S', 'M', 'T', 'W', 'T', 'F', 'S']
	DAYSIZE = TSIZE * .75
	y = yr(0) + 5.8 * y_delta
	y_factor = .25
    endif else begin
	DAYS = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']
	DAYSIZE = TSIZE * .6
	y = yr(0) + 5.1 * y_delta
    endelse
for I = 0, 6 do xyouts,/norm,size=DAYSIZE, align=.5, $
	xr(0) + (I + .5) * x_delta , y, DAYS(I)

; Calculate Horizontal and Vertical positions
X = fltarr(7)
Y = fltarr(y_div)
if (SMALL) then begin
	for i = 0, 5 do Y(I) = yr(0) + (5-I) * y_delta
	for i = 0, 6 do X(I) = xr(0) + (I - .5) * x_delta
	NALIGN = .5			; Center numbers
	NSIZE = TSIZE
    endif else begin
	J = 0
	for i = 4.65, .5, -1 do begin
	    Y(J) = i
	    J = J + 1
	    endfor
	Y(5) = .3 
	for i = 0, 5 do Y(I) = yr(0) + Y(I) * y_delta
	for i = 0, 6 do X(I) = xr(0) + (I + .95) * x_delta
	NALIGN = 1.			; Right justify
	NSIZE = TSIZE 
    endelse

; Get starting square and number of days in month
CAL_INFO, MONTH, YEAR, COL, NUM_DAYS
ROW = 0

; Numbers
for I = 1, NUM_DAYS do begin
    if (COL gt 6) then begin ROW = ROW + 1 & COL = 0 & endif
    xyouts, /norm, size=TSIZE, align = NALIGN, X(COL), Y(ROW), I
    COL = COL + 1
    endfor

end







pro CALENDAR , MONTH, YEAR

ON_ERROR, 2		; Return to caller if errors

MONTHS = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG', $
	  'SEP','OCT','NOV','DEC']

; Process the input
NP = n_params()
case NP of
	0: begin
	    DATE = systime()
	    L_MONTH = long(where(strupcase(strmid(DATE, 4, 3)) eq MONTHS))
	    L_MONTH = L_MONTH(0) + 1	; Scalarize it...
	    L_YEAR = long(strmid(DATE, 20, 4))
	    end
	1: begin
	    L_YEAR=LONG(MONTH)		; Only 1 parm, take it as year
	    DO_ALL_YEAR = 1
	    end
	2: begin
	    L_MONTH = LONG(MONTH)
	    L_YEAR=LONG(YEAR)
	    end
	else: message, 'Wrong number of parameters.'
	endcase

erase
if (NP eq 1) then begin
	x_delta = .2325
	y_delta = .28
	l = .025
	r = .975
	plots,/norm,[l,r,r,l,l],[l,l,r,r,l]
;	plots,/norm,[l,r],[.9,.9]
	xyouts,/norm,size=2.75,align=.5, .5, .9, $
		strcompress(string(L_YEAR),/rem)
	cur = 1
	for i = 2, 0, -1 do for j = 0, 3 do begin
	    DRAW_CAL, [l + (j+.1)*x_delta, l + (j+1)*x_delta], $
		[l + l + i*y_delta, l + (i+1)*y_delta], cur, L_YEAR, 1
	    CUR = CUR + 1
	    endfor
    endif else begin
	DRAW_CAL, [.025, 0.975], [.025, .975], L_MONTH, L_YEAR, 0
    endelse

end
;$Id: c_correlate.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       C_CORRELATE
;
; PURPOSE:
;       This function computes the cross correlation Pxy(L) or cross 
;       covariance Rxy(L) of two sample populations X and Y as a function
;       of the lag (L).
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = C_correlate(X, Y, Lag)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An n-element vector of type integer, float or double.
;
;     LAG:    A scalar or n-element vector, in the interval [-(n-2), (n-2)],
;             of type integer that specifies the absolute distance(s) between
;             indexed elements of X.
;
; KEYWORD PARAMETERS:
;       COVARIANCE:    If set to a non-zero value, the sample cross 
;                      covariance is computed.
;
; EXAMPLE
;       Define two n-element sample populations.
;         x = [3.73, 3.67, 3.77, 3.83, 4.67, 5.87, 6.70, 6.97, 6.40, 5.57]
;         y = [2.31, 2.76, 3.02, 3.13, 3.72, 3.88, 3.97, 4.39, 4.34, 3.95]
;
;       Compute the cross correlation of X and Y for LAG = -5, 0, 1, 5, 6, 7
;         lag = [-5, 0, 1, 5, 6, 7]
;         result = c_correlate(x, y, lag)
;
;       The result should be:
;         [-0.448655, 0.915846, 0.628814, -0.393466, -0.350169, -0.282198]
;
; PROCEDURE:
;       See computational formula published in IDL manual.
;
; REFERENCE:
;       INTRODUCTION TO STATISTICAL TIME SERIES
;       Wayne A. Fuller
;       ISBN 0-471-28715-6
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, October 1994
;
;-

function cross_cov, x, y, m, nx
  ;Sample cross covariance function.

  xmean = total(x) / nx
  ymean = total(y) / nx
  t = lindgen(nx - m - 1L)
  return, total((x(t) - xmean) * (y(t + m) - ymean))

end

function c_correlate, x, y, lag, covariance = covariance

  ;Compute the sample cross correlation or cross covariance of 
  ;(Xt, Xt+l) and (Yt, Yt+l) as a function of the lag (l).

  on_error, 2

  nx = n_elements(x)
  ny = n_elements(y)

  if nx ne ny then $
    message, 'x and y must be vectors of equal length.'
  
  nlag = n_elements(lag)

  if nlag eq 1 then lag = [lag] ;Create a 1-element vector.

  xtype = size(x)
  ytype = size(y)
  if xtype(2) eq 5 or ytype(2) eq 5 then cross = dblarr(nlag) $
  else cross = fltarr(nlag)

  if keyword_set(covariance) eq 0 then begin ;Compute Cross Correlation.
    for k = 0, nlag-1 do begin
      if lag(k) ge 0 then $
        cross(k) = cross_cov(x, y, lag(k), nx) / $
                   sqrt(cross_cov(x, x, 0L, nx) * cross_cov(y, y, 0L, ny)) $
      else cross(k) = cross_cov(y, x, abs(lag(k)), ny) / $
                   sqrt(cross_cov(x, x, 0L, nx) * cross_cov(y, y, 0L, ny))
    endfor
  endif else begin ;Compute Cross Covariance.
    for k = 0, nlag-1 do begin
      if lag(k) ge 0 then $
        cross(k) = cross_cov(x, y, lag(k), nx) / nx $
      else cross(k) = cross_cov(y, x, abs(lag(k)), nx) / nx
    endfor
  endelse

  return, cross

end
  
; $Id: cdf_exists.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;
; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	CDF_EXISTS
;
; PURPOSE:
;	Test for the existence of the CDF library
;
; CATEGORY:
;	File Formats
;
; CALLING SEQUENCE:
;	Result = CDF_EXISTS()
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	Returns TRUE (1) if the CDF data format library is
;	supported. Returns FALSE(0) if it is not.
;
; EXAMPLE:
;	IF cdf_exists() EQ 0 THEN Fail,"CDF not supported on this machine"
;
; MODIFICATION HISTORY
;	Written by:	Joshua Goldstein,  12/8/92
;
;-

;	A fake function if libraries don't exist
FUNCTION cdf_inquire,x
	return,0
END

;
FUNCTION cdf_exists
	exists=0
	on_ioerror, ok
	oldquiet= !quiet
	!quiet=1

	x=cdf_inquire(0)
	!quiet=oldquiet
	return,0

   ok:
	!quiet=oldquiet
	return,1
END
; $Id: chebyshev.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION CHEBYSHEV,D,N
;+
; NAME:
;	CHEBYSHEV
;
; PURPOSE:
;	Implements forward and reverse Chebyshev polynomial expansion of
;	a set of data.
;
; CATAGORY:
;	Mathematics.
;
; CALLING SEQUENCE:
;	Result = CHEBYSHEV(D, N)
;
; INPUT:
;	D:  A vector containing the values at the zeros of Chebyshev
;	    polynomial.
;
;	N:  A flag that, if set to -1, returns a set of Chebyshev polynomials.
;	    If set to +1, the original data is returned.
;
; OUTPUT:
;	Returns either the set of Chebyshev polynomials or the original
;	data depending on the value of N.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Results from this function are subject to roundoff error given
;	discontinuous data.
;
; RESTRICTIONS:                                           
;	Unknown.
;
; PROCEDURE:
;	Straightforward implementation of recursion formula. 
;
; REVISION HISTORY:
;	Jan, 1986  Written by Leonard Kramer, U. of Maryland
;		   University Research Foundation
;-	
	ON_ERROR,2              ;Return to caller if an error occurs	
	IF (N_PARAMS(0) NE 2 ) THEN BEGIN
	  PRINT,'two parameters required'
          STOP
	ENDIF
 	UNITY =(ABS(D(0))+1.)/(ABS(D(0))+1.)
        NL=N_ELEMENTS(D)
	NE2=(NL-1.)/2.
	C=TRANSPOSE([TRANSPOSE(D),TRANSPOSE(D)])
	C(*,0)=1.
	X = cos(!Pi * (findgen(NL) + .5)/Nl)
	C(0,1)=X
	T=D
        CASE N OF 
	-1: BEGIN
          FOR I = 0, 1 DO T(I) = 2 * TOTAL(D * C(*,I))/NL
  	  FOR I=2,NL-1 DO BEGIN
	    SAVE=C(*,1)
	    C(0,1)= 2.*X*C(*,1)-C(*,0)
	    C(0,0)=SAVE
            T(I) = 2 * TOTAL( D * C(*, 1))/NL
	  ENDFOR
	  END
	1: BEGIN
          T = fltarr(NL) - .5 * D(0)
	  FOR I=0,1 DO T = T + D(I) * C(*,I)
	  FOR I=2,NL-1 DO BEGIN
	    SAVE=C(*,1)
	    C(0,1)= 2.*X*C(*,1)-C(*,0)
	    C(0,0)=SAVE
	    T=T+D(I)*C(*,1)
	  ENDFOR
	  END
	ELSE:
	ENDCASE
	RETURN,T
END

;$Id: chisqr_cvf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CHISQR_CVF
;
; PURPOSE: 
;	This function computes the cutoff value (v) such that:
;                   Probability(X > v) = p
;       where X is a random variable from the Chi-square distribution
;       with (df) degrees of freedom. 
;
; CATEGORY:
;       Statistics.
; 
; CALLING SEQUENCE:
;       Result = chisqr_cvf(P, DF)
;
; INPUTS:
;       P:    A non-negative scalar, in the interval [0.0, 1.0], of type
;             float or double that specifies the probability of occurance 
;             or success.
;
;      DF:    A positive scalar of type integer, float or double that 
;             specifies the degrees of freedom of the Chi-square distribution.
;
; EXAMPLE:
;       Compute the cutoff value (v) such that Probability(X > v) = 0.100
;       from the Chi-square distribution with (DF = 3) degrees of freedom. 
;       The result should be 6.25139
;         result = chisqr_cvf(0.100, 3) 
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function chisqr_cvf, p, df

  on_error, 2  ;Return to caller if error occurs.

  if p lt 0. or p gt 1. then message, $
    'p must be in the interval [0.0, 1.0]'
  if p eq 0 then return, 1.0e12
  if p eq 1 then return, 0.0
  if df lt 0 then message, $
    'Degrees of freedom must be positive.'

  case 1 of
    df eq 1: up = 300.0 
    df eq 2: up = 100.0 
    df gt 2 and df le 5: up = 30.0
    df gt 5 and df le 14: up = 20.0
    else: up = 12.0
  endcase
  below = 0
  while chisqr_pdf(up, df) lt (1 - p) do begin
      below = up
      up = 2 * up
  endwhile

  return, bisect_pdf([1-p, df], 'chisqr_pdf', up, below)
end

;$Id: chisqr_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CHISQR_PDF
;
; PURPOSE: 
;       This function computes the probabilty (p) such that:
;                   Probability(X <= v) = p
;       where X is a random variable from the Chi-square distribution
;       with (df) degrees of freedom.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = chisqr_pdf(V, DF)
;
; INPUTS:
;       V:    A scalar of type integer, float or double that specifies 
;             the cutoff value.
;
;      DF:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the Chi-square distribution.
;
; EXAMPLES:
;       Compute the probability that a random variable X, from the Chi-square 
;       distribution with (DF = 3) degrees of freedom, is less than or equal 
;       to 6.25. The result should be 0.899939 
;         result = chisqr_pdf(6.25, 3)
;
;       Compute the probability that a random variable X, from the Chi-square
;       distribution with (DF = 3) degrees of freedom, is greater than 6.25. 
;       The result should be 0.100061
;         result = 1 - chisqr_pdf(6.25, 3)
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function chisqr_pdf, x, df

  on_error, 2  ;Return to caller if error occurs.

  if x le 0 then return, 0.0 else begin
    gres = igamma_pdf(df/2.0, x/2.0)
    if gres ne -1 then return, gres else $
      message, 'Computational error detected.'
  end

end

; $Id: cir_3pnt.pro,v 1.2 1993/10/04 19:50:01 doug Exp $

PRO cir_3pnt, x, y, r, x0, y0

;+
; NAME:
;	CIR_3PNT
;
; PURPOSE:
;	This procedure returns the radius and center of a circle,
;	given 3 points on the circle. This is analogous to finding
;	the circumradius and circumcircle of a triangle; the center
;	of the circumcircle is the point at which the three perpendicular
;	bisectors of the triangle formed by the points meet.
;
; CATEGORY:
;	Analytical geometry.
;
; CALLING SEQUENCE:
;	CIR_3PNT, X, Y, R, X0, Y0
;
; INPUTS:
;	X: A three-element vector containing the X-coordinates of the points.
;	Y: A three-element vector containing the Y-coordinates of the points.
;
; OUTPUTS:
;	R: The radius of the circle. The procedure returns 0.0 if the points
;	   are co-linear.
;	X0, Y0: The coordinates of the center of the circle. The procedure
;	        returns 0.0 if the points are co-linear.
;
; PROCEDURE:
;	Derived from Glasser, ed.  Graphics Gems, Volume 1, Page 22.
;
; EXAMPLE:
;	X = [1.0, 2.0, 3.0]
;	Y = [1.0, 2.0, 1.0]
;	CIR_3PNT, X, Y, R, X0, Y0
;	Print, 'The radius is: ', R
;	Print, 'The center of the circle is at: ', X0, Y0
	
; MODIFICATION HISTORY:
; 	Written by:	DMS, RSI, Nov, 1992.
;-

x = double(x)
y = double(y)

d1 = (x(2)-x(0)) * (x(1)-x(0)) + (y(2)-y(0)) * (y(1)-y(0))
d2 = (x(2)-x(1)) * (x(0)-x(1)) + (y(2)-y(1)) * (y(0)-y(1))
d3 = (x(0)-x(2)) * (x(1)-x(2)) + (y(0)-y(2)) * (y(1)-y(2))

c1 = d2 * d3
c2 = d3 * d1
c3 = d1 * d2
c = c1 + c2 + c3 + 0.0		;Force to floating or dbl
if abs(c lt 1e-14) then begin	;Colinear?
	r =  0.
	x0 = 0.
	y0 = 0.
	return
	endif
r = sqrt((d1 + d2)*(d2 + d3) * (d3 + d1)/c)/2.
v = [ c2 + c3, c3 + c1, c1 + c2 ]/(2.*c)
x0 = total(v * x)
y0 = total(v * y)
end
;$Id: comfit.pro,v 1.3 1995/02/16 22:38:05 dave Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       COMFIT
;
; PURPOSE:
;       This function fits the paired data {X(i), Y(i)} to one of six common
;       types of appoximating models using a gradient-expansion least-squares
;       method. The result is a vector containing the model parameters.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = COMFIT(X, Y, A0)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An n-element vector of type integer, float or double.
;
;      A0:    A vector of initial estimates for each model parameter. The length
;             of this vector depends upon the type of model selected.
;
; KEYWORD PARAMETERS:
;       EXPONENTIAL:    If set to a non-zero value, the parameters of the 
;                       exponential model are computed. Y = a0  * a1^x + a2.
;
;         GEOMETRIC:    If set to a non-zero value, the parameters of the
;                       geometric model are computed.  Y = a0 * x^a1 + a2.
;    
;          GOMPERTZ:    If set to a non-zero value, the parameters of the
;                       Gompertz model are computed.  Y = a0 * a1^(a2*x) + a3.
;
;        HYPERBOLIC:    If set to a non-zero value, the parameters of the
;                       hyperbolic model are computed.  Y = 1./(a0 + a1*x)
;
;          LOGISTIC:    If set to a non-zero value, the parameters of the
;                       logistic model are computed.  Y = 1./(a0 * a1^x + a2)
;
;         LOGSQUARE:    If set to a non-zero value, the parameters of the
;                       logsquare model are computed.
;			Y = a0 + a1*alog10(x) + a2 * alog10(x)^2
;
;             SIGMA:    Use this keyword to specify a named variable which 
;                       returns a vector of standard deviations for the computed
;                       model parameters.
;                
;           WEIGHTS:    An n-element vector of weights. If the WEIGHTS vector 
;                       is not specified, an n-element vector of 1.0s is used.
;
;              YFIT:    Use this keyword to specify a named variable which 
;                       returns n-element vector of y-data corresponding to the 
;                       computed model parameters.
;
; EXAMPLE:
;       Define two n-element vectors of paired data.
;         x = [2.27, 15.01, 34.74, 36.01, 43.65, 50.02, 53.84, 58.30, 62.12, $
;             64.66, 71.66, 79.94, 85.67, 114.95]
;         y = [5.16, 22.63, 34.36, 34.92, 37.98, 40.22, 41.46, 42.81, 43.91, $
;             44.62, 46.44, 48.43, 49.70, 55.31]
;       Define a 3-element vector of initial estimates for the logsquare model.
;         a0 = [1.5, 1.5, 1.5]
;       Compute the model parameters of the logsquare model, a(0), a(1), & a(2).
;         result = comfit(x, y, a0, sigma = sigma, yfit = yfit, /logsquare)
;       The result should be the 3-element vector:
;         [1.42494, 7.21900, 9.18794]
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1994
;-

pro exp_func, x, a, f, pder
  f = a(0) * a(1)^x + a(2)
  if n_params() ge 4 then $
    pder = [[a(1)^x], [a(0) * x * a(1)^(x-1)], [replicate(1., n_elements(x))]]
end

pro geo_func, x, a, f, pder
  f = a(0) * x^a(1) + a(2)
  if n_params() ge 4 then $
    pder = [[x^a(1)], [a(0) * alog(x) * x^a(1)], [replicate(1., n_elements(x))]]
end

pro gom_func, x, a, f, pder
  f = a(0) * a(1)^(a(2)*x) + a(3)
  if n_params() ge 4 then $
    pder = [[a(1)^(a(2)*x)], [a(0) * a(2) * x * a(1)^(a(2)*x-1)], $
	[a(0) * x * alog(a(1)) * a(1)^(a(2)*x)], [replicate(1., n_elements(x))]]
end

pro hyp_func, x, a, f, pder
  f = 1.0 / (a(0) + a(1) * x)
  if n_params() ge 4 then $
    pder = [[-1.0 / (a(0) + a(1) * x)^2], [-x / (a(0) + a(1) * x)^2]]
end

pro log_func, x, a, f, pder
  f = 1.0 / (a(0) * a(1)^x + a(2))
  if n_params() ge 4 then begin
    denom =  -1.0/(a(0) * a(1)^x + a(2))^2
    pder = [[a(1)^x*denom], [a(0) * x * a(1)^(x-1)*denom], [denom]]
    endif
end

pro logsq_func, x, a, f, pder
  b = alog10(x)
  b2 = b^2
  f = a(0) + a(1) * b + a(2) * b2
  if n_params() ge 4 then $
    pder = [[replicate(1., n_elements(x))], [b], [b2]]
end

function comfit, x, y, a0, weights = weights, sigma = sigma, yfit = yfit, $
                       exponential = exponential, geometric = geometric, $
                       gompertz = gompertz, hyperbolic = hyperbolic, $
                       logistic = logistic, logsquare = logsquare

  on_error, 2

  fcn_names = ['exp_func', 'geo_func', 'gom_func', 'hyp_func', 'log_func', $
		'logsq_func']
  fcn_npar = [ 3, 3, 4, 2, 3, 3]

  nx = n_elements(x)
  wx = n_elements(weights)
  if nx ne n_elements(y) then $
    message, 'x and y must be vectors of equal length.'

  if wx eq 0 then weights = replicate(1.0, nx) $
  else if wx ne nx then $
	message, 'x and weights must be vectors of equal length.'

  a1 = a0			;Copy initial guess
  if keyword_set(exponential) then i = 0 $
  else if keyword_set(geometric) then i = 1 $
  else if keyword_set(gompertz) then i = 2 $
  else if keyword_set(hyperbolic) then i = 3 $
  else if keyword_set(logistic) then i = 4 $
  else if keyword_set(logsquare) then i = 5 $
  else message, 'Type of model must be supplied as a keyword parameter.'

  if n_elements(a1) ne fcn_npar(i) then $
	message, 'a0 must be supplied as a '+strtrim(fcn_npar(i), 2) + $
	     '-element initial guess vector.'
  yfit = curvefit(x, y, weights, a1, sigma, function_name = fcn_names(i))
  return, a1
end
;$Id: complexround.pro,v 1.3 1994/11/29 18:31:31 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       COMPLEXROUND
;
; PURPOSE:
;       This function rounds a complex scalar or array.
;
; CATEGORY:
;       Numerical Analysis.
;
; CALLING SEQUENCE:
;       Result = Complexround(z)
;
; INPUTS:
;       Z: A complex scalar or array.
;
; RESTRICTIONS:
;       The input argument must be complex.
;
; PROCEDURE:
;       This function rounds the real and imaginary components of the 
;       complex input argument.
;
; EXAMPLE:
;       ;Define a complex array.
; 	  z = [[complex(1.245, 3.880), complex( 1.245, -3.880)], $
;              [complex(1.499, 5.501), complex(-1.355, -2.115)]]
;       ;Round it.
;         result = complexround(z) 
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1992
;       Modified:    GGS, RSI, September 1994
;                    Added support for double-precision complex inputs.
;                    Uses IDL's intrinsic ROUND function.
;-

function complexround, z

  ;dimension = size(input)  ;Size of input array.
  ;output = complexarr(dimension(1), dimension(2))
  ;real = float(input) ;Separate into real and imaginary. 
  ;imag = imaginary(input)

  ;z1 = real + 0.5 ;Round real components.
  ;neg1 = where(real lt 0, count1)
  ;if count1 ne 0 then z1(neg1) = z1(neg1) - 1
  ;z1 = fix(z1)

  ;z2 = imag + 0.5 ;Round imaginary components.
  ;neg2 = where(imag lt 0, count2)
  ;if count2 ne 0 then z2(neg2) = z2(neg2) - 1
  ;z2 = fix(z2)

  ;output = complex(z1,z2)
  ;return, complex(z1,z2)

  on_error, 2
 
  sz = size(z)

  if sz(sz(0)+1) eq 6 then begin 
    return, complex(round(float(z)), round(imaginary(z))) 
  endif else if sz(sz(0)+1) eq 9 then $
    return, dcomplex(round(float(z)), round(imaginary(z))) $
  else message, 'Input must be of complex type.'

end
;$Id: cond.pro,v 1.7 1995/01/05 18:16:55 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       COND
;
; PURPOSE:
;       This function computes the condition number of an N by N array.
;
; CATEGORY:
;       Complex Linear Algebra.
;
; CALLING SEQUENCE:
;       Result = COND(A)
;
; INPUTS:
;       A:      An N by N real or complex array.
;
; KEYWORD PARAMETERS:
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
; EXAMPLE:
;       Define a complex array (a).
;         a = [[complex(1, 0), complex(2,-2), complex(-3,1)], $
;              [complex(1,-2), complex(2, 2), complex(1, 0)], $
;              [complex(1, 1), complex(0, 1), complex(1, 5)]]
;       Compute the condition number of the complex array (a) using 
;       double-precision complex arithmetic.
;         result = cond(a, /double)
;         
; PROCEDURE:
;       This function returns the condition number of an N x N real or
;       complex array (A) by explicitly computing, norm(A)*norm(A_inverse).
;       If A is real and A_inverse is invalid (due to the singularity of A 
;       or floating-point errors in the nr_invert function), the condition 
;       number is returned as a -1. If A is complex and A_inverse is invalid
;       (due to the singularity of A), calling COND.PRO results in floating-
;       point errors.
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, April 1992
;       Modified:    GGS, RSI, February 1994
;                    Accepts complex inputs. Added DOUBLE keyword.
;       Modified:    GGS, RSI, November 1994
;                    Added support for double-precision complex inputs.
;                    Changed NR_INVERT to INVERT.
;-

function cond, a, double = double

  on_error, 2  ; Return to caller if error occurs.

  dimension = size(a)
  if dimension(1) ne dimension(2) then message, $
    'Input array is not square.'

  if keyword_set(double) eq 0 then dbl = 0 $
  else dbl = 1

  if dimension(3) ne 6 and dimension(3) ne 9 then begin ;Real matrix.
    ;inv = nr_invert(transpose(a), s, double = dbl)
    inv = invert(a, s, double=dbl)
    if s ne 0 then return, -1 $ ;Check status of inverse.
    else return, norm(a) * norm(inv)
  endif else $ ;Complex matrix.
    return, norm(a) * norm(lu_complex(a, -1, double = dbl))

  inv = 0

end
; $Id: congrid.pro,v 1.2 1993/11/03 01:30:15 dave Exp $

;+
; NAME:
;	CONGRID
;
; PURPOSE:
;       Shrink or expand the size of an array by an arbitrary amount.
;       This IDL procedure simulates the action of the VAX/VMS
;       CONGRID/CONGRIDI function.
;
;	This function is similar to "REBIN" in that it can resize a
;       one, two, or three dimensional array.   "REBIN", however,
;       requires that the new array size must be an integer multiple
;       of the original size.   CONGRID will resize an array to any
;       arbitrary size (REBIN is somewhat faster, however).
;       REBIN averages multiple points when shrinking an array,
;       while CONGRID just resamples the array.
;
; CATEGORY:
;       Array Manipulation.
;
; CALLING SEQUENCE:
;	array = CONGRID(array, x, y, z)
;
; INPUTS:
;       array:  A 1, 2, or 3 dimensional array to resize.
;               Data Type : Any type except string or structure.
;
;       x:      The new X dimension of the resized array.
;               Data Type : Int or Long (greater than or equal to 2).
;
; OPTIONAL INPUTS:
;       y:      The new Y dimension of the resized array.   If the original
;               array has only 1 dimension then y is ignored.   If the
;               original array has 2 or 3 dimensions then y MUST be present.
;
;       z:      The new Z dimension of the resized array.   If the original
;               array has only 1 or 2 dimensions then z is ignored.   If the
;               original array has 3 dimensions then z MUST be present.
;
; KEYWORD PARAMETERS:
;       INTERP: If set, causes linear interpolation to be used.
;               Otherwise, the nearest-neighbor method is used.
;
;	CUBIC:	If set, uses "Cubic convolution" interpolation.  A more
;		accurate, but more time-consuming, form of interpolation.
;		CUBIC has no effect when used with 3 dimensional arrays.
;
;       MINUS_ONE:
;               If set, will prevent CONGRID from extrapolating one row or
;               column beyond the bounds of the input array.   For example,
;               If the input array has the dimensions (i, j) and the
;               output array has the dimensions (x, y), then by
;               default the array is resampled by a factor of (i/x)
;               in the X direction and (j/y) in the Y direction.
;               If MINUS_ONE is present (AND IS NON-ZERO) then the array
;               will be resampled by the factors (i-1)/(x-1) and (j-1)/(y-1).
;
; OUTPUTS:
;	The returned array has the same number of dimensions as the original
;       array and is of the same data type.   The returned array will have
;       the dimensions (x), (x, y), or (x, y, z) depending on how many
;       dimensions the input array had.
;
; PROCEDURE:
;       IF the input array has three dimensions, or if INTERP is set,
;       then the IDL interpolate function is used to interpolate the
;       data values.
;       If the input array has two dimensions, and INTERP is NOT set,
;       then the IDL POLY_2D function is used for nearest neighbor sampling.
;       If the input array has one dimension, and INTERP is NOT set,
;       then nearest neighbor sampling is used.
;
; EXAMPLE:
;       ; vol is a 3-D array with the dimensions (80, 100, 57)
;       ; Resize vol to be a (90, 90, 80) array
;       vol = CONGRID(vol, 90, 90, 80)
;
; MODIFICATION HISTORY:
;       DMS, Sept. 1988.
;       DMS, Added the MINUS_ONE keyword, Sept. 1992.
; 	Daniel Carr. Re-wrote to handle one and three dimensional arrays
;                    using INTERPOLATE function.
; 	DMS, RSI, Nov, 1993.  Added CUBIC keyword.
;-

FUNCTION CONGRID, arr, x, y, z, Interp=int, Minus_One=m1, Cubic = cubic

ON_ERROR, 2		;Return to caller if error
s = Size(arr)

IF ((s(0) EQ 0) OR (s(0) GT 3)) THEN $
   Message, 'Array must have 1, 2, or 3 dimensions.'

;  Supply defaults = no interpolate, and no minus_one.
if n_elements(int) le 0 then int = 0 else int = keyword_set(int)
if n_elements(m1) le 0 then m1 = 0 else m1 = keyword_set(m1)
cub = KEYWORD_SET(cubic)
if cub THEN int = 1	;Cubic implies interpolate
	

CASE s(0) OF
   1: BEGIN				; *** ONE DIMENSIONAL ARRAY
	srx = float(s(1) - m1)/(x-m1) * findgen(x)  ;subscripts
      IF int THEN $
         RETURN, INTERPOLATE(arr, srx, CUBIC = cub) ELSE $
         RETURN, arr(ROUND(srx))
   ENDCASE
   2: BEGIN ; *** TWO DIMENSIONAL ARRAY
	IF int THEN BEGIN
	  srx = float(s(1) - m1) / (x-m1) * findgen(x)
	  sry = float(s(2) - m1) / (y-m1) * findgen(y)
          RETURN, INTERPOLATE(arr, srx, sry, /GRID, CUBIC=cub)
	ENDIF ELSE $
	  RETURN, POLY_2D(arr, $
		[[0,0],[(s(1)-m1)/float(x-m1),0]], $ ;Use poly_2d
		[[0,(s(2)-m1)/float(y-m1)],[0,0]],int,x,y)

   ENDCASE
   3: BEGIN ; *** THREE DIMENSIONAL ARRAY
	srx = float(s(1) - m1) / (x-m1) * findgen(x)
	sry = float(s(2) - m1) / (y-m1) * findgen(y)
	srz = float(s(3) - m1) / (z-m1) * findgen(z)
	RETURN, interpolate(arr, srx, sry, srz, /grid)
   ENDCASE
ENDCASE

RETURN, arr_r
END
; $Id: coord2to3.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION COORD2TO3, MX, MY, DIM, D0, PTI
;+
; NAME:
;	COORD2TO3
;
; PURPOSE:
;	Return 3D data coordinates given the normalized X and Y screen
;	coordinates and one of the three data coordinates.
;
; CATEGORY:
;	Geometry / Graphics.
;
; CALLING SEQUENCE:
;	Result = COORD2TO3(Mx, My, Dim, D0 [, PTI])
;
; INPUTS:
;	Mx, My: The normalized X and Y screen coordinates.
;
;	Dim:  	A parameter used to specify which data coordinate is fixed.
;		Use 0 for a fixed X data coordinate, 1 for a fixed Y data 
;		coordinate, or 2 for a fixed Z data coordinate.
;
;	D0:	The value of the fixed data coordinate.
;
; OPTIONAL INPUT PARAMETERS:
;	PTI:  	The inverse of !P.T.  If this parameter is not supplied, 
;		or set to 0, COORD2TO3 computes the inverse.  If this routine
;		is to be used in a loop, the caller should supply PTI for
;		highest efficiency.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	Returns a 3-element vector containing the 3D data coordinates.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	A valid 3D transform must exist in !P.T or PTI.
;	The axis scaling variables, !X.S, !Y.S and !Z.S must be valid.
;
; PROCEDURE:
;	The intersection of the plane determined by data coordinates
;	Dim and D0 and the screen coordinate line (Mx, My, 0),
;	(Mx, My, 1) is computed.
;
; EXAMPLE:
;	To return the data coordinates of the mouse, fixing the
;	data Z value at 10, enter the commands:
;		CURSOR, X, Y, /NORM	;Get the normalized mouse coords.
;	  	P = COORD2TO3(X, Y, 2, 10.0)
;
; MODIFICATION HISTORY:
;	DMS, 9/91.
;-


if n_elements(pti) le 0 then pti = invert(!p.t) $
   else if total(pti) eq 0. then pti = invert(!p.t)

vs = [[!x.s], [!y.s], [!z.s]]
a = d0 * vs(1,dim) + vs(0,dim)  ;To normalized data coords

;	Solve for normalized screen Z
az = (a - mx * pti(0,dim) - my * pti(1,dim) - pti(3,dim)) / pti(2,dim)
p = [ mx, my, az, 1]		;Normalized screen coords
p = p # pti			;to normalized 3d coords
return, (p(0:2) - vs(0,*)) / vs(1,*) ;to 3d data coords.
end
;$Id: correlate.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CORRELATE
;
; PURPOSE:
;       This function computes the linear Pearson correlation coefficient
;       of two n-element vectors or the Correlation Matrix of an M x N 
;       array. Alternatively, this function computes the covariance of two
;       n-element vectors or the Covariance Matrix of an M x N array.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Correlate(X [,Y])
;
; INPUTS:
;       X:    An n-element vector or an M x N array of type integer, float
;             or double.
; 
;       Y:    An n-element vector of type integer, float or double. If X is 
;             an M x N array, this parameter should not be supplied in the
;             calling sequence.
;
; KEYWORD PARAMETERS:
;       COVARIANCE:    If set to a non-zero value, the sample covariance is 
;                      computed. 
;       
; RESTRICTIONS:
;       If X is an n-element vector, then Y must also be supplied as an 
;       n-element vector; Result = Correlate(X, Y)
;
;       If X is an M x N array, then Y should not be supplied; 
;       Result = Correlate(X)
;
; EXAMPLES:
;       Define the n-element data vectors.
;         x = [65, 63, 67, 64, 68, 62, 70, 66, 68, 67, 69, 71]
;         y = [68, 66, 68, 65, 69, 66, 68, 65, 71, 67, 68, 70]
;
;       Compute the linear Pearson correlation coefficient of x and y.
;         result = correlate(x, y)
;       The result should be 0.702652
;
;       Compute the covariance of x and y.
;         result = correlate(x, y, /covariance)
;       The result should be 3.66667
;  
;       Define an array with x and y as its columns.
;         a = transpose([[x],[y]])
;       Compute the correlation matrix.
;         result = correlate(a)
;       The result should be [[1.000000,  0.702652]
;                             [0.702652,  1.000000]]
;
;       Compute the covariance matrix.
;         result = correlate(a, /covariance)
;       The result should be [[7.69697,  3.66667]
;                             [3.66667,  3.53788]]
;
; PROCEDURE:
;       CORRELATE computes the linear Pearson correlation coefficient of
;       two n-element vectors. If X is an M x N array, M-columns by N-rows,
;       the result will be an M x M array of linear Pearson correlation 
;       coefficients with the iTH column and jTH row element corresponding
;       to the correlation of the iTH and jTH columns of the M x N array.
;       The M x M array of linear Pearson correlation coefficients (also 
;       known as the Correlation Matrix) is always symmetric and contains 
;       1s on the main diagonal. The Covariance Matrix is also symmetric.  
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Written by:  DMS, RSI, Sept 1983
;       Modified:    GGS, RSI, July 1994
;                    Added COVARIANCE keyword.
;                    Included support for matrix input.  
;                    New documentation header.
;-

function cov_mtrx, x
  nx = size(x)
  varxi = x - (x # replicate(1.0/nx(2), nx(2))) # replicate(1.0, nx(2))
  varxi = (varxi # transpose(varxi)) / (nx(2)-1)
  return, varxi
end

function crr_mtrx, x
  nx = size(x)
  ;cm = replicate(1.0, nx(1), nx(1))
  varxi = x - (x # replicate(1.0/nx(2), nx(2))) # replicate(1.0, nx(2))
  ss = varxi^2 # replicate(1.0, nx(2))
  ss = sqrt(ss # ss)
  ;cm = (varxi # transpose(varxi))/ss
  return, (varxi # transpose(varxi))/ss
end

function correlate, x, y, covariance = covariance

  on_error,2  ;Return to caller if an error occurs.

  if n_params() eq 2 then begin  ;Vector inputs.
    nx = n_elements(x)
    if nx le 1 or n_elements(y) le 1 then $
      message, 'x and y must be n-element vectors.'  
    ;Means.
    xmean = total(x) / nx
    ymean = total(y) / nx
    ;Deviations.
    xx = x - xmean
    yy = y - ymean
    if keyword_set(covariance) eq 0 then return, $  ;Correlation.
      total(xx * yy)/sqrt(total(xx^2) * total(yy^2)) $
    else return, total(xx * yy) / (nx-1)  ;Covariance.
  endif else begin          
    if keyword_set(covariance) eq 0 then return, $
      crr_mtrx(x) $  ;Correlation Matrix.
    else return, cov_mtrx(x)  ;Covariance Matrix.
  endelse
end

;$Id: cramer.pro,v 1.3 1994/11/29 20:44:18 beth Exp $
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CRAMER
;
; PURPOSE:
;       This function solves an n by n linear system of equations 
;       using Cramer's rule.
;
; CATEGORY:
;       Linear Algebra.
;
; CALLING SEQUENCE:
;       Result = CRAMER(A, B)
;
; INPUTS:
;       A:      An N by N array of type: float, or double.
;
;       B:      An N-element vector of type: float, or double.
;
; KEYWORD PARAMETERS:
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
;       ZERO:   Use this keyword to set the value of floating-point
;               zero. A floating-point zero on the main diagonal of
;               a triangular matrix results in a zero determinant.
;               A zero determinant results in a 'Singular matrix'
;               error and stops the execution of CRAMER.PRO.
;               For single-precision inputs, the default value is 
;               1.0e-6. For double-precision inputs, the default value 
;               is 1.0e-12.
;
; EXAMPLE:
;       Define an array (a).
;         a = [[ 2.0,  1.0,  1.0], $
;              [ 4.0, -6.0,  0.0], $
;              [-2.0,  7.0,  2.0]]
;
;       And right-side vector (b).
;         b = [3.0, 10.0, -5.0]
;
;       Compute the solution of the system, ax = b.
;         result = cramer(a, b)
;
; PROCEDURE:
;       CRAMER.PRO uses ratios of column-wise permutations of the array (a)
;       to calculate the solution vector (x) of the linear system, ax = b.
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, February 1994
;       Modified:    GGS, RSI, November 1994
;                    Added support for double precision results.
;-

function cramer, a, b, double = double, zero = zero

  on_error, 2  ;Return to caller if error occurs.

  dim = size(a)
  if dim(1) ne dim(2) then $
    message, 'Input matrix is not square.'

  if dim(3) ne 4 and dim(3) ne 5 then $
    message, 'Input matrix must be float or double.'

  dbl = 0
  if keyword_set(double) ne 0 then dbl = 1

  if keyword_set(zero) eq 0 and dim(3) eq 4 then $
    zero = 1.0e-6             ;Single-precision zero.
  if keyword_set(zero) eq 0 and dim(3) eq 5 then $
    zero = 1.0e-12            ;Double-precision zero.

  det = determ(a, double = dbl, zero = zero)
  if det eq 0 then $
    message, 'Singular matrix.'

  if dim(3) eq 5 or dbl eq 1 then x = dblarr(dim(1)) $
  else x = fltarr(dim(1))

  for k = 0, dim(1)-1 do begin
    col = a(k,*) ;Save the Kth column of a.
    a(k,*) = b   ;Permute the Kth column of a with b.
    x(k) = determ(a, double = dbl, zero = zero) / det
                 ;Solve for the Kth component of the solution x.
    a(k,*) = col ;Restore a to its original state.
  endfor

  return, x

end
; $Id: create_view.pro,v 1.2 1993/10/04 20:31:27 doug Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	CREATE_VIEW
;
; PURPOSE:
;	This procedure sets the various system variables required to
;       define a coordinate system and a 3-D view.   This procedure
;       builds the system viewing matrix (!P.T) in such a way that the
;       correct aspect ratio of the data is maintained even if the
;       display window is not square.
;       CREATE_VIEW also sets the "Data" to "Normal" coordinate
;       conversion factors (!X.S, !Y.S, and !Z.S) so that center of
;       the unit cube will be located at the center of the display
;       window.
;
; CATEGORY:
;	Viewing.
;
; CALLING SEQUENCE:
;       CREATE_VIEW
;	
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;       XMIN:       The minimum data value on the X axis.
;                   The default is (0.0).
;                   Data type : Any scalar numeric value.
;       XMAX:       The maximum data value on the X axis.
;                   The default is (1.0).
;                   Data type : Any scalar numeric value.
;       YMIN:       The minimum data value on the Y axis.
;                   The default is (0.0).
;                   Data type : Any scalar numeric value.
;       YMAX:       The maximum data value on the Y axis.
;                   Data type : Any scalar numeric value.
;                   The default is (1.0).
;       ZMIN:       The minimum data value on the Z axis.
;                   The default is (0.0).
;                   Data type : Any scalar numeric value.
;       ZMAX:       The maximum data value on the Z axis.
;                   The default is (1.0).
;                   Data type : Any scalar numeric value.
;       AX:         The orientation (X rotation) of the view.
;                   The default is (0.0).
;                   Data type : Float.
;       AY:         The orientation (Y rotation) of the view.
;                   The default is (0.0).
;                   Data type : Float.
;       AZ:         The orientation (Z rotation) of the view.
;                   The default is (0.0).
;                   Data type : Float.
;       WINX:       The X size, in pixels, of the window that the
;                   view is being set up for.
;                   The default is (640).
;                   Data type : Long.
;       WINY:       The Y size, in pixels, of the window that the
;                   view is being set up for.
;                   The default is (512).
;                   Data type : Long.
;       ZOOM:       The view zoom factor.   If zoom is a single
;                   value then the view will be zoomed equally in
;                   all 3 dimensions.   If zoom is a 3 element vector
;                   then the view will be scaled zoom(0) in X,
;                   zoom(1) in Y, and zoom(2) in Z.
;                   The default is (1.0).
;                   Data type : Float or Fltarr(3).
;       ZFAC:       Use this keyword to expand or contract the view
;                   in the Z dimension.
;                   The default is (1.0).
;                   Data type : Float.
;       PERSP:      The perspective projection distance.   A value of
;                   (0.0) indicates an isometric projection (NO per-
;                   spective).
;                   The default is (0.0).
;                   Data type : Float.
;       RADIANS:    Set this keyword to a non-zero value if the values
;                   passed to AX, AY, and AZ are in radians.
;                   The default is degrees.
;                   Data type : Int.
;
; SIDE EFFECTS:
;	This procedure sets the following IDL system variables :
;
;          !P.T, !P.T3D, !P.Position, !P.Clip, !P.Region
;          !X.S, !X.Style, !X.Range, !X.Margin
;          !Y.S, !Y.Style, !Y.Range, !Y.Margin
;          !Z.S, !Z.Style, !Z.Range, !Z.Margin
;
; PROCEDURE:
;       This procedure sets the 4x4 system viewing matrix (!P.T) by
;       calling T3D with the following parameters :
;
;       ; Reset (!P.T) to the identity matrix.
;          T3D, /RESET
;       ; Translate the center of the unit cube to the origin.
;          T3D, TRANSLATE=[(-0.5), (-0.5), (-0.5)]
;       ; Zoom the view.
;          T3D, SCALE=ZOOM
;       ; Scale the view to preserve the correct aspect ratio.
;          xrange = xmax - xmin
;          yrange = ymax - ymin
;          zrange = (zmax - zmin) * zfac
;          max_range = xrange > yrange > zrange
;          T3D, SCALE=([xrange, yrange, zrange] / max_range)
;       ; Rotate the view.
;          T3D, ROTATE=[0.0, 0.0, AZ]
;          T3D, ROTATE=[0.0, AY, 0.0]
;          T3D, ROTATE=[AX, 0.0, 0.0]
;       ; Define a perspective projection (if any).
;          IF (p_proj) THEN T3D, PERSPECTIVE=PERSP
;       ; Compensate for the aspect ratio of the display window.
;          T3D, SCALE=[xfac, yfac, 1.0]
;       ; Translate the unit cube back to its starting point.
;          T3D, TRANSLATE=[(0.5), (0.5), (0.5)]
;
; EXAMPLE:
;       Set up a view to display an iso-surface from volumetric data.
;
;       ; Create some data.
;          vol = FLTARR(40, 50, 30)
;          vol(3:36, 3:46, 3:26) = RANDOMU(s, 34, 44, 24)
;          FOR i=0, 10 DO vol = SMOOTH(vol, 3)
;
;       ; Generate the iso-surface.
;          SHADE_VOLUME, vol, 0.2, polygon_list, vertex_list, /LOW
;
;       ; Set up the view.
;       ; Note that the subscripts into the Vol array range from
;       ; 0 to 39 in X, 0 to 49 in Y, and 0 to 29 in Z.   As such,
;       ; the 3-D coordinates of the iso-surface (vertex_list) may
;       ; range from 0.0 to 39.0 in X, 0.0 to 49.0 in Y,
;       ; and 0.0 to 29.0 in Z.   Set XMIN, YMIN, and ZMIN to
;       ; zero (the default), and set XMAX=39, YMAX=49, and ZMAX=29.
;          WINDOW, XSIZE=600, YSIZE=400
;          CREATE_VIEW, XMAX=39, YMAX=49, ZMAX=29, AX=(-60.0), AZ=(30.0), $
;                       WINX=600, WINY=400, ZOOM=(0.7), PERSP=(1.0)
;
;       ; Display the iso surface in the specified view.
;          img = POLYSHADE(polygon_list, vertex_list, /DATA, /T3D)
;          TVSCL, img
;
; MODIFICATION HISTORY:
; 	Written by:	Daniel Carr. Wed Sep  2 16:40:47 MDT 1992
;       Modified the way the view is compensated for the data aspect ratio.
;                       Daniel Carr. Tue Dec  8 17:53:54 MST 1992
;-

PRO Create_View, Xmin=p_xmin, Xmax=p_xmax, Ymin=p_ymin, Ymax=p_ymax, $
                 Zmin=p_zmin, Zmax=p_zmax, Az=p_az, Ay=p_ay, Ax=p_ax, $
                 Winx=p_winx, Winy=p_winy, Zoom=p_zoom, Zfac=p_zfac, $
                 Persp=p_persp, Radians=p_radians

; *** Test inputs

xmin = 0.0
IF (N_Elements(p_xmin) GT 0) THEN xmin = Float(p_xmin(0))
xmax = 1.0
IF (N_Elements(p_xmax) GT 0) THEN xmax = Float(p_xmax(0))
IF (xmax LE xmin) THEN BEGIN
   Print, 'Xmax must be larger than Xmin'
   STOP
ENDIF

ymin = 0.0
IF (N_Elements(p_ymin) GT 0) THEN ymin = Float(p_ymin(0))
ymax = 1.0
IF (N_Elements(p_ymax) GT 0) THEN ymax = Float(p_ymax(0))
IF (ymax LE ymin) THEN BEGIN
   Print, 'Ymax must be larger than Ymin'
   STOP
ENDIF

zmin = 0.0
IF (N_Elements(p_zmin) GT 0) THEN zmin = Float(p_zmin(0))
zmax = 1.0
IF (N_Elements(p_zmax) GT 0) THEN zmax = Float(p_zmax(0))
IF (zmax LE zmin) THEN BEGIN
   Print, 'Zmax must be larger than Zmin'
   STOP
ENDIF

radians = 0B
IF (N_Elements(p_radians) GT 0) THEN radians = Byte(p_radians(0))

az = 0.0
IF (N_Elements(p_az) GT 0) THEN az = Float(p_az(0))
IF (radians GE 1B) THEN az = az * 180.0 / !PI
ay = 0.0
IF (N_Elements(p_ay) GT 0) THEN ay = Float(p_ay(0))
IF (radians GE 1B) THEN ay = ay * 180.0 / !PI
ax = 0.0
IF (N_Elements(p_ax) GT 0) THEN ax = Float(p_ax(0))
IF (radians GE 1B) THEN ax = ax * 180.0 / !PI

winx = 640.0
IF (N_Elements(p_winx) GT 0) THEN winx = Float(p_winx(0))
IF (winx LT 2.0) THEN BEGIN
   Print, 'Window X size must be >= 2'
   STOP
ENDIF
winy = 512.0
IF (N_Elements(p_winy) GT 0) THEN winy = Float(p_winy(0))
IF (winy LT 2.0) THEN BEGIN
   Print, 'Window Y size must be >= 2'
   STOP
ENDIF

zoom = [1.0, 1.0, 1.0]
IF (N_Elements(p_zoom) GT 0) THEN zoom = $
   [Float(p_zoom(0)), Float(p_zoom(0)), Float(p_zoom(0))]
IF (N_Elements(p_zoom) GE 3) THEN zoom = $
   [Float(p_zoom(0)), Float(p_zoom(1)), Float(p_zoom(2))]
IF (Min(zoom) LE 0.0) THEN BEGIN
   Print, 'Zoom factor must be > 0'
   STOP
ENDIF

zfac = 1.0
IF (N_Elements(p_zfac) GT 0) THEN zfac = Float(p_zfac(0))
IF (zfac LT 0.0) THEN BEGIN
   Print, 'Zfac must be >= 0'
   STOP
ENDIF

persp = 0.0
IF (N_Elements(p_persp) GT 0) THEN persp = Float(p_persp(0))
p_proj = 0B
IF (persp GT 0.0) THEN p_proj = 1B

; *** Start setting up view

!X.Style = 1
!X.Range = [xmin, xmax]
!X.Margin = [0, 0]
!Y.Style = 1
!Y.Range = [ymin, ymax]
!Y.Margin = [0, 0]
!Z.Style = 1
!Z.Range = [zmin, zmax]
!Z.Margin = [0, 0]

!X.S = [(-xmin), 1.0] / (xmax - xmin)
!Y.S = [(-ymin), 1.0] / (ymax - ymin)
!Z.S = [(-zmin), 1.0] / (zmax - zmin)

!P.Position = [0.0, 0.0, 1.0, 1.0]
!P.Clip = [0, 0, (winx-1), (winy-1), 0, 0]
!P.Region = [0.0, 0.0, 1.0, 1.0]
!P.T3D = 1

xfac = 1.0
yfac = 1.0
IF (winx GT winy) THEN xfac = winy / winx
IF (winy GT winx) THEN yfac = winx / winy

xrange = xmax - xmin
yrange = ymax - ymin
zrange = (zmax - zmin) * zfac
max_range = xrange > yrange > zrange
xyz_fac = [xrange, yrange, zrange] / max_range

T3d, /Reset
T3d, Translate=[(-0.5), (-0.5), (-0.5)]
T3d, Scale=zoom
T3d, Scale=xyz_fac
T3d, Rotate=[0.0, 0.0, az]
T3d, Rotate=[0.0, ay, 0.0]
T3d, Rotate=[ax, 0.0, 0.0]
IF (p_proj) THEN T3d, Perspective=persp
T3d, Scale=[xfac, yfac, 1.0]
T3d, Translate=[(0.5), (0.5), (0.5)]

RETURN
END
; $Id: crossp.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function Crossp,v1,v2
;
;+
; NAME:
;	CROSSP
;
; PURPOSE:
;	Evaluate the vector or cross-product of vectors v1 and v2.
;
; CATEGORY:
;	Vector mathematics.
;
; CALLING SEQUENCE:
;	Result = CROSSP(v1, v2)
;
; INPUTS:
;	v1, v2:  Three-element vectors.
;
; OUTPUTS:
;	Returns a 3-element, floating-point vector.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	Vectors must have 3 elements.
;
; PROCEDURE:
;	v1 X v2 = | i  j  k  | = (b1c2 - b2c1)i + (c1a2-c2a1)j + (a1b2-a2b1)k
;		  | a1 b1 c1 |
;		  | a2 b2 c2 |
;
; MODIFICATION HISTORY:
;	Written, DMS, Aug, 1983;
;-
	on_error,2                      ;Return to caller if an error occurs
	return,[v1(1)*v2(2)-v2(1)*v1(2), V1(2)*v2(0)-V2(2)*v1(0), $
		v1(0)*v2(1)-v2(0)*v1(1) ]
end

;$Id: cti_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CTI_TEST
;
; PURPOSE:
;       This function constructs a "contingency table" from an array of
;       observed frequencies and tests the hypothesis that the rows and
;       columns are independent using an extension of the chi-squared 
;       goodness-of-fit test. The result is a two-element vector contain-
;       ing the chi-squared test statistic X2 and probability of obtaining 
;       a value of X2 or greater.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = CTI_TEST(OBFREQ)
;
; INPUTS:
;       OBFREQ:  An array of c-columns and r-rows of type integer, float 
;                or double containing observed frequencies.
;
; KEYWORD PARAMETERS:
;        COEFF:  Use this keyword to specify a named variable which returns
;                the Coefficient of Contingency. A non-negative scalar,
;                in the interval [0.0, 1.0], which measures the degree
;                of dependence within a contingency table. The larger the
;                value of COEFF, the greater the degree of dependence.
;
;    CORRECTED:  If set to a nonzero value, the "Yate's Correction for
;                Continuity" is used to compute the chi-squared test 
;                statistic, X2. The Yate's correction always decreases the
;                magnitude of the chi-squared test statistic, X2. In general,
;                this keyword should be set for small sample sizes.
;
;         CRAMV: Use this keyword to specify a named variable which returns
;                Cramer's V. A non-negative scalar, in the interval [0.0, 1.0],
;                which measures the degree of dependence within a contingency
;                table.
;
;           DF:  Use this keyword to specify a named variable which returns
;                the degrees of freedom used to compute the probability of 
;                obtaining the value of the chi-squared test statistic or
;                greater. DF = (r - 1) * (c - 1) where r and c are the
;                number of rows and columns of the contingency table, 
;                respectively.
;
;       EXFREQ:  Use this keyword to specify a named variable which returns
;                an array of c-columns and r-rows containing expected  
;                frequencies. The elements of this array are often refered
;                to as the "cells" of the expected frequencies. The expected
;                frequency of each cell is computed as the product of row
;                and column marginal frequencies divided by the overall 
;                total of observed frequencies.
; 
;     RESIDUAL:  Use this keyword to specify a named variable which returns
;                an array of c-columns and r-rows containing signed differences
;                between corresponding cells of observed frequencies and 
;                expected frequencies.
;
; EXAMPLE:
;       Define the 5-column and 4-row array of observed frequencies.
;         obfreq = [[748, 821, 786, 720, 672], $
;                   [ 74,  60,  51,  66,  50], $
;                   [ 31,  25,  22,  16,  15], $
;                   [  9,  10,   6,   5,   7]]
;       Test the hypothesis that the rows and columns of "obfreq" contain
;       independent data at the 0.05 significance level.
;         result = cti_test(obfreq, coeff = coeff)
;       The result should be the two-element vector [14.3953, 0.276181].
;       The computed value of 0.276181 indicates that there is no reason to
;       reject the proposed hypothesis at the 0.05 significance level.
;       The Coefficient of Contingency returned in the parameter "coeff" 
;       (coeff = 0.0584860) also indicates the lack of dependence between
;       the rows and columns of the observed frequencies. Setting the 
;       CORRECTED keyword returns the two-element vector [12.0032, 0.445420]
;       and (coeff = 0.0534213) resulting in the same conclusion of 
;       independence.
;
; PROCEDURE:
;       CTI_TEST constructs a "contingency table" from a 2-dimensional
;       input array of observed frequencies and applies the principles of
;       the chi-squared goodness-of-fit test to determine the independence
;       of the rows and columns. For small sample sizes, a correction for
;       absolute differences between observed and expected frequencies may
;       be applied by setting the CORRECTED keyword.
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, August 1994
;-

function cti_test, obfreq, corrected = corrected, coeff = coeff, $
                           cramv = cramv, df = df, $
                           exfreq = exfreq, residual = residual

  on_error, 2

  ;Size attributes for array of observed values.
  sobfreq = size(obfreq)

  if sobfreq(0) ne 2 then message, $
    'Observed frequencies must be two-dimensional array.'

  ineg = where(obfreq lt 0, nneg)
  if nneg ne 0 then message, $
    'Array of observed frequencies cannot contain negative data.'

  col = sobfreq(1) ;Column dimension.
  row = sobfreq(2) ;Row dimension.

  obtotal = total(obfreq) ;Overall total.

  ;Marginal frequencies.
  coltotal = total(obfreq, 2)
  rowtotal = total(obfreq, 1)

  ;Expected frequencies.
  exfreq = coltotal # rowtotal / obtotal  

  ;Degrees of freedom
  df = (row - 1) * (col - 1)

  if keyword_set(corrected) ne 0 then begin
    ;Apply Yate's Correction.
    residual = abs(obfreq - exfreq) 
    z = total((residual - 0.5)^2.0 / exfreq)
    prob = 1 - chisqr_pdf(z, df)
  endif else begin
    residual = (obfreq - exfreq)
    z = total(residual^2.0 / exfreq)
    prob = 1 - chisqr_pdf(z, df)
  endelse

  ;Coefficient of contingency.
  coeff = sqrt(z / (z + obtotal)) 

  ;Cramer's V.
  cramv = sqrt(z / (obtotal * min([row - 1, col - 1])))

  return, [z, prob]

end
; $Id: ct_luminance.pro,v 1.2 1994/05/16 22:27:35 dave Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;++NODOCUMENT
; NAME:
;	CT_LUMINANCE
;
; PURPOSE:
;	Calculate the luminance of colors.
;
; CATEGORY:
;	Color tables
;
; CALLING SEQUENCE:
;	L = CT_LUMINANCE(R, G, B)
;
; INPUTS:
;	R = Red color table.  If omitted, use the color values from
;		either the COLORS common block, or the current color table.
;	G = Green color table, optional parameter.
;	B = Blue color table, optional parameter.
;
; KEYWORD PARAMETERS:
;	BRIGHT=var - Stores the index of the brightest color in the current
;		colortable into var.
;	DARK=var - Stores the index of the darkest color in the current
;		colortable into var.
;	READ_TABLES = if set and parameters are not specified,
;		read directly from color tables, using
;		TVLCT, /GET.  Do not use the COLORS common block.
;
; OUTPUTS:
;   This function returns an array containing the luminance values
;	of the specified colors.  If the R,G,B parameters are not
;	specified, or if R is of integer, byte or long type, the
;	result is a longword array.  Otherwise, the result is a 
;	floating point array.
;
; COMMON BLOCKS:
;	COLORS:	Contains the current RGB color tables.
;
; MODIFICATION HISTORY:
;	April 1, 1992, AB
;		When splitting XPALETTE into widget clusters, this code
;		became necessary in multiple places. This routine
;		encapsulates it.
;	May 15, 1994, DMS
;		Process colors from parameters or current color table.
;-

function CT_LUMINANCE, R, G, B, DARK=dark, BRIGHT=bright, READ_TABLES=read_it

  common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

  ; This is the standard NTSC luminance equation

  if n_elements(r) gt 0 then begin	;Use params?
	lum = .3 * r + .59 * g + .11 * b
	s = size(r)		;Integer?
	if s(s(0)+1) le 3 then lum = round(lum) < 255  ;Integerize?
  endif else if keyword_set(read_it) then begin	;Use current color table?
	tvlct, r, g, b, /GET
	lum = ROUND(.3 * r + .59 * g + .11 * b) < 255
  endif else BEGIN			;Use common block?
	  ; Make sure the colors common block is initialized
	  if (n_elements(r_curr) eq 0) then begin
	    r_orig = bytscl(indgen(!d.table_size))
	    g_orig = r_orig & b_orig = r_orig
	    r_curr = r_orig & g_curr = r_orig & b_curr = r_orig
	  endif
	lum= ROUND(.3 * r_curr + .59 * g_curr + .11 * b_curr) < 255
  endelse

  bright = max(lum, min=dark)
;  bright = (byte(where(lum eq bright)))(0)
;  dark = (byte(where(lum eq dark)))(0)
  return, lum
end
; $Id: curvefit.pro,v 1.7 1995/06/15 16:24:13 dave Exp $
function curvefit, x, y, w, a, sigmaa, Function_Name = Function_Name, $
                        itmax=itmax, iter=iter, tol=tol, chi2=chi2, $
                        noderivative=noderivative
; Copyright (c) 1988-1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CURVEFIT
;
; PURPOSE:
;       Non-linear least squares fit to a function of an arbitrary 
;       number of parameters.  The function may be any non-linear 
;       function.  If available, partial derivatives can be calculated by 
;       the user function, else this routine will estimate partial derivatives
;       with a forward difference approximation.
;
; CATEGORY:
;       E2 - Curve and Surface Fitting.
;
; CALLING SEQUENCE:
;       Result = CURVEFIT(X, Y, W, A, SIGMAA, FUNCTION_NAME = name, $
;                         ITMAX=ITMAX, ITER=ITER, TOL=TOL, /NODERIVATIVE)
;
; INPUTS:
;       X:  A row vector of independent variables.  This routine does
;		not manipulate or use values in X, it simply passes X
;		to the user-written function.
;
;       Y:  A row vector containing the dependent variable.
;
;       W:  A row vector of weights, the same length as Y.
;               For no weighting,
;               w(i) = 1.0.
;               For instrumental weighting,
;               w(i) = 1.0/y(i), etc.
;
;       A:  A vector, with as many elements as the number of terms, that 
;           contains the initial estimate for each parameter.  If A is double-
;           precision, calculations are performed in double precision, 
;           otherwise they are performed in single precision.
;
; KEYWORDS:
;       FUNCTION_NAME:  The name of the function (actually, a procedure) to 
;       fit.  If omitted, "FUNCT" is used. The procedure must be written as
;       described under RESTRICTIONS, below.
;
;       ITMAX:  Maximum number of iterations. Default = 20.
;       ITER:   The actual number of iterations which were performed
;       TOL:    The convergence tolerance. The routine returns when the
;               relative decrease in chi-squared is less than TOL in an 
;               interation. Default = 1.e-3.
;       CHI2:   The value of chi-squared on exit
;       NODERIVATIVE:   If this keyword is set then the user procedure will not
;               be requested to provide partial derivatives. The partial
;               derivatives will be estimated in CURVEFIT using forward
;               differences. If analytical derivatives are available they
;               should always be used.
;
; OUTPUTS:
;       Returns a vector of calculated values.
;       A:  A vector of parameters containing fit.
;
; OPTIONAL OUTPUT PARAMETERS:
;       Sigmaa:  A vector of standard deviations for the parameters in A.
;
; COMMON BLOCKS:
;       NONE.
;
; SIDE EFFECTS:
;       None.
;
; RESTRICTIONS:
;       The function to be fit must be defined and called FUNCT,
;       unless the FUNCTION_NAME keyword is supplied.  This function,
;       (actually written as a procedure) must accept values of
;       X (the independent variable), and A (the fitted function's
;       parameter values), and return F (the function's value at
;       X), and PDER (a 2D array of partial derivatives).
;       For an example, see FUNCT in the IDL User's Libaray.
;       A call to FUNCT is entered as:
;       FUNCT, X, A, F, PDER
; where:
;       X = Variable passed into CURVEFIT.  It is the job of the user-written
;		function to interpret this variable.
;       A = Vector of NTERMS function parameters, input.
;       F = Vector of NPOINT values of function, y(i) = funct(x), output.
;       PDER = Array, (NPOINT, NTERMS), of partial derivatives of funct.
;               PDER(I,J) = DErivative of function at ith point with
;               respect to jth parameter.  Optional output parameter.
;               PDER should not be calculated if the parameter is not
;               supplied in call. If the /NODERIVATIVE keyword is set in the
;               call to CURVEFIT then the user routine will never need to
;               calculate PDER.
;
; PROCEDURE:
;       Copied from "CURFIT", least squares fit to a non-linear
;       function, pages 237-239, Bevington, Data Reduction and Error
;       Analysis for the Physical Sciences.
;
;       "This method is the Gradient-expansion algorithm which
;       combines the best features of the gradient search with
;       the method of linearizing the fitting function."
;
;       Iterations are performed until the chi square changes by
;       only TOL or until ITMAX iterations have been performed.
;
;       The initial guess of the parameter values should be
;       as close to the actual values as possible or the solution
;       may not converge.
;
; EXAMPLE:  Fit a function of the form f(x) = a * exp(b*x) + c to
;	sample pairs contained in x and y.
;	In this example, a=a(0), b=a(1) and c=a(2).
;	The partials are easily computed symbolicaly:
;		df/da = exp(b*x), df/db = a * x * exp(b*x), and df/dc = 1.0
;
;		Here is the user-written procedure to return F(x) and
;		the partials, given x:
;       pro gfunct, x, a, f, pder	; Function + partials
;	  bx = exp(a(1) * x)
;         f= a(0) * bx + a(2)		;Evaluate the function
;         if N_PARAMS() ge 4 then $	;Return partials?
;		pder= [[bx], [a(0) * x * bx], [replicate(1.0, N_ELEMENTS(y))]]
;       end
;
;         x=findgen(10)			;Define indep & dep variables.
;         y=[12.0, 11.0,10.2,9.4,8.7,8.1,7.5,6.9,6.5,6.1]
;         w=1.0/y			;Weights
;         a=[10.0,-0.1,2.0]		;Initial guess
;         yfit=curvefit(x,y,w,a,sigmaa,function_name='gfunct')
;	  print, 'Function parameters: ', a
;         print, yfit
;       end
;
; MODIFICATION HISTORY:
;       Written, DMS, RSI, September, 1982.
;       Does not iterate if the first guess is good.  DMS, Oct, 1990.
;       Added CALL_PROCEDURE to make the function's name a parameter.
;              (Nov 1990)
;       12/14/92 - modified to reflect the changes in the 1991
;            edition of Bevington (eq. II-27) (jiy-suggested by CreaSo)
;       Mark Rivers, U of Chicago, Feb. 12, 1995
;           - Added following keywords: ITMAX, ITER, TOL, CHI2, NODERIVATIVE
;             These make the routine much more generally useful.
;           - Removed Oct. 1990 modification so the routine does one iteration
;             even if first guess is good. Required to get meaningful output
;             for errors. 
;           - Added forward difference derivative calculations required for 
;             NODERIVATIVE keyword.
;           - Fixed a bug: PDER was passed to user's procedure on first call, 
;             but was not defined. Thus, user's procedure might not calculate
;             it, but the result was then used.
;           
;-
       on_error,2              ;Return to caller if error

       ;Name of function to fit
       if n_elements(function_name) le 0 then function_name = "FUNCT"
       if n_elements(tol) eq 0 then tol = 1.e-3		;Convergence tolerance
       if n_elements(itmax) eq 0 then itmax = 20	;Maximum # iterations
	type = size(a)
	type = type(type(0)+1)
	double = type eq 5
	if (type ne 4) and (type ne 5) then a = float(a)  ;Make params floating

       ; If we will be estimating partial derivatives then compute machine
       ; precision
       if keyword_set(NODERIVATIVE) then begin
          res = nr_machar(DOUBLE=double)
          eps = sqrt(res.eps)
       endif

       nterms = n_elements(a)   ; # of parameters
       nfree = n_elements(y) - nterms ; Degrees of freedom
       if nfree le 0 then message, 'Curvefit - not enough data points.'
       flambda = 0.001          ;Initial lambda
       diag = lindgen(nterms)*(nterms+1) ; Subscripts of diagonal elements

;      Define the partial derivative array
       if double then pder = dblarr(n_elements(y), nterms) $
	else pder = fltarr(n_elements(y), nterms)
;
       for iter = 1, itmax do begin   ; Iteration loop

;         Evaluate alpha and beta matricies.
          if keyword_set(NODERIVATIVE) then begin
;            Evaluate function and estimate partial derivatives
             call_procedure, Function_name, x, a, yfit
             for term=0, nterms-1 do begin
                p = a       ; Copy current parameters
                ; Increment size for forward difference derivative
                inc = eps * abs(p(term))    
                if (inc eq 0.) then inc = eps
                p(term) = p(term) + inc
                call_procedure, function_name, x, p, yfit1
                pder(0,term) = (yfit1-yfit)/inc
             endfor
          endif else begin
             ; The user's procedure will return partial derivatives
             call_procedure, function_name, x, a, yfit, pder 
          endelse

          beta = (y-yfit)*w # pder
          alpha = transpose(pder) # (w # (fltarr(nterms)+1)*pder)
          chisq1 = total(w*(y-yfit)^2)/nfree ; Present chi squared.

				; If a good fit, no need to iterate
	  all_done = chisq1 lt total(abs(y))/1e7/NFREE
;
;         Invert modified curvature matrix to find new parameters.

          repeat begin
             c = sqrt(alpha(diag) # alpha(diag))
             array = alpha/c
             array(diag) = array(diag)*(1.+flambda)              
             array = invert(array)
             b = a+ array/c # transpose(beta) ; New params
             call_procedure, function_name, x, b, yfit  ; Evaluate function
             chisqr = total(w*(y-yfit)^2)/nfree         ; New chisqr
	     if all_done then goto, done
             flambda = flambda*10.                      ; Assume fit got worse
          endrep until chisqr le chisq1
;
          flambda = flambda/100.  ; Decrease flambda by factor of 10
          a=b                     ; Save new parameter estimate.
          if ((chisq1-chisqr)/chisq1) le tol then goto,done  ; Finished?
       endfor                        ;iteration loop
;
       message, 'Failed to converge', /INFORMATIONAL
;
done:  sigmaa = sqrt(array(diag)/alpha(diag)) ; Return sigma's
       chi2 = chisqr                          ; Return chi-squared
       return,yfit              ;return result
END
; $Id: cv_coord.pro,v 1.1 1994/04/05 17:22:55 dan Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CV_COORD
;
; PURPOSE:
;       Converts 2-D and 3-D coordinates between the RECTANGULAR, POLAR,
;       CYLINDRICAL, and SPHERICAL coordinate systems.
;
; CATEGORY:
;       Graphics
;
; CALLING SEQUENCE:
;       Coord = CV_COORD()
;
; KEYWORD PARAMETERS:
;
;       FROM_RECT:
;                  A vector of the form [x, y] or [x, y, z], or a (2, n) or
;                  (3, n) array containing rectangular coordinates to convert.
;
;       FROM_POLAR:
;                  A vector of the form [angle, radius], or a (2, n) array of
;                  polar coordinates to convert.
;
;       FROM_CYLIN:
;                  A vector of the form [angle, radius, z], or a (3, n) array
;                  of cylindrical coordinates to convert.
;
;       FROM_SPHERE:
;                  A vector of the form [longitude, latitude, radius], or a
;                  (3, n) array of spherical coordinates to convert.
;
;       TO_RECT:   If set, then rectangular coordinates are returned.
;
;       TO_POLAR:  If set, then polar coordinates are returned.
;
;       TO_CYLIN:  If set, then cylindrical coordinates are returned.
;
;       TO_SPHERE: If set, then spherical coordinates are returned.
;
;       DEGREES:   If set, then the input (and output) coordinates are in
;                  degrees (where applicable). Otherwise, the angles are
;                  in radians.
;
; OUTPUTS:
;       This function returns the converted coordinate(s) based on which of
;       the "TO_" keywords is used :
;
;          TO_RECT   : If the input coordinates were polar, then a vector
;                      of the form [x, y] or a (2, n) array is returned.
;                      Otherwise, a vector of the form [x, y, z], or a
;                      (3, n) array is returned.
;          TO_POLAR  : A vector of the form [angle, radius], or a (2, n)
;                      array is returned.
;          TO_CYLIN  : A vector of the form [angle, radius, z], or a (3, n)
;                      array is returned.
;          TO_SPHERE : A vector of the form [longitude, latitude, radius],
;                      or a (3, n) array is returned.
;
;       If the value passed to the "FROM_" keyword is double precision, then
;       all calculations are performed in double precision and the returned
;       value is double precision. Otherwise, single precision is used.
;
;       If none of the "FROM_" keywords are specified then 0 is returned.
;       If none of the "TO_" keywords are specified then the input coordinates
;       are returned.
;
; PROCEDURE:
;       When converting from spherical to polar coordinates, the points
;       are first projected along the z axis to the x-y plane to get 2-D
;       rectangular coordinates. The 2-D rectangular coordinates are
;       then converted to polar.
;
; EXAMPLE:
;       ; Convert from spherical to cylindrical coordinates.
;
;       sphere_coord = [[45.0, -60.0, 10.0], [0.0, 0.0, 0.0]]
;       rect_coord = CV_COORD(From_Sphere=sphere_coord, /To_Cylin, /Degrees)
;
;       ; Convert from rectangular to polar coordinates.
;
;       rect_coord = [10.0, 10.0]
;       polar_coord = CV_COORD(From_Rect=rect_coord, /To_Polar)
;
; MODIFICATION HISTORY:
;       Written by:     Daniel Carr, Thu Mar 31 14:42:58 MST 1994
;-

FUNCTION CV_COORD, From_Rect=from_rect, From_Polar=from_polar, $
                   From_Cylin=from_cylin, From_Sphere=from_sphere, $
                   To_Rect=to_rect, To_Polar=to_polar, $
                   To_Cylin=to_cylin, To_Sphere=to_sphere, $
                   Degrees=degrees

IF (N_Elements(from_rect) GT 0L) THEN BEGIN ; Convert from rectangular.
   sz_from = Size(from_rect)
   IF (sz_from(0) EQ 1L) THEN $
      sz_from = [2L, sz_from(1), 1L, sz_from(2), sz_from(3)]

   IF (sz_from(sz_from(0) + 2L) EQ 5L) THEN BEGIN ; Double precision.
      IF (Keyword_Set(degrees)) THEN ang_out = 180.0D/!DPI ELSE ang_out = 1.0D
      zero = 0.0D
   ENDIF ELSE BEGIN ; Single precision
      IF (Keyword_Set(degrees)) THEN ang_out = !Radeg ELSE ang_out = 1.0
      zero = 0.0
   ENDELSE

   IF (Keyword_Set(to_polar)) THEN BEGIN
      ang = Replicate(zero, 1L, sz_from(2))
      rad = Sqrt(from_rect(0, *)^2 + from_rect(1, *)^2)
      non_zero_ind = Where(rad NE zero)
      IF (non_zero_ind(0) GE 0L) THEN $
         ang(non_zero_ind) = ang_out * $
            Atan(from_rect(1, non_zero_ind), from_rect(0, non_zero_ind))
      RETURN, [ang, rad]
   ENDIF

   IF (Keyword_Set(to_cylin)) THEN BEGIN
      ang = Replicate(zero, 1L, sz_from(2))
      rad = Sqrt(from_rect(0, *)^2 + from_rect(1, *)^2)
      non_zero_ind = Where(rad NE zero)
      IF (non_zero_ind(0) GE 0L) THEN $
         ang(non_zero_ind) = ang_out * $
            Atan(from_rect(1, non_zero_ind), from_rect(0, non_zero_ind))
      IF (sz_from(1) GE 3L) THEN RETURN, [ang, rad, from_rect(2, *)] $
      ELSE RETURN, [ang, rad, Replicate(zero, 1L, sz_from(2))]
   ENDIF

   IF (Keyword_Set(to_sphere)) THEN BEGIN
      ang1 = Replicate(zero, 1L, sz_from(2))
      ang2 = Replicate(zero, 1L, sz_from(2))
      IF (sz_from(1) LT 3L) THEN z = Replicate(zero, 1L, sz_from(2)) $
      ELSE z = from_rect(2, *)
      rad = Sqrt(from_rect(0, *)^2 + from_rect(1, *)^2 + z^2)
      non_zero_ind = Where(rad GT zero)
      IF (non_zero_ind(0) GE 0L) THEN BEGIN
         ang1(non_zero_ind) = ang_out * $
            Atan(from_rect(1, non_zero_ind), from_rect(0, non_zero_ind))
         ang2(non_zero_ind) = ang_out * Atan(z(0, non_zero_ind), $
            Sqrt(from_rect(0, non_zero_ind)^2 + from_rect(1, non_zero_ind)^2))
      ENDIF
      RETURN, [ang1, ang2, rad]
   ENDIF

   RETURN, from_rect
ENDIF

IF (N_Elements(from_polar) GT 0L) THEN BEGIN ; Convert from polar.
   sz_from = Size(from_polar)
   IF (sz_from(0) EQ 1L) THEN $
      sz_from = [2L, sz_from(1), 1L, sz_from(2), sz_from(3)]

   IF (sz_from(sz_from(0) + 2L) EQ 5L) THEN BEGIN ; Double precision.
      IF (Keyword_Set(degrees)) THEN ang_in = !DPI/180.0D ELSE ang_in = 1.0D
      zero = 0.0D
   ENDIF ELSE BEGIN ; Single precision
      IF (Keyword_Set(degrees)) THEN ang_in = !Dtor ELSE ang_in = 1.0
      zero = 0.0
   ENDELSE

   IF (Keyword_Set(to_rect)) THEN $
      RETURN, [from_polar(1, *) * Cos(ang_in * from_polar(0, *)), $
               from_polar(1, *) * Sin(ang_in * from_polar(0, *))]

   IF (Keyword_Set(to_cylin)) THEN $
      RETURN, [from_polar(0, *), from_polar(1, *), $
               Replicate(zero, 1, sz_from(2))]

   IF (Keyword_Set(to_sphere)) THEN $
      RETURN, [from_polar(0, *), Replicate(zero, 1, sz_from(2)), $
               from_polar(1, *)]

   RETURN, from_polar
ENDIF

IF (N_Elements(from_cylin) GT 0L) THEN BEGIN ; Convert from cylindrical.
   sz_from = Size(from_cylin)
   IF (sz_from(0) EQ 1L) THEN $
      sz_from = [2L, sz_from(1), 1L, sz_from(2), sz_from(3)]

   IF (sz_from(sz_from(0) + 2L) EQ 5L) THEN BEGIN ; Double precision.
      IF (Keyword_Set(degrees)) THEN BEGIN
         ang_in = !DPI/180.0D
         ang_out = 180.0D/!DPI
      ENDIF ELSE BEGIN
         ang_in = 1.0D
         ang_out = 1.0D
      ENDELSE
      zero = 0.0D
   ENDIF ELSE BEGIN ; Single precision
      IF (Keyword_Set(degrees)) THEN BEGIN
         ang_in = !Dtor
         ang_out = !Radeg
      ENDIF ELSE BEGIN
         ang_in = 1.0
         ang_out = 1.0
      ENDELSE
      zero = 0.0
   ENDELSE

   IF (Keyword_Set(to_rect)) THEN $
      RETURN, [from_cylin(1, *) * Cos(ang_in * from_cylin(0, *)), $
               from_cylin(1, *) * Sin(ang_in * from_cylin(0, *)), $
               from_cylin(2, *)]

   IF (Keyword_Set(to_polar)) THEN RETURN, [from_cylin(0, *), from_cylin(1, *)]

   IF (Keyword_Set(to_sphere)) THEN BEGIN
      ang1 = from_cylin(0, *)
      ang2 = Replicate(zero, 1L, sz_from(2))
      rad = Sqrt(from_cylin(1, *)^2 + from_cylin(2, *)^2)
      non_zero_ind = Where(rad GT zero)
      IF (non_zero_ind(0) GE 0L) THEN $
         ang2(non_zero_ind) = ang_out * Atan(from_cylin(2, non_zero_ind), $
                                             from_cylin(1, non_zero_ind))
      RETURN, [ang1, ang2, rad]
   ENDIF

   RETURN, from_cylin
ENDIF

IF (N_Elements(from_sphere) GT 0L) THEN BEGIN ; Convert from spherical.
   sz_from = Size(from_sphere)
   IF (sz_from(0) EQ 1L) THEN $
      sz_from = [2L, sz_from(1), 1L, sz_from(2), sz_from(3)]

   IF (sz_from(sz_from(0) + 2L) EQ 5L) THEN BEGIN ; Double precision.
      IF (Keyword_Set(degrees)) THEN ang_in = !DPI/180.0D ELSE ang_in = 1.0D
      zero = 0.0D
   ENDIF ELSE BEGIN ; Single precision
      IF (Keyword_Set(degrees)) THEN ang_in = !Dtor ELSE ang_in = 1.0
      zero = 0.0
   ENDELSE

   IF (Keyword_Set(to_rect)) THEN BEGIN
      RETURN, [ $
          from_sphere(2, *) * Cos(ang_in * from_sphere(0, *)) * $
                                     Cos(ang_in * from_sphere(1, *)), $
          from_sphere(2, *) * Sin(ang_in * from_sphere(0, *)) * $
                                     Cos(ang_in * from_sphere(1, *)), $
          from_sphere(2, *) * Sin(ang_in * from_sphere(1, *))]
   ENDIF

   IF (Keyword_Set(to_polar)) THEN $
      RETURN, [from_sphere(0, *), $
               from_sphere(2, *) * Cos(ang_in * from_sphere(1, *))]

   IF (Keyword_Set(to_cylin)) THEN $
      RETURN, [from_sphere(0, *), $
               from_sphere(2, *) * Cos(ang_in * from_sphere(1, *)), $
               from_sphere(2, *) * Sin(ang_in * from_sphere(1, *))]

   RETURN, from_sphere
ENDIF

RETURN, 0
END
; $Id: cw_animate.pro,v 1.11 1995/04/20 23:09:28 billo Exp $

;
; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_ANIMATE
;
; PURPOSE:
;	This widget displays an animated sequence of images using
;	X-windows Pixmaps. This is a compound widget, based on the
;	XINTERANIMATE procedure, with the following advantages:
;		- It can be included in other applications.
;		- Multiple copies can be run simultaneously.
;
;	The speed and direction of the display can be adjusted using
;	the widget interface.
;
; CATEGORY:
;	Image display, compound widgets.
;
; CALLING SEQUENCE:
;	To initially create:
;		widget = CW_ANIMATE(PARENT, SIZEX, SIZEY, NFRAMES)
;
;	To reinitialize when another animation is loaded:
;		CW_ANIMATE_INIT, ANIMATEBASE, SIZEX, SIZEY, NFRAMES
;
;	To load a single image:
;		CW_ANIMATE_LOAD, WIDGET, IMAGE = IMAGE, FRAME = FRAME_INDEX
;
;	To load a single image that is already displayed in an existing window:
;
;		CW_ANIMATE_LOAD, WIDGET, FRAME = FRAME_INDEX, $
;			WINDOW = [WINDOW_NUMBER [, X0, Y0, SX, SY]]
;
;	(This technique is much faster than reading back from the window.)
;
;	To display the animation after all the images have been loaded:
;
;		CW_ANIMATE, WIDGET [, RATE]
;
;	To get a copy of the vector of Pixmaps being used by the widget.
;	If this routine is called, the widget does not destroy the pixmaps
;	when it is destroyed. The user can then provide them to a later
;	call to CW_ANIMATE to re-use them while skipping the Pixmap creation
;	and rendering step:
;
;		CW_ANIMATE_GETP, widget, PIXMAPS
;
; INPUTS:
;   CW_ANIMATE:
;		PARENT:	 The ID of the parent widget.
;		SIZEX:	 The width of the displayed image.
;		SIZEY:	 The height of the displayed image.
;		NFRAMES: The number of frames in the animation sequence.
;
;   CW_ANIMATE_INIT:
;		ANIMATEBASE: The ID of the base animation widget.
;		SIZEX:	 The width of the displayed image.
;		SIZEY:	 The height of the displayed image.
;		NFRAMES: The number of frames in the animation sequence.
;
;  	CW_ANIMATE_LOAD:
;		WIDGET:	 The ID of the widget (as created with CW_ANIMATE)
;			 into which the image should be loaded.
;
;   CW_ANIMATE_RUN:
;		WIDGET:	 The ID of the widget (as created with CW_ANIMATE)
;			 into which the image should be loaded.
;		RATE:	 A value between 0 and 100 that represents the
;			 speed of the animation as a percentage of the
;			 maximum display rate. The fastest animation has
;			 a value of 100 and the slowest  has a value of 0.
;			 The default animation rate is 100.
;       STOP:    If this keyword is set, the animation is stopped.
;       NFRAMES: Specifies the number of frames to animate, must
;                        <= the number specified in CW_ANIMATE().
;
; KEYWORD PARAMETERS:
;   	CW_ANIMATE:
;		PIXMAPS: This keyword provides the new widget with a vector
;			 of pre-existing pixmap (off screen window) IDs.
;			 This vector is usually obtained from a call to
;			 CW_ANIMATE_GETP applied to a previous animation
;			 widget.
;		UVALUE:  A user supplied value to be stored in the widget's
;			 user value field.
;               NO_KILL: If NOT set, an "End Animation" button is added to the
;			 animation base.  If set the button is not added.
;		OPEN_FUNC: A user supplied string that specifies a callback
;			 function name. When a value is specified for this
;			 keyword, an "Open..." pushbutton is added to the
;			 window.  When the "Open..." pushbutton is clicked
;			 the OPEN_FUNC function is called to load new
;			 animation data.
;
;   	CW_ANIMATE_INIT:
;		PIXMAPS: This keyword provides the new widget with a vector
;			 of pre-existing pixmap (off screen window) IDs.
;			 This vector is usually obtained from a call to
;			 CW_ANIMATE_GETP applied to a previous animation
;			 widget.
;
;   	CW_ANIMATE_LOAD:
;		CYCLE:   If set, cycle. Normally, frames are displayed
;			 going either forward or backwards. If CYCLE is
;			 set, reverse direction after the last frame in
;			 either direction is displayed.
;		FRAME: 	 The frame number to be loaded. This is a value
;			 between 0 and NFRAMES. If not supplied, frame 0
;		  	 is loaded.
;		IMAGE:   The image to be loaded.
;		ORDER:   Set this keyword to display images from the top
;			 down instead of the default bottom up. This keyword
;			 is only used when loading images with the IMAGE
;			 keyword.
;		TRACK:   If set, the frame slider tracks the current frame.
;			 Default is not to track.
;		WINDOW:  When this keyword is specified, an image is copied
;			 from an existing window to the animation pixmap.
;			 When using X windows, this technique is much faster
;			 than reading from the display and then loading with
;			 the IMAGE keyword.
;
;			 The value of this parameter is either an IDL window
;			 number (in which case the entire window is copied),
;			 or a vector containing the window index and the
;			 rectangular bounds of the area to be copied. For
;			 example:
;			 WINDOW = [Window_Number, X0, Y0, Sx, Sy]
;
;      		XOFFSET: The horizontal offset, in pixels from the left of
;			 the frame, of the image in the destination window.
;
;      		YOFFSET: The vertical offset, in pixels from the bottom of
;			 the frame, of the image in the destination window.
;
; OUTPUTS:
;	No explicit outputs.
;
; SIDE EFFECTS:
;	If the widget is realized before calls to CW_ANIMATE_LOAD, the frames
;	are displayed as they are loaded. This provides the user with an
;	indication of how things are progressing.
;
;	When the widget is destroyed, it destroys the pixmaps used in the
;	animation, unless they were previously obtained via CW_ANIMATE_GETP
;       and the KILL_ANYWAY keyword was not set.
;
;	The only event returned by this widget indicates that the user
;	has pressed the DONE button. The parent application should use
;	this as a signal to kill the animation widget via WIDGET_CONTROL.
;
; RESTRICTIONS:
;	If more than one animation widget is running at a time, they
;	will fight for resources and run slower.
;
; PROCEDURE:
;	When initialized, this procedure creates pixmaps containing the
;	frames of the animation sequence. Once the images are loaded,
;	they are displayed by copying the images from the pixmap or buffer
;	to the visible draw widget.
;
; EXAMPLE:
;	Assume the following event handler procedure exists:
;		PRO EHANDLER, EV
;		  WIDGET_CONTROL, /DESTROY, EV.TOP
;		end
;
;	Enter the following commands to open the file ABNORM.DAT (a series
;	of images of a human heart) and load the images it contains into
;	an array H:
;
;		OPENR, 1, FILEPATH('abnorm.dat', SUBDIR = 'images')
;		H = BYTARR(64, 64, 16)
;		READU, 1, H
;		CLOSE, 1
;		H = REBIN(H, 128, 128, 16)
;
;	Create an instance of the animation widget at load the frames:
;
;		base = widget_base()
;		animate = CW_ANIMATE(base, 128, 128, 16)
;		WIDGET_CONTROL, /REALIZE, base
;		for i=0,15 do CW_ANIMATE_LOAD, animate, FRAME=i, IMAGE=H(*,*,I)
;
;	Start the animation:
;
;		CW_ANIMATE_RUN, animate
;		XMANAGER, "CW_ANIMATE Demo", base, EVENT_HANDLER = "EHANDLER"
;
;	Pressing the DONE button kills the application.
;
; MODIFICATION HISTORY:
;	AB, June 1992		Heavily based on the XINTERANIMATE procedure.
;	SR, September 1992	Fixed a problem when a paused animation's
;				frame selection was moved and the resulting
;				frame change ended up in another animation.
;	SR, November  1992	Fixed a problem when a single paused animation
;				would fail when the frame selection slider
;				event tried to set do a bad drawing window.
;	DMS/AB, March, 1993	Got rid of state caching. Got rid of
;				XMANAGER background tasks in favor of new
;				"WIDGET_CONTROL,timer=" feature.
;	ACY, October 1993	Set RETAIN=2 for draw widget to prevent
;				clipping by an overlapping window when
;				loading frames.
;       DMS, Dec, 1993          Added STOP and NFRAMES keywords to CW_ANIMATE_RUN.
;                               Added KILL_ANYWAY keyword to CW_ANIMATE_GETP.
;       WSO, Jan, 1995          Added OPEN_FUNC keyword and updated UI.
;-

PRO SetBitmapButtons, state

  COMMON BitmapButtons, $
             reversebutton, blk_reversebutton, $
             pausebutton, blk_pausebutton, $
             playbutton, blk_playbutton, $
             cycleForwardBtn, blk_cycleForwardBtn

  WIDGET_CONTROL, state.currentAction, SET_VALUE = state.currentBitmap

  IF state.framedelta EQ 0 THEN BEGIN  ; paused
     WIDGET_CONTROL, state.wPauseButton, SET_VALUE = blk_pausebutton
     state.currentAction = state.wPauseButton
     state.currentBitmap = pausebutton
  ENDIF ELSE BEGIN
     IF state.framedelta GT 0 THEN BEGIN  ; animating forward
        IF state.cycle THEN BEGIN
           WIDGET_CONTROL, state.wCyclePlayButton, SET_VALUE = blk_cycleForwardBtn
           state.currentAction = state.wCyclePlayButton
           state.currentBitmap = cycleForwardBtn
        ENDIF ELSE BEGIN
           WIDGET_CONTROL, state.wPlayButton, SET_VALUE = blk_playbutton
           state.currentAction = state.wPlayButton
           state.currentBitmap = playbutton
        ENDELSE
     ENDIF ELSE BEGIN                       ; animating backwards
        WIDGET_CONTROL, state.wReversePlayButton, SET_VALUE = blk_reversebutton
        state.currentAction = state.wReversePlayButton
        state.currentBitmap = reversebutton
     ENDELSE
  ENDELSE
END


PRO CW_ANIMATE_CLN, widget
; When the widget dies, clean up here. Widget is the ID of the
; *child* actually holding the state in its UVALUE.

     ; kills state stored in widget
   WIDGET_CONTROL, widget, GET_UVALUE = state, /NO_COPY

   IF (N_ELEMENTS(state) GT 0) THEN BEGIN
      IF (state.dont_kill_pixmaps EQ 0) THEN BEGIN
         HANDLE_VALUE, state.pwinHdl, pwin
         FOR i=0, N_ELEMENTS(pwin)-1 DO BEGIN
            IF (pwin(i) GE 0) THEN $
               WDELETE, pwin(i)
         ENDFOR
         HANDLE_FREE, state.pwinHdl
      ENDIF
        ; Restore the state
      WIDGET_CONTROL, widget, SET_UVALUE = state, /NO_COPY
   ENDIF
END





FUNCTION CW_ANIMATE_EV, event

     ; Retrieve the structure from the child that contains the sub ids
   wAnimateBase = event.handler
   wTopBase = WIDGET_INFO(wAnimateBase, /CHILD)
    ;This kills the old uvalue
   WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY
   ret = 0

   CASE event.id OF
      wAnimateBase: $
         IF (state.framedelta NE 0) THEN BEGIN            ; Animation
            WIDGET_CONTROL, wAnimateBase, TIMER=state.delay
            curframe = state.curframe
            nframes = state.nframes

            curframe = curframe + state.framedelta            ; New frame

            r = 0.0
            IF state.cycle THEN BEGIN
               IF curframe LT 0 THEN BEGIN
                  state.framedelta = 1
                  curframe = 0
                  t = systime(1)
                  r = 2 * nframes / float(t-state.loop_start_t)
               ENDIF
               IF curframe GE nframes THEN BEGIN
                  state.framedelta = -1
                  curframe = nframes-1
               ENDIF
            ENDIF ELSE BEGIN
               WHILE curframe LT 0 DO $
                  curframe = curframe + nframes ; Into range
               WHILE curframe GE nframes DO $
                  curframe = curframe - nframes
               IF curframe EQ 0 THEN BEGIN                  ; Display rate?
                  t = systime(1)
                  r = nframes / FLOAT(t-state.loop_start_t)  ; Rate in Frames/Sec
               ENDIF
            ENDELSE

            state.curframe = curframe
            IF r NE 0.0 THEN BEGIN            ;Update time?
               WIDGET_CONTROL, state.wFramesPerSecValue, SET_VALUE = $
                  STRING(r, FORMAT='(f6.1)')
               state.loop_start_t = t
            ENDIF
            WSET, state.draw_win                  ;Set to the drawing window
            HANDLE_VALUE, state.pwinHdl, pwin, /NO_COPY
            IF pwin(curframe) GE 0 THEN $            ;Next frame
               DEVICE, COPY =[0, 0, state.sizex, state.sizey, 0, 0, pwin(curframe)]
            IF state.track THEN $
               WIDGET_CONTROL, state.wFramesIndicatorSlider, SET_VALUE = curframe
            HANDLE_VALUE, state.pwinHdl, pwin, /SET, /NO_COPY
            EMPTY
         ENDIF

      state.wFramesSpeedSlider : BEGIN            ;New rate
         WIDGET_CONTROL, state.wFramesSpeedSlider, GET_VALUE = temp
         IF temp EQ 100 THEN $
            state.delay=0. $
         ELSE $
            state.delay= 2./(1.+temp)
         END

      state.wFramesIndicatorSlider : BEGIN
         WIDGET_CONTROL, state.wFramesIndicatorSlider, GET_VALUE = temp
         IF (temp NE state.curframe) THEN BEGIN
            WSET, state.draw_win
            state.curframe = temp
            HANDLE_VALUE, state.pwinHdl, pwin, /NO_COPY
            IF (pwin(temp) GE 0) THEN $
               DEVICE, COPY = [0, 0, state.sizex, state.sizey, 0, 0, pwin(temp)]
            HANDLE_VALUE, state.pwinHdl, pwin, /SET, /NO_COPY
            EMPTY
         ENDIF
         END

      state.wPauseButton : $
         IF (state.framedelta NE 0) THEN BEGIN
            WIDGET_CONTROL, state.wFramesIndicatorSlider, SET_VALUE = state.curframe
            WIDGET_CONTROL, state.wFramesIndicatorSlider, SENSITIVE = 1
            WIDGET_CONTROL, state.wFramesPerSecValue, SET_VALUE = $
                  STRING(0.0, FORMAT='(f6.1)')
            state.framedelta = 0
            SetBitmapButtons, state
         ENDIF

      state.wPlayButton : BEGIN
         WIDGET_CONTROL, state.wFramesIndicatorSlider, SENSITIVE = 0
         WIDGET_CONTROL, state.wFramesSpeedSlider, SENSITIVE = 1
         IF (state.framedelta EQ 0) THEN $
            WIDGET_CONTROL, wAnimateBase, TIMER=state.delay
         state.framedelta = 1
         state.cycle = 0
         SetBitmapButtons, state
         END

      state.wReversePlayButton : BEGIN
         WIDGET_CONTROL, state.wFramesIndicatorSlider, SENSITIVE = 0
         WIDGET_CONTROL, state.wFramesSpeedSlider, SENSITIVE = 1
         IF (state.framedelta EQ 0) THEN $
            WIDGET_CONTROL, wAnimateBase, TIMER=state.delay
         state.framedelta = -1
         state.cycle = 0
         SetBitmapButtons, state
         END

      state.wCyclePlayButton : BEGIN
         WIDGET_CONTROL, state.wFramesIndicatorSlider, SENSITIVE = 0
         WIDGET_CONTROL, state.wFramesSpeedSlider, SENSITIVE = 1
         IF (state.framedelta EQ 0) THEN $
            WIDGET_CONTROL, wAnimateBase, TIMER=state.delay
         state.framedelta = 1
         state.cycle = 1
         SetBitmapButtons, state
         END

      state.wActiveSliderCheck: BEGIN
         state.track = event.select
         END

      state.wHelpButton : $
         XDISPLAYFILE, "animatedemo.hlp", TITLE = "Animation Help", $
            GROUP = event.top, WIDTH = 55, HEIGHT = 16, $
            TEXT = [ $
               "                                                       ", $
               "      The animation widget is used for displaying", $
               "a series of images created with IDL as an animation.  The", $
               "user can select the speed, direction or specific frames in", $
               "the animation.", $
               "      The top slider is used to control the speed of", $
               "the animation.  Moving it to the far right is one hundred", $
               "percent, as fast as the animation can go.  If there are", $
               "other IDL widget applications using background tasks,", $
               "they can slow down the animation.  Closing the other", $
               "applications can speed up the animation.", $
               "      The four bitmap buttons are reverse play, pause, ", $
               "forward play and cycle.  Use them to select a direction or to", $
               "pause the animation and view specific framestate.", $
               "      The bottom slider is used to view single frames", $
               "from the animation.  The animation must be paused to ", $
               "use the frame selection slider."   ]

      state.wColorsButton : $
         XLOADCT, GROUP = event.top

      state.wOpenButton : BEGIN
           ; get a copy before the structure is killed
         open_func = state.open_func
         framedelta = state.framedelta
         wFramesSpeedSlider = state.wFramesSpeedSlider
           ; Need to restore state since the following routines use it
         WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY
         CW_ANIMATE_RUN, wAnimateBase, /STOP
           ; Disable all controls until all frames are loaded
         WIDGET_CONTROL, wAnimateBase, SENSITIVE = 0
         fileOK = CALL_FUNCTION(open_func, event.top, wAnimateBase)

         IF fileOK THEN BEGIN
            WIDGET_CONTROL, wFramesSpeedSlider, GET_VALUE = rate
            IF framedelta EQ 0 THEN $
               framedelta = 1
            CW_ANIMATE_RUN, wAnimateBase, rate, DELTA=framedelta, /LASTFRAME
         ENDIF ELSE $
              ; Disable all controls until all frames are loaded
            WIDGET_CONTROL, wAnimateBase, SENSITIVE = 1


           ; Need structure back - This kills the old uvalue
         WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY
         END

      state.wEndAnimationButton: $
         ret = {ID:wAnimateBase, TOP:event.top, HANDLER:0L, action:"DONE" }

      ELSE:
      ENDCASE

   WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY   ; Restore the state
   RETURN, ret

END





pro CW_ANIMATE_LOAD, widget, IMAGE = image, FRAME = frame, ORDER = order, $
      WINDOW = window, XOFFSET = xoffset, YOFFSET = yoffset, $
      TRACK = track, CYCLE = cycle


   wTopBase = WIDGET_INFO(widget, /CHILD)
   WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY
   HANDLE_VALUE, state.pwinHdl, pwin, /NO_COPY

   old_window = !D.WINDOW

   displayload = WIDGET_INFO(widget, /REALIZED)
   IF (displayload NE 0) THEN BEGIN
      WIDGET_CONTROL, GET_VALUE=temp, state.wImageArea
      state.draw_win = temp
      WSET, state.draw_win
      ; In case the draw widget size is different than that requested.
      state.sizex = !D.X_VSIZE
      state.sizey = !D.Y_VSIZE
   ENDIF

   ; Default values and range checking
   IF (N_ELEMENTS(yoffset) EQ 0) THEN $
      yoffset = 0
   IF (N_ELEMENTS(xoffset) EQ 0) THEN $
      xoffset = 0
   IF (N_ELEMENTS(frame)) GT 0 THEN BEGIN
      IF (frame LT 0) OR (frame GE N_ELEMENTS(pwin)) THEN $
         MESSAGE, "Frame number must be from 0 to nframes -1."
   ENDIF ELSE $
      frame=0


   j = N_ELEMENTS(window)            ;check to see if WINDOW was set

   IF (j GT 0) THEN BEGIN            ;Copy image from window?
      IF (j LT 5) THEN BEGIN            ;If coords not spec, use all
         WSET, window(0)
         p = [ window(0), 0, 0, !D.X_VSIZE, !D.Y_VSIZE ]  ;Get size of window
      ENDIF ELSE $
         p = window

      IF pwin(frame) LT 0 THEN BEGIN            ;Create pixwin?
         WINDOW, /FREE, XSIZE = state.sizex, YSIZE = state.sizey, /PIXMAP
         pwin(frame) = !D.WINDOW
      ENDIF

      IF (p(3) GT state.sizex) OR (p(4) GT state.sizey) THEN $
         MESSAGE, "Window parameter larger than setup"

      IF displayload THEN BEGIN            ;Load display window
         WSET, state.draw_win                        ;Show it?
         IF state.draw_win NE p(0) THEN $            ;Copy to show window?
            DEVICE, COPY = [ p(1), p(2), p(3), p(4), xoffset, yoffset, p(0)]
         WSET, pwin(frame)                  ;Pixmap destination
            ;Copy from display window to pixmap
         DEVICE, COPY = [ xoffset, yoffset, p(3), p(4), xoffset, yoffset, $
            state.draw_win ]
      ENDIF ELSE BEGIN                  ;load / no show
         WSET, pwin(frame)
         DEVICE, COPY = [ p(1), p(2), p(3), p(4), xoffset, yoffset, p(0)]
      ENDELSE

      EMPTY
      IF (N_ELEMENTS(state.draw_win) EQ 0) THEN $
         state.draw_win = -1

      IF (old_window GE 0) THEN $
         WSET, old_window

       ; When displayload is set, the frame slider should update to show frame num
      IF displayload THEN $
         WIDGET_CONTROL, state.wFramesIndicatorSlider, SET_VALUE = frame
      GOTO, Done
   ENDIF                                    ;So WINDOW was not set.

   IF N_ELEMENTS(image) NE 0  THEN BEGIN            ;Make sure image was set.

       ; When displayload is set, the draw widget should be updated
       ; to show the new frame being loaded and the frame slider
       ; should be set correspondingly
      IF (displayload NE 0) THEN BEGIN
         WIDGET_CONTROL, state.wFramesIndicatorSlider, SET_VALUE = frame
         WSET, state.draw_win
         TV, image
         EMPTY
      ENDIF

       ;Make sure the image is of a valid size and report if not.
      sz = SIZE(image)
      IF ((sz(0) NE 2) OR (sz(1) GT state.sizex) OR (sz(2) GT state.sizey)) THEN $
         MESSAGE, "Image parameter must be 2D of size" + $
                  STRING(state.sizex)+ STRING(state.sizey)

      IF N_ELEMENTS(order) EQ 0 THEN $
         ORDER = 0        ;Default order
      IF pwin(frame) LT 0 THEN BEGIN
         WINDOW, /FREE, xsize = state.sizex, ysize = state.sizey, /pixmap
         pwin(frame) = !D.WINDOW
      ENDIF ELSE $
         WSET, pwin(frame)
      TV, image, xoffset, yoffset, ORDER = order
      EMPTY
      IF (old_window GE 0) THEN $
         WSET, old_window
      GOTO, Done
   ENDIF                                    ;End of "if IMAGE was set".

  Done: HANDLE_VALUE, state.pwinHdl, pwin, /SET, /NO_COPY

   WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY  ;Restore uvalue

END ;CW_ANIMATE_LOAD




pro CW_ANIMATE_RUN, widget, rate, STOP = stop, NFRAMES = nframes, $
                       DELTA = delta, LASTFRAME=lastFrame

   wTopBase = WIDGET_INFO(widget, /CHILD)
   WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY

   old_window = !D.WINDOW                        ;Save old window

   ; Refuse to run if the cluster isn't realized.
   IF (WIDGET_INFO(widget, /REALIZED) EQ 0) THEN $
      MESSAGE,'Animation widget must be realized before it can run'

   IF KEYWORD_SET(stop) THEN BEGIN           ;Stop the animation
      state.framedelta = 0                ;This shows we've stopped.
      WIDGET_CONTROL, state.wFramesIndicatorSlider, SET_VALUE = state.curframe
      WIDGET_CONTROL, state.wFramesIndicatorSlider, SENSITIVE = 1
      SetBitmapButtons, state
      GOTO, done
   ENDIF

   ; It is realized now, so get the draw widget window ID.
   WIDGET_CONTROL, GET_VALUE=temp, state.wImageArea
   state.draw_win = temp
   WSET, temp
   EMPTY

   WIDGET_CONTROL, widget, /SENSITIVE
   WIDGET_CONTROL, state.wFramesIndicatorSlider, SENSITIVE = 0
   IF N_ELEMENTS(nframes) GT 0 THEN BEGIN        ;Nframes spec?
      HANDLE_VALUE, state.pwinHdl, pwin, /NO_COPY
      IF nframes GT N_ELEMENTS(pwin) THEN $
         MESSAGE, 'Run called with too many frames'
      HANDLE_VALUE, state.pwinHdl, pwin, /SET, /NO_COPY
      state.nframes = nframes
   ENDIF


   ;Set up the initial values used by the background task
   IF N_ELEMENTS(lastFrame) NE 0 THEN $
      state.curframe = state.nframes $
   ELSE $
      state.curframe = 0

   IF N_ELEMENTS(delta) NE 0 THEN $
      state.framedelta = -1 > delta < 1 $           ; In range?
   ELSE $
      state.framedelta = 1

   IF N_ELEMENTS(rate) NE 0 THEN BEGIN
      rate = 0 > rate < 100            ; In range?
      WIDGET_CONTROL, state.wFramesSpeedSlider, SET_VALUE = rate
   ENDIF ELSE $
      rate = 100

   IF rate EQ 100 THEN $
      state.delay=0.0 $
   ELSE $
      state.delay = 2./(1.+rate)

   SetBitmapButtons, state

   state.loop_start_t = SYSTIME(1)            ;Start of loop time
   WIDGET_CONTROL, widget, TIMER=state.delay, EVENT_FUNC = 'CW_ANIMATE_EV'
 done:
   WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY      ;Rewrite state
END


pro CW_ANIMATE_GETP, widget, PIXMAPS, KILL_ANYWAY = kill_anyway
; Return the vector of pixmap ID's associated with the animation
; widget in named variable PIXMAPSTATE. Frames without a pixmap contain a -1.
; This routine should not be called until all the frames are loaded, or the
; vector will not be complete. It should be called before the call to
; CW_ANIMATE_RUN.
;
; Note: Normally, the animation widget destroys its pixmaps when it
;      is destroyed. If this routine is called however, the pixmaps
;      are not destroyed. Cleanup becomes the responsibility of the
;      caller.
   wTopBase = WIDGET_INFO(widget, /CHILD)
   WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY
   HANDLE_VALUE, state.pwinHdl, pwin, /NO_COPY
   pixmaps = pwin
   HANDLE_VALUE, state.pwinHdl, pwin, /SET, /NO_COPY
   IF KEYWORD_SET(kill_anyway) EQ 0 THEN $
      state.dont_kill_pixmaps = 1
   WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY
END


PRO CW_ANIMATE_INIT, wAnimateBase, sizex, sizey, nframes, PIXMAPS=old_pixmaps

   ON_ERROR, 2                                    ;return to caller

   wTopBase = WIDGET_INFO(wAnimateBase, /CHILD)
   WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY

   nparams = N_PARAMS()
   IF (nparams LT 3) OR (nparams GT 4) THEN $
      MESSAGE, 'Incorrect number of arguments'
   IF NOT (KEYWORD_SET(uval)) THEN $
      uval = 0

   n = N_ELEMENTS(old_pixmaps)
   IF (n GT 0) THEN BEGIN
      nframes = n
      pwin = old_pixmaps
   ENDIF ELSE $
      pwin = REPLICATE(-1, nframes)            ;Array of window indices

   IF (nframes LE 1) THEN $
      MESSAGE, "Animations must have 2 or more frames"

       ; save the number of frames to animate in the animation structure
   state.nframes = nframes
       ; save the Pixmap array to animate in the animation structure
   IF HANDLE_INFO(state.pwinHdl) THEN BEGIN
       ; Need to temporarily restore state since the following routine uses it
      WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY
      CW_ANIMATE_CLN, wTopBase
       ; Need structure back - This kills the widget uvalue
      WIDGET_CONTROL, wTopBase, GET_UVALUE = state, /NO_COPY
   ENDIF

   state.pwinHdl = HANDLE_CREATE()
   HANDLE_VALUE, state.pwinHdl, pwin, /SET, /NO_COPY

   WIDGET_CONTROL, state.wFramesIndicatorSlider, SET_SLIDER_MAX = nframes - 1

   IF state.wImageArea NE 0 THEN BEGIN
        ; to avoid flash - only set the size if it changes
      IF (state.sizex NE sizex OR state.sizey NE sizey) THEN $
         WIDGET_CONTROL, state.wImageArea, XSIZE =sizex, YSIZE=sizey
   ENDIF ELSE BEGIN
      wImageBase = WIDGET_BASE(wTopBase, /COLUMN)      ;To prevent stretching
      state.wImageArea = WIDGET_DRAW(wImageBase, XSIZE =sizex, YSIZE=sizey, $
                         XOFFSET = 280, YOFFSET = 20, RETAIN = 2)
   ENDELSE

       ; save the x dimensions of draw widget in the animation structure
   state.sizex = sizex
       ; save the y dimensions of draw widget in the animation structure
   state.sizey = sizey

       ; Disable all controls until all frames are loaded
   WIDGET_CONTROL, wAnimateBase, SENSITIVE = 0

   WIDGET_CONTROL, wTopBase, SET_UVALUE = state, /NO_COPY

END


; Setup the play reverse, pause, play forward and cycle pushbutton bitmaps. These
; variables reside in the "BitmapButtons" common block.
; Both a depressed (blk_) and a not-depressed version are needed for each button.
PRO InitBitmapButtons

  COMMON BitmapButtons

   reversebutton = [[000B, 000B, 000B], [000B, 032B, 000B], [000B, 048B, 000B],$
		[000B, 056B, 000B], [000B, 060B, 000B], [000B, 046B, 000B], $
		[000B, 231B, 015B], [144B, 003B, 024B], [016B, 231B, 027B], $
		[080B, 238B, 027B], [208B, 060B, 026B], [208B, 056B, 026B], $
		[208B, 048B, 026B], [208B, 032B, 026B], [208B, 000B, 026B], $
		[208B, 000B, 026B], [208B, 255B, 027B], [016B, 000B, 024B], $
		[240B, 255B, 031B], [224B, 255B, 015B], [000B, 000B, 000B], $
		[000B, 000B, 000B], [000B, 000B, 000B], [000B, 000B, 000B] ]
   blk_reversebutton = [[255B, 255B, 255B], [255B, 223B, 255B],[255B, 207B, 255B],$
		[255B, 199B, 255B], [255B, 195B, 255B], [255B, 209B, 255B], $
		[255B, 024B, 240B], [111B, 252B, 231B], [239B, 024B, 228B], $
		[175B, 017B, 228B], [047B, 195B, 229B], [047B, 199B, 229B], $
		[047B, 207B, 229B], [047B, 223B, 229B], [047B, 255B, 229B], $
		[047B, 255B, 229B], [047B, 000B, 228B], [239B, 255B, 231B], $
		[015B, 000B, 224B], [031B, 000B, 240B], [255B, 255B, 255B], $
		[255B, 255B, 255B], [255B, 255B, 255B], [255B, 255B, 255B] ]
   pausebutton = [[000B, 000B, 000B], [000B, 000B, 000B], [000B, 000B, 000B], $
		[192B, 195B, 003B], [192B, 194B, 002B], [192B, 194B, 002B], $
		[192B, 194B, 002B], [192B, 194B, 002B], [192B, 194B, 002B], $
		[192B, 194B, 002B], [192B, 194B, 002B], [192B, 194B, 002B], $
		[192B, 194B, 002B], [192B, 194B, 002B], [192B, 194B, 002B], $
		[192B, 194B, 002B], [192B, 194B, 002B], [192B, 194B, 002B], $
		[192B, 194B, 002B], [192B, 195B, 003B], [192B, 195B, 003B], $
		[000B, 000B, 000B], [000B, 000B, 000B], [000B, 000B, 000B] ]
   blk_pausebutton = [[255B, 255B, 255B], [255B, 255B, 255B], [255B, 255B, 255B],$
		[063B, 060B, 252B], [063B, 061B, 253B], [063B, 061B, 253B], $
		[063B, 061B, 253B], [063B, 061B, 253B], [063B, 061B, 253B], $
		[063B, 061B, 253B], [063B, 061B, 253B], [063B, 061B, 253B], $
		[063B, 061B, 253B], [063B, 061B, 253B], [063B, 061B, 253B], $
		[063B, 061B, 253B], [063B, 061B, 253B], [063B, 061B, 253B], $
		[063B, 061B, 253B], [063B, 060B, 252B], [063B, 060B, 252B], $
		[255B, 255B, 255B], [255B, 255B, 255B], [255B, 255B, 255B] ]
   playbutton = [[000B, 000B, 000B], [000B, 004B, 000B], [000B, 012B, 000B], $
		[000B, 028B, 000B], [000B, 060B, 000B], [000B, 116B, 000B], $
		[240B, 231B, 000B], [024B, 192B, 009B], [216B, 231B, 008B], $
		[216B, 119B, 010B], [088B, 060B, 011B], [088B, 028B, 011B], $
		[088B, 012B, 011B], [088B, 004B, 011B], [088B, 000B, 011B], $
		[088B, 000B, 011B], [216B, 255B, 011B], [024B, 000B, 008B], $
		[248B, 255B, 015B], [240B, 255B, 007B], [000B, 000B, 000B], $
		[000B, 000B, 000B], [000B, 000B, 000B], [000B, 000B, 000B] ]
   blk_playbutton = [[255B, 255B, 255B], [255B, 251B, 255B], [255B, 243B, 255B],$
		[255B, 227B, 255B], [255B, 195B, 255B], [255B, 139B, 255B], $
		[015B, 024B, 255B], [231B, 063B, 246B], [039B, 024B, 247B], $
		[039B, 136B, 245B], [167B, 195B, 244B], [167B, 227B, 244B], $
		[167B, 243B, 244B], [167B, 251B, 244B], [167B, 255B, 244B], $
		[167B, 255B, 244B], [039B, 000B, 244B], [231B, 255B, 247B], $
		[007B, 000B, 240B], [015B, 000B, 248B], [255B, 255B, 255B], $
		[255B, 255B, 255B], [255B, 255B, 255B], [255B, 255B, 255B] ]
  cycleForwardBtn = [[000B, 000B, 000B], [000B, 000B, 000B], [000B, 128B, 000B], $
		[000B, 128B, 001B], [000B, 128B, 003B], [248B, 255B, 006B], $
		[008B, 000B, 012B], [008B, 000B, 024B], [248B, 255B, 012B], $
		[248B, 255B, 006B], [000B, 128B, 003B], [000B, 129B, 001B], $
		[128B, 129B, 000B], [192B, 001B, 000B], [096B, 255B, 015B], $
		[048B, 000B, 008B], [024B, 000B, 008B], [048B, 255B, 015B], $
		[096B, 255B, 015B], [192B, 001B, 000B], [128B, 001B, 000B], $
		[000B, 001B, 000B], [000B, 000B, 000B], [000B, 000B, 000B] ]
   blk_cycleForwardBtn = [[255B, 255B, 255B], [255B, 255B, 255B], [255B, 127B, 255B], $
		[255B, 127B, 254B], [255B, 127B, 252B], [007B, 000B, 249B], $
		[247B, 255B, 243B], [247B, 255B, 231B], [007B, 000B, 243B], $
		[007B, 000B, 249B], [255B, 127B, 252B], [255B, 126B, 254B], $
		[127B, 126B, 255B], [063B, 254B, 255B], [159B, 000B, 240B], $
		[207B, 255B, 247B], [231B, 255B, 247B], [207B, 000B, 240B], $
		[159B, 000B, 240B], [063B, 254B, 255B], [127B, 254B, 255B], $
		[255B, 254B, 255B], [255B, 255B, 255B], [255B, 255B, 255B] ]
END


function CW_ANIMATE, parent, sizex, sizey, nframes, UVALUE=uval, $
    PIXMAPS=old_pixmaps, TRACK = track, CYCLE=cycle, DRAW = draw, $
    NO_KILL = no_kill, OPEN_FUNC=open_func

  COMMON BitmapButtons

   ON_ERROR, 2                                    ;return to caller

      ; Set the bitmaps for the bitmap buttons
   InitBitmapButtons

   nparams = N_PARAMS()
   IF (nparams LT 3) OR (nparams GT 4) THEN $
      MESSAGE, 'Incorrect number of arguments'
   IF NOT (KEYWORD_SET(uval))  THEN $
      uval = 0
   IF NOT (KEYWORD_SET(open_func)) THEN $
      open_func = 0

   wAnimateBase = WIDGET_BASE(parent, /COLUMN)
   wTopBase = WIDGET_BASE(wAnimateBase, /ROW)
   wControlBase = WIDGET_BASE(wTopBase, /COLUMN, /FRAME, XPAD=10, YPAD=10, SPACE=20)
   wVCRButtonBase = WIDGET_BASE(wControlBase, /ROW)
   wReversePlayButton = WIDGET_BUTTON(wVCRButtonBase, VALUE = reversebutton)
   wPauseButton = WIDGET_BUTTON(wVCRButtonBase, VALUE = blk_pausebutton)
   wPlayButton = WIDGET_BUTTON(wVCRButtonBase, VALUE = playbutton)
   wCyclePlayButton = WIDGET_BUTTON(wVCRButtonBase, VALUE = cycleForwardBtn)
   currentAction = wPauseButton
   currentBitmap = pausebutton

   wSpeedBase = WIDGET_BASE(wControlBase, /COLUMN)
   wSpeedBaseLabel = WIDGET_LABEL(wSpeedBase, VALUE = "Animation Speed:", /ALIGN_LEFT)
   wFramesSpeedBase = WIDGET_BASE(wSpeedBase, TITLE = "Animation Speed", /COLUMN, /FRAME)
   wFramesPerSecBase = WIDGET_BASE(wFramesSpeedBase, /ROW)
   wFramesPerSecLabel = WIDGET_LABEL(wFramesPerSecBase, VALUE = "Frames/Sec:")
   wFramesPerSecValue = WIDGET_LABEL(wFramesPerSecBase, VALUE = '0.000')
   wFramesSpeedSlider = WIDGET_SLIDER(wFramesSpeedBase, /DRAG, VALUE = 100, $
             MAXIMUM = 100, MINIMUM = 0, /SUPPRESS_VALUE)

   wFrameBase = WIDGET_BASE(wControlBase, /COLUMN)
   wFrameBaseLabel = WIDGET_LABEL(wFrameBase, VALUE = "Animation Frame:", /ALIGN_LEFT)
   wFrameIndicatorBase = WIDGET_BASE(wFrameBase, TITLE = "Animation Frame", /COLUMN, /FRAME)
   wFramesIndicatorSlider = WIDGET_SLIDER(wFrameIndicatorBase, /DRAG, VALUE = 0, $
             MAXIMUM = nframes - 1, MINIMUM = 0)
   wActiveSliderCheck = CW_BGROUP(wFrameIndicatorBase, ['Active Slider'], $
           FRAME = 0, /NONEXCLUSIVE, /RETURN_INDEX, $
           SET_VALUE=KEYWORD_SET(track))

   wButtonBase = WIDGET_BASE(wAnimateBase, /ROW, /ALIGN_LEFT)
   IF KEYWORD_SET(no_kill) THEN $
      wEndAnimationButton = 0L $
   ELSE $
      wEndAnimationButton = WIDGET_BUTTON(wButtonBase, VALUE='End Animation')
   wColorsButton = WIDGET_BUTTON(wButtonBase, VALUE='Colors...')
   IF (KEYWORD_SET(open_func)) THEN $
      wOpenButton = WIDGET_BUTTON(wButtonBase, VALUE='Open...') $
   ELSE $
      wOpenButton = 0
   wHelpButton = WIDGET_BUTTON(wButtonBase, VALUE='Help')

   IF N_ELEMENTS(draw) EQ 1 THEN $
      wImageArea = draw $
   ELSE $
      wImageArea = 0

   ; Set the event handler function. This cluster does not get or set a value
   ; Make sure it lingers so the cleanup routine can get at its state.
   WIDGET_CONTROL, wAnimateBase, SET_UVALUE = uval, EVENT_FUNC = 'CW_ANIMATE_EV', $
       /DELAY_DESTROY

   ;pwin = REPLICATE(-1, nframes)            ;Array of window indices

   ; This structure gets stuffed into the uval. of the first child
   ; of wAnimateBase
   WIDGET_CONTROL, wTopBase, SET_UVALUE = $
      { wEndAnimationButton: wEndAnimationButton, $      ; End button
        wColorsButton: wColorsButton, $                  ; Adjust color palette button
        wOpenButton: wOpenButton, $                       ; Open file button
        open_func: open_func, $                          ; Open file function
        wHelpButton: wHelpButton, $                      ; Help button
        wActiveSliderCheck: wActiveSliderCheck, $        ; button group widget
        wFramesSpeedSlider: wFramesSpeedSlider, $        ; Speed selection slider
        wReversePlayButton: wReversePlayButton, $        ; Reverse button
        wPauseButton: wPauseButton, $                    ; Stop (pause) button
        wPlayButton: wPlayButton, $                      ; Forward button
        wCyclePlayButton: wCyclePlayButton, $            ; Cycle forward button
        currentAction : currentAction, $                 ; current action button id
        currentBitmap : currentBitmap, $                 ; current button bitmap
        wFramesIndicatorSlider: wFramesIndicatorSlider, $; Frame selection slider
        wFramesPerSecValue: wFramesPerSecValue, $        ; Animation rate display
        wImageArea: wImageArea, $                        ; Draw widget for animation
        draw_win: -1, $                                  ; Window # of draw widget
        sizex: 0, sizey: 0, $                            ; Dimensions of draw widget
        nframes: 0, $                                    ; # of frames in animation
        curframe: 0, $
        cycle: KEYWORD_SET(cycle), $                     ; Ne 0 to cycle
        track: KEYWORD_SET(track), $                     ; Ne 0 to track with slider
        framedelta: 0, $                                 ; # frames to step.
        delay: 0.0D, $                                   ; Delay between frames
        loop_start_t: 0.0D, $                            ; System time at start
        dont_kill_pixmaps: 0, $                          ; TRUE if pixmaps preserved on kill
        pwinHdl: 0L }                                    ; handle to the Pixmap array

  ; When the child holding the state gets killed, have a cleanup
  ; procedure called to mop up
   WIDGET_CONTROL, wTopBase, KILL_NOTIFY = 'CW_ANIMATE_CLN'

   CW_ANIMATE_INIT, wAnimateBase, sizex, sizey, nframes, PIXMAPS=old_pixmaps

   RETURN, wAnimateBase

END
; $Id: cw_arcball.pro,v 1.5 1994/01/12 22:56:21 alan Exp $
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_ARCBALL
;
; PURPOSE:
;	CW_ARCBALL is a compound widget for intuitively specifying
;	three-dimensional orientations.
;
; CATEGORY:
;	Widget, 3d graphics
;
; CALLING SEQUENCE:
;	Widget_id = CW_ARCBALL(Parent)
;
; INPUTS:
;       PARENT:	The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	FRAME:	If set, draws a frame around the widget.
;		The default is FRAME=0.
;	LABEL:	A string containing the widget's label.
;	VALUE:	An initial value for the 3 x 3 rotation matrix. This
;		must be a valid rotation matrix (no translation or
;		perspective) where: transpose(value) = inverse(value).
;		This can be the upper-left corner of !P.T after executing
;		the command T3D, /RESET, ROTATE=[x,y,z]. The default
;		is the identity matrix.
;	UVALUE:	The initial user value for the widget.
;	SIZE:	The size of the square drawable area containing the arcball,
;		in pixels.  Default size = 192.	
;	UPDATE:	If set, the widget will send an event each time
;		the mouse button is released after a drag operation.
;		Otherwise, an event is only sent when the Update
;		button is pressed.
;	COLORS:	A 6-element array containing the color indices to be used.
;		  Colors(0) = View axis color
;		  Colors(1) = object axis color, 
;		  Colors(2) = XZ plane +Y side (body top) color, 
;		  Colors(3) = YZ plane (fin) color,
;		  Colors(4) = XZ plane -Y side (body bottom),
;		  Colors(5) = background color.
;		Default value = [ 1,7,2,3,7,0], which yields good colors
;		with the TEK_COLOR table.
;		  (white, yellow, red, green, yellow, black).
;	RETAIN: Retain parameter for window, 0 = none, 1 = server's default,
;		2 = use backing store.  default = 1.
;
; OUTPUTS:
;	The ID of the widget is returned.
;
; SIDE EFFECTS:
;	Events are generated as described above. The current graphics window
;	is changed.
;
; RESTRICTIONS:
;	This widget can generate any rotation about any axis.
;	Not all rotations are compatible with the IDL SURFACE
;	procedure, which is restricted to rotations that project the
;	object Z axis parallel to the view Y axis.
;
; PROCEDURE:
;	This widget is based on "ARCBALL: A User Interface for
;	Specifying Three-Dimensional Orientation Using a Mouse", by Ken
;	Shoemake, Computer Graphics Laboratory, University of Pennsylvania,
;	Philadelphia, PA 19104. "In Arcball, human factors and mathematical
;	fundamentals come together exceptionally well."
;
;	The user drags a simulated track-ball with the mouse to interactively
;	obtain arbitrary rotations. Sequences of rotations may be cascaded.
;	The rotations may be unconstrained (about any axis), constrained to
;	the view X, Y, or Z axes, or to the object's X, Y, or Z axis.
;
;	Use the call:
;		WIDGET_CONTROL, id, /SET_VALUE
;	to draw the arcball after the widget is initially realized.
;	Also, the SET_VALUE entry will set the widget's value to the
;	given 3x3 rotation matrix and redraw the widget.
;
;	The WIDGET_CONTROL, id, GET_VALUE=v
;	call returns the current 3x3 rotation matrix.
;	
; EXAMPLE:
;	See the procedure ARCBALL_TEST, contained in this file.
;	To test CW_ARCBALL:
;	.RUN cw_arcball
;	ARCBALL_TEST
;
; MODIFICATION HISTORY:
;	DMS, RSI, September, 1993.  Written
;	ACY, RSI, January, 1994.  Correct test on initial value.
;-


function arcball_constrain, pt0, axis
; Project the point pt0 onto the plane perpendicular
; to axis and passing thru the center of the sphere.

proj = pt0 - total(axis * pt0) * axis
norm = sqrt(total(proj^2))
if norm gt 0.0 then begin
    s = 1.0/norm
    if proj(2) lt 0.0 then s = -s
    pt = s * proj
endif else if axis(2) eq 1.0 then pt = [1.0, 0., 0.] $
else pt = [ -axis(1), axis(0), 0.0 ] / sqrt(total(axis(0:1)^2))
return, pt
end


function quaternion_m3, q
; Given a unit quaternion, q, return its 3x3 rotation matrix.
x = q(0)
y = q(1)
z = q(2)
w = q(3)
a = [[ w^2+x^2-y^2-z^2, 2*(x*y+w*z), 2*(x*z-w*y)], $
     [ 2*(x*y-w*z), w^2-x^2+y^2-z^2, 2*(y*z+w*x)], $
     [ 2*(x*z+w*y), 2*(y*z-w*x), w^2-x^2-y^2+z^2]]
return, a
end



PRO ARCBALL_ARC, p0, p1, cx, cy, radius, COLOR=col
; Given 2 points on the unit sphere p0(3) and p1(3), draw the great circle
; arc connecting them.  (cx, cy) = center of sphere in whatever units are
; specified via the EXTRA parameter.  Radius = radius of sphere.
;
len = acos(total(p0 * p1) < 1.0)
if len eq 0.0 then return
n = 12                  ;# of line segments
s = sin(findgen(n+1) * (len / n))  ;Sines
p = fltarr(2,n+1,/nozero)
c = [cx, cy]
for i=0, n do p(0,i) = radius * (p0 * s(n-i) + p1 * s(i))/s(n) + c
plots, p, COLOR=col, /DEVICE
end




PRO ARCBALL_AXIS_ARC, p, cx, cy, radius, COLOR=c
; Draw the half great circle, whose plane is perpendicular to p.
;
s = sqrt(1.0 - p(2)^2 > 0.0)
if s eq 0.0 then begin      ;Outline of circle
    x = [1,0,-1,0,1]
    y = [0,1,0,-1,0]
    for i=0,3 do arcball_arc, [x(i),y(i),0.0], [x(i+1), y(i+1), 0.0], $
			cx, cy, radius, COLOR=c
endif else begin
    p0 = [ -p(0)*p(2)/s, -p(1)*p(2)/s, s]
    p1 = [ p(1)/s, -p(0)/s, 0.0]
    arcball_arc, p0, p1, cx, cy, radius, COLOR=c
    arcball_arc, p0, -p1, cx, cy, radius,COLOR=c
endelse
end


PRO CW_ARCBALL_DRAW, state, DO_ARC = do_arc  ;Draw the arcball spaceship.
; If do_arc is set, draw the great circle between pt0 and pt1

if state.window eq 0 then begin   ;First call?
    WIDGET_CONTROL, state.draw_id, GET_VALUE=v
    state.window = v
    ENDIF

wset, state.window
col = state.colors
erase, col(5)
wsize = state.wsize
c = state.center
r = state.radius
plots, [0,wsize], c, /device, color=col(0)
plots, c, [0,wsize], /device, color=col(0)
plots, state.circle, /device, color=col(0)
if keyword_set(do_arc) then begin
	plots, state.pt0 * r + c, /PSYM, /DEVICE, COLOR=col(0)
	arcball_arc, state.pt0, state.pt1, c, c, r, COLOR = col(2)
	ENDIF
rot = state.cvalue

rr = .4 * r * rot 		;*** Draw the object
offset = [c, c, 0] # replicate(1,3)
t0 = rr # [[0,0,1], [-0.5,0,-1], [.5,0,-1]]   ;Main triangle
t1 = rr # [[0,0,1], [0,.5,-1], [0,0,-1.]]

q = crossp(t0(*,0) - t0(*,1), t0(*,2) - t0(*,1))  ;which one first?
;;; [1,7,2,3]
if q(2) ge 0 then begin
    polyfill, t0+offset, color=col(2), /DEVICE
    polyfill, t1+offset, color=col(3), /DEVICE
endif else begin
    polyfill, t1+offset, color=col(3), /DEVICE
    polyfill, t0+offset, color=col(4), /DEVICE
endelse


for i=0,2 do begin		;Draw each object axis
    p = fltarr(3,3,3)
    p(i) = 1.0
    p1 = rot # p
    arcball_axis_arc, p1, c, c, r, COLOR=col(1)
    endfor
end

PRO CW_ARCBALL_HELP, top
s = size(top)
if s(s(0)+1) eq 8 then begin		;Called with structure?  Quit.
	WIDGET_CONTROL, top.top, /DESTROY
	RETURN
	END

a = widget_base(/column, title='ARCBALL Help')	;Not structure.
b = WIDGET_TEXT(a, value = [ $
	'Use the mouse to drag and rotate the simulated trackball.', $
	'Rotate about the view Z axis by dragging outside the circle.', $
	' ', $
	'Use the Constraint button to constrain rotations about the', $
	'axis closest to where the mouse is first clicked.'], $
	XSIZE=72, YSIZE = 6)
b = WIDGET_BUTTON(a, VALUE='Dismiss', /NO_REL)
WIDGET_CONTROL, a, /REAL
XMANAGER, 'Arcball Help', a, $
	EVENT_HANDLER='CW_ARCBALL_HELP', /MODAL, GROUP=top
end

Function CW_ARCBALL_EVENT,  event

WIDGET_CONTROL, event.id, GET_UVALUE=child	;Widget with state
WIDGET_CONTROL, child, GET_UVALUE=state, /NO_COPY 

case event.id of
state.draw_id: BEGIN		;Draw event
    if (event.press or state.buttons or event.release) eq 0 then goto, done
    xy = ([event.x, event.y] - state.center) / state.radius
    r = total(xy^2)		;Distance from ctr
    if r gt 1.0 then pt1 = [xy/sqrt(r), 0.0] $      ;Outside circle, z = 0.
    else pt1 = [xy, sqrt(1.0-r)]
    c = state.constrain
    if event.press ne 0 then begin
	if c(0) ne 0 then begin
	    ident = [[1.,0.,0.], [0.,1.,0.],[0.,0.,1.]]
	    if c(0) eq 2 then ident = state.value # ident  ;Object axes?
	    jmax = -1000.
	    for i=0,2 do begin		;Find closest
		t = total(arcball_constrain(pt1, ident(*,i)) * pt1)
		if t gt jmax then begin jmax = t & j = i & endif
		endfor
	    state.constrain(1) = j
	    state.pt0 = arcball_constrain(pt1, ident(*,j))
	endif else state.pt0 = pt1		;Constrained...
	state.buttons = 1
    endif else if state.buttons ne 0 then begin  ;Drag event
	if c(0) ne 0 then begin
	    ident = [[1.,0.,0.], [0.,1.,0.],[0.,0.,1.]]
	    if c(0) eq 2 then ident = state.value # ident  ;Object axes?
	    pt1 = arcball_constrain(pt1, ident(*,c(1)))	
	    endif
	state.pt1 = pt1
	pt0 = state.pt0
	q = [crossp(pt0, pt1), total(pt0*pt1)]  ;Quaternion
	state.cvalue = quaternion_m3(q) # state.value
	CW_ARCBALL_DRAW, state, /DO_ARC
	ENDIF
    if event.release ne 0 then begin
	state.value = state.cvalue
	state.buttons = 0
	if state.update_id eq 0 then goto, update  ;Auto update?
	endif
    ENDCASE
state.constrain_id: state.constrain(0) = event.index
state.help_id: cw_arcball_help, event.top
state.reset_id: BEGIN
    state.value =  [[1.,0.,0.], [0.,1.,0.],[0.,0.,1.]]
    state.cvalue = state.value
    CW_ARCBALL_DRAW, state
    if state.update_id eq 0 then goto, update  ;Auto update?
    ENDCASE
state.update_id: BEGIN
  update:
    value = { id: state.base, $
	top: event.top, $
	handler: event.handler, $
	value: state.value }
    WIDGET_CONTROL, child, SET_UVALUE=state, /NO_COPY  ;Save value
    return, value
    ENDCASE
ENDCASE

done:
WIDGET_CONTROL, child, SET_UVALUE=state, /NO_COPY 
return, 0
end

FUNCTION CW_ARCBALL_GET, id	;Return current 3x3 matrix
child = WIDGET_INFO(id, /CHILD)
WIDGET_CONTROL, child, GET_UVALUE=state, /NO_COPY
value = state.value
WIDGET_CONTROL, child, SET_UVALUE=state, /NO_COPY
return, value
end

PRO CW_ARCBALL_SET, id, value
child = WIDGET_INFO(id, /CHILD)
WIDGET_CONTROL, child, GET_UVALUE=state, /NO_COPY
if n_elements(value) eq 9 then BEGIN
	state.value = value
	state.cvalue = value
	ENDIF
CW_ARCBALL_DRAW, state
WIDGET_CONTROL, child, SET_UVALUE=state, /NO_COPY
end


FUNCTION CW_ARCBALL, parent, FRAME=frame, LABEL=label, $
	VALUE=sval, UVALUE=uvalue, RETAIN=retain, $
	SIZE=xsize, UPDATE = autou, COLORS = colors
;
  if keyword_set(parent) eq 0 then $
    parent = WIDGET_BASE(title='CW_ARCBALL')

  framet = keyword_set(frame)
  base = WIDGET_BASE(parent, FUNC_GET_VALUE='CW_ARCBALL_GET', $
	PRO_SET_VALUE='CW_ARCBALL_SET', EVENT_FUN='CW_ARCBALL_EVENT')
  if n_elements(uvalue) gt 0 then WIDGET_CONTROL, base, SET_UVALUE=uvalue

  base1 = WIDGET_BASE(base, /column, FRAME=framet)
  if n_elements(label) ne 0 then $
    junk = WIDGET_LABEL(base1, value=label)

  if n_elements(xsize) eq 0 then xsize = 192
  if n_elements(retain) le 0 then retain = 1
  draw_id = widget_draw(base1, xsize = xsize, ysize=xsize, $
    /BUTTON_EVENTS, /MOTION_EVENTS, UVALUE=base1, RETAIN = retain)
  constrain_id = CW_BSELECTOR(base1, ['None', 'View Axes', 'Object Axes'], $
	LABEL_LEFT = 'Constraint:', UVALUE=base1)
  junk = WIDGET_BASE(base1, /row)
  if keyword_set(autou) eq 0 then $
      update_id = WIDGET_BUTTON(junk, VALUE='Update', /NO_REL, UVALUE=base1) $
  else update_id = 0L
  reset_id = WIDGET_BUTTON(junk, VALUE='Reset', /NO_REL, UVALUE=base1)
  help_id = WIDGET_BUTTON(junk, VALUE='Help', /NO_REL, UVALUE=base1)

  if n_elements(sval) gt 0 then begin
	s = size(sval)
	if s(0) ne 2 or s(1) ne 3 or s(2) ne 3 then $
		message, 'Value must be a 3x3 matrix.'
	err = max(abs(sval - sval # transpose(sval) # sval))  ;Valid rot mat?
	if err gt 1.0e-6 then $
		message,'Value is an invalid rotation matrix'
  endif else sval = [[1.,0.,0.], [0.,1.,0.],[0.,0.,1.]]
; Colors are 0: View axes, 1: object axes, 2: top color, 3: sail color, 
;	4: bottom color, 5: background color.
  if n_elements(colors) ne 6 then colors = [ 1,7,2,3,7,0]

	

  np = 36               ;# of points in circle
  state = { CW_ARCB_STATE, $
    base: base, $		;Main base
    draw_id: draw_id, $		;Control id's
    constrain_id: constrain_id, $
    update_id: update_id, $
    reset_id: reset_id, $
    help_id: help_id, $
    wsize: xsize, $		;Window size
    radius: xsize * .42, $	;Circle radius
    center: xsize / 2., $	;Center x & y coords
    window: 0, $		;index
    circle: fltarr(2, np), $	;XY pnts for main circle
    colors: colors, $		;fixed axes, object axes, color1, color2
    value: sval, $		;Initial Rotation matrix
    cvalue: sval, $		;Current rotation matrix
    buttons: 0L, $		;mouse buttons
    pt0: fltarr(3), $		;Beginning of drag on sphere
    pt1: fltarr(3), $		;Current drag point on sphere
    constrain: [0,0]}		;type of constraint & axis index
  x = findgen(np) * ((2 * !pi) / (np-1))
  y = state.radius * sin(x) + state.center
  x = state.radius * cos(x) + state.center
  state.circle = transpose([[x],[y]])

  WIDGET_CONTROL, base1, SET_UVALUE=state, /NO_COPY
  return, base
END


;*****************************************************************
pro arcball_event, event	;Used by ARCBALL_TEST and ARCBALL_HELP
; If a button event is sent to this procedure, its top level base
; is destroyed, otherwise the event is printed.
;
if tag_names(event, /STRUCTURE_NAME) eq 'WIDGET_BUTTON' then $
    widget_control, event.top, /DESTROY $
else print, 'Arcball:', event.value
end

PRO ARCBALL_TEST		;Simple test program.
a = WIDGET_BASE(/COLUMN, TITLE='Arcball Test')
b = CW_ARCBALL(a, LABEL='Test me', size=256, /UPDATE)
c = WIDGET_BUTTON(a, value='Done')
WIDGET_CONTROL, a, /REALIZE
tek_color
WIDGET_CONTROL, b, SET_VALUE=1	;Draw first ball
XMANAGER, 'Arcball', a		;Manage it
end
; $Id: cw_bgroup.pro,v 1.13 1995/04/11 18:12:50 ali Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_BGROUP
;
; PURPOSE:
;	CW_BGROUP is a compound widget that simplifies creating
;	a base of buttons. It handles the details of creating the
;	proper base (standard, exclusive, or non-exclusive) and filling
;	in the desired buttons. Events for the individual buttons are
;	handled transparently, and a CW_BGROUP event returned. This
;	event can return any one of the following:
;		- The Index of the button within the base.
;		- The widget ID of the button.
;		- The name of the button.
;		- An arbitrary value taken from an array of User values.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;		Widget = CW_BGROUP(Parent, Names)
;
;	To get or set the value of a CW_BGROUP, use the GET_VALUE and
;	SET_VALUE keywords to WIDGET_CONTROL. The value of a CW_BGROUP
;	is:
;
;		-----------------------------------------------
;		Type		Value
;		-----------------------------------------------
;		normal		None
;		exclusive   	Index of currently set button
;		non-exclusive	Vector indicating the position
;				of each button (1-set, 0-unset)
;		-----------------------------------------------
;
;
; INPUTS:
;       Parent:		The ID of the parent widget.
;	Names:		A string array, containing one string per button,
;			giving the name of each button.
;
; KEYWORD PARAMETERS:
;
;	BUTTON_UVALUE:	An array of user values to be associated with
;			each button and returned in the event structure.
;	COLUMN:		Buttons will be arranged in the number of columns
;			specified by this keyword.
;	EVENT_FUNCT:	The name of an optional user-supplied event function 
;			for buttons. This function is called with the return
;			value structure whenever a button is pressed, and 
;			follows the conventions for user-written event
;			functions.
;	EXCLUSIVE:	Buttons will be placed in an exclusive base, with
;			only one button allowed to be selected at a time.
;	FONT:		The name of the font to be used for the button
;			titles. If this keyword is not specified, the default
;			font is used.
;	FRAME:		Specifies the width of the frame to be drawn around
;			the base.
;	IDS:		A named variable into which the button IDs will be
;			stored, as a longword vector.
;	LABEL_LEFT:	Creates a text label to the left of the buttons.
;	LABEL_TOP:	Creates a text label above the buttons.
;	MAP:		If set, the base will be mapped when the widget
;			is realized (the default).
;	NONEXCLUSIVE:	Buttons will be placed in an non-exclusive base.
;			The buttons will be independent.
;	NO_RELEASE:	If set, button release events will not be returned.
;	RETURN_ID:	If set, the VALUE field of returned events will be
;			the widget ID of the button.
;	RETURN_INDEX:	If set, the VALUE field of returned events will be
;			the zero-based index of the button within the base.
;			THIS IS THE DEFAULT.
;	RETURN_NAME:	If set, the VALUE field of returned events will be
;			the name of the button within the base.
;	ROW:		Buttons will be arranged in the number of rows
;			specified by this keyword.
;	SCROLL:		If set, the base will include scroll bars to allow
;			viewing a large base through a smaller viewport.
;	SET_VALUE:	The initial value of the buttons. This is equivalent
;			to the later statement:
;
;			WIDGET_CONTROL, widget, set_value=value
;
;	SPACE:		The space, in pixels, to be left around the edges
;			of a row or column major base. This keyword is
;			ignored if EXCLUSIVE or NONEXCLUSIVE are specified.
;	UVALUE:		The user value to be associated with the widget.
;	XOFFSET:	The X offset of the widget relative to its parent.
;	XPAD:		The horizontal space, in pixels, between children
;			of a row or column major base. Ignored if EXCLUSIVE
;			or NONEXCLUSIVE are specified.
;	XSIZE:		The width of the base. 
;	X_SCROLL_SIZE:	The width of the viewport if SCROLL is specified.
;	YOFFSET:	The Y offset of the widget relative to its parent.
;	YPAD:		The vertical space, in pixels, between children of
;			a row or column major base. Ignored if EXCLUSIVE
;			or NONEXCLUSIVE are specified.
;	YSIZE:		The height of the base. 
;	Y_SCROLL_SIZE:	The height of the viewport if SCROLL is specified.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; SIDE EFFECTS:
;	This widget generates event structures with the following definition:
;
;		event = { ID:0L, TOP:0L, HANDLER:0L, SELECT:0, VALUE:0 }
;
;	The SELECT field is passed through from the button event. VALUE is
;	either the INDEX, ID, NAME, or BUTTON_UVALUE of the button,
;	depending on how the widget was created.
;
; RESTRICTIONS:
;	Only buttons with textual names are handled by this widget.
;	Bitmaps are not understood.
;
; MODIFICATION HISTORY:
;	15 June 1992, AB
;	7 April 1993, AB, Removed state caching.
;	6 Oct. 1994, KDB, Font keyword is not applied to the label.
;       10 FEB 1995, DJC  fixed bad bug in event procedure, getting
;                         id of stash widget.
;	11 April 1995, AB Removed Motif special cases.
;-


pro CW_BGROUP_SETV, id, value

  ON_ERROR, 2						;return to caller

  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  case state.type of
    0: message,'unable to set plain button group value'
    1: begin
	  WIDGET_CONTROL, SET_BUTTON=0, state.ids(state.excl_pos)
	  state.excl_pos = value
	  WIDGET_CONTROL, /SET_BUTTON, state.ids(value)
	end
    2: begin
	  n = n_elements(value)-1
	  for i = 0, n do begin
	    state.nonexcl_curpos(i) = value(i)
	    WIDGET_CONTROL, state.ids(i), SET_BUTTON=value(i)
	  endfor
	end
  endcase

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
end



function CW_BGROUP_GETV, id, value

  ON_ERROR, 2						;return to caller

  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  case state.type of
    0: message,'unable to get plain button group value'
    1: ret = state.excl_pos
    2: ret = state.nonexcl_curpos
  endcase

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY

  return, ret

end



function CW_BGROUP_EVENT, ev
  WIDGET_CONTROL, ev.handler, GET_UVALUE=stash
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY
  WIDGET_CONTROL, ev.id, get_uvalue=uvalue

  ret = 1			;Assume we return a struct
  case state.type of
    0:
    1: if (ev.select eq 1) then begin
	  state.excl_pos = uvalue
	ENDIF else begin
	  if (state.no_release ne 0) then ret = 0
	  if (uvalue eq state.excl_pos) then begin
	    ; Don't allow them to unset the current button
	    ret = 0
	  endif
	ENDELSE
    2: begin
	  ; Keep track of the current state
	  state.nonexcl_curpos(uvalue) = ev.select
          if (state.no_release ne 0) and (ev.select eq 0) then ret = 0
	end
  endcase

  if ret then begin		;Return a struct?
      ret = { ID:state.base, TOP:ev.top, HANDLER:0L, SELECT:ev.select, $
	       VALUE:state.ret_arr(uvalue) }
      efun = state.efun
      WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
      if efun ne '' then return, CALL_FUNCTION(efun, ret) $
      else return, ret
  endif else begin		;Trash the event
      WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
      return, 0
  endelse
end







function CW_BGROUP, parent, names, $
	BUTTON_UVALUE = button_uvalue, COLUMN=column, EVENT_FUNCT = efun, $
	EXCLUSIVE=excl, FONT=font, FRAME=frame, IDS=ids, LABEL_TOP=label_top, $
	LABEL_LEFT=label_left, MAP=map, $
	NONEXCLUSIVE=nonexcl, NO_RELEASE=no_release, RETURN_ID=return_id, $
	RETURN_INDEX=return_index, RETURN_NAME=return_name, $
	ROW=row, SCROLL=scroll, SET_VALUE=sval, SPACE=space, UVALUE=uvalue, $
	XOFFSET=xoffset, XPAD=xpad, XSIZE=xsize, X_SCROLL_SIZE=x_scroll_size,$
	YOFFSET=yoffset, YPAD=ypad, YSIZE=ysize, Y_SCROLL_SIZE=y_scroll_size


  IF (N_PARAMS() ne 2) THEN MESSAGE, 'Incorrect number of arguments'

  ON_ERROR, 2						;return to caller

  ; Set default values for the keywords
  version = WIDGET_INFO(/version)
  if (version.toolkit eq 'OLIT') then def_space_pad = 4 else def_space_pad = 3
  IF (N_ELEMENTS(column) eq 0) 		then column = 0
  IF (N_ELEMENTS(excl) eq 0) 		then excl = 0
  IF (N_ELEMENTS(frame) eq 0)		then frame = 0
  IF (N_ELEMENTS(map) eq 0)		then map=1
  IF (N_ELEMENTS(nonexcl) eq 0)		then nonexcl = 0
  IF (N_ELEMENTS(no_release) eq 0)	then no_release = 0
  IF (N_ELEMENTS(row) eq 0)		then row = 0
  IF (N_ELEMENTS(scroll) eq 0)		then scroll = 0
  IF (N_ELEMENTS(space) eq 0)		then space = def_space_pad
  IF (N_ELEMENTS(uvalue) eq 0)		then uvalue = 0
  IF (N_ELEMENTS(xoffset) eq 0)		then xoffset=0
  IF (N_ELEMENTS(xpad) eq 0)		then xpad = def_space_pad
  IF (N_ELEMENTS(xsize) eq 0)		then xsize = 0
  IF (N_ELEMENTS(x_scroll_size) eq 0)	then x_scroll_size = 0
  IF (N_ELEMENTS(yoffset) eq 0)		then yoffset=0
  IF (N_ELEMENTS(ypad) eq 0)		then ypad = def_space_pad
  IF (N_ELEMENTS(ysize) eq 0)		then ysize = 0
  IF (N_ELEMENTS(y_scroll_size) eq 0)	then y_scroll_size = 0
  



  top_base = 0L
  if (n_elements(label_top) ne 0) then begin
    next_base = WIDGET_BASE(parent, XOFFSET=xoffset, YOFFSET=yoffset, /COLUMN)
    if(keyword_set(font))then $
       junk = WIDGET_LABEL(next_base, value=label_top,font=font) $
    else    junk = WIDGET_LABEL(next_base, value=label_top)
    top_base = next_base
  endif else next_base = parent
  if (n_elements(label_left) ne 0) then begin
    next_base = WIDGET_BASE(next_base, XOFFSET=xoffset, YOFFSET=yoffset, /ROW)
    if(keyword_set(font))then $
       junk = WIDGET_LABEL(next_base, value=label_left, font=font) $
    else junk = WIDGET_LABEL(next_base, value=label_left)
    if (top_base eq 0L) then top_base = next_base
  endif
  ; We need some kind of outer base to hold the users UVALUE
  if (top_base eq 0L) then begin
    top_base = WIDGET_BASE(parent, XOFFSET=xoffset, YOFFSET=yoffset)
    next_base = top_base
  endif
  If (top_base EQ next_base) THEN $
     next_base = WIDGET_BASE(top_base, Xpad=1, Ypad=1, Space=1)

  ; Set top level base attributes
  WIDGET_CONTROL, top_base, MAP=map, $
	FUNC_GET_VALUE='CW_BGROUP_GETV', PRO_SET_VALUE='CW_BGROUP_SETV', $
	SET_UVALUE=uvalue

  ; The actual button holding base
  base = WIDGET_BASE(next_base, COLUMN=column, EXCLUSIVE=excl, FRAME=frame, $
	NONEXCLUSIVE=nonexcl, ROW=row, SCROLL=scroll, SPACE=space, $
	XPAD=xpad, XSIZE=xsize, X_SCROLL_SIZE=x_scroll_size, $
	YPAD=ypad, YSIZE=ysize, Y_SCROLL_SIZE=y_scroll_size, $
	EVENT_FUNC='CW_BGROUP_EVENT', $
	UVALUE=WIDGET_INFO(top_base, /child))


  n = n_elements(names)
  ids = lonarr(n)
  for i = 0, n-1 do begin
    if (n_elements(font) eq 0) then begin
      ids(i) = WIDGET_BUTTON(base, value=names(i), UVALUE=i)
    endif else begin
      ids(i) = WIDGET_BUTTON(base, value=names(i), FONT=font, UVALUE=i)
    endelse
  endfor

  ; Keep the state info in the real (inner) base UVALUE.
  ; Pick an event value type:
  ;	0 - Return ID
  ;	1 - Return INDEX
  ;	2 - Return NAME
  ret_type = 1
  if KEYWORD_SET(RETURN_ID) then ret_type = 0
  if KEYWORD_SET(RETURN_NAME) then ret_type = 2
  if KEYWORD_SET(BUTTON_UVALUE) then ret_type = 3
    case ret_type of
      0: ret_arr = ids
      1: ret_arr = indgen(n)
      2: ret_arr = names
      3: ret_arr = button_uvalue
    endcase
  type = 0
  if (excl ne 0) then type = 1

  if (nonexcl ne 0) then type = 2
  if n_elements(efun) le 0 then efun = ''
  state = { type:type, $	; 0-Standard, 1-Exclusive, 2-Non-exclusive
	    base: top_base, $	; cw_bgroup base...
	    ret_arr:ret_arr, $	; Vector of event values
	    efun : efun, $	; Name of event fcn
	    nonexcl_curpos:intarr(n), $	; If non-exclus, tracks state
	    excl_pos:0, $			; If exclusive, current button
	    ids:ids, $			; Ids of buttons
	    no_release:no_release }
  WIDGET_CONTROL, WIDGET_INFO(top_base, /CHILD), SET_UVALUE=state, /NO_COPY

  if (n_elements(sval) ne 0) then CW_BGROUP_SETV, top_base, sval

  return, top_base
END
; $Id: cw_clr_index.pro,v 1.1 1993/10/27 16:02:46 troy Exp $
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:	
;	CW_CLR_INDEX
;
; PURPOSE:
;	CW_CLR_INDEX is a compound widget for the selection of a color
;	index. A horizontal color bar is displayed. Clicking on the bar sets
;	the color index.
;
; CATEGORY:
;	Compound Widgets
;
; CALLING SEQUENCE:
;	Widget = CW_CLR_INDEX(Parent)
;
; INPUTS:
;	Parent:	      ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	COLOR_VALUES: A vector of color indices containing the colors to
;		      be displayed in the color bar. If omitted, NCOLORS
;		      and START_COLOR specify the range of color indices.
;	EVENT_FUNCT:  The name of an optional user-supplied event function.
;		      This function is called with the return value structure
;		      whenever a button is pressed, and follows the conventions ;		      for user-written event functions.
;	FRAME:        If set, a frame will be drawn around the widget.
;	LABEL:        A text label that appears to the left of the color bar.
;	NCOLORS:      The number of colors to place in the color bar.  
;		      The default = !D.N_COLORS.
;	START_COLOR:  The starting color index, placed at the left of the bar.
;	UVALUE:       The user value to be associated with the widget.
;	XSIZE:        The width of the color bar in pixels. The default =192.
;	YSIZE:        The height of the color bar in pixels. The default = 12.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; SIDE EFFECTS:
;	This widget generates event structures with the following definition:
;
;	Event = { CW_COLOR_INDEX, ID: base, TOP: ev.top, HANDLER: 0L, VALUE: c}
;	Value is the color index selected.
;
; PROCEDURE:
;	Standard Compound widget.  Use WIDGET_CONTROL, SET_VALUE and GET_VALUE
;	to change/read the widget's value.
;
; EXAMPLE:
;	A = WIDGET_BASE(TITLE='Example', /COLUMN)
;	B = CW_CLR_INDEX(A, LABEL='Color:')
;
; MODIFICATION HISTORY:
;	DMS,	June, 1993.	Written.
;	TAC,	Oct, 1993.	Changed name to cw_clr_index
;-

function CW_COLOR_INDEXE, ev		;Color index widget's event proc
if ev.press ne 0 then return, 0
base = ev.handler
widget_control, widget_info(base, /child), get_uvalue = state
c = long(state.start_color + (ev.x * state.scale))  ;New color
if state.extra ne 0L then BEGIN
    WIDGET_CONTROL, state.extra, GET_UVALUE=cv
    c = cv(c)
    endif
CW_COLOR_INDEXS, base, c	
ret =  { CW_COLOR_INDEX, ID: base, TOP: ev.top, HANDLER: 0L, VALUE: c}
if state.efun eq '' then return, ret $
else return, CALL_FUNCTION(state.efun, ret)
end


function CW_COLOR_INDEXG, id
	widget_control, widget_info(id, /child), get_uvalue = state
	return, state.value
end


pro CW_COLOR_INDEXS, id, value		;Set color index widget value
widget_control, (draw = widget_info(id, /child)), get_uvalue = state, /NO_COPY
old_win = !d.window

if state.inited eq 0 then begin
    widget_control, state.pwin_id, get_value = i
    wset, i
    x = long(state.scale * findgen(!d.x_size))	;0 to n_colors-1
    if state.extra ne 0L then begin
	WIDGET_CONTROL, state.extra, GET_UVALUE=cv
	x = cv(x)
	ENDIF
    tv, x # replicate(1, !d.y_size) + state.start_color
    state.inited = 1
    endif

state.value = value			;Save new value
widget_control, state.rect_id, get_value = i
wset, i
tv, replicate(value, !d.x_size, !d.y_size)
wset, old_win
widget_control, state.txt_id, set_value = '(' + strtrim(value,2) + ')'
widget_control, draw, set_uvalue = state, /NO_COPY
return
end


function CW_CLR_INDEX, parent, LABEL = label, FRAME = frame, $
	UVALUE = uvalue, XSIZE = xsize, YSIZE = ysize, NCOLORS = ncolors, $
	START_COLOR = start_color, EVENT_FUNC = efun, COLOR_VALUES = cv

if n_elements(frame) eq 0 then frame = 0
if n_elements(uvalue) eq 0 then uvalue = 0
if n_elements(xsize) eq 0 then xsize = 192
if n_elements(ysize) eq 0 then ysize = 12
if n_elements(cv) gt 0 then begin
	ncolors = n_elements(cv)
	start_color = 0
	endif
if n_elements(ncolors) eq 0 then ncolors = !d.N_COLORS
if n_elements(start_color) eq 0 then start_color = 0
if n_elements(label) eq 0 then label = ''

base = widget_base(parent, /ROW, FRAME = frame, $
	EVENT_FUNC = 'CW_COLOR_INDEXE', FUNC_GET_VALUE = 'CW_COLOR_INDEXG', $
	PRO_SET_VALUE = 'CW_COLOR_INDEXS', UVALUE = uvalue)
if n_elements(efun) le 0 then efun = ''
state = { CW_C_INDEX_STATE, $
	txt_id : 0L, rect_id : 0L, pwin_id : 0L, inited : 0, efun: efun, $
	scale : float(ncolors) / xsize, value : 0L, $
	start_color : long(start_color), extra: 0L }
child = widget_label(base, value = label)
state.txt_id = widget_text(base, xsize=5, ysize = 1, value = '(0)')
if n_elements(cv) gt 0 then BEGIN
    WIDGET_CONTROL, state.txt_id, SET_UVALUE=cv
    state.extra = state.txt_id
    endif

state.rect_id = widget_draw(base, /FRAME, XSIZE = 16, YSIZE = ysize, $
	UVALUE = 0, RETAIN=2)
state.pwin_id = widget_draw(base, /frame, xsize = xsize, $
	ysize = ysize, /BUTTON)
widget_control, child, set_uvalue = state
return, base
end

; $Id: cw_colorsel.pro,v 1.5 1994/05/23 20:10:25 ali Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_COLORSEL
;
; PURPOSE:
;	CW_COLORSEL is a compound widget that displays all the colors
;	in the current colormap and allows the user to select the color
;	indices via the mouse or with sliders.
;
; CATEGORY:
;	Compund widgets.
;
; CALLING SEQUENCE:
; 	widget = CW_COLORSEL(Parent)
;
; INPUTS:
;	Parent:	 The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	FRAME:	 If set, a frame is drawn around the widget.
;	UVALUE:	 The user value for the widget.
;	XOFFSET: The X offset position
;	YOFFSET: The Y offset position
;
; OUTPUTS:
;	The ID of the created widget is returned.
;
; SIDE EFFECTS:
;	This widget generates event structures containing a field named
;	VALUE, which contains the colormap index selected by the user.
;
; PROCEDURE:
;	The COLORSEL widget displays all the colors in the current
;	colormap in a 16x16 (320x320 pixels) grid. To select a color
;	index, the user moves the mouse pointer over the desired
;	color square and presses any mouse button. Alternatively, the
;	color index can be selected by moving one of the three sliders
;	provided around the grid.
;
;	WIDGET_CONTROL, SET_VALUE=index can be used to set the current
;		color index.
;
;	WIDGET_CONTROL, SET_VALUE=-1 informs the widget to initialize
;		itself and redraw. It should be called when any of the
;		following happen:
;			- The widget needs redrawing.
;			- The brightest or darkest color has changed. 
;
;	WIDGET_CONTROL, GET_VALUE=var can be used to retrieve the
;		current color index.
;
; MODIFICATION HISTORY:
;	March 30, 1992, AB
;		Removed the relevant code from XPALETTE.PRO and modified
;		it to create this reusable widget cluster.
;	September 4, 1992, SR
;		Fixed a bug where the value of the xslider was calculated
;		as negative and WIDGET_CONTROL, SET_VALUE failed.
;	7 April 1993, AB, Removed state caching.
;	October 20, 1993, KDB 
;		Changed return value in function CSEL_GET_VALUE
;		from state.cur_idx to ret
;	23 May 1994, AB
;		Added NOTIFY_REALIZE routine to eliminate the need
;		to call "WIDGET_CONTROL, SET_VALUE=-1" when the widget
;		is realized.
;-

pro CSEL_SETSLIDERS, state, type, cur_x, cur_y, idx
; Set the three position sliders according to the supplied values.
; Move the mark to the new location.
; entry:
;	type - Controls operation of procedure. Can have the following
;		values:
;		0 - Set all three sliders from IDX. state.x and state.y
;		    are updated.
;		1 - Set Row and Column sliders from IDX. Update
;		    state.x and state_y.
;		2 - Set Column and Index sliders from CUR_X and CUR_Y.
;		3 - Set Row and Index sliders from CUR_X and CUR_Y.

  change_x = 0
  change_y = 0
  change_idx = 0
  nc = !D.table_size

  if (type lt 2) then begin		; From IDX
    if (idx ge nc) then idx = nc -1
    if (type eq 0) then change_idx = 1	; Update slider to match
    ; Calculate current Y and see if slider value needs changing
    tmp = idx / 16
    if (idx ne cur_y) then begin
      cur_y = tmp
      change_y = 1
    endif
    ; Calculate current X and see if slider value needs changing
    tmp = idx - (cur_y * 16)
    if (tmp GE 0) AND (tmp ne cur_x) then begin
      cur_x = tmp
      change_x = 1
    endif
  endif else begin			; From CUR_X and CUR_Y
    if (type eq 2) then begin
      tmp = cur_x
      while (((cur_y * 16) + tmp) ge nc) do tmp = tmp - 1
      if (tmp ne cur_x) then begin
        cur_x = tmp
        change_x = 1
      endif
    endif else begin
      tmp = cur_y
      while (((tmp * 16) + cur_x) ge nc) do tmp = tmp - 1
      if (tmp ne cur_y) then begin
        cur_y = tmp
        change_y = 1
      endif
    endelse
    IDX = (cur_y * 16B) + cur_x
    change_idx = 1
  endelse

  if (change_x) then WIDGET_CONTROL, set_value=cur_x, state.column
  if (change_y) then WIDGET_CONTROL, set_value=cur_y, state.row
  if (change_idx) then WIDGET_CONTROL, set_value=idx, state.by_index
  state.x = cur_x
  state.y = cur_y
  CSEL_MVMARK, state, idx

end







function CSEL_NEW_COLORS, state
; Choose the best foreground and background colors for the current
; color maps. Returns 1 if the colors changed, 0 otherwise.

  res = 0
  luminance = ct_luminance(dark=dark_col, bright=bright_col)

  if (bright_col ne state.bright_idx) then begin
    state.bright_idx = bright_col
    res = 1
  endif

  if (dark_col ne state.dark_idx) then begin
    state.dark_idx = dark_col
    res = 1
  endif

  if (res ne 0) then begin
    marker = bytarr(20, 20) + state.dark_idx
    marker(2, 2) = bytarr(16, 16) + state.bright_idx
    marker(4, 4) = bytarr(12, 12) + state.dark_idx
    marker(6, 6) = bytarr(8, 8) + state.bright_idx
    marker(8, 8) = bytarr(4, 4) + state.dark_idx
    state.marker = marker

    marker = bytarr(20, 20) + state.dark_idx
    marker(1:18, 2:17) = bytarr(18, 16) + state.bright_idx
    state.unreach = marker
 
  endif

  return, res
end







pro CSEL_MVMARK, state, to_index
; Move the marker and update the current color square.

  cur_idx = state.cur_idx

  new_pos = to_index ne cur_idx

  ; Restore current square
  wset, state.spectrum_win
  if (new_pos) then begin
    tv, bytarr(20, 20) + byte(cur_idx), cur_idx
    state.cur_idx = (cur_idx = to_index)
  endif
  tv, state.marker, cur_idx


end







function CSEL_EVENT, ev

  ; Recover the state of this compound widget
  parent = ev.handler
  stash = WIDGET_INFO(parent, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY


  case (ev.id) of

  state.by_index: begin
    set_slide_idx:
      CSEL_SETSLIDERS, state, 1, state.x, state.y, ev.value
    end

  state.column: begin
    CSEL_SETSLIDERS, state, 2, byte(ev.value), state.y, tmp
    end

  state.row : begin
    CSEL_SETSLIDERS, state, 3, state.x, byte(ev.value), tmp
    end

  state.spectrum: begin
      if (ev.press ne 0) then begin
	tmp = ((319 - ev.y) / 20 ) * 16 + (ev.x / 20)
	CSEL_SETSLIDERS, state, 0, state.x, state.y, tmp
      endif else begin
        WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
	return, 0		; Swallow key release events
      endelse
      end
    endcase

  value=state.cur_idx
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  return, {COLORSEL_EVENT, ID: parent, TOP:ev.top, HANDLER:0L, VALUE: value }

end







pro CSEL_REALIZE, id

  ;Retrieve the state information.
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY


  ; Initialize everything
  ; What is the spectrum window id?
  WIDGET_CONTROL, state.spectrum, get_value=tmp
  state.spectrum_win=tmp

  junk = CSEL_NEW_COLORS(state)
  ; Draw spectrum widgets
  wset, state.spectrum_win
  tmp=bytarr(20,20)
  for i = 0, !d.table_size-1 do begin
    tv, tmp, i
    tmp = tmp + 1B
  endfor


  ; Draw the unreachable squares
  wset, state.spectrum_win
  tmp = state.unreach
  for i = !d.table_size, 255 do tv, tmp, i

  ; Highlight the current position using the marker
  CSEL_MVMARK, state, state.cur_idx

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
end







pro CSEL_SET_VALUE, id, value

  if (value eq -1) then begin
    CSEL_REALIZE, id
  endif else begin
    ;Retrieve the state information.
    stash = WIDGET_INFO(id, /CHILD)
    WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

    CSEL_SETSLIDERS, state, 0, 0, 0, value

    WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  endelse

end







function CSEL_GET_VALUE, id

  ;Retrieve the state information.
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  ret = state.cur_idx

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  return, ret 
end







function CW_COLORSEL, parent, FRAME = frame, UVALUE = uval, $
	XOFFSET=xoff, YOFFSET=yoff


  state = { by_index:0L, $		; By index slider widget
	    row:0L, $			; Row slider widget
	    column:0L, $		; Column slider widget
	    spectrum:0L, $		; Spectrum widget 
	    first_child:0L, $		; ID of first child of base.
	    x:0L, y:0L, $		; Current X and Y of marker in spectrum
	    cur_idx:0, $		; Current index
	    marker:bytarr(20,20,/nozero), $	; Byte array used as marker
	    unreach:bytarr(20,20,/nozero), $	; Image for unreachable colors
	    spectrum_win:0, $		; Spectrum draw window index
	    bright_idx:-1, dark_idx:-1}	; Dark and bright colors for marker


  on_error,2              ;Return to caller if an error occurs

  IF NOT (KEYWORD_SET(frame))  THEN frame = 0
  IF NOT (KEYWORD_SET(uval))  THEN uval = 0
  IF NOT (KEYWORD_SET(xoff))  THEN xoff = 0
  IF NOT (KEYWORD_SET(yoff))  THEN yoff = 0

  version = WIDGET_INFO(/VERSION)
  newer_motif = (version.style eq 'Motif') and (version.release ne '1.0')

  ; Create widgets
  base = WIDGET_BASE(parent,  frame=frame, uvalue=uval, $
	EVENT_FUNC='CSEL_EVENT', FUNC_GET_VALUE='CSEL_GET_VALUE', $
	PRO_SET_VALUE='CSEL_SET_VALUE', NOTIFY_REALIZE='CSEL_REALIZE', $
	XOFFSET=xoff, YOFFSET=yoff)
  if (newer_motif) then begin
        state.row = WIDGET_SLIDER(base, min=15, max=0, xoff = 325, $
	    yoff= 75, /vert, val=0, title='Row', ysize=320)
  endif else begin
        state.row = WIDGET_SLIDER(base, min=15, max=0, xoff = 325, $
		yoff= 75, /vert, val=0, title='Row', ysize=320, xsize=75)
  endelse
  state.column = WIDGET_SLIDER(base, max=15, title='Column', $
	xsize=320, yoff=400)
  state.spectrum=WIDGET_DRAW(base, xsize=320, ysize=320, /frame, /button, $
	yoff=75)
  state.by_index = WIDGET_SLIDER(base, max=!d.table_size-1, $
	title = 'By Index', xsize=320)


  state.cur_idx = 0
  state.x = 0
  state.y = 0

  ; Stash the state
  WIDGET_CONTROL, WIDGET_INFO(base, /CHILD), SET_UVALUE=state, /NO_COPY

  return, base
end

; $Id: cw_defroi.pro,v 1.4 1995/02/22 15:33:28 dave Exp $
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_DEFROI
;
; PURPOSE:
;   Widget to define a region of interest within a widget drawable. 
; CATEGORY:
;   Regions of interest, graphics.
; CALLING SEQUENCE:
;   Result = CW_DEFROI(draw)
; INPUTS:
;   Draw = id of drawable to draw the region.  The drawable should
; 	have both MOTION and BUTTON events enabled.
; KEYWORD PARAMETERS:
;   IMAGE_SIZE = the size of the underlying array, expressed
;       as a two element vector: [columns, rows].  Default =
;       drawable size / zoom.
;   OFFSET = offset of lower left corner of image within the
;       drawable.  Default = [0,0].
;   ORDER = if set, return inverted subscripts, as if the array
;       were output from top to bottom.
;   RESTORE = Set to restore the drawable to its previous appearance
;       on exit.  Otherwise, the regions remain on the drawable.
;   ZOOM = if the image array was expanded (via REBIN for example)
;       specify this two element vector containing the expansion
;       factor in X and Y.  Default = [1,1].  Must be integer.
; OUTPUTS:
;      Result = subscripts of points within the region[s] defined.
;       If no region was defined, a scalar -1 is returned.
; COMMON BLOCKS:
;       None.
; SIDE EFFECTS:
;       The regions are drawn within the drawable.  Set the RESTORE
;       keyword to undo the damage.  
; RESTRICTIONS:
;   This is a MODAL widget.  No other widget applications will be
;   responsive while this widget is in use.
;
; PROCEDURE:
;   Complicated.
; EXAMPLE:
;   To obtain the average of the counts of a region within a drawable:
;   Assume A = the array of interest, n columns, m rows, and that
;   it is displayed in drawable D, at offset X=20, Y=100, and zoomed
;   with a factor of 2:
;       TV, REBIN(A, M*2, N*2), 20, 100     ;Display the image
;       q = CW_DEFROI(D, ZOOM=[2,2], OFFSET=[20,100], IMAGE_SIZE=[m,n])
;       if q(0) ne -1 then print,'Average = ', total(a(q))/n_elements(q)
;       
; MODIFICATION HISTORY:
;   DMS, RSI, December, 1993.  Written.
;-

pro CW_DEFROI_nmode, s, new
; Set new mode... Save old roi by concatenating it with s.subs.
n = s.npts
if (s.mode ne 1) and (n le 2) then n = 0  ;must have 3 pnts for polygon
WIDGET_CONTROL, s.mode_w, SET_VALUE=0       ;Revert to add mode
s.amode = 0

if n ge 1 then begin       ;Old region to save?
    if s.mode eq 1 then begin   ;Points?
        WIDGET_CONTROL, s.xy_pnts, GET_UVALUE=xy, /NO_COPY  ;Get old ROI
        xy = xy(0,0:n-1) + s.image_size(0) * xy(1,0:n-1) ;points to subs
        xy = REFORM(xy, n_elements(xy), /OVERWRITE) ;Make linear
    endif else begin
        CW_DEFROI_DRAW, s, -1, /FILL
        WIDGET_CONTROL, s.xy_pnts, GET_UVALUE=xy, /NO_COPY  ;Get old ROI
        xy = polyfillv(xy(0,0:n-1),xy(1,0:n-1),s.image_size(0), s.image_size(1))
    ENDELSE
    WIDGET_CONTROL, s.subs, GET_UVALUE=t, /NO_COPY      ;Prev roi pnts
        ;Concatenate s and xy
    if n_elements(t) le 0 then WIDGET_CONTROL, s.subs, SET_UVALUE=xy, /NO_COPY $
    else WIDGET_CONTROL, s.subs, SET_UVALUE=[t,xy], /NO_COPY
    endif               ;Old region to save

s.mode = new
s.npts = 0
end

PRO CW_DEFROI_DRAW, s, i, FILL = fill
; Draw the outline (or polygon if FILL is set) 
; of the region or the ith segment if i < 0.
; Use the XOR drawing mode.

n = s.npts
if n lt 1 then return
   
WSET, s.win   
DEVICE, SET_GRAPHICS=6          ;Xor drawing mode   
col = 1
while col lt !d.table_size do col = col + col
WIDGET_CONTROL, s.xy_pnts, GET_UVALUE=xy, /NO_COPY  ;Get ROI
  xsave = !x.s & ysave = !y.s       ;Set scaling to pixel coords
  p = float([!d.x_size, !d.y_size])
  f = s.offset / p
  q = s.zoom / p
  !x.s = [f(0), q(0)]
  !y.s = [f(1), q(1)]

if s.mode eq 1 then BEGIN       ;Point mode?
    if i lt 0 then begin
        i = 0 & i1 = n-1
    ENDIF else i1 = i
    for j = i, i1 do $
        polyfill, xy(0,j) + [0, .9, .9, 0], xy(1,j) + [0,0,.9,.9], COLOR=col
ENDIF ELSE BEGIN            ;Polygon/circle/rect
    if n ge 2 then begin
        if i lt 0 then plots, COLOR=col, xy(*, 0:n-1)+.5 $ ;All of it?
        else plots, COLOR=col, xy(*, i:i+1)+.5  ;One segment
        IF KEYWORD_SET(FILL) then POLYFILL, xy(*,0:n-1), COLOR=col
    ENDIF
ENDELSE

!x.s = xsave & !y.s = ysave
WIDGET_CONTROL, s.xy_pnts, SET_UVALUE=xy, /NO_COPY  ;Set ROI   
DEVICE, SET_GRAPHICS=3          ;Copy mode   
end   
   
   
PRO CW_DEFROI_event, ev, s
; This routine is only called from the CW_DEFROI event loop.
; ev = event structure, s = state structure.


s.button = s.button or ev.press xor ev.release  ;New button state   
n = s.npts
x = (ev.x - s.offset(0)) / s.zoom(0)    ;Pixel coordinates
y = (ev.y - s.offset(1)) / s.zoom(1)   

if s.order then y0 = s.image_size(1)-y-1 else y0 = y
WIDGET_CONTROL, s.pos_w, $
    SET_VALUE=string(x, y0, format='("Position: ",i,", ",i)')

if (x lt 0) or (y lt 0) or $            ;Within region?
    (x ge s.image_size(0)) or (y ge s.image_size(1)) then return
if ev.press ne 0 then s.drag = [x,y]    ;Start of drag operation


if (s.mode eq 2) or (s.mode eq 3) then begin ;Rect or square?
    if s.button ne 0 then begin          ;Drag
        if n gt 0 then CW_DEFROI_draw, s, -1      ;Remove old
        t = s.drag
        if s.mode eq 2 then begin   ;Rectangle
            n = 5
            xy = [[t], [x, t(1)], [x, y], [t(0), y], [t]]
        endif else begin        ;Circle
            n = 30              ;# of points
            a = findgen(n+1) * (2 * !pi/(n-1))
            r = sqrt((float(x)-t(0))^2 + (float(y) - t(1))^2)
            xy = transpose([[t(0) + r * cos(a)], [t(1) + r * sin(a)]])
        endelse
    WIDGET_CONTROL, s.xy_pnts, SET_UVALUE=xy, /NO_COPY   ;Restore UVALUE
    s.npts = n
    CW_DEFROI_draw, s, -1
    ENDIF                       ;DRAG
    return
ENDIF                           ;Rect or square


if s.button eq 0 then return        ;Must be point or polygon...
tmode = s.amode                     ;Default mode
if s.button eq 4 then tmode = 1     ;Rt button to remove

if tmode then begin            ;Remove prev point?
    if (ev.press ne 0) and (n gt 0) then begin
        CW_DEFROI_DRAW, s, -1   ;Erase old region
        WIDGET_CONTROL, s.xy_pnts, GET_UVALUE=xy, /NO_COPY ;Get ROI array
        d = float(x-xy(0,0:n-1))^2 + float(y-xy(1,0:n-1))^2  ;Dist
        t = min(d, ipnt)        ;Closest...
        if ipnt ne (n-1) then xy(0,ipnt) = xy(*,ipnt+1:*)  ;Collapse
        s.npts = n-1
        WIDGET_CONTROL, s.xy_pnts, SET_UVALUE=xy, /NO_COPY  ;Save ROI array
        if n gt 1 then CW_DEFROI_DRAW, s, -1   ;Draw new region
        endif   
    return
    endif               ;Remove mode....   
           
; Here we add a point
WIDGET_CONTROL, s.xy_pnts, GET_UVALUE=xy, /NO_COPY  ;Get ROI array

; Add a point
if n_elements(xy) le 1 then xy = intarr(2,100)   
        ; Remove duplicates...   
if n gt 0 then if x eq xy(0,n-1) and y eq xy(1,n-1) then goto, done0
if s.mode eq 1 then for i=0, n-1 do $       ;Point mode?
    IF x eq xy(0,i) and y eq xy(1,i) then goto, done0    ;No duplicates

if (n+1) ge n_elements(xy)/2 then xy = [[xy], [intarr(2,n)]]  ;Extend array?

xy(0,n) = x     ;New point
xy(1,n) = y
n = n + 1
s.npts = n
WIDGET_CONTROL, s.xy_pnts, SET_UVALUE=xy, /NO_COPY   ;Restore UVALUE

if s.mode eq 0 then begin           ;Polygon?
    if n ge 2 then CW_DEFROI_draw, s, n-2           ;Draw the new segment
endif else begin                    ;Point
    CW_DEFROI_draw, s, n-1         ;Draw new point
endelse
return
   
done0: WIDGET_CONTROL, s.xy_pnts, SET_UVALUE=xy, /NO_COPY   
end   
   



function CW_DEFROI, draw, ZOOM = zoom, IMAGE_SIZE = image_size, $   
    OFFSET = offset, RESTORE = restore, ORDER = order

base = widget_base(title='Region of Interest', /COLUMN)   
xy_pnts = WIDGET_TEXT(base, YSIZE=2, /FRAME, UVALUE=0, $
    value=['Add with left button: drag or click', $   
        'Remove with right button'])   
Options = CW_BGROUP(base, /ROW, /NO_RELEASE, /RETURN_NAME,  $
    ['Clear', 'Clear All', 'New', 'Cancel'])   
junk = CW_BGROUP(base, /ROW, /EXCLUSIVE, /NO_REL, /RETURN_NAME, $
    ['Polygon', 'Point', 'Rectangle', 'Circle'], SET_VALUE=0)
mode_w = CW_BGROUP(base, /ROW, LABEL_LEFT = 'Mode:', /EXCLUSIVE, /NO_REL, $   
    /RETURN_NAME, ['Add', 'Remove'], SET_VALUE=0)
junk = CW_BGROUP(base, /ROW, /NO_REL, /RETURN_NAME, ['Done'])
pos_w = WIDGET_TEXT(base, YSIZE=1, XSIZE=18, /FRAME, $
    VALUE='Position:    0,    0')

WIDGET_CONTROL, draw, GET_VALUE=win
WSET, win   
   
if n_elements(zoom) le 0 then zoom = [1,1]
if n_elements(image_size) le 0 then image_size = [!d.x_size, !d.y_size] / zoom
if n_elements(offset) le 0 then offset = [0,0]   
p  = offset + image_size /2   
if (!version.os NE 'MacOS') THEN TVCRS, p(0), p(1), /DEVICE ELSE TVCRS, 1
   
WINDOW, /PIXMAP, /FREE, xs = !d.x_size, ys=!d.y_size  ;Save window
backing = !d.window
DEVICE, copy = [0,0, !d.x_size, !d.y_size, 0, 0, win]  ;Save it

s = { CW_DEFROI_STRUCT, $       ;Structure containing state
    base: base, $       ;Main base widget
    xy_pnts: xy_pnts, $ ;Current roi vertex list
    npts : 0L, $        ;# of points in current roi
    subs : pos_w, $     ;Widget holding prev subscripts
    pos_w : pos_w, $    ;Position text widget
    mode: 0, $          ;major mode
    amode: 0, $         ;0 for add, 1 for remove
    draw: draw, $       ;draw widget id
    win:  win, $        ;draw widget window #
    button: 0, $        ;button state
    image_size : long(image_size), $   ;Image array size
    mode_w: mode_w, $   ;Add/remove button widget
    backing: backing, $ ;Pixmap for backing store
    offset: fix(offset), $   ;offset of array within window
    zoom : fix(zoom), $ ;zoom factor
    order : KEYWORD_SET(order), $  ;Image order
    drag: [0,0]}        ;Beginning of drag motion
   
WIDGET_CONTROL, base, /REALIZE
WSHOW, win
   
WHILE 1 DO BEGIN                ;Internal event loop   
    ev = WIDGET_EVENT([base, draw])
    n = s.npts
    if ev.id eq draw then CW_DEFROI_EVENT, ev, s $
    else case ev.value of   
'Clear All':  BEGIN
    WIDGET_CONTROL, s.subs, GET_UVALUE=t, /NO_COPY  ;Clr list of subscripts
    t = 0
    WSET, win
    DEVICE, copy = [0,0, !d.x_size, !d.y_size, 0, 0, backing]  ;Restore it
    s.npts = 0
    ENDCASE
'Clear':  BEGIN   
    if (n ge 2) or (s.mode eq 1 and n ge 1) then $
        CW_DEFROI_draw, s, -1        ;Erase roi   
    s.npts = 0   
    CW_DEFROI_NMODE, s, s.mode
    ENDCASE
'New' : CW_DEFROI_nmode, s, s.mode      ;Make a new region...
'Cancel':  BEGIN   
    xy = -1
    goto, all_done
    ENDCASE    

;    ['Polygon', 'Point', 'Rectangle', 'Circle'], SET_VALUE=0)
'Polygon': CW_DEFROI_nmode, s, 0
'Point' :  CW_DEFROI_nmode, s, 1
'Rectangle' :  CW_DEFROI_nmode, s, 2
'Circle' :  CW_DEFROI_nmode, s, 3

'Add':  s.amode = 0
'Remove': s.amode = 1
'Done': BEGIN   
    cw_defroi_nmode, s, 0       ;Save old region
    WIDGET_CONTROL, s.subs, GET_UVALUE=t, /NO_COPY  ;List of subscripts
    xy = BYTARR(s.image_size(0), s.image_size(1))  ;Return only unique
    if n_elements(t) gt 0 then xy(t) = 1
    if s.order then xy = reverse(xy,2)  ;Flip it?
    xy = where(temporary(xy))
all_done:
    IF KEYWORD_SET(restore) then begin      ;Undo damage?
        WSET, win
        DEVICE, copy = [0,0, !d.x_size, !d.y_size, 0, 0, backing]  ;Restore it
        ENDIF
    WDELETE, backing
    WIDGET_CONTROL, base, /DESTROY   
    return, xy
    ENDCASE    
ENDCASE   
ENDWHILE            ;Event loop
END   

; $Id: cw_dice.pro,v 1.4 1993/11/16 18:37:58 ali Exp $

; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_DICE
;
; PURPOSE:
;	CW_DICE is a compound widget that implements a single die.
;	This widget uses a button with a bitmap label.
;
;	The primary purpose of this compound widget is to serve as
;	a full example of a realistic compound widget for the IDL
;	User's Guide.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	Widget = CW_DICE(Parent)
;
; INPUTS:
;       Parent:	  The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	TUMBLE_CNT: The widget simulates the tumbling of a dice by
;		changing the bitmap on the dice several times before
;		settling down to a final value. The number of "tumbles"
;		is specified by the TUMBLE_CNT keyword. The default is 10.
;	TUMBLE_PERIOD: The amount of time in seconds between each tumble
;		of the dice. The default is .05 seconds.
;	UVALUE:	  The user value for the widget.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; COMMON BLOCKS
;	CW_DICE_BLK: Used to store dice faces, and the current
;		random number generator seed for the CW_DICE class.
;
; SIDE EFFECTS:
;	This widget generates event structures containing an extra
;	field named VALUE giving the final value resulting from a dice roll.
;	Such events are only sent when the user presses the dice button.
;
; PROCEDURE:
;	The CW_DICE widget consists of a single pushbutton that
;	displays its current dice value as a bitmask. If the user presses
;	the button, it tumbles for a moment and then the new value is
;	displayed and an event is issued.
;
;	The current value of the dice is available via the
;	WIDGET_CONTROL,GET_VALUE command.
;
;	The current value can be set by issuing the
;	WIDGET_CONTROL, SET_VALUE command. If the requested value is
;	outside the range [1,6], then the dice tumbles to a new value
;	as if the user had pressed the button, but no event is issued.
;
; MODIFICATION HISTORY:
;	24 October 1993, AB, RSI
;-

pro CW_DICE_ROLL, dice, state
  ; Given the state structure from a CW_DICE instance, this routine,
  ; sets it to a new value

  COMMON CW_DICE_BLK, seed, faces

  IF (state.remaining EQ 0) THEN BEGIN		; Initial request
    state.remaining = state.tumble_cnt
    state.value = FIX(6 * RANDOMU(seed) + 1)	; Get final answer up front
  ENDIF 

  IF (state.remaining EQ 1) THEN BEGIN
    value = state.value			; Last time, so use final answer
  ENDIF ELSE BEGIN			; Not last time, use random value
    value = FIX(6 * RANDOMU(seed) + 1)	; Intermediate value
    WIDGET_CONTROL, dice, TIMER=state.tumble_period
  ENDELSE

  WIDGET_CONTROL, dice, set_value=faces(*,*,value-1)

  state.remaining = state.remaining - 1
end







FUNCTION CW_DICE_EVENT, ev

  ; Recover the state of this compound widget
  base = ev.handler
  stash = WIDGET_INFO(base, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  ; Roll the die and display the new result.
  CW_DICE_ROLL, stash, state

  ; If this invocation is not from the timer, issue an event
  if (TAG_NAMES(ev, /STRUCTURE_NAME) ne 'TIMER_EVENT') THEN $
    ret = { CW_DICE_EVENT,ID: base,TOP:ev.top,HANDLER:0L,VALUE:state.value } $
  ELSE ret = 0

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  RETURN, ret

end







pro CW_DICE_SET_VAL, id, value

  COMMON CW_DICE_BLK, seed, faces

  ; Recover the state of this compound widget
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  ; If value out of range, roll the dice ourselves
  IF (value < 1) OR (value > 6) THEN BEGIN
    CW_DICE_ROLL, stash, state
  ENDIF ELSE BEGIN		; Use the requested value.
    state.value=value
    WIDGET_CONTROL, stash, SET_VALUE=faces(*,*,value-1)
  endelse

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
end







function CW_DICE_GET_VAL, id

  ; Recover the state of this compound widget
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  ret = state.value

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  return, ret
end








function CW_DICE, parent, value, UVALUE=uvalue, TUMBLE_CNT=tumble_cnt, $
	TUMBLE_PERIOD=tumble_period

  COMMON CW_DICE_BLK, seed, faces

  IF NOT (KEYWORD_SET(tumble_cnt))  THEN tumble_cnt=10
  IF (tumble_cnt lt 1) then tumble_cnt = 10
  IF NOT (KEYWORD_SET(tumble_period))  THEN tumble_period=.05
  IF (tumble_period lt 0) then tumble_period = .05
  IF NOT (KEYWORD_SET(uvalue))  THEN uvalue=0

  on_error,2              ;Return to caller if an error occurs


  ; Generate the die faces. Each bitmap is 32x32 bits, 4x32 bytes, or 1x32
  ; longwords. This completely non-obvious computation was derived by
  ; using the X Window bitmap program to obtain the bitmaps. Then, I used the
  ; READ_X11_BITMAP program to read them into IDL and did some analysis
  ; to convert them into a programmatically generated longword array.
  ; The final step is to cast the longword array into the 6 byte arrays.
  faces = lonarr(192)
  i4=indgen(4)+1
  s5=[0,5]
  pos=[13, 77, 141, 36, 54, 67, 87, 100, 118, 131, 151, 164, 182]
  v1=['c00300'x,'c00300'x,'c00300'x,'e0010000'x,'8007'x,'f0000000'x,'f'x, $
      'e0018007'x,'e0018007'x,'f000000f'x,'f000000f'x,'f0c0030f'x,'f0c0030f'x]
  v2=['e00700'x,'e00700'x,'e00700'x,'f0030000'x,'c00f'x,'f8010000'x,'801f'x, $
      'f003c00f'x,'f003c00f'x,'f801801f'x,'f801801f'x,'f8e1871f'x,'f8e1871f'x]
  for i = 0, n_elements(pos)-1 do begin
    faces(s5+pos(i)) = v1(i)
    faces(i4+pos(i)) = v2(i)
  endfor
  faces = byte(faces,0,4,32,6)
  BYTEORDER, faces, /HTONL		; Little endian machines need swap

  ; Use RANDOMU to pick the initial value of the die, unless the user
  ; provided one.
  if (n_elements(value) eq 0) then value = fix(6 * randomu(seed) + 1)

  ; The state of this compound widget:
  ;	- It's currently displayed value.
  ;	- The number of times the dice should tumble before settling down.
  ;	- The amount of time in seconds in between tumbles.
  ;	- The number of tumbles left before the event should be reported.
  state = { value:value, tumble_cnt:FIX(tumble_cnt), $
	    tumble_period:tumble_period, remaining:0 }


  base = WIDGET_BASE(parent, UVALUE=uvalue, EVENT_FUNC='CW_DICE_EVENT',$
        FUNC_GET_VALUE='CW_DICE_GET_VAL', PRO_SET_VALUE='CW_DICE_SET_VAL')

  die = WIDGET_BUTTON(base, value=faces(*,*,value-1))

  ; Stash the state
  WIDGET_CONTROL, WIDGET_INFO(base, /CHILD), SET_UVALUE=state, /NO_COPY

  return, base
end
; $Id: cw_field.pro,v 1.10 1994/05/06 16:09:51 kirk Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_FIELD
;
; PURPOSE:
;	This widget cluster function manages a data entry field widget.
;	The field consists of a label and a text widget.  CW_FIELD's can
;	be string fields, integer fields or floating-point fields.  The
;	default is an editable string field.
;
; CATEGORY:
;	Widget Clusters.
;
; CALLING SEQUENCE:
;	Result = CW_FIELD(Parent)
;
; INPUTS:
;	Parent:	The widget ID of the widget to be the field's parent.
;
; KEYWORD PARAMETERS:
;	TITLE:	A string containing the text to be used as the label for the
;		field.  The default is "Input Field:".
;
;	VALUE:	The initial value in the text widget.  This value is
;		automatically converted to the type set by the STRING,
;		INTEGER, and FLOATING keywords described below.
;
;	UVALUE:	A user value to assign to the field cluster.  This value
;		can be of any type.
;
;	FRAME:	The width, in pixels, of a frame to be drawn around the
;		entire field cluster.  The default is no frame.
;
;RETURN_EVENTS:	Set this keyword to make cluster return an event when a
;		<CR> is pressed in a text field.  The default is
;		not to return events.  Note that the value of the text field
;		is always returned when the WIDGET_CONTROL, field, GET_VALUE=X
;		command is used.
;
;   ALL_EVENTS: Like RETURN_EVENTS but return an event whenever the
;		contents of a text field have changed.
;
;	COLUMN:	Set this keyword to center the label above the text field.
;		The default is to position the label to the left of the text
;		field.
;
;	ROW:	Set this keyword to position the label to the left of the text
;		field.  This is the default.
;
;	XSIZE:	An explicit horizontal size (in characters) for the text input
;		area.  The default is to let the window manager size the
;		widget.  Using the XSIZE keyword is not recommended.
;
;	YSIZE:	An explicit vertical size (in lines) for the text input
;		area.  The default is 1.
;
;	STRING:	Set this keyword to have the field accept only string values.
;		Numbers entered in the field are converted to their string
;		equivalents.  This is the default.
;
;     FLOATING:	Set this keyword to have the field accept only floating-point
;		values.  Any number or string entered is converted to its
;		floating-point equivalent.
;
;      INTEGER:	Set this keyword to have the field accept only integer values.
;		Any number or string entered is converted to its integer
;		equivalent (using FIX).  For example, if 12.5 is entered in
;		this type of field, it is converted to 12.
;
;	LONG:	Set this keyword to have the field accept only long integer
;		values.  Any number or string entered is converted to its
;		long integer equivalent (using LONG).
;
;	FONT:	A string containing the name of the X Windows font to use
;		for the TITLE of the field.
;
;    FIELDFONT:	A string containing the name of the X Windows font to use
;		for the TEXT part of the field.
;
;	NOEDIT:	Normally, the value in the text field can be edited.  Set this
;		keyword to make the field non-editable.
;
; OUTPUTS:
;	This function returns the widget ID of the newly-created cluster.
;
; COMMON BLOCKS:
;	None.
;
; PROCEDURE:
;	Create the widgets, set up the appropriate event handlers, and return
;	the widget ID of the newly-created cluster.
;
; EXAMPLE:
;	The code below creates a main base with a field cluster attached
;	to it.  The cluster accepts string input, has the title "Name:", and
;	has a frame around it:
;
;		base = WIDGET_BASE()
;		field = CW_FIELD(base, TITLE="Name:", /FRAME)
;		WIDGET_CONTROL, base, /REALIZE
;
; MODIFICATION HISTORY:
; 	Written by:	Keith R. Crosley   June 1992
;			KRC, January 1993 -- Added support for LONG
;					     integers.
;		        AB, 7 April 1993, Removed state caching.
;			JWG, August 1993, Completely rewritten to make
;				use of improved TEXT widget functionality
;			ACY, 25 March, 1994, fix usage of FRAME keyword
;                       KDB, May 1994, Initial value =0 would result
;                                      in a null text field. Fixed
;                                      keyword check.
;
;-

;
;  Check and return the portion of a string that
;	is a valid floating point number.
;
FUNCTION CW_FIELD_VALIDATE, Value
	;	Look for invalid mantissa

    IF Value EQ '' THEN RETURN, ''

    Chars	= [ BYTE(Value), 0b ]
    Curr	= 0
    NeedDecimal	= 1

	;	Valid #s
	;	[+-]<number>[exponent]
	;	number ::= [0-9]+[.[0-9]*] or .[0-9]+
	;	exponent ::= {eEdD}[+-][0-9]+

	;	Signed value?
    IF Chars(Curr) EQ 43b OR Chars(Curr) EQ 45b THEN Curr = Curr + 1

	;	Look for digits before the decimal point
    IF Chars(Curr) GE 48b AND Chars(Curr) LE 57b THEN BEGIN
	NeedDecimal	= 0

	;	while(isdigit(*p))++p;
	WHILE Chars(Curr) GE 48b AND Chars(Curr) LE 57b DO Curr = Curr + 1
    ENDIF

	;	Must have .[0-9]+

    IF NeedDecimal THEN BEGIN
	IF Chars(Curr) NE 46b THEN RETURN,''	; invalid #
	Curr	= Curr + 1
	IF Chars(Curr) LT 48b OR Chars(Curr) GT 57b THEN RETURN,''

	;	while(isdigit(*p))++p;
	WHILE Chars(Curr) GE 48b AND Chars(Curr) LE 57b DO Curr = Curr + 1
    ENDIF ELSE BEGIN

	;	Might have .[0-9]*

	IF Chars(Curr) EQ 46b THEN BEGIN
	    Curr	= Curr + 1
		;	while(isdigit(*p))++p;
	    WHILE Chars(Curr) GE 48b AND Chars(Curr) LE 57b DO Curr = Curr + 1
	ENDIF
    ENDELSE

	;	Exponent?
    Dummy	= WHERE(Chars(Curr) EQ BYTE("dDeE"), Count)
    IF Count THEN BEGIN
	; Save exponent position in case the exponent is invalid
	; and only mantissa is valid number.
	SaveCurr	= Curr - 1

	Curr		= Curr + 1	; skip 'e'
	;	Signed exponent?
	IF Chars(Curr) EQ 43b OR Chars(Curr) EQ 45b THEN Curr = Curr + 1

	;	At least one digit after 'e' or exponent is malformed
	IF Chars(Curr) LT 48b OR Chars(Curr) GT 57b THEN BEGIN
		Curr	= SaveCurr	; Revert -- invalid exponent
	ENDIF ELSE BEGIN
	;	find end of exponent digits
	    WHILE Chars(Curr) GE 48b AND Chars(Curr) LE 57b DO Curr = Curr + 1
	ENDELSE
    ENDIF

    RETURN,STRING(Chars(0:Curr))	; Chars from 0-Curr are valid
END


FUNCTION CW_FIELD_VALUE, Value, Type

    IF Type EQ 0 THEN RETURN, Value

    NValue	= CW_FIELD_VALIDATE(Value(0))

    CASE Type OF
    1:	RETURN, FLOAT(NValue)
    2:	RETURN, FIX(NValue)
    3:	RETURN, LONG(NValue)
    ENDCASE
END

;
;	Procedure to set the value of a CW_FIELD
;
PRO CW_FIELD_SET, Base, Value

	sValue	= Value		; Prevent alteration from reaching back to caller

	Sz	= SIZE(sValue)
	IF Sz(0) NE 7 THEN sValue = STRTRIM(Value,2)

	Child	= WIDGET_INFO(Base, /CHILD)
	WIDGET_CONTROL, Child, GET_UVALUE=State, /NO_COPY
	WIDGET_CONTROL, State.TextId, $
		SET_VALUE=STRTRIM(CW_FIELD_VALUE(sValue, State.Type),2)
	WIDGET_CONTROL, Child, SET_UVALUE=State, /NO_COPY
END

;
;	Function to get the value of a CW_FIELD
;
FUNCTION CW_FIELD_GET, Base

	Child	= WIDGET_INFO(Base, /CHILD)
	WIDGET_CONTROL, Child, GET_UVALUE=State, /NO_COPY
	WIDGET_CONTROL, State.TextId, GET_VALUE=Value

	Ret	= CW_FIELD_VALUE(Value, State.Type)

	WIDGET_CONTROL, Child, SET_UVALUE=State, /NO_COPY
	RETURN, Ret
END

;	Ascii assumptions
;
;	+ - .	= 43,45,46
;	0-9	= 48-57
;	DEde	= 68,69,100,101
;

;
;	Examine an input stream of characters.
;	Alter the field contents to reflect this.
;	If any character inserted in a single operation is invalid,
;		ignore the entire operation.
;	Consider that field may contain a (known) invalid state
;
PRO CW_FIELD_INT, Ch, State, Event, Altered

    Altered	= 0		; nothing so far
    Nil		= 0		; field has contents
    Minus	= 0		; field is not just a '-'
    Negate	= 0		; new text has no '-'s in it
    TextId	= State.TextId

	; Special Cases:
	;	We don't actually care where in the input string a
	;	'-' is.  If there is an odd number of them, we
	;	negate the value (see below)
	;
	;	Current String		Char		Result
	;	Nil			'-'		'-'
	;	-			'-'		Nil
	;	<any number>		'-'		-<number>

    WIDGET_CONTROL, TextId, GET_VALUE=Value
    Value	= Value(0)

    IF Value EQ '' THEN Nil = 1		; Value is nil string
    IF Value EQ '-' THEN Minus = 1	; Value is an invalid number


	;	<CR> 
    IF Ch EQ 10b THEN BEGIN
	Altered	= 2
	RETURN
    ENDIF

    IF Ch EQ 45b THEN Negate = 1 $
    ELSE IF Ch GE 48b AND Ch LE 57b THEN BEGIN
	Nil = 0 & Minus = 0
    ENDIF ELSE RETURN	; ![0-9]

    ;	Add new character (if any)

    Selection	= WIDGET_INFO(TextId, /TEXT_SELECT)
    TIP		= Selection(0)+1-Negate	; Text Insertion Point

    IF Negate EQ 0 THEN BEGIN
	WIDGET_CONTROL, TextId, SET_VALUE=STRING(Ch), /USE_TEXT_SELECT
	Altered	= 1
    ENDIF

    IF Negate THEN BEGIN
	IF Nil THEN BEGIN
	    WIDGET_CONTROL, TextId, SET_VALUE='-'
	    TIP	= 1
	ENDIF ELSE IF Minus THEN BEGIN
	    WIDGET_CONTROL, TextId, SET_VALUE=''
	ENDIF ELSE BEGIN
	    ;	We actually have a number to negate

	    WIDGET_CONTROL, TextId, GET_VALUE=Value
	    IValue	= LONG(Value)
	    TIP		= TIP + (IValue GT 0) - (IValue LT 0)
	    WIDGET_CONTROL, TextId, SET_VALUE=STRTRIM(-IValue,2)
	ENDELSE
	Altered	= 1
    ENDIF

    ; Set selection point
    IF Altered THEN WIDGET_CONTROL, TextId, SET_TEXT_SELECT=[TIP,0]
END


FUNCTION CW_FIELD_EXPONENT, Value, Idx

    BValue	= BYTE(Value)

    Idx	= WHERE(BValue EQ 68b, Count)
    IF Count EQ 1 THEN RETURN, 1
    Idx	= WHERE(BValue EQ 69b, Count)
    IF Count EQ 1 THEN RETURN, 1
    Idx	= WHERE(BValue EQ 100b, Count)
    IF Count EQ 1 THEN RETURN, 1
    Idx	= WHERE(BValue EQ 101b, Count)
    IF Count EQ 1 THEN RETURN, 1
    RETURN, 0
END

;
;	Floating point number are even more complicated.
;	There are more invalid states available.
;	Currently, we are more lax.
;
PRO CW_FIELD_FLOAT, Ch, State, Event, Altered

    TextId	= State.TextId
    WIDGET_CONTROL, TextId, GET_VALUE=Value
    Value	= Value(0)

    IF Ch EQ 10b THEN BEGIN
	Value	= CW_FIELD_VALIDATE(Value)
	WIDGET_CONTROL, TextId, SET_VALUE=Value
	WIDGET_CONTROL, TextId, SET_TEXT_SELECT=[Strlen(Value),0]
	Altered	= 2
	RETURN
    ENDIF

	;	Unfortunately, we have a lot of invalid states
	;	possible that aren't a problem.
	;	We make sure of just a minimum number of
	;	things:
	;	One EeDd per field.
	;	One decimal point, before the exponent
	;	- sign must be 1st char or follow the exponent.

    Selection	= WIDGET_INFO(TextId, /TEXT_SELECT)

    IF Ch GE 48b AND Ch LE 57b THEN BEGIN
	WIDGET_CONTROL, TextId, SET_VALUE=STRING(Ch), /USE_TEXT_SELECT
    ENDIF ELSE BEGIN
	CASE Ch OF

	46b:	BEGIN
		;	Ignore it if there is one already
		;	New decimal point must precede exponent

	    Idx	= WHERE(BYTE(Value) EQ 46b, Count)
	    IF Count EQ 1 THEN RETURN
	    IF CW_FIELD_EXPONENT( Value, Idx ) THEN BEGIN
		IF Idx(0) LT Selection(0) THEN RETURN
	    ENDIF
	    WIDGET_CONTROL, TextId, SET_VALUE=STRING(Ch), /USE_TEXT_SELECT
	END
	43b:	BEGIN	; + must follow exponent
	    IF CW_FIELD_EXPONENT( Value, Idx ) THEN BEGIN
		IF Idx(0)+1 EQ Selection(0) THEN BEGIN
		    WIDGET_CONTROL, TextId, SET_VALUE='+', /USE_TEXT_SELECT
		ENDIF ELSE RETURN
	    ENDIF ELSE RETURN
	END
	45b:	BEGIN
	    HaveExp	= CW_FIELD_EXPONENT( Value, Idx )
	    IF  (HaveExp AND Idx(0)+1 EQ Selection(0)) OR $
		(Selection(0) EQ 0 AND STRMID(Value,0,1) NE "-") THEN BEGIN
		WIDGET_CONTROL, TextId, SET_VALUE='-', /USE_TEXT_SELECT
	    ENDIF ELSE RETURN
	END

	68b:	GOTO, Exponent
	69b:	GOTO, Exponent
	100b:	GOTO, Exponent
	101b:	BEGIN
	Exponent:

	;	Replace if one exists. Otherwise allow it anywhere
	;	AFTER the decimal point
	    IF CW_FIELD_EXPONENT( Value, Idx ) THEN BEGIN
		Selection	= [ Idx, 1 ]
		WIDGET_CONTROL, TextId, SET_TEXT_SELECT=Selection
	    ENDIF ELSE BEGIN
		Idx	= WHERE(BYTE(Value) EQ 46b, Count)
		IF Count EQ 1 THEN BEGIN
		    IF Selection(0) LE Idx(0) THEN RETURN
		ENDIF
	    ENDELSE
	    WIDGET_CONTROL, TextId, SET_VALUE=STRING(Ch), /USE_TEXT_SELECT
	END

	ELSE:	RETURN	; Bad
	ENDCASE
    ENDELSE



    Altered	= 1
    WIDGET_CONTROL, TextId, SET_TEXT_SELECT=[Selection(0)+1,0]
END

FUNCTION CW_FIELD_EVENT, Event

    StateHolder	= WIDGET_INFO(Event.Handler, /CHILD)
    WIDGET_CONTROL, StateHolder, GET_UVALUE=State, /NO_COPY

	;	At this point, we need to look at what kind of field
	;	we have:

    Altered	= 0

    ;	If the user has types <CR> then update field

    IF State.Type NE 0 THEN BEGIN		; Not a String?

	IF Event.Type LE 1 THEN BEGIN		; Insert Characters?

	    IF State.Type EQ 1 THEN Procedure='CW_FIELD_FLOAT' $
	    ELSE Procedure='CW_FIELD_INT'

	    Altered	= 0
	    IF Event.Type EQ 0 THEN BEGIN
		CALL_PROCEDURE, Procedure, Event.Ch, State, Event, Altered
	    ENDIF ELSE BEGIN
		Chars	= BYTE(Event.Str)
		FOR I=0,N_ELEMENTS(Chars)-1 DO $
		    CALL_PROCEDURE, Procedure, Chars(I), State, Event, Altered
	    ENDELSE

	ENDIF ELSE IF Event.Type EQ 2 THEN BEGIN	; Delete Text

	    IF Event.Length GT 0 THEN BEGIN ; Bug in widget
		WIDGET_CONTROL, State.TextId, $
			SET_TEXT_SELECT=[Event.Offset,Event.Length]
		WIDGET_CONTROL, State.TextId, SET_VALUE='', /USE_TEXT_SELECT

		;	See if user wants an update
	        Altered = 1
	    ENDIF

	ENDIF
    ENDIF ELSE BEGIN
	;	All delete/add char events effect the contents of
	;	a string. <CR> is considered special.
	IF Event.Type GE 0 AND Event.Type LE 2 THEN Altered	= 1
	IF Event.Type EQ 0 THEN $
	   Altered	= 1 + (Event.Ch EQ 10b)
    ENDELSE


    Ret	= 0

	;	If the entry has been modified or <CR> was hit
	;	And the user is interested in all event or
	;	Just <CR> AND <CR> was the cause of update then
	;	send it
    IF State.Update NE 0 AND $
       Altered GE State.Update THEN BEGIN

	WIDGET_CONTROL, State.TextId, GET_VALUE=Value
	RValue	= CW_FIELD_VALUE(Value, State.Type)

	Ret	= {			$
		ID: Event.Handler,	$
		TOP: Event.Top,		$
		HANDLER: 0L,		$
		VALUE: RValue,		$
		TYPE: State.Type,	$
		UPDATE: Altered - 1	$	; 0=any,1=CR
	}
    ENDIF

    ;	Restore our state structure
    WIDGET_CONTROL, StateHolder, SET_UVALUE=State, /NO_COPY
    RETURN, Ret
END


FUNCTION CW_FIELD, Parent, COLUMN=Column, ROW=Row, $
	FLOATING=Float, INTEGER=Int, LONG=Long, STRING=String, $
	FONT=LabelFont, FRAME=Frame, TITLE=Title, UVALUE=UValue, VALUE=Value, $
	RETURN_EVENTS=ReturnEvents, ALL_EVENTS=AllUpdates, $
	FIELDFONT=FieldFont, NOEDIT=NoEdit, TEXT_FRAME=TextFrame, $
	XSIZE=XSize, YSIZE=YSize
;	FLOOR=vmin, CEILING=vmax

	;	Examine our keyword list and set default values
	;	for keywords that are not explicitly set.

    Column		= KEYWORD_SET(Column)
    Row			= 1 - Column
    AllEvents		= 1 - KEYWORD_SET(NoEdit)

	; Enum Update { None, All, CRonly }
    Update		= 0
    IF KEYWORD_SET(AllUpdates) THEN Update	= 1
    IF KEYWORD_SET(ReturnEvents) THEN Update	= 2

    IF KEYWORD_SET(FieldFont) EQ 0 THEN FieldFont=''
    IF KEYWORD_SET(Frame) EQ 0 THEN Frame=0
    IF KEYWORD_SET(LabelFont) EQ 0 THEN LabelFont=''
    IF KEYWORD_SET(Title) EQ 0 THEN Title="Input Field:"
    IF N_Elements(value) EQ 0 THEN value=''
    IF KEYWORD_SET(UValue) EQ 0 THEN UValue=0
    IF KEYWORD_SET(XSize) EQ 0 THEN XSize=0
    IF KEYWORD_SET(YSize) EQ 0 THEN YSize=1

				Type	= 0	; string is default
    IF KEYWORD_SET(Float) THEN 	Type	= 1
    IF KEYWORD_SET(Int) THEN	Type	= 2
    IF KEYWORD_SET(Long) THEN	Type	= 3

	;	Don't allow multiline non string widgets
    IF KEYWORD_SET(YSize) EQ 0 OR Type NE 0 THEN YSize=1
    TextFrame	= KEYWORD_SET( TextFrame )

	;	Build Widget

    Base	= WIDGET_BASE(Parent, ROW=Row, COLUMN=Column, UVALUE=UValue, $
			EVENT_FUNC='CW_FIELD_EVENT', $
			PRO_SET_VALUE='CW_FIELD_SET', $
			FUNC_GET_VALUE='CW_FIELD_GET', $
			FRAME=Frame )
    Label	= WIDGET_LABEL(Base, VALUE=Title, FONT=LabelFont)
    Text	= WIDGET_TEXT(Base, VALUE=STRTRIM(Value,2), $
			XSIZE=XSize, YSIZE=YSize, FONT=FieldFont, $
			ALL_EVENTS=AllEvents, $
			EDITABLE=(AllEvents AND TYPE EQ 0), $
			FRAME=TextFrame )

			; NO_ECHO=(AllEvents AND (TYPE NE 0)))

	; Save our internal state in the first child widget
    State	= {		$
	TextId:Text,		$
	Title:Title,		$
	Update:Update,		$
	Type:Type		$
    }
    WIDGET_CONTROL, WIDGET_INFO(Base, /CHILD), SET_UVALUE=State, /NO_COPY
    RETURN, Base
END
; $Id: cw_form.pro,v 1.1 1995/01/28 18:10:14 dave Exp $
; Copyright (c) 1995, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_FORM
;
; PURPOSE:
;	CW_FORM is a compound widget that simplifies creating
;	forms which contain text, numeric fields, buttons, 
;	and droplists.  Event handling is also simplified.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	widget = CW_FORM([Parent,] Desc)
;
; INPUTS:
;       Parent:	The ID of the parent widget.  Omitted for a top level 
;		modal widget.

; Desc: A string array describing the form.  Each element of the
;	string array contains two or more comma delimited fields.  The
;	character '\' may be used to escape commas that appear within fields.
;	To include the backslash character, escape it with a second
;	backslash.
;
;	The fields are defined as follows:
;
; Field 1: Depth: the digit 0, 1, 2, or 3.  0 continues the current
;	level, 1 begins a new level, 2 denotes the last element of the
;	current level, and 3 both begins a new level and is the last entry of
;	the current level.  Nesting is used primarily with row or column 
;	bases for layout.  See the example below.
; Field 2: Item type: BASE, BUTTON, DROPLIST, FLOAT, INTEGER, LABEL, or TEXT.
;	The items return the following value types:
;	BUTTON - For single buttons, 0 if clear, 1 if set.
;		For multiple buttons, also called button groups, that are
;		exclusive the index of the set button is returned.  For
;		non-exclusive button groups, the value is an array
;		an element for each button containing 1
;		if the button is set, 0 otherwise.
;	DROPLIST - a 0 based index indicating which item is selected.
;	FLOAT, INTEGER, TEXT - return their respective data type.
;
; Field 3: Initial value.  Omitted for bases.
;	For BUTTON and DROPLIST items, the value field contains one
;		or more item names, delimited by the | character.
;	For FLOAT, INTEGER, LABEL, and TEXT items the value field contains the
;		initial value of the field.
;
; Fields 4 and following: Keywords or Keyword=value pairs that specify
;	optional attributes or options.  Possibilities include:
;
;	COLUMN	If present, specifies column layout.
;	EXCLUSIVE  If present makes an exclusive set of buttons.  The
;		default is nonexclusive.
;	FONT=<font name>  If present, the font for the item is specified.
;	FRAME:	If present, a frame is drawn around the item.
;	LABEL_LEFT=<label>  annotate a button or button group with a label
;		placed to the left of the buttons.  Valid with BUTTON,
;		DROPLIST, FLOAT, INTEGER and TEXT items.
;	LABEL_TOP=<label> annotate a button or button group with a label
;		placed at the top of the buttons.  Valid with BUTTON,
;		DROPLIST, FLOAT, INTEGER and TEXT items.
;	LEFT, CENTER, or RIGHT   Specifies alignment of label items.
;	QUIT	If present, when the user activiates this entry when it
;		is activated as a modal widget, the form is destroyed
;		and its value returned as the result of CW_FORM.  For non-
;		modal form widgets, events generated by changing this item
;		have their QUIT field set to 1.
;	ROW	If present, specifies row layout.
;	SET_VALUE  Sets the initial value of button groups.
;	TAG=<name>   the tag name  of this element.  The widget's value
;		is a structure corresponding to the form.  Each form item
;		has a corresponding tag-value pair in the widget's value.
;		Default = TAGnnn, where nnn is the index of the item
;		in the Desc array.
;	WIDTH=n Specifies the width, in characters, of a TEXT, INTEGER,
;		or FLOAT item.
;	
; KEYWORD PARAMETERS:
;	COLUMN:		  If set the main orientation is vertical, otherwise
;			  horizontal.
;	IDS:		  A named variable into which the widget id of
;				each widget corresponding to an element
;				in desc is stored.
;	TITLE:		  The title of the top level base.  Not used
;			  if a parent widget is supplied.
;	UVALUE:		  The user value to be associated with the widget.
;
; OUTPUTS:
;       If Parent is supplied, the result is the ID of the base containing
;	the form.  If Parent is omitted, the form is realized as a modal
;	top level widget. The function result is then a structure containing
;	the value of each field in the form when the user finishes.
;
;	This widget has a value that is a structure with a tag/value pair
;	for each field in the form.  WIDGET_CONTROL, id, GET_VALUE=v may
;	be used to read the current value of the form.  WIDGET_CONTROL, id,
;	SET_VALUE={ Tagname: value, ..., Tagname: value} sets the values
;	of one or more tags.
;
; SIDE EFFECTS:
;	Widgets are created.
;
; RESTRICTIONS:
;	
; EXAMPLES:

;	**** Define a form, with a label, followed by two vertical button
;	groups one non-exclusive and the other exclusive, followed by a text
;	field, and an integer field, followed lastly by OK and Done buttons.
;	If either the OK or Done buttons are pressed, the form is exited.
;	
;
;		; String array describing the form
;	desc = [ $
;	    '0, LABEL, Centered Label, CENTER', $
;		; Define a row base on a new depth.  All elements until a depth
;		; of two are included in the row.
; 	    '1, BASE,, ROW, FRAME', $
; 	    '0, BUTTON, B1|B2|B3, LABEL_TOP=Nonexclusive:, COLUMN, TAG=bg1', $
;		; This element terminates the row.
; 	    '2, BUTTON, E1|E2|E2, EXCLUSIVE,LABEL_TOP=Exclusive,COLUMN,TAG=bg2', $
; 	    '0, TEXT, , LABEL_LEFT=Enter File name:, WIDTH=12, TAG=fname', $
;	    '0, INTEGER, 0, LABEL_LEFT=File size:, WIDTH=6, TAG=fsize', $
;	    '1, BASE,, ROW', $
;	    '0, BUTTON, OK, QUIT,FONT=*helvetica-medium-r-*-180-*,TAG=OK', $
;	    '2, BUTTON, Cancel, QUIT']
;
;    To use the form in a modal manner:
;	  a = CW_FORM(desc, /COLUMN)
;	  help, /st,a
;    When the form is exited, (when the user presses the OK or Cancel buttons), 
;	the following structure is returned as the function's value:
;		BG1             INT       Array(3)  (Set buttons = 1, else 0)
;		BG2             INT              1  (Exclusive: a single index)
;		FNAME           STRING    'test.dat' (text field)
;		FSIZE           LONG               120 (integer field)
;		OK              LONG                 1 (this button was pressed)
;		TAG8            LONG                 0 (this button wasn't)
;	Note that if the Cancel button is pressed, the widget is exited with
;	the OK field set to 0.
;
;  *****************
;
;    To use CW_FORM inside another widget:
;	    a = widget_base(title='Testing')
;	    b = cw_form(a, desc, /COLUMN)
;	    WIDGET_CONTROL, a, /real
;	    xmanager, 'Test', a
;	In this example, an event is generated each time the value of
;	the form is changed.  The event has the following structure:
;	   ID              LONG                <id of CW_FORM widget>
;	   TOP             LONG                <id of top-level widget>
;	   HANDLER         LONG                <internal use>
;	   TAG             STRING    'xxx'	; name of field that changed
;	   VALUE           INT       xxx	; new value of changed field
;	   QUIT            INT              0	; quit flag
;    The event handling procedure (in this example, called TEST_EVENT), may use
;	the TAG field of the event structure to determine which field
;	changed and perform any data validation or special actions required.
;	It can also get and set the value of the widget by calling
;	WIDGET_CONTROL.
;    A simple event procedure might be written to monitor the QUIT field
;	of events from the forms widget, and if set, read and save the
;	widget's value, and finally destroy the widget.
;
;    To set or change a field within the form from a program, use a the
;	WIDGET_CONTROL procedure:
;	   	WIDGET_CONTROL, b, SET_VALUE={FNAME: 'junk.dat'}
;	This statement sets the file name field of this example.
;
; MODIFICATION HISTORY:
;	January, 1995.  DMS, Written.
;-
;


function CW_FORM_PARSE, Extra, Name, Value, Index=Index
; Given the extra fields in the string array Extra,
;	determine if one field starts with Name.
; If so, return TRUE, otherwise FALSE.
; If the field contains the character '=' after Name, return the contents
; of the field following the equal sign.
; Return the index of the found element in Index.
;

found = where(strpos(extra, name) eq 0, count)
if count eq 0 then return, 0
if count gt 1 then message,'Ambiguous field name: '+name, /CONTINUE

index = found(0)
item = extra(index)
nlen = strlen(name)
value = ''			;Assume no value
equal = strpos(item,'=',nlen) ;Find = character
if equal ge 0 then value = strmid(item, equal+1, 1000) ;Extract following
extra(index)=''			;clean it out...
return, 1
end


pro CW_FORM_APPEND, extra, e, keyword, USE_VALUE=use_value, ACTUAL_KEYWORD=akw
if CW_FORM_PARSE(e, keyword, value) then begin
    if n_elements(akw) le 0 then akw = keyword
    if KEYWORD_SET(use_value) eq 0 then value = 1
    if n_elements(extra) eq 0 then extra = create_struct(akw, value) $
    else extra = create_struct(extra, akw, value)
endif
end



pro CW_FORM_LABEL, parent, nparent, e, frame
;Put LABEL_LEFT and/or LABEL_RIGHT on a base.

nparent = parent
    
if CW_FORM_PARSE(e, 'LABEL_LEFT', value) then begin
	nparent = WIDGET_BASE(nparent, /ROW, FRAME=frame)
	frame = 0
	junk1 = WIDGET_LABEL(nparent, VALUE=value)
	endif
if CW_FORM_PARSE(e, 'LABEL_TOP', value) then begin
	nparent = WIDGET_BASE(nparent, /COLUMN, FRAME=frame)
	frame = 0
	junk1 = WIDGET_LABEL(nparent, VALUE=value)
	endif
end



pro CW_FORM_BUILD, parent, desc, cur, ids, lasttag
; Recursive routine that builds the form hierarchy described in DESC.
; Returns the ID of each button in ids.

; Format of a field descriptor:
; Field 0,  Flags: 
; Field 1, Type of item.  BASE, LABEL, INTEGER, FLOAT, DROPLIST,
;	EXCLUSIVE_BUTTONS, TEXT
; Field 2, Value of item...
; Fields >= 3, optional flags
;
;
; Type id = 0 for bgroup, 1 for droplist, 2 for button,
;	3 for integer, 4 for float, 5 for text.
;
  n = n_elements(desc)

  while cur lt n do begin
    a = str_sep(desc(cur), ',', /TRIM, ESC='\')
    if n_elements(a) lt 2 then $
	message,'Form element '+strtrim(cur,2)+'is missing a field separator'
    extra=0			;Clear extra keywords by making it undefined
    junk = temporary(extra)	;Clear common param list
    type = -1			;Assume type == no events.
    quit = 0
    frame = 0
    if n_elements(a) gt 3 then begin	;Addt'l common params?
	e = a(3:*)		;Remove leading/trailing blanks
	quit = CW_FORM_PARSE(e, 'QUIT')
	frame = CW_FORM_PARSE(e, 'FRAME')
	CW_FORM_APPEND, extra, e, 'FONT', /USE_VALUE
	CW_FORM_APPEND, extra, e, 'COLUMN'
	CW_FORM_APPEND, extra, e, 'ROW'
	CW_FORM_APPEND, extra, e, 'LEFT', ACTUAL='ALIGN_LEFT'
	CW_FORM_APPEND, extra, e, 'CENTER', ACTUAL='ALIGN_CENTER'
	CW_FORM_APPEND, extra, e, 'RIGHT', ACTUAL='ALIGN_RIGHT'
    endif else e = ''

    case a(1) of		;Which widget type?
'BASE': BEGIN
    new = WIDGET_BASE(parent, FRAME=frame, _EXTRA=extra)
    ENDCASE
'BUTTON': BEGIN
    CW_FORM_APPEND, extra, e, 'LABEL_LEFT', /USE_VALUE
    CW_FORM_APPEND, extra, e, 'LABEL_TOP', /USE_VALUE
    CW_FORM_APPEND, extra, e, 'SET_VALUE', /USE_VALUE
    exclusive = CW_FORM_PARSE(e,'EXCLUSIVE')
    values = str_sep(a(2),'|', ESC='\')
    if n_elements(values) ge 2 then begin
        type = 0
        new = CW_BGROUP(parent, str_sep(a(2),'|'),  $
		        EXCLUSIVE = exclusive, NONEXCLUSIVE = 1-exclusive, $
		        FRAME=frame, _EXTRA=extra)
        WIDGET_CONTROL, new, GET_VALUE=value
    endif else begin
        type = 2
	new = WIDGET_BUTTON(parent, value=values(0), FRAME=frame, _EXTRA=extra)
	value = 0L
    endelse
    uextra = { value: value }
    ENDCASE
'DROPLIST': BEGIN
    CW_FORM_LABEL, parent, nparent, e, frame
    new = WIDGET_DROPLIST(nparent, VALUE = str_sep(a(2), '|'), $
		FRAME=frame, UVALUE=ids(n), _EXTRA=extra)
    uextra = { VALUE: 0L }
    type = 1
    ENDCASE
'INTEGER': BEGIN
    type = 3
    value = 0L
process_integer:
    uextra = { VALUE: value }    
    CW_FORM_LABEL, parent, nparent, e, frame
    if CW_FORM_PARSE(e, 'WIDTH', temp) then width = fix(temp) else width=6
    new = WIDGET_TEXT(nparent, /ALL_EVENTS, /EDITABLE, YSIZE=1, $
		XSIZE=width, UVALUE=ids(n))
    if n_elements(a) ge 3 then BEGIN		;Save value
	WIDGET_CONTROL, new, SET_VALUE=a(2)
	uextra.value = a(2)
	endif
   ENDCASE
'FLOAT': BEGIN
    type = 4
    value = 0.0
    goto, process_integer
    ENDCASE
'LABEL': BEGIN
    new = WIDGET_LABEL(parent, value=a(2), FRAME=frame, _EXTRA=extra)
    ENDCASE
'TEXT': BEGIN
    type=5
    value = ''
    goto, process_integer
    ENDCASE
else: BEGIN
	MESSAGE,'Illegal form element type: ' + a(1), /CONTINUE
	new = WIDGET_BASE(parent)
    ENDCASE
ENDCASE

    ids(cur) = new
    if type ge 0 then begin
	if CW_FORM_PARSE(e, 'TAG', value) then value = STRUPCASE(value) $
	else value='TAG'+strtrim(cur,2)	  ;default name = TAGnnn.
        u = CREATE_STRUCT( $
		{ type: type, base: ids(n+1), tag:value, next: 0L, quit:quit}, $
		uextra)
	widget_control, new, SET_UVALUE= u
		;First tag?  If so, set child uvalue -> important widget ids.
	if lasttag eq 0 then begin
	    WIDGET_CONTROL, ids(n), GET_UVALUE=tmp, /NO_COPY
	    tmp.head = new
	    WIDGET_CONTROL, ids(n), SET_UVALUE=tmp, /NO_COPY
	endif else begin		;Otherwise, update chain.
	    WIDGET_CONTROL, lasttag, GET_UVALUE=u, /NO_COPY
	    u.next = new
	    WIDGET_CONTROL, lasttag, SET_UVALUE=u, /NO_COPY
	    endelse
	lasttag = new
	endif			;Type

    i = where(strlen(e) gt 0, count)
    if count gt 0 then begin	;Unrecognized fields?
	Message, /CONTINUE, 'Descriptor: '+ desc(cur)
	for j=0, count-1 do message, /CONTINUE, 'Unrecognized field: '+ e(i(j))
	endif

    cur = cur + 1
    dflags = fix(a(0))		;Level flags
    if dflags and 1 then CW_FORM_BUILD, new, desc, cur, ids, lasttag  ;Begin new
    if (dflags and 2) ne 0 then return	;End current
  endwhile
end				;CW_FORM_BUILD



Function CW_FORM_EVENT, ev		;Event handler for CW_FORM
widget_control,   ev.id, GET_UVALUE=u, /NO_COPY  ;What kind of widget?

if u.type eq 1 then begin	;Droplist?  (can't get value)
    v = ev.index
    u.value = v
endif else if u.type eq 2 then begin
    v = ev.select
    u.value=v
endif else begin		;Other types of widgets
    WIDGET_CONTROL, ev.id, GET_VALUE=v
    if u.type ge 3 then begin  ;Toss selection events from text widgets
	v = v(0)
        ret = 0
	if ev.type eq 3 then goto, toss
	endif
    on_ioerror, invalid
    u.value = v			;Does an implicit conversion
    v = u.value
    goto, back_in

; We come here if we get an invalid number.  
invalid: WIDGET_CONTROL, ev.id, SET_VALUE=''  ;Blank it out
    v = ''
    u.value = ''
endelse			;u.type

back_in: ret= { id: u.base, top: ev.top, handler: 0L, $
		tag: u.tag, value: v, quit: u.quit} ;Our value
toss: widget_control, ev.id, SET_UVALUE=u, /NO_COPY	;Save new value...
return, ret
end			;CW_FORM_EVENT


Pro CW_FORM_SETV, id, value	;In this case, value = { Tagname : value, ... }
x = WIDGET_INFO(id, /CHILD)	;Get head of list
WIDGET_CONTROL, x, GET_UVALUE=u
head = u.head
tags = tag_names(value)
n = n_elements(tags)

while head ne 0 do begin
    WIDGET_CONTROL, head, GET_UVALUE=u, /NO_COPY
    w = where(u.tag eq tags, count)
    if count ne 0 then begin
;	u.value = value.(w(0))	;Set the value
	if u.type ne 2 then WIDGET_CONTROL, head, $
;			SET_VALUE=value.(w(0)) ;Change the widget
	n = n - 1
	endif
    next = u.next
    WIDGET_CONTROL, head, SET_UVALUE=u, /NO_COPY
    if n le 0 then return		;Done...
    head = next
endwhile
end


Function CW_FORM_GETV, id	;Return value of a CW_FORM widget.

x = WIDGET_INFO(id, /CHILD)	;Get head of list
WIDGET_CONTROL, x, GET_UVALUE=u
head = u.head

while head ne 0 do begin
    WIDGET_CONTROL, head, GET_UVALUE=u, /NO_COPY
    if n_elements(ret) le 0 then ret = CREATE_STRUCT(u.tag, u.value) $
    else ret = CREATE_STRUCT(ret, u.tag, u.value)
    next = u.next
    WIDGET_CONTROL, head, SET_UVALUE=u, /NO_COPY
    head = next
endwhile
return, ret
end


pro cw_form_modal_event, ev
if ev.quit ne 0 then begin
    child = WIDGET_INFO(ev.id, /CHILD)
    WIDGET_CONTROL, child, GET_UVALUE=u  ;Get handle
    WIDGET_CONTROL, ev.id, GET_VALUE=v  ;The widget's value
    WIDGET_CONTROL, ev.top, /DESTROY
    HANDLE_VALUE, u.handle, v, /SET
    endif
end

FUNCTION CW_FORM, parent, desc, $
	COLUMN = column, IDS=ids, TITLE=title, UVALUE=uvalue

;  ON_ERROR, 2						;return to caller
  ; Set default values for the keywords
  If KEYWORD_SET(column) then row = 0 else begin row = 1 & column = 0 & end

  p = parent
  handle = 0L
  if n_params() eq 1 then begin
	desc = parent
	if n_elements(title) le 0 then title='FORM Widget'
	p = WIDGET_BASE(TITLE=title, Column = column, row=row)
	handle = handle_create()
  endif
  Base = WIDGET_BASE(p, Column = column, row=Row)

  if n_elements(uvalue) gt 0 then WIDGET_CONTROL, base, SET_UVALUE=uvalue
  n = n_elements(desc)
  ids = lonarr(n+2)		;Element n is ^ to child, n+1 ^ to base
  child = WIDGET_BASE(base)	;Widget to contain info...
  ids(n) = child
  ids(n+1) = base
  lasttag = 0
  WIDGET_CONTROL, child, SET_UVALUE={ head: 0L, base: base, handle: handle}

  CW_FORM_BUILD, base, desc, 0, ids, lasttag
  widget_control, base, EVENT_FUNC='CW_FORM_EVENT', $
	FUNC_GET_VALUE='CW_FORM_GETV', PRO_SET_VALUE='CW_FORM_SETV'

  if n_params() eq 1 then begin		;Modal?
	WIDGET_CONTROL, p, /realize
	XMANAGER, 'CW_FORM', p, EVENT_HANDLER='CW_FORM_MODAL_EVENT', /MODAL
	HANDLE_VALUE, handle, v, /NO_COPY
	HANDLE_FREE, handle
	return, v
	endif
  return, base
END

; $Id: cw_fslider.pro,v 1.5 1994/02/10 22:11:18 dave Exp $
; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_FSLIDER
;
; PURPOSE:
;	The standard slider provided by the WIDGET_SLIDER() function is
;	integer only. This compound widget provides a floating point
;	slider.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	widget = CW_FSLIDER(Parent)
;
; INPUTS:
;       Parent:		The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	DRAG:		Set this keyword to zero if events should only
;			be generated when the mouse is released. If it is
;			non-zero, events will be generated continuously
;			when the slider is adjusted. Note: On slow systems,
;			/DRAG performance can be inadequate. The default
;			is DRAG=0.
;       EDIT:		Set this keyword to make the slider label be
;			editable. The default is EDIT=0.
;	FORMAT:		Provides the format in which the slider value is
;			displayed. This should be a format as accepted by
;			the STRING procedure. The default is FORMAT='(G13.6)'
;	FRAME:		Set this keyword to have a frame drawn around the
;			widget. The default is FRAME=0.
;	MAXIMUM:	The maximum value of the slider. The default is 
;			MAXIMUM=100.
;	MINIMUM:	The minimum value of the slider. The default is
;			MINIMUM=0.
;	SUPPRESS_VALUE:	If true, the current slider value is not displayed.
;			The default is SUPPRESS_VALUE=0.
;	TITLE:		The title of slider. (The default is no title.)
;	UVALUE:		The user value for the widget.
;	VALUE:		The initial value of the slider
;	VERTICAL:	If set, the slider will be oriented vertically.
;			The default is horizontal.
;	XSIZE:		For horizontal sliders, sets the length.
;	YSIZE:		For vertical sliders, sets the height.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; SIDE EFFECTS:
;	This widget generates event structures containing a field
;	named value when its selection thumb is moved. This is a
;	floating point value.
;
; PROCEDURE:
;	WIDGET_CONTROL, id, SET_VALUE=value can be used to change the
;		current value displayed by the widget.
;
;	WIDGET_CONTROL, id, GET_VALUE=var can be used to obtain the current
;		value displayed by the widget.
;
; MODIFICATION HISTORY:
;	April 2, 1992, SMR and AB
;		Based on the RGB code from XPALETTE.PRO, but extended to
;		support color systems other than RGB.
;	5 January 1993, Mark Rivers, Brookhaven National Labs
;		Added EDIT keyword. 
;       7 April 1993, AB, Removed state caching.
;	28 July 1993, ACY, set_value: check labelid before setting text.
;-


PRO fslider_set_value, id, value

  ; Set the value of both the slider and the label
  ON_ERROR, 2						;return to caller

  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  WIDGET_CONTROL, state.slideid, $
	SET_VALUE = 1000000. * $
		(float(value) - state.bot) / (state.top - state.bot)
  IF (state.labelid NE 0) THEN $
  	WIDGET_CONTROL, state.labelid, $
		SET_VALUE = STRING(FLOAT(value), format=state.format)

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
END



FUNCTION fslider_get_value, id

  ; Return the value of the slider
  ON_ERROR, 2						;return to caller

  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  WIDGET_CONTROL, state.slideid, GET_VALUE = tmp
  ret = ((tmp / 1000000.) * (state.top - state.bot)) + state.bot

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY 
  return, ret
END


;-----------------------------------------------------------------------------

FUNCTION fslide_event, ev

  ; Retrieve the structure from the child that contains the sub ids
  parent=ev.handler
  stash = WIDGET_INFO(parent, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY


  ; See which widget was adjusted, the slider or the label

  if (ev.id eq state.slideid) then begin
    ; Get the non-adjusted value
    WIDGET_CONTROL, state.slideid, GET_VALUE = nonadj
    ; Compute the floating point value
    value = ((nonadj / 1000000.) * (state.top - state.bot)) + state.bot
    drag = ev.drag
    ; Update label
    IF (state.labelid NE 0) THEN $
      WIDGET_CONTROL, state.labelid, $
           SET_VALUE=STRING(value, format=state.format)

  endif else if (ev.id eq state.labelid) then begin

    WIDGET_CONTROL, state.labelid, GET_VALUE = tmp

    value = float(tmp(0))
    value = value > state.bot
    value = value < state.top
    ;Update the slider, set new value
    WIDGET_CONTROL, state.slideid, $
	SET_VALUE = 1000000. * $
		(value - state.bot) / (state.top - state.bot)

    drag = 0
    ; Update the label so it has desired format
    WIDGET_CONTROL, state.labelid, $
           SET_VALUE=STRING(value, format=state.format)
  endif

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  RETURN, { ID:parent, TOP:ev.top, HANDLER:0L, VALUE:value, DRAG:drag }
END

;-----------------------------------------------------------------------------

FUNCTION cw_fslider, parent, $
		DRAG = drag, $
                EDIT = edit, $
		FRAME = frame, $
		MAXIMUM = max, $
		MINIMUM = min, $
		SUPPRESS_VALUE = sup, $
		TITLE = title, $
		UVALUE = uval, $
		VALUE = val, $
		VERTICAL = vert, $
		XSIZE = xsize, $
		YSIZE = ysize, $
		FORMAT=format

  IF (N_PARAMS() EQ 0) THEN MESSAGE, 'Incorrect number of arguments'

  ON_ERROR, 2						;return to caller

  ; Defaults for keywords
  IF NOT (KEYWORD_SET(drag))  THEN drag = 0
  IF NOT (KEYWORD_SET(edit))  THEN edit = 0
  IF NOT (KEYWORD_SET(frame)) THEN frame = 0
  IF N_ELEMENTS(max) EQ 0     THEN max = 100.0
  IF N_ELEMENTS(min) EQ 0     THEN min = 0.0
  IF NOT (KEYWORD_SET(sup))   THEN sup = 0
  IF NOT (KEYWORD_SET(title)) THEN title = ""
  IF NOT (KEYWORD_SET(uval))  THEN uval = 0
  IF NOT (KEYWORD_SET(val))   THEN val = min
  IF NOT KEYWORD_SET(format)  THEN format='(G13.6)'

  state = {slideid:0L, labelid:0L, top:max, bot:min, format:format }

  ; Motif 1.1 and newer sliders react differently to XSIZE and YSIZE
  ; keywords than Motif 1.0 or OpenLook. These defs are for horizontal sliders
  version = WIDGET_INFO(/version)
  newer_motif = (version.style eq 'Motif') and (version.release ne '1.0')

  ; The sizes of the parts depend on keywords and whether or not the
  ; float slider is vertical or horizontal
  ;these are display specific and known to be inherently evil
  sld_thk = 16
  chr_wid = 7
  IF (KEYWORD_SET(vert)) THEN BEGIN
    if (newer_motif) then begin
      if (not KEYWORD_SET(xsize)) then xsize = 0
    endif else begin
      title_len = STRLEN(title) * chr_wid
      xsize = (sld_thk * 1.4) + title_len	; Take label into account
    endelse
    IF NOT (KEYWORD_SET(ysize)) THEN ysize = 100
    l_yoff = ysize / 2
  ENDIF ELSE BEGIN					;horizontal slider
    vert = 0
    tmp = not keyword_set(xsize)
    if (newer_motif) then begin
      if (tmp) then xsize = 0
      IF NOT (KEYWORD_SET(ysize)) THEN ysize = 0
    endif else begin
      if (tmp) then xsize = 100
      IF (TITLE NE '') THEN sld_thk = sld_thk + 21
      ysize = sld_thk		; Make the slider not waste label space
    endelse
    l_yoff = 0
  ENDELSE

  if (vert) then begin
    mainbase = WIDGET_BASE(parent, FRAME = frame, /ROW)
    labelbase = WIDGET_BASE(mainbase)
  endif else begin
    mainbase = WIDGET_BASE(parent, FRAME = frame, /COLUMN)
    labelbase = mainbase
  endelse
  WIDGET_CONTROL, mainbase, SET_UVALUE = uval, EVENT_FUNC = 'fslide_event', $
	PRO_SET_VALUE='FSLIDER_SET_VALUE', $
	FUNC_GET_VALUE='FSLIDER_GET_VALUE'



  IF (sup EQ 0) THEN $
    ; Only build the label if suppress_value is FALSE
    state.labelid = WIDGET_TEXT(labelbase, YOFFSET = l_yoff, $
		VALUE = STRING(FLOAT(val), format=state.format), $
                edit=edit) $
  ELSE state.labelid = 0

    state.slideid = WIDGET_SLIDER(mainbase, $
		TITLE = TITLE, $
		XSIZE = xsize, $
		YSIZE = ysize, $
		/SUPPRESS_VALUE, $
		MINIMUM = 0, $
		MAXIMUM = 1000000, $
		VALUE = 1000000. * $
			(float(val) - state.bot) / $
			(state.top - state.bot), $
		VERTICAL = vert, $
		DRAG=drag, $
		SCROLL=10000)

  
  WIDGET_CONTROL, WIDGET_INFO(mainbase, /CHILD), SET_UVALUE=state, /NO_COPY
  RETURN, mainbase

END
; $Id: cw_orient.pro,v 1.4 1993/10/07 23:06:44 doug Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

PRO drawbox, state, FINAL = FINAL

	; This routine is responsible for drawing the cube when the
	; cw_orient compound widget is in the trackball mode.  When 
	; the FINAL keyword is set, the view is first erased and then
	; the origin indicator is added.

  COMMON CW_ORIENT_BOX, box, faces, norms

  wind = !D.WINDOW				; set to the view window and
  wset, state.trackball				; make sure to save the old

  IF (KEYWORD_SET(final)) THEN ERASE

  IF ( NOT(KEYWORD_SET(box))) THEN BEGIN	; build the face vertices
						; topology and normals only
						; once
    verts = [[.15, .15, .15],[.15, .15, .85],[.15, .85, .85],[.15, .85, .15], $
	     [.85, .15, .15],[.85, .15, .85],[.85, .85, .85],[.85, .85, .15]]

    faces = [[0,1,2,3,0], $
             [1,2,6,5,1], $
             [4,5,6,7,4], $
             [4,7,3,0,4], $
             [2,6,7,3,2], $
             [1,5,4,0,1]]

    norms = [[-1, 0, 1, 0, 0, 0, 0], $		; The last entry in the norms
	     [0, 0, 0, 0, 1, -1, 0], $		; is the origin.  Each normal
	     [0, 1, 0, -1, 0, 0, 0], $		; is a vector from the origin
	     [1, 1, 1, 1, 1, 1, 1 ]] 		; to the endpoint in +/- XYZ.
  ENDIF
  ns = norms # !P.T				; Translate the norms for the
						; current !P.T
  FOR i = 0, 5 DO BEGIN
    IF (ns(6,2) - ns(i,2) LT 0) THEN $		; Compute the Z component of
	PLOTS, verts(*, faces(*,i)), $		; each normal and if it is less
		/T3D, /NORMAL, $		; than zero, the cooresponding
		COLOR = !D.N_COLORS / 2		; face can be seen so draw it.
  ENDFOR

  IF (KEYWORD_SET(FINAL)) THEN BEGIN		; If a final drawing, then
    plots, [.15, .15, .15], $			; draw the little origin 
	   [.25, .15, .15], $			; indicator.
	   [.15, .15, .25], /T3D, /NORMAL
    plots, [.25, .15], $
	   [.15,.15], $
	   [.15,.15], /T3D, /NORMAL
  ENDIF

  WSET, wind
END ; end of drawbox routine

;---------------------------------------------------------------------------

function CW_ORIENT_EVENT, ev

  COMMON CW_OR_PRIVATE, scaler
  COMMON CW_TMP, xlast, zlast, xrot, zrot

  base = ev.handler
  stash = WIDGET_INFO(base, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY


  CASE ev.id OF

    state.modemenu: BEGIN

      CASE ev.value OF

	1: BEGIN; If slider mode was selected, map the sliders and set current.
            IF (state.currentbase NE state.slidebase) THEN BEGIN
	      WIDGET_CONTROL, state.slidebase, MAP = 1
	      WIDGET_CONTROL, state.currentbase, MAP = 0
	      state.currentbase = state.slidebase
	    ENDIF
	    GOTO, SWALLOW_EV_RET
	  END

	2: BEGIN; If trackball mode was selected, make sure window id is known
	    IF (state.trackballid NE state.currentbase) THEN BEGIN
	      WIDGET_CONTROL, state.trackbase, MAP = 1
	      WIDGET_CONTROL, state.currentbase, MAP = 0
	      state.currentbase = state.trackballid
	      IF state.trackball EQ 0 THEN BEGIN
		WIDGET_CONTROL, state.trackballid, GET_VALUE = temp
		state.trackball = temp(0)
	      ENDIF
	      drawbox, state, /FINAL
	    ENDIF
	    GOTO, SWALLOW_EV_RET
	  END

	3: BEGIN; If reset menu selection was made.
	    WIDGET_CONTROL, state.xslide, GET_UVALUE = xrot
	    WIDGET_CONTROL, state.zslide, GET_UVALUE = zrot
	    t3d, /RESET, TRANSLATE = [-.5, -.5, -.5], SCALE = scaler
	    t3d, ROTATE = [-90, xrot, 0]
	    t3d, ROTATE = [zrot, 0, 0]
	    t3d, TRANSLATE = [.5, .5, .5]
	    WIDGET_CONTROL, state.xslide, SET_VALUE = xrot
	    WIDGET_CONTROL, state.zslide, SET_VALUE = zrot
	    IF (state.trackballid EQ state.currentbase) THEN $
	      drawbox, state, /FINAL
	  END
	ENDCASE ; End of ev.value CASE
      END ; End of case state.modemenu.

    state.trackballid: BEGIN
	IF ev.press THEN BEGIN
		; Begin tracking the trackball as the mouse button is down.
		; Set the drawing mode to XOR
	  WIDGET_CONTROL, state.xslide, GET_VALUE = xrot
	  WIDGET_CONTROL, state.zslide, GET_VALUE = zrot
	  xlast = ev.x
	  zlast = ev.y
	  state.trackmode = 1
	  DEVICE, SET_GRAPHICS_FUNCTION = 6
	  GOTO, SWALLOW_EV_RET
	ENDIF

	IF ev.release THEN BEGIN
		; Once finished tracking, do range checking and then restore
		; drawing mode and redraw the cube.
	  IF (xrot LT 0) THEN xrot = xrot + 360
	  IF (zrot LT 0) THEN zrot = zrot + 360
	  IF (xrot GT 360) THEN xrot = xrot - 360
	  IF (zrot GT 360) THEN zrot = zrot - 360
	  WIDGET_CONTROL, state.xslide, SET_VALUE = xrot
	  WIDGET_CONTROL, state.zslide, SET_VALUE = zrot
  	  state.trackmode = 0
  	  DEVICE, SET_GRAPHICS_FUNCTION = 3
  	  drawbox, state, /FINAL
	ENDIF

	IF state.trackmode THEN BEGIN
  	  drawbox, state
		; For each direction, figure out the magnitude of movement
		; first and then the direction.
	  IF (xlast NE ev.x) THEN BEGIN
  	    xangle = ASIN((100.0 - ABS(xlast-ev.x)) / 100.0) * 1.7
	    IF ((xlast - ev.x) LT 0) THEN xangle = -xangle
  	    xlast = ev.x
  	  ENDIF ELSE xangle = 0

	  IF (zlast NE ev.y) THEN BEGIN
	    zangle = -ASIN((100.0 - ABS(zlast-ev.y)) / 100.0) * 1.7
	    IF ((zlast - ev.y) LT 0) THEN zangle = -zangle
	    zlast = ev.y
	  ENDIF ELSE zangle = 0

	  xrot = xrot - xangle			; Apply the changes to the
	  zrot = zrot - zangle			; rotation values.

	  t3d, /RESET, TRANSLATE = [-.5, -.5, -.5], SCALE = scaler
	  t3d, ROTATE = [-90, xrot, 0]
	  t3d, ROTATE = [zrot, 0, 0]
	  t3d, TRANSLATE = [.5, .5, .5]

	  drawbox, state
	  GOTO, SWALLOW_EV_RET			; Don't return an event until
	ENDIF					; the user lets go.

	IF (ev.release EQ 0) THEN GOTO, SWALLOW_EV_RET
      END; case state.trackballid


    ELSE: BEGIN	; Handle the sliders which are the only events not covered
		; above.
	WIDGET_CONTROL, state.xslide, GET_VALUE = xrot
	WIDGET_CONTROL, state.zslide, GET_VALUE = zrot
	t3d, /RESET, TRANSLATE = [-.5, -.5, -.5], SCALE = scaler
	t3d, ROTATE = [-90, xrot, 0]
	t3d, ROTATE = [zrot, 0, 0]
	t3d, TRANSLATE = [.5, .5, .5]
      END

  ENDCASE ; End of ev.id CASE

  ev.id = base
  ev.handler = 0

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  RETURN, ev

swallow_ev_ret:
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  RETURN, 0

END ; End of cw_orient_event routine.

;---------------------------------------------------------------------------

FUNCTION CW_ORIENT, parent, UVALUE = UVALUE, XSIZE = XSIZE, YSIZE = YSIZE, $
			FRAME = FRAME, AX = AX, AZ = AZ, TITLE = TITLE

; Copyright (c) 1992, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_ORIENT
;
; PURPOSE:
;	This compound widget provides a means to interactively adjust the
;	three dimensional drawing transformation (!P.T). The compound
;	widget only returns events when !P.T has been altered.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	widget = CW_ORIENT(Parent)
;
; INPUTS:
;       Parent:	The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	AX:	The initial rotation in the X direction. If not set, the 
;		default is 30 degrees.
;	AZ:	The initial rotation in the Z direction. If not set, the 
;		default is 30 degrees.
;	FRAME:	If set, a frame will be drawn around the widget. The
;		default is FRAME=0.
;	TITLE:	The title of the widget. (Default is no title.)
;	UVALUE:	The user value of the widget.
;	XSIZE:	Determines the width of the widget. The default is 100.
;	YSIZE:	Determines the height of the widget. The default is 100.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; COMMON BLOCKS:
;	CW_OR_PRIVATE: Private to this module.
;
; SIDE EFFECTS:
;	This widget generates event structures each time a modification
;	to the orientation is made.  This widget also resets !P.T to 
;	reflect the changed orientation.
;
; MODIFICATION HISTORY:
;	August 7, 1992, SMR
;       7 April 1993, AB, Removed state caching.
;-

  COMMON CW_OR_PRIVATE, scaler

  ON_ERROR, 2				; Return to caller.

  	; Define the contents of the state structure.

  state = {trackball:0L, trackballid:0L, $
		slidebase:0L, trackbase:0L, currentbase:0L, $
		xslide:0L, zslide:0L, $
		trackmode:0, modemenu:0L}

  	; Set default values for the keywords.

  IF N_ELEMENTS(FRAME) NE 0	THEN frm = 1 ELSE frm = 0
  IF N_ELEMENTS(UVALUE) NE 0	THEN uval = UVALUE ELSE uval = 0
  IF N_ELEMENTS(XSIZE) NE 0	THEN xsi = XSIZE ELSE xsi = 120
  IF N_ELEMENTS(YSIZE) NE 0	THEN ysi = YSIZE ELSE ysi = 120
  IF N_ELEMENTS(AX) NE 0	THEN xrot = AX ELSE xrot = 30
  IF N_ELEMENTS(AZ) NE 0	THEN zrot = AZ ELSE zrot = 30
  IF N_ELEMENTS(TITLE) NE 0	THEN tit = TITLE ELSE tit = ''

  orientbase = WIDGET_BASE(parent, $
			EVENT_FUNC = "CW_ORIENT_EVENT", $
			UVALUE = uval, $
			/COLUMN, $
			FRAME = frm)

  IF (TIT NE '') THEN title = WIDGET_LABEL(orientbase, $
			VALUE = TIT)

  panelbase = WIDGET_BASE(orientbase)
  state.slidebase = WIDGET_BASE(panelbase, /COLUMN, MAP = 1)
  state.currentbase = state.slidebase

  state.modemenu = cw_pdmenu(orientbase, [ $
		{CW_PDMENU_S, flags:1, name:'Orientation'}, $
		{CW_PDMENU_S, flags:0, name:'Sliders'}, $
		{CW_PDMENU_S, flags:0, name:'Trackball'},   $
		{CW_PDMENU_S, flags:0, name:'Reset Transformation'}], ids = i)

  state.xslide = WIDGET_SLIDER(state.slidebase, $
			MIN = 0, MAX = 359, VALUE = xrot, $
			TITLE = "X angle", $
			XSIZE = 120, $
			UVALUE = xrot)
  state.zslide = WIDGET_SLIDER(state.slidebase, $
			MIN = 0, MAX = 359, VALUE = zrot, $
			TITLE = "Z angle", $
			XSIZE = 120, $
			UVALUE = zrot)

  state.trackbase = WIDGET_BASE(panelbase, MAP = 0)
  state.trackballid = WIDGET_DRAW(state.trackbase, $
			XSIZE = xsi, YSIZE = ysi, $
			/MOTION, /BUTTON)

  WIDGET_CONTROL, WIDGET_INFO(orientbase, /CHILD), SET_UVALUE=state, /NO_COPY

  scaler = REPLICATE(1./SQRT(3),3)

  !X.S = [0, 1]
  !Y.S = [0, 1]
  !Z.S = [0, 1]
  t3d, /RESET, TRANSLATE = [-.5, -.5, -.5], SCALE = scaler
  t3d, ROTATE = [-90, xrot, 0]
  t3d, ROTATE = [zrot, 0, 0]
  t3d, TRANSLATE = [.5, .5, .5]

  RETURN, orientbase
END
; $Id: cw_pdmenu.pro,v 1.7 1995/07/03 15:43:54 idl Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_PDMENU
;
; PURPOSE:
;	CW_PDMENU is a compound widget that simplifies creating
;	pulldown menus. It has a simpler interface than the XPDMENU
;	procedure, which it is intended to replace. Events for the
;	individual buttons are handled transparently, and a CW_PDMENU
;	event returned. This event can return any one of the following:
;               - The Index of the button within the base.
;               - The widget ID of the button.
;               - The name of the button.
;		- The fully qualified name of the button. This allows
;		  different sub-menus to contain buttons with the same
;		  name in an unambiguous way.
;
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	widget = CW_PDMENU(Parent, Desc)
;
; INPUTS:
;       Parent:	The ID of the parent widget.
;	Desc:	An array of strings or structures.  Each element contains
;		a menu description with two fields, a flag field, and
;		the name of the item.  If a structure, each element
;		is defined as follows:
;			{ CW_PDMENU_S, flags:0, name:'' }
;
;		The name tag gives the name of button. The flags
;		field is a two-bit bitmask that controls how the button is
;		interpreted:
;
;		    Value	   Meaning
;		    -------------------------------------------
;		     0     This button is neither the beginning
;			   nor the end of a pulldown level.
;		     1     This button is the root of a
;                          sub-pulldown menu. The sub-buttons
;			   start with the next button.
;		     2     This button is the last button at the
;			   current pulldown level. The next button
;			   belongs to the same level as the current
;			   parent button.
;		     3     This button is the root of a sub-pulldown
;			   menu, but it is also the last entry of
;			   the current level.
;
;	If Desc is a string, each element contains the flag field
;	followed by a backslash character, followed by the menu item's
;	contents.  See the example below.
;
;	EVENT PROCEDURES:  An event procedure may be specified for an
;	element and all its children, by including a third field
;	in Desc, if Desc is a string array.  Events for buttons without
;	an event procedure, are dispatched normally.
;	See the example below.
;
; KEYWORD PARAMETERS:
;	DELIMITER:        The character used to separate the parts of a
;			  fully qualified name in returned events. The
;			  default is to use the '.' character.
;	FONT:		  The name of the font to be used for the button
;			  titles. If this keyword is not specified, the
;			  default font is used.
;	HELP:		  If MBAR is specified and one of the buttons on the
;			  menubar has the label "help" (case insensitive) then
;			  that button is created with the /HELP keyword to
;			  give it any special appearance it is supposed to
;			  have on a menubar. For example, Motif expects
;			  help buttons to be on the right.
;	IDS:		  A named variable into which the button IDs will
;			  be stored as a longword vector.
;	MBAR:		  if constructing a menu-bar pulldown, set this
;			  keyword.  In this case, the parent must be the 
;			  widget id of the menu bar of a top-level base,
;			  returned by WIDGET_BASE(..., MBAR=mbar).
;	RETURN_ID:	  If present and non-zero, the VALUE field of returned
;			  events will be the widget ID of the button.
;	RETURN_INDEX:	  If present and non-zero, the VALUE field of returned
;			  events will be the zero-based index of the button
;			  within the base. THIS IS THE DEFAULT.
;	RETURN_NAME:	  If present and non-zero, the VALUE field of returned
;			  events will be the name of the selected button.
;	RETURN_FULL_NAME: If present and non-zero, the VALUE field of returned
;               	  events will be the fully qualified name of the
;			  selected button. This means that the names of all
;			  the buttons from the topmost button of the pulldown
;			  menu to the selected one are concatenated with the
;			  delimiter specified by the DELIMITER keyword. For
;			  example, if the top button was named COLORS, the
;			  second level button was named BLUE, and the selected
;			  button was named LIGHT, the returned value would be
;
;			  COLORS.BLUE.LIGHT
;
;			  This allows different submenus to have buttons with
;			  the same name (e.g. COLORS.RED.LIGHT).
;	UVALUE:		  The user value to be associated with the widget.
;	XOFFSET:	  The X offset of the widget relative to its parent.
;	YOFFSET:	  The Y offset of the widget relative to its parent.
;
; OUTPUTS:
;       The ID of the top level button is returned.
;
; SIDE EFFECTS:
;	This widget generates event structures with the following definition:
;
;		event = { ID:0L, TOP:0L, HANDLER:0L, VALUE:0 }
;
;	VALUE is either the INDEX, ID, NAME, or FULL_NAME of the button,
;	depending on how the widget was created.
;
; RESTRICTIONS:
;	Only buttons with textual names are handled by this widget.
;	Bitmaps are not understood.
;
; EXAMPLE:
;	The following is the description of a menu bar with two buttons,
;	"Colors" and "Quit". Colors is a pulldown containing the colors
;	"Red", "Green", Blue", "Cyan", and "Magenta". Blue is a sub-pulldown
;	containing "Light", "Medium", "Dark", "Navy", and "Royal":
;
;		; Make sure CW_PDMENU_S is defined
;		junk = { CW_PDMENU_S, flags:0, name:'' }
;
;		; The description
;		desc = [ { CW_PDMENU_S, 1, 'Colors' }, $
;			     { CW_PDMENU_S, 0, 'Red' }, $
;			     { CW_PDMENU_S, 0, 'Green' }, $
;			     { CW_PDMENU_S, 1, 'Blue' }, $
;			         { CW_PDMENU_S, 0, 'Light' }, $
;			         { CW_PDMENU_S, 0, 'Medium' }, $
;			         { CW_PDMENU_S, 0, 'Dark' }, $
;			         { CW_PDMENU_S, 0, 'Navy' }, $
;			         { CW_PDMENU_S, 2, 'Royal' }, $
;			       { CW_PDMENU_S, 0, 'Cyan' }, $
;			       { CW_PDMENU_S, 2, 'Magenta' }, $
;			 { CW_PDMENU_S, 2, 'Quit' } ]
;
;	The same menu may be defined as a string by equating the Desc parameter
;	to the following string array:
;	
;	desc =[ '1\Colors' , $
;		'0\Red' , $
;		'0\Green' , $
;		'1\Blue\BLUE_EVENT_PROC' , $
;		'0\Light' , $
;		'0\Medium' , $
;		'0\Dark' , $
;		'0\Navy' , $
;		'2\Royal' , $
;		'0\Cyan' , $
;		'2\Magenta\MAGENTA_EVENT_PROC' , $
;		'2\Quit'  ]
;
;
;	The following small program can be used with the above description
;	to create the specified menu:
;
;
;		base = widget_base()
;		menu = cw_pdmenu(base, desc, /RETURN_FULL_NAME)
;		WIDGET_CONTROL, /REALIZE, base
;		repeat begin
;		  ev = WIDGET_EVENT(base)
;		  print, ev.value
;		end until ev.value eq 'Quit'
;		WIDGET_CONTROL, /DESTROY, base
;		end
;
;	Note that independent event procedures were specified for
;	the multiple Blue buttons (blue_event_proc), and the Magenta button 
;	(magenta_event_proc).

; MODIFICATION HISTORY:
;	18 June 1992, AB
;	16 Jan 1995, DMS, Added MBAR keyword, event procedures,
;			and menu descriptor strings.
;	2 July 1995, AB, Added HELP keyword.
;-


function CW_PDMENU_EVENT, ev

  WIDGET_CONTROL, ev.id, get_uvalue=uvalue

  return, { ID:ev.handler, TOP:ev.top, HANDLER:0L, value:uvalue }

end







pro CW_PDMENU_BUILD, parent, desc, cur, n, ev_type, full_qual_str, $
	delim, ids, mbars, HELP_KW, FONT=font
; Recursive routine that builds the pulldown hierarchy described in DESC.
; Returns the ID of each button in ids.

  is_string = size(desc)
  is_string = is_string(is_string(0)+1) eq 7
  while (cur lt n) do begin
    if is_string then begin
	a = str_sep(desc(cur), '\', /TRIM)
	dflags = fix(a(0))
	dname = a(1)
    endif else begin
	dflags = desc(cur).flags
	dname = desc(cur).name
    endelse
    if (strlen(full_qual_str) ne 0) then $
      new_qstr = full_qual_str + delim + dname $
    else new_qstr = dname
	;If parented to a menu bar, don't draw a frame.
    if (dflags and 1) then menu=2-mbars else menu = 0 
    if ((mbars ne 0) and (HELP_KW ne 0) and (strupcase(dname) eq 'HELP')) then begin
        if (keyword_set(font)) then begin
          new = WIDGET_BUTTON(parent, value=dname, MENU=menu, FONT=font, /help)
        endif else begin
          new = WIDGET_BUTTON(parent, value=dname, MENU=menu, /help)
        endelse
    endif else begin
        if (keyword_set(font)) then begin
          new = WIDGET_BUTTON(parent, value=dname, MENU=menu, FONT=font)
        endif else begin
          new = WIDGET_BUTTON(parent, value=dname, MENU=menu)
        endelse
    endelse
    case ev_type of
      0: uvalue = cur
      1: uvalue = new
      2: uvalue = dname
      3: uvalue = new_qstr
    endcase
    WIDGET_CONTROL, new, SET_UVALUE=uvalue
    if n_elements(a) ge 3 then WIDGET_CONTROL, new, EVENT_PRO=a(2)
    ids(cur) = new
    cur = cur + 1
    if (dflags and 1) then $
      CW_PDMENU_BUILD,new,desc,cur,n,ev_type,new_qstr,delim,ids,mbars, 0,FONT=font
    if ((dflags and 2) ne 0) then return
  endwhile

end






function CW_PDMENU, parent, desc, COLUMN=column, DELIMITER=delim, FONT=font, $
	IDS=ids, MBAR=mbar, HELP=HELP_KW, $
	RETURN_ID=r_id, RETURN_INDEX=ignore, RETURN_NAME=r_name, $
	RETURN_FULL_NAME=r_full_name, $
	UVALUE=uvalue, XOFFSET=xoffset, YOFFSET=yoffset


  IF (N_PARAMS() ne 2) THEN MESSAGE, 'Incorrect number of arguments'

  ON_ERROR, 2						;return to caller

  ; Set default values for the keywords
  If KEYWORD_SET(column) then row = 0 else begin row = 1 & column = 0 & end
  IF (N_ELEMENTS(delim) eq 0)	then delim = '.'
  IF (N_ELEMENTS(uvalue) eq 0)	then uvalue = 0
  IF (N_ELEMENTS(xoffset) eq 0)	then xoffset=0
  IF (N_ELEMENTS(yoffset) eq 0)	then yoffset=0

  ; How to interpret ev_type:
  ;	0 - Return index
  ;	1 - Return ID
  ;	2 - Return name
  ;	3 - Return fully qualified name.
  ev_type = 0
  if (keyword_set(r_id)) 	then ev_type = 1
  if (keyword_set(r_name)) 	then ev_type = 2
  if (keyword_set(r_full_name))	then ev_type = 3


  n = n_elements(desc)
  ids = lonarr(n)
  mbars = KEYWORD_SET(mbar)
  help_kw = KEYWORD_SET(HELP_KW)
  if mbars then base = parent $
  else base = widget_base(parent, COLUMN=column, $
		     ROW=row, UVALUE=uvalue, XOFFSET=xoffset, YOFFSET=yoffset)
  WIDGET_CONTROL, base, EVENT_FUNC='CW_PDMENU_EVENT' 
 CW_PDMENU_BUILD, base, desc, 0, n, ev_type, '', delim, ids, mbars, help_kw, $
	FONT=font
  return, base
END
; $Id: cw_rgbslider.pro,v 1.5 1994/05/13 00:14:54 dave Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_RGBSLIDER
;
; PURPOSE:
;	CW_RGBSLIDER is a compund widget that provides three sliders for
;	adjusting color values. The RGB, CMY, HSV, and HLS color systems
;	can all be used. No matter which color system is in use,
;	the resulting color is always supplied in RGB, which is the
;	base system for IDL.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	Widget = CW_RGBSLIDER(Parent)
;
; INPUTS:
;       Parent:	  The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	CMY:	  If set, the initial color system used is CMY.
;	DRAG:	  Set to zero if events should only be generated when
;		  the mouse button is released. If this keyword is set,
;		  events will be generated continuously when the sliders
;		  are adjusted. Note: On slow systems, /DRAG performance
;		  can be inadequate. The default is DRAG=0.
;	FRAME:	  If set, a frame will be drawn around the widget. The
;		  default is FRAME=0 (no frame drawn).
;	HSV:	  If set, the initial color system used is HSV.
;	HLS:	  If set, the initial color system used is HLS.
;	LENGTH:	  The length of the sliders. The default = 256.
;	RGB:	  If set, the initial color system used is RGB.
;		  This is the default.
;	UVALUE:	  The user value for the widget.
;	VERTICAL: If set, the sliders will be oriented vertically.
;		  The default is VERTICAL=0 (horizontal sliders).
;	COLOR_INDEX: If set, display a small rectangle with the
;		  selected color, using the given index.
;		  The color is updated as the values are changed.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; SIDE EFFECTS:
;	This widget generates event structures containing a three fields
;	named 'R', 'G', and 'B' containing the Red, Green, and Blue
;	components of the selected color.
;
; PROCEDURE:
;	The CW_RGBSLIDER widget has the following controls:
;
;	Color System Selection: A pulldown menu which allows the user
;		to change between the supported color systems.
;
;	Color adjustment sliders: Allow the user to select a new color
;		value. 
;
;	By adjusting these controls, the user selects color values which
;	are reported via the widget event mechanism.
;
; MODIFICATION HISTORY:
;	April 1, 1992, AB
;		Based on the RGB code from XPALETTE.PRO, but extended to
;		support color systems other than RGB.
;       7 April 1993, AB, Removed state caching.
;	10 May 1994, DMS, Added Color_index param to display color.
;-

pro CW_RGB_CHNG_CS, state, base_idx
  ; Change the current color system.
  ; State is the state structure to use (READ-ONLY)
  ; base_idx is the index into state.select_b of the base to change to.

  case (base_idx) of
    0: begin		; RGB
	WIDGET_CONTROL, state.r_sl, set_value=state.r_v
	WIDGET_CONTROL, state.g_sl, set_value=state.g_v
	WIDGET_CONTROL, state.b_sl, set_value=state.b_v
	end
    1: begin		; CMY
	WIDGET_CONTROL, state.c_sl, set_value=255-state.r_v
	WIDGET_CONTROL, state.m_sl, set_value=255-state.g_v
	WIDGET_CONTROL, state.y_sl, set_value=255-state.b_v
        end
    2: begin		; HSV
	COLOR_CONVERT, state.r_v, state.g_v, state.b_v, a, b, c, /RGB_HSV
	WIDGET_CONTROL, state.hsv_h_sl, set_value=(state.h_v = a)
	WIDGET_CONTROL, state.hsv_s_sl, set_value=(state.f1_v = b)
	WIDGET_CONTROL, state.hsv_v_sl, set_value=(state.f2_v = c)
	end
    3: begin		; HLS
	COLOR_CONVERT, state.r_v, state.g_v, state.b_v, a, b, c, /RGB_HLS
	WIDGET_CONTROL, state.hls_h_sl, set_value=(state.h_v = a)
	WIDGET_CONTROL, state.hls_l_sl, set_value=(state.f1_v = b)
	WIDGET_CONTROL, state.hls_s_sl, set_value=(state.f2_v = c)
	end

  endcase

  ; Change the displayed slider base
  WIDGET_CONTROL, map=0, state.select_b(state.curr_b_idx)
  WIDGET_CONTROL, map=1, state.select_b(base_idx)
  state.curr_b_idx = base_idx
end



PRO CW_RGB_SET_DRAW, state
if state.color_window lt 0 then begin	;Initialize?
	WIDGET_CONTROL, state.color_draw, GET_VALUE=i
	WSET, i
	state.color_window = i
	ERASE, state.color_index		;Set to our value
	endif
TVLCT, state.r_v, state.g_v, state.b_v, state.color_index
end




function CW_RGB_EVENT, ev

  ; Recover the state of this compound widget
  base = ev.handler
  stash = WIDGET_INFO(base, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  case (ev.id) of
    state.select_s : begin
        if (state.curr_b_idx ne (ev.value-1)) then $
		CW_RGB_CHNG_CS,state,ev.value-1
	WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
        return, 0		; Swallow the event
      end

    state.r_sl: state.r_v = ev.value
    state.g_sl: state.g_v = ev.value
    state.b_sl: state.b_v = ev.value

    state.c_sl: state.r_v = 255 - ev.value
    state.m_sl: state.g_v = 255 - ev.value
    state.y_sl: state.b_v = 255 - ev.value

    state.hsv_h_sl: begin
	state.h_v = ev.value
	goto, calc_new_hsv
	end
    state.hsv_s_sl: begin
	state.f1_v = ev.value
	goto, calc_new_hsv
	end
    state.hsv_v_sl: begin
	state.f2_v = ev.value
      calc_new_hsv:
	COLOR_CONVERT, state.h_v, state.f1_v, state.f2_v, a, b, c, /HSV_RGB
	state.r_v = a
        state.g_v = b
	state.b_v = c
	end
    

    state.hls_h_sl: begin
	state.h_v = ev.value
	goto, calc_new_hls
	end
    state.hls_l_sl: begin
	state.f1_v = ev.value
	goto, calc_new_hls
	end
    state.hls_s_sl: begin
	state.f2_v = ev.value
      calc_new_hls:
	COLOR_CONVERT, state.h_v, state.f1_v, state.f2_v, a, b, c, /HLS_RGB
	state.r_v = a
        state.g_v = b
	state.b_v = c
	end
    
  endcase

  if state.color_index ge 0 then CW_RGB_SET_DRAW, state

  ; Return an RGB event
  ret = { RGB_EVENT, ID: base, TOP:ev.top, HANDLER:0L, $
            R:state.r_v, G:state.g_v, B:state.b_v }
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  return, ret

end







pro CW_RGB_SET_VAL, id, value

  ; Recover the state of this compound widget
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  state.r_v = value(0)
  state.g_v = value(1)
  state.b_v = value(2)

  case (state.curr_b_idx) of
    0: begin	; RGB
	WIDGET_CONTROL, state.r_sl, set_value=state.r_v
	WIDGET_CONTROL, state.g_sl, set_value=state.g_v
	WIDGET_CONTROL, state.b_sl, set_value=state.b_v
	end
    1: begin	; CMY
	WIDGET_CONTROL, state.c_sl, set_value=255-state.r_v
	WIDGET_CONTROL, state.m_sl, set_value=255-state.g_v
	WIDGET_CONTROL, state.y_sl, set_value=255-state.b_v
        end
    2: begin	; HSV
	COLOR_CONVERT, state.r_v, state.g_v, state.b_v, a, b, c, /RGB_HSV
	WIDGET_CONTROL, state.hsv_h_sl, set_value=(state.h_v = a)
	WIDGET_CONTROL, state.hsv_s_sl, set_value=(state.f1_v = b)
	WIDGET_CONTROL, state.hsv_v_sl, set_value=(state.f2_v = c)
	end
    3: begin	; HLS
	COLOR_CONVERT, state.r_v, state.g_v, state.b_v, a, b, c, /RGB_HLS
	WIDGET_CONTROL, state.hls_h_sl, set_value=(state.h_v = a)
	WIDGET_CONTROL, state.hls_l_sl, set_value=(state.f1_v = b)
	WIDGET_CONTROL, state.hls_s_sl, set_value=(state.f2_v = c)
	end
  endcase
  if state.color_index ge 0 then CW_RGB_SET_DRAW, state
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
end







function CW_RGB_GET_VAL, id

  ; Recover the state of this compound widget
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  ret = [ state.r_v, state.g_v, state.b_v ]

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  return, ret
end








function CW_RGBSLIDER, parent, vertical=vertical, frame=frame, drag=drag, $
		       uvalue=uvalue, rgb=map_rgb, cmy=map_cmy, $
			hsv=map_hsv, hls=map_hls, LENGTH = length, $
			COLOR_INDEX=color_index

  IF NOT (KEYWORD_SET(drag))  THEN drag=0
  IF NOT (KEYWORD_SET(frame))  THEN frame=0
  IF NOT (KEYWORD_SET(vertical))  THEN vertical=0
  IF NOT (KEYWORD_SET(uvalue))  THEN uvalue=0
  IF NOT (KEYWORD_SET(length))  THEN length=256
  IF N_ELEMENTS(Color_index) le 0 then color_index=-1

  map_rgb = KEYWORD_SET(map_rgb)
  map_cmy = KEYWORD_SET(map_cmy)
  map_hsv = KEYWORD_SET(map_hsv)
  map_hls = KEYWORD_SET(map_hls)
  ; Make sure only one color system is selected.
  junk = map_rgb + map_cmy + map_hsv + map_hls
  if (junk eq 0) then map_rgb = 1	; RGB is the default
  if (junk gt 1) then $
	message, 'The RGB, CMY, HSV, and HLS keywords are mutually exclusive.'

  ; The variables in the state struct have suffixes that identify their class
  ;	_b - The various slider bases
  ;	_s - The pulldown menu selection buttons
  ;     _sl - The sliders
  ;     _v - Current values in various systems
  state = { CW_RGBSLIDER_STATE, $
	    r_v:0B, g_v:0B, b_v:0B, $		; Current RGB for all C.S.
	    h_v:0.0, f1_v:0.0, f2_v:0.0, $	; Curr. for HLS and HSV
	    r_sl:0L, g_sl:0L, b_sl:0L, $	; RGB sliders
	    c_sl:0L, m_sl:0L, y_sl:0L, $	; CMY sliders
	    hsv_h_sl:0L, hsv_s_sl:0L, hsv_v_sl:0L, $	; HSV sliders
	    hls_h_sl:0L, hls_l_sl:0L, hls_s_sl:0L, $	; HLS sliders
	    select_s:0L, select_b:lonarr(4), curr_b_idx:0L, $ ;Slider bases
	    first_child:0L, $			; Where the state is kept
	    color_index: long(color_index), $
	    color_window: -1L, $
	    color_draw: 0L }

  on_error,2              ;Return to caller if an error occurs

  base = WIDGET_BASE(parent, /COLUMN, FRAME=frame, EVENT_FUNC='CW_RGB_EVENT',$
        FUNC_GET_VALUE='CW_RGB_GET_VAL', PRO_SET_VALUE='CW_RGB_SET_VAL', $
	UVALUE=uvalue)
  junk = { CW_PDMENU_S, flags:0, name:'' }

  junk1 = WIDGET_BASE(base, /ROW)
;  state.select_s=CW_PDMENU(junk1, [ { CW_PDMENU_S, 1, 'Select Color System' },$
;	{ CW_PDMENU_S, 0, 'RGB  (Red/Green/Blue)' }, $
;	{ CW_PDMENU_S, 0, 'CMY  (Cyan/Magenta/Yellow)' }, $
;	{ CW_PDMENU_S, 0, 'HSV  (Hue/Saturation/Value)' }, $
;	{ CW_PDMENU_S, 0, 'HLS  (Hue/Lightness/Saturation)' }])
  if color_index gt 0 then $
	state.color_draw = WIDGET_DRAW(junk1, xsize=24, ysize=24, RET=2)

  selbase = WIDGET_BASE(base)

  fslide_fmt = '(F4.2)'
  if (vertical eq 0) then begin
    tmp = WIDGET_BASE(selbase, /COLUMN, /MAP)
      state.r_sl = WIDGET_SLIDER(tmp, max=255, title='Red', $
				  drag=drag, xsize=length)
      state.g_sl = WIDGET_SLIDER(tmp, max=255, title='Green', $
				 drag=drag, xsize=length)
      state.b_sl = WIDGET_SLIDER(tmp, max=255, title='Blue', $
				 drag=drag, xsize=length)
      state.select_b(0) = tmp
    tmp = WIDGET_BASE(selbase, /COLUMN, MAP=0)
      state.c_sl = WIDGET_SLIDER(tmp, max=255, title='Cyan', $
				 drag=drag, xsize=length)
      state.m_sl = WIDGET_SLIDER(tmp, max=255, title='Magenta', $
				 drag=drag, xsize=length)
      state.y_sl = WIDGET_SLIDER(tmp, max=255, title='Yellow', $
				 drag=drag, xsize=length)
      state.select_b(1) = tmp
    tmp = WIDGET_BASE(selbase, /COLUMN, MAP=0)
      state.hsv_h_sl = WIDGET_SLIDER(tmp, max=360, title='Hue', $
				     drag=drag, xsize=length)
      state.hsv_s_sl = CW_FSLIDER(tmp, max=1.0, title='Saturation', $
			          drag=drag, xsize=length, format=fslide_fmt)
      state.hsv_v_sl = CW_FSLIDER(tmp, max=1.0, title='Value', $
			          drag=drag, xsize=length, format=fslide_fmt)
      state.select_b(2) = tmp
    tmp = WIDGET_BASE(selbase, /COLUMN, MAP=0)
      state.hls_h_sl = WIDGET_SLIDER(tmp, max=360, title='Hue', $
			             drag=drag, xsize=length)
      state.hls_l_sl = CW_FSLIDER(tmp, max=1.0, title='Lightness', $
			          drag=drag, xsize=length, format=fslide_fmt)
      state.hls_s_sl = CW_FSLIDER(tmp, max=1.0, title='Saturation', $
			          drag=drag, xsize=length, format=fslide_fmt)
      state.select_b(3) = tmp
  endif else begin				; Vertical sliders
    tmp = WIDGET_BASE(selbase, /ROW, /MAP)
      state.r_sl = WIDGET_SLIDER(tmp, max=255, title='R',drag=drag, $
				 ysize=length, /vertical)
      state.g_sl = WIDGET_SLIDER(tmp, max=255, title='G', $
				 drag=drag, ysize=length, /vertical)
      state.b_sl = WIDGET_SLIDER(tmp, max=255, title='B', $
				 drag=drag, ysize=length, /vertical)
      state.select_b(0) = tmp
    tmp = WIDGET_BASE(selbase, /ROW, MAP=0)
      state.c_sl = WIDGET_SLIDER(tmp, max=255, title='C', $
				 drag=drag, ysize=length, /vertical)
      state.m_sl = WIDGET_SLIDER(tmp, max=255, title='M', $
				 drag=drag, ysize=length, /vertical)
      state.y_sl = WIDGET_SLIDER(tmp, max=255, title='Y', $
				 drag=drag, ysize=length, /vertical)
      state.select_b(1) = tmp
    tmp = WIDGET_BASE(selbase, /ROW, MAP=0)
      state.hsv_h_sl = WIDGET_SLIDER(tmp, max=360, title='H', $
				     drag=drag, ysize=length, /vertical)
      state.hsv_s_sl = CW_FSLIDER(tmp, max=1.0, title='S', $
				   drag=drag, ysize=length, /vertical, $
				   format=fslide_fmt)
      state.hsv_v_sl = CW_FSLIDER(tmp, max=1.0, title='V', $
				   drag=drag, ysize=length, /vertical, $
				   format=fslide_fmt)
      state.select_b(2) = tmp
    tmp = WIDGET_BASE(selbase, /ROW, MAP=0)
      state.hls_h_sl = WIDGET_SLIDER(tmp, max=360, title='H', $
			             drag=drag, ysize=length, /vertical)
      state.hls_l_sl = CW_FSLIDER(tmp, max=1.0, title='L',drag=drag,$
			          ysize=length, /vertical, format=fslide_fmt)
      state.hls_s_sl = CW_FSLIDER(tmp, max=1.0, title='S',drag=drag,$
			          ysize=length, /vertical, format=fslide_fmt)
      state.select_b(3) = tmp
  endelse

  ; Stash the state
  WIDGET_CONTROL, WIDGET_INFO(base, /CHILD), SET_UVALUE=state, /NO_COPY

  ; If the initial color system is not RGB, switch it now before it's realized
  if (map_cmy) then CW_RGB_CHNG_CS, nstate, 1
  if (map_hsv) then CW_RGB_CHNG_CS, nstate, 2
  if (map_hls) then CW_RGB_CHNG_CS, nstate, 3

  return, base
end
; $Id: cw_tmpl.pro,v 1.2 1993/04/07 20:55:16 ali Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;
; PURPOSE:
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	widget = CW_TMPL(parent)
;
; INPUTS:
;       PARENT - The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	UVALUE - Supplies the user value for the widget.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;
; PROCEDURE:
;	WIDGET_CONTROL, id, SET_VALUE=value can be used to change the
;		current value displayed by the widget.
;
;	WIDGET_CONTROL, id, GET_VALUE=var can be used to obtain the current
;		value displayed by the widget.
;
; MODIFICATION HISTORY:
;-


PRO tmpl_set_value, id, value

	; This routine is used by WIDGET_CONTROL to set the value for
	; your compound widget.  It accepts one variable.  
	; You can organize the variable as you would like.  If you have
	; more than one setting, you may want to use a structure that
	; the user would need to build and then pass in using 
	; WIDGET_CONTROL, compoundid, SET_VALUE = structure.

	; Return to caller.
  ON_ERROR, 2

	; Retrieve the state.
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

	; Set the value here.

	; Restore the state.
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY

END



FUNCTION tmpl_get_value, id

	; This routine is by WIDGET_CONTROL to get the value from 
	; your compound widget.  As with the set_value equivalent,
	; you can only pass one value here so you may need to load
	; the value by using a structure or array.

	; Return to caller.
  ON_ERROR, 2

	; Retrieve the structure from the child that contains the sub ids.
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

	; Get the value here


	; Restore the state.
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY

        ; Return the value here.

END

;-----------------------------------------------------------------------------

FUNCTION tmpl_event, ev

	; This routine handles all the events that happen in your
	; compound widget and if the events need to be passed along
	; this routine should return the new event.  If nobody needs
	; to know about the event that just occured, this routine 
	; can just return 0.  If your routine never needs to pass
	; along an event, this routine can be a procedure instead
	; of a function.  Whichever type used must be set below in the
	; WIDGET_BASE call using either the EVENT_PROC or EVENT_FUNC 
	; keyword.  An event function that returns a scalar 0 is 
	; essentially an event procedure.

  parent=ev.handler


	; Retrieve the structure from the child that contains the sub ids.
  stash = WIDGET_INFO(parent, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

	; Process your compound widgets events here.
	; If the event doesn't need to propagate up any further, just 
	; return 0 and the event will stop here.  Otherwise, modify
	; the event for your usage and return it.


        ; Restore the state structure
  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY

	; You may need to add more tags to the event structure for your 
	; compound widget.  If so do it after the first three which are
	; required and preserve the order of the first three.

  RETURN, { ID:parent, TOP:ev.top, HANDLER:0L }
END

;-----------------------------------------------------------------------------

FUNCTION cw_tmpl, parent, UVALUE = uval

	; You should not use the user value of the main base for
	; your compound widget as the person using your compound widget
	; may want it for his or her own use.  
	; You also should not use the user value of the first widget you
	; install in the base as it is used to keep track of the state.

	; state structure for your compound widget.

  IF (N_PARAMS() EQ 0) THEN MESSAGE, 'Must specify a parent for Cw_Tmpl'

  ON_ERROR, 2					;return to caller

	; Defaults for keywords
  IF NOT (KEYWORD_SET(uval))  THEN uval = 0

	; Rather than use a common block to store the widget IDs of the 
	; widgets in your compound widget, put them into this structure so
	; that you can have multiple instances of your compound widget.
  state = { id:0 }

	; Here the widget base that encompasses your compound widget's 
	; individual components is created.  This is the widget ID that
	; is passed back to the user to represent the entire compound
	; widget.  If it gets mapped, unmapped, sensitized or otherwise
	; effected, each of its individual subcomponents will also be 
	; effected.  You can see that the event handler is installed here.
	; As events occur in the sub-components of the compound widgets,
	; the events are passed up the tree until they hit this base 
	; where the event handler you define above handles them.  Similarily
	; whenever WIDGET_CONTROL, SET/GET_VALUE is called on this base,
	; the routine defined by the FUNC_GET/PRO_SET_VALUE is called to
	; set the value of the compound widget.  None of the three keywords
	; that override the standard behaviour are not required so it 
	; depends on your usage whether they are needed.
  mainbase = WIDGET_BASE(parent, UVALUE = uval, $
		EVENT_FUNC = "tmpl_event", $
		FUNC_GET_VALUE = "tmpl_get_value", $
		PRO_SET_VALUE = "tmpl_set_value")

	; Here you would define the sub-components of your widget.  There
	; is an example component which is just a label.
  state.id = WIDGET_LABEL(mainbase, VALUE = "Compound Widget Template")

	; Save out the initial state structure into the first childs UVALUE.
  WIDGET_CONTROL, WIDGET_INFO(base, /CHILD), SET_UVALUE=state, /NO_COPY

	; Return the base ID of your compound widget.  This returned
	; value is all the user will know about the internal structure
	; of your widget.
  RETURN, mainbase

END





; $Id: cw_zoom.pro,v 1.5 1994/11/23 20:37:25 alan Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	CW_ZOOM
;
; PURPOSE:
;	This compound widget displays two images: an original image
;	in one window and a portion of the original image in another.
;	The user may select the center of the zoom region, the zoom scale,
;	the interpolation style, and the method of indicating the zoom center.
;
; CATEGORY:
;	Compound widgets.
;
; CALLING SEQUENCE:
;	Widget = CW_ZOOM(Parent)
;
; INPUTS:
;       Parent:	 The ID of the parent widget.
;
; KEYWORD PARAMETERS:
;	FRAME:	 If set, a frame will be drawn around the widget. The
;		 default is FRAME=0 (no frame).
;	MAX:	 The maximum zoom scale, which must be greater than
;		 or equal to 1. The default = 20.
;	MIN:	 The minimum zoom scale, which must be greater than
;		 or equal to 1. The default = 1.
;	RETAIN:	 Controls the setting for backing store for both windows.
;		 If backing store is provided, a window which was obscured
;		 will be redrawn when it becomes exposed. Set RETAIN=0 for
;		 no backing store. Set RETAIN=1 to "request backing store
;		 from server" (this is the default). Set RETAIN=2 for IDL
;		 to provide backing store.
;	SAMPLE:	 Set to zero for bilinear interpolation, or to a non-zero
;		 value for nearest neighbor interpolation. Bilinear
;		 interpolation gives higher quality results, but requires
;		 more time. The default is SAMPLE=0 (bilinear interpolation).
;	SCALE:	 The initial integer scale factor to use for the zoomed image.
;		 The default is SCALE=4. The scale must be greater than or
;		 equal to 1.
;	TRACK:	 Set to zero if the zoom window should be updated only when
;		 the mouse button is pressed. Set to a non-zero value if the
;		 zoom window should be updated continuously as the cursor
;		 is moved across the original image. Note: On slow systems,
;		 /TRACK performance can be inadequate. The default is TRACK=0.
;	UVALUE:	 The user value for the widget.
;	XSIZE:	 The width of the window (in pixels) for the original image.
;		 The default is 500.
;	YSIZE:	 The height of the window (in pixels) for the original image.
;		 The default is 500.
;	X_SCROLL_SIZE: The width of the visible part of the original image.
;		       This may be smaller than the actual width controlled
;		       by the XSIZE keyword. The default is 0, for no
;		       scroll bar.
;	Y_SCROLL_SIZE: The height of the visible part of the original image.
;		       This may be smaller than the actual height controlled
;		       by the YSIZE keyword. The default is 0, for no
;		       scroll bar.
;	X_ZSIZE: The width of the window for the zoomed image.
;		 The default is 250.
;	Y_ZSIZE: The height of the window for the zoomed image.
;		 The default is 250.
;
; OUTPUTS:
;       The ID of the created widget is returned.
;
; SIDE EFFECTS:
;	When the "Report Zoom to Parent" button is pressed, this widget
;	will generate an event structure containing several data fields.
;		x_zsize, y_zsize:	size of the zoomed image
;		x0, y0:			lower left corner in original image
;		x1, y1:			upper right corner in original image
;	This event is a report to the parent that allows retrieval of the
;	zoomed image using WIDGET_CONTROL.
;
; PROCEDURE:
;	WIDGET_CONTROL, id, SET_VALUE=value can be used to change the
;		original, unzoomed image displayed by the widget.
;		The value may not be set until the widget has been
;		realized.
;
;	WIDGET_CONTROL, id, GET_VALUE=var can be used to obtain the current
;		zoomed image displayed by the widget.
;
; MODIFICATION HISTORY:
;	June 30, 1992, ACY
;       7 April 1993, AB, Removed state caching.
;	13 June, 1994, ACY, Save window and set to zoom prior to erase
;			    Add byte conversion in set_value
;	23 November, 1994, ACY, add code to handle cases in which the
;			set_value image is larger or smaller than the
;			original image.  Also remove scaling on display
;			operation (only scale the image when it is set.)
;-

;-----------------------------------------------------------------------------

PRO zoom_set_value, id, value

  ON_ERROR, 2						;return to caller

  ; Retrieve the state
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY


  ; Put the value into the state structure
  ;state.orig_image = byte(value)
  ; Handle cases where set_value image is smaller or larger than orig_image
  temp_size = size(value)
  set_x_sz = temp_size(1)
  set_y_sz = temp_size(2)
  ; get the smaller section common to both orig_image and set_value
  new_x_sz = state.x_im_sz < set_x_sz
  new_y_sz = state.y_im_sz < set_y_sz
  ; Set the state value.  Scale to range of the display here
  ; so that display operations after this can simply use TV
  ; and preserve the same range as in the original image
  state.orig_image(0:new_x_sz-1,0:new_y_sz-1) = $
     bytscl(value(0:new_x_sz-1,0:new_y_sz-1), top=!d.n_colors-1)


  ; Get the window number from the draw widget.  This can only be done
  ; after the widget has been realized.
  WIDGET_CONTROL, state.draw, GET_VALUE=win_temp
  state.draw_win = win_temp(0)
  WIDGET_CONTROL, state.zoom, GET_VALUE=win_temp
  state.zoom_win = win_temp(0)

  ; Use TV to display an image in the draw widget.  Set the window for
  ; the TV command since there may be other draw windows.
  ;Save window number
  save_win = !D.WINDOW
  WSET, state.draw_win
  TV, state.orig_image
  ;Restore window
  IF (save_win NE -1) THEN WSET, save_win

  draw_zoom, state, state.oldx, state.oldy

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY

END

;-----------------------------------------------------------------------------

FUNCTION zoom_get_value, id

  ON_ERROR, 2                                           ;return to caller

  ; Retrieve the state
  stash = WIDGET_INFO(id, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY

  ; Get the value from the state structure
  ret = state.zoom_image

  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
  RETURN, ret
END

;-----------------------------------------------------------------------------

PRO draw_zoom, state, newx, newy

  ; compute size of rectangle in original image
  ; round up to make sure image fills zoom window
  rect_x = long(state.x_zm_sz / float(state.scale) + 0.999)
  rect_y = long(state.y_zm_sz / float(state.scale) + 0.999)

  ; compute location of origin of rect (user specified center)
  x0 = newx - rect_x/2
  y0 = newy - rect_y/2

  ; make sure rectangle fits into original image
  ;left edge from center
  x0 = x0 > 0
  ; limit right position
  x0 = x0 < (state.x_im_sz - rect_x)

  ;bottom
  y0 = y0 > 0
  y0 = y0 < (state.y_im_sz - rect_y)

  IF (state.scale EQ 1) THEN BEGIN
    ;Save window number
    save_win = !D.WINDOW
    WSET, state.zoom_win
    IF (rect_x GT state.x_im_sz OR rect_y GT state.y_im_sz) THEN BEGIN
      ERASE
      IF (rect_x GT state.x_im_sz) THEN x0 = 0 & rect_x = state.x_im_sz
      IF (rect_y GT state.x_im_sz) THEN y0 = 0 & rect_y = state.y_im_sz
    ENDIF
    ; don't use tvscl here, to preserve same range as in unzoomed image
    TV, state.orig_image(x0:x0+rect_x-1,y0:y0+rect_y-1)
    ;Restore window
    IF (save_win NE -1) THEN WSET, save_win
  ENDIF ELSE BEGIN
    ;Make integer rebin factors.  These may be larger than the zoom image
    dim_x = rect_x * state.scale
    dim_y = rect_y * state.scale

    x1 = x0 + rect_x - 1
    y1 = y0 + rect_y - 1

    temp_image = rebin(state.orig_image(x0:x1,y0:y1), $
                       dim_x, dim_y, $
                       sample=state.sample)

    ;Save the zoomed image
    state.zoom_image = $
                     temp_image(0:state.x_zm_sz-1,0:state.y_zm_sz-1)

    ;Save the corners in original image
    state.x0 = x0
    state.y0 = y0
    state.x1 = x1
    state.y1 = y1

    ;Display the new zoomed image
    ;Save window number
    save_win = !D.WINDOW
    WSET, state.zoom_win
    ; don't use tvscl here, to preserve same range as in unzoomed image
    TV, state.zoom_image
    ;Restore window
    IF (save_win NE -1) THEN WSET, save_win

 ENDELSE

END


;-----------------------------------------------------------------------------

FUNCTION zoom_event, event

  ; Retrieve the structure from the child that contains the sub ids
  parent=event.handler
  stash = WIDGET_INFO(parent, /CHILD)
  WIDGET_CONTROL, stash, GET_UVALUE=state, /NO_COPY


  CASE event.id OF
    state.draw: $
       IF state.track GT 0 OR event.press EQ 1 THEN BEGIN
          draw_zoom, state, event.x, event.y
          state.oldx = event.x
          state.oldy = event.y
       ENDIF

    state.slide: $
       BEGIN
          WIDGET_CONTROL, event.id, GET_VALUE = temp_scale
          IF (temp_scale LT 1) THEN temp_scale = 1
          state.scale = temp_scale
          draw_zoom, state, state.oldx, state.oldy
       END

    state.sample_base: $
       CASE event.value OF
          state.nn_id: BEGIN
			  state.sample = 1
			  draw_zoom, state, state.oldx, state.oldy
		       END
          state.bilin_id: BEGIN
                             state.sample = 0
                             draw_zoom, state, state.oldx, state.oldy
                	  END
       ENDCASE

    state.track_base: $
       CASE event.value OF
          state.notrack_id:  state.track = 0
          state.track_id:    state.track = 1
       ENDCASE
    state.report_id: begin
	  ret = {ZOOM_EVENT, ID:parent, $
		TOP:event.top, HANDLER:0L, $
		x_zsize:state.x_zm_sz, y_zsize:state.y_zm_sz, $
		x0:state.x0, y0:state.y0, $
		x1:state.x1, y1:state.y1}
	  WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
	  return, ret
	end
ENDCASE

; Swallow events, except for the REPORT event
WIDGET_CONTROL, stash, SET_UVALUE=state, /NO_COPY
RETURN, 0

END

;-----------------------------------------------------------------------------


FUNCTION cw_zoom, parent, $
		FRAME=frame, $
		MAX=max, $
		MIN=min, $
		RETAIN=retain, $
		SAMPLE=sample, $
		SCALE=scale, $
		TRACK=track, $
		UVALUE = uval, $
		XSIZE=xsize, $
		YSIZE=ysize, $
		X_SCROLL_SIZE=x_scroll_size, $
		Y_SCROLL_SIZE=y_scroll_size, $
		X_ZSIZE=x_zsize, $
		Y_ZSIZE=y_zsize

  IF (N_PARAMS() NE 1) THEN MESSAGE, 'Incorrect number of arguments'

  ON_ERROR, 2						;return to caller

  ; Defaults for keywords
  IF (N_ELEMENTS(frame) EQ 0) THEN frame = 0L
  IF (N_ELEMENTS(max) EQ 0) THEN max = 20L
  IF (N_ELEMENTS(min) EQ 0) THEN min = 1L
  IF (N_ELEMENTS(retain) EQ 0) THEN retain = 1L
  IF (N_ELEMENTS(sample) EQ 0) THEN sample = 0L
  IF (N_ELEMENTS(scale) EQ 0) THEN scale = 4L
  IF (N_ELEMENTS(track) EQ 0) THEN track = 0L
  IF (N_ELEMENTS(uval) EQ 0)  THEN uval = 0L
  IF (N_ELEMENTS(xsize) EQ 0) THEN xsize = 500L
  IF (N_ELEMENTS(ysize) EQ 0) THEN ysize = 500L
  IF (N_ELEMENTS(x_scroll_size) EQ 0) THEN x_scroll_size = 0L
  IF (N_ELEMENTS(y_scroll_size) EQ 0) THEN y_scroll_size = 0L
  IF (N_ELEMENTS(x_zsize) EQ 0) THEN x_zsize = 250L
  IF (N_ELEMENTS(y_zsize) EQ 0) THEN y_zsize = 250L

  base = WIDGET_BASE(parent, $
			EVENT_FUNC = 'zoom_event', $
			FRAME = frame, $
			FUNC_GET_VALUE='ZOOM_GET_VALUE', $
			PRO_SET_VALUE='ZOOM_SET_VALUE', $
			/ROW, $
			UVALUE = uval)

  lcol = WIDGET_BASE(base, /COLUMN)

  ; A widget called 'draw' is created.
  draw = WIDGET_DRAW(lcol, $
	/BUTTON_EVENTS, $	;generate events when buttons pressed
	/MOTION_EVENTS, $
	/FRAME, $
	RETAIN = retain, $
	XSIZE = xsize, $
	YSIZE = ysize, $
	X_SCROLL_SIZE = x_scroll_size, $
	Y_SCROLL_SIZE = y_scroll_size)

  rcol = WIDGET_BASE(base, /COLUMN)

  ; The REPORT button:
  report = WIDGET_BUTTON(rcol, $
		VALUE = 'REPORT ZOOM TO PARENT')

  ; A label containing some instructions:
  wdrlabel = WIDGET_LABEL(rcol, $
	   VALUE = 'Press left button to zoom.')

  ; A widget called 'zoom' is created.
  zoom = WIDGET_DRAW(rcol, $
        /FRAME, $
        RETAIN = retain, $
        XSIZE = x_zsize, $
        YSIZE = y_zsize)

  IF (min LT 1) THEN min = 1
  IF (max LT 1) THEN max = 1
  slide = WIDGET_SLIDER(rcol, $
                        MINIMUM = min, $
                        MAXIMUM = max, $
                        VALUE = scale, $
                        TITLE = 'Zoom Scale', $
                        /FRAME)

  ;make sure sample is 0 or 1
  IF (sample GT 0) THEN sample = 1
  sample_base = cw_bgroup(rcol, ['Bilinear', 'Nearest Neighbor'], $
		/COLUMN, $
		/EXCLUSIVE, $
		/FRAME, $
		IDS=sample_ids, $
		LABEL_TOP = 'Interpolation Style', $
		/NO_RELEASE, $
		/RETURN_ID, $
		SET_VALUE = sample)

  ;make sure track is 0 or 1
  IF (track GT 0) THEN track = 1
  track_base = cw_bgroup(rcol, ['Button Press Only', 'Track Cursor'], $
		/COLUMN, $
		/EXCLUSIVE, $
		/FRAME, $
		IDS=track_ids, $
		LABEL_TOP = 'Cursor Input Style', $
		/NO_RELEASE, $
		/RETURN_ID, $
		SET_VALUE = track)

  state = {	orig_image:	BYTARR(xsize,ysize), $
		zoom_image:	BYTARR(x_zsize,y_zsize), $
		draw:		draw, $
		zoom:		zoom, $
		slide:		slide, $
		sample_base:	sample_base, $
		bilin_id:	sample_ids(0), $
		nn_id:		sample_ids(1), $
		track_base:	track_base, $
		notrack_id:	track_ids(0), $
		track_id:	track_ids(1), $
		report_id:	report, $
		draw_win:	-1L, $
		zoom_win:	-1L, $
		x_im_sz:	xsize, $
		y_im_sz:	ysize, $
		retain:		1L, $
		track:		track, $
		scale:		scale, $
		sample:		sample, $
		x_zm_sz:	x_zsize, $
		y_zm_sz:	y_zsize, $
		oldx:		xsize / 2L, $
		oldy:		ysize / 2L, $
		x0:		0L, $
		y0:		0L, $
		x1:		0L, $
		y1:		0L $
		}

  WIDGET_CONTROL, WIDGET_INFO(base, /CHILD), SET_UVALUE=state, /NO_COPY
  RETURN, base

END
; $Id: defroi.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function Defroi, Sx, Sy, Xverts, Yverts, X0=x0, Y0=y0, ZOOM = ZOOM, $
	NOREGION = Noregion, NOFILL = Nofill, RESTORE = restore
 ;Define an irregular Region of Interest.
;+
; NAME:			DEFROI
; PURPOSE:	Define an irregular region of interest of an image
;		using the image display system and the cursor/mouse.
; CATEGORY:	Image processing.
; CALLING SEQUENCE:
;	R = Defroi(Sx, Sy, X0, Y0)
; INPUTS:
;	Sx, Sy = Size of image, in pixels.
; Optional Inputs:
;	X0, Y0 = Coordinate of Lower left corner of image on display.
;	If omitted, (0,0) is assumed.  Screen device coordinates.
;	ZOOM = zoom factor, if omitted, 1 is assumed.
; OUTPUTS:
;	Function result = vector of subscripts of pixels inside the region.
;	Side effect: The lowest bit in which the write mask is enabled
;	is changed.
; OPTIONAL OUTPUTS:
;	Xverts, Yverts = Optional output parameters which will contain
;		the vertices enclosing the region.
; KEYWORD Parameters:
;	NOREGION = Setting NOREGION inhibits the return of the
;		pixel subscripts.
;	NOFILL = if set, inhibits filling of irregular region on completion.
;	RESTORE = if set, original image on display is restored to its
;		original state on completion. 
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:
;	Display is changed if RESTORE is not set.
; RESTRICTIONS:
;	Only works for interactive, pixel oriented devices with a
;		cursor and an exclusive or writing mode.
;	A region may have at most 1000 vertices.  If this is not enough
;		edit the line setting MAXPNTS.
; PROCEDURE:
;	The exclusive or drawing mode is used to allow drawing and
;	erasing objects over the original object.
;
;	The operator marks the vertices of the region, either by
;		dragging the mouse with the left button depressed or by
;		marking vertices of an irregular polygon by clicking the
;		left mouse button, or with a combination of both.
;	The center button removes the most recently drawn points.
;	Press the right mouse button when finished.
;	When the operator is finished, the region is filled using 
;		the polyfill function, and the polyfillv function is used
;		to compute the subscripts within the region.
;
; MODIFICATION HISTORY:  DMS, March, 1987.
; 	Revised for SunView, DMS, Nov, 1987.
;       Added additional argument checking, SNG April, 1991
;	Modified for devices without write masks: DMS, March, 1992.
;		Uses exclusive or mode rather than write masks.
;	
;-
;
on_error,2		;Return to caller if error
nc1 = !d.table_size-1	;# of colors available

if sx lt 1 or sy lt 1 then $		;Check some obvious things
    message, 'Dimensions of the region must be greater than zero.'

if sx gt !d.x_size then $
    message, 'The width of the region must be less than ' + $
	strtrim(string(!d.x_size),2)

sy = sy < !d.y_size

device, set_graphics=6             ;Set XOR mode
again:
n = 0
print,'Left button to mark point'
print,'Middle button to erase previous point'
print,'Right button to close region'
maxpnts = 1000			;max # of points.
xverts = intarr(maxpnts)		;arrays
yverts = intarr(maxpnts)
xprev = -1
yprev = -1
if n_elements(x0) le 0 then x0 = 0
if n_elements(y0) le 0 then y0 = 0
if n_elements(zoom) le 0 then zoom = 1
;
Cursor, xx, yy, /WAIT, /DEV		;Get 1st point with wait
repeat begin
	xx = (xx - x0) / zoom	;To image coords
	yy = (yy - y0) / zoom
	if (xx lt sx) and (yy lt sy) and (!err eq 1) and $
	    ((xx ne xprev) or (yy ne yprev)) then begin	    ;New point?
		xprev = xx
		yprev = yy
		if n ge (maxpnts-1) then begin
			print,'Too many points'
			n = n-1
			endif
		xverts(n) = xx
		yverts(n) = yy
		if n ne 0 then $
		  plots,xverts(n-1:n)*zoom+x0,yverts(n-1:n)*zoom + y0, $
			/dev,color=nc1,/noclip
		n = n + 1
		endif
;		We use 2 or 5 for the middle button because some Microsoft
;		compatible mice use 5.
	if ((!err eq 2) or (!err eq 5)) and (n gt 0) then begin
		n = n-1
		if n gt 0 then begin  ;Remove a vertex
		  plots,xverts(n-1:n)*zoom+x0,yverts(n-1:n)*zoom+y0,color=nc1,$
			/dev,/noclip
                  wait, .1           ;Dont erase too fast
		  endif
	endif
	Cursor, xx, yy, /WAIT, /DEV    ;get x,y, no wait, device coords.
	endrep until !err eq 4

if n lt 3 then begin
	print,'ROI - Must have 3 points for region.  Try again.'
	goto,again
	endif
xverts = xverts(0:n-1)		;truncate
yverts = yverts(0:n-1)

if keyword_set(restore) then $
	plots, xverts*zoom+x0, yverts *zoom + y0, /dev, color=nc1, /noclip $
else if keyword_set(nofill) then $
 	plots, [xverts(0),xverts(n-1)]*zoom+x0, $
	       [yverts(0),yverts(n-1)]*zoom+y0,$
		/dev,color = nc1,/noclip   $	 ;Complete polygon
else polyfill, xverts*zoom+x0, yverts*zoom+y0,$
		/dev,color = nc1,/noclip ;Complete polygon

if !order ne 0 then yverts = sy-1-yverts	;Invert Y?
device,set_graphics=3   ;Re-enable normal copy write

if keyword_set(noregion) then a = 0 $
  else a = polyfillv(xverts,yverts,sx,sy)	; get subscripts inside area.

return,a
end
; $Id: demo_mode.pro,v 1.2 1993/10/27 22:05:39 kirk Exp $

;+
; NAME:
;	DEMO_MODE
;
; PURPOSE:
;	Returns true if IDL is in Demo Mode.
;
; CALLING SEQUENCE:
;	Result = DEMO_MODE()
;
; OUTPUTS:
;	Returns 1 if IDL is in Demo Mode and 0 otherwise.
;
; SIDE EFFECTS:
;	Does a FLUSH, -1.
;
; PROCEDURE:
;	Do a FLUSH, -1 and trap the error message.
;
; MODIFICATION HISTORY:
;	Written by SMR, Research Systems, Inc.	Feb. 1991
;	KDB Oct,1993: The error string had an extra ' ' in it and 
;		      the function would always return 0. 
;-

FUNCTION DEMO_MODE

!err=0
FLUSH, -1
return, ((!err ne 0) and $
    (!ERR_STRING EQ 'FLUSH: Feature disabled for demo mode.'))

END
; $Id: deriv.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function Deriv, X, Y
;+
; NAME:
;	DERIV
;
; PURPOSE:
;	Perform numerical differentiation using 3-point, Lagrangian 
;	interpolation.
;
; CATEGORY:
;	Numerical analysis.
;
; CALLING SEQUENCE:
;	Dy = Deriv(Y)	 	;Dy(i)/di, point spacing = 1.
;	Dy = Deriv(X, Y)	;Dy/Dx, unequal point spacing.
;
; INPUTS:
;	Y:  Variable to be differentiated.
;	X:  Variable to differentiate with respect to.  If omitted, unit 
;	    spacing for Y (i.e., X(i) = i) is assumed.
;
; OPTIONAL INPUT PARAMETERS:
;	As above.
;
; OUTPUTS:
;	Returns the derivative.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	See Hildebrand, Introduction to Numerical Analysis, Mc Graw
;	Hill, 1956.  Page 82.
;
; MODIFICATION HISTORY:
;	Written, DMS, Aug, 1984.
;-
;

on_error,2              ;Return to caller if an error occurs
n = n_elements(x)
if n lt 3 then message, 'Parameters must have at least 3 points'

if n_params(0) ge 2 then begin
	if n ne n_elements(y) then message,'Vectors must have same size'
	d = float(shift(y,-1) - shift(y,1))/(shift(x,-1) - shift(x,1))
	d(0) = (-3.0*y(0) + 4.0*y(1) - y(2))/(x(2)-x(0))
	d(n-1) = (3.*y(n-1) - 4.*y(n-2) + y(n-3))/(x(n-1)-x(n-3))
   end else begin
	d = (shift(x,-1) - shift(x,1))/2.
	d(0) = (-3.0*x(0) + 4.0*x(1) - x(2))/2.
	d(n-1) = (3.*x(n-1) - 4.*x(n-2) + x(n-3))/2.
   endelse
return, d
end
; $Id: derivsig.pro,v 1.2 1993/10/15 21:57:36 doug Exp $
Function Derivsig, X, Y, sigx, sigy
;+
; NAME:
;	DERIVSIG
;
; PURPOSE:
;	This function computes the standard deviation of a derivative
;       as found by the DERIV function, using the input variables of
;	DERIV and the standard deviations of those input variables.
;
; CATEGORY:
;	Numerical analysis.
;
; CALLING SEQUENCE:
;	sigDy = Derivsig(sigy)		;sigma(Dy(i)/di), point spacing = 1.
;	sigDy = Derivsig(X,Y,sigx,sigy) ;sigma(Dy/Dx), unequal point spacing.
;
; INPUTS:
;	Y:	The variable to be differentiated. Omit if X is omitted.
;	X:	The Variable to differentiate with respect to. If omitted,
;		unit spacing is assumed for Y, i.e. X(i) = i.
;       sigy:	The standard deviation of Y. (Vector if used alone in
;		call, vector or constant if used with other parameters)
;       sigx:	The standard deviation of X (either vector or constant).
;		Use "0.0" if the abscissa is exact; omit if X is omitted.
;
; OPTIONAL INPUT PARAMETERS:
;	As above.
;
; OUTPUTS:
;	This function returns the standard deviation of the derivative.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	See Bevington, "Data Analysis and Reduction for the Physical
;           Sciences," McGraw-Hill (1969), Chap 4.
;
; MODIFICATION HISTORY:
;       Written by Richard Bonomo at the University of Wisconsin - Madison
;       department of Electrical and Computer Engineering, July, 1991.
;	"DERIV" written by DMS, Aug, 1984.
;-
;

on_error,2              ;Return to caller if an error occurs
prms=n_params(0)
n = n_elements(x)
if (n lt 3) and (prms gt 1) then message, 'X must have at least 3 points'
if (n lt 3) and (prms eq 1) then message, $
    'sigy must be a vector of at least 3 points if used alone'

if ((prms ne 1) and (prms ne 4)) then message,$
   'function DERIVSIG must be called with either 1 or 4 parameters'

if prms eq 1 then begin ; unit spacing assumed
        sigy=x
        if n_elements(sigy) eq 1 then sigy=fltarr(n) + sigy
        sigd=sqrt(0.25*(shift(sigy,-1)*shift(sigy,-1) + $
         shift(sigy,1)*shift(sigy,1)))
        sigd(0)=sqrt(0.25*(sigy(0)^2*9.0 + sigy(1)^2*16.0 + sigy(2)^2))
        sigd(n-1)=sqrt(0.25*(sigy(n-1)^2*9.0 + sigy(n-2)*16.0 + sigy(n-3)))
endif
if prms eq 4 then begin
        if n ne n_elements(y) then message,'Vectors must have same size'
        if n_elements(sigy) eq 1 then sigy=fltarr(n) + sigy
        nix=n_elements(sigx)
        if (nix eq 1) and (sigx(0) ne 0.0) then sigx=fltarr(n) + sigx
        nix=n_elements(sigx)
        if (nix ne n) and (nix ne 1) then message,$
           'sigx vector must have the same length as X, or be a scalar'
        dsq=shift(x,-1)-shift(x,1)
        dsq=dsq*dsq
        dy=shift(y,-1)-shift(y,1)
        sigd=(shift(sigy,-1)*shift(sigy,-1) + shift(sigy,1)*shift(sigy,1))/dsq
        if (nix ne 1) then sigd=sigd + (shift(sigx,-1)^2*dy^2 + $
         shift(sigx,1)^2*dy^2)/(dsq*dsq)
        sigd=sqrt(sigd)
        dsq=x(2)-x(0)
        dsq=dsq*dsq
;
        sigd(0)=(sigy(0)^2*9.0 + sigy(1)^2*16.0 + sigy(2)^2)/dsq
        if (nix ne 1) then sigd(0) = sigd(0) + (sigx(2)^2*(3.0*y(0) - $
         4.0*y(1) + y(2))^2 + sigx(0)^2*(-3.0*y(0) + 4.0*y(1) - y(2))^2)/$
         (dsq*dsq)
        sigd(0)=sqrt(sigd(0))
;
        dsq=x(n-1)-x(n-3)
        dsq=dsq*dsq
        sigd(n-1)=(sigy(n-1)^2*9.0 + sigy(n-2)^2*16.0 + sigy(n-3)^2)/dsq
        if (nix ne 1) then sigd(n-1) = sigd(n-1) + (sigx(n-1)^2*(-3.0*y(n-1)$
         + 4.0*y(n-2) - y(n-3))^2 + sigx(n-3)^2*(3.0*y(n-1) - 4.0*y(n-2)$
         + y(n-3))^2)/(dsq*dsq)
        sigd(n-1)=sqrt(sigd(n-1))
endif
return, sigd
end
;$Id: determ.pro,v 1.6 1994/11/29 18:35:29 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       DETERM
;
; PURPOSE:
;       This function computes the determinant of an N by N array.
;
; CATEGORY:
;       Linear Algebra.
;
; CALLING SEQUENCE:
;       Result = DETERM(A)
;
; INPUTS:
;       A:      An N by N array of type: float, or double.
;
; KEYWORD PARAMETERS:
;       CHECK:  If set to a non-zero value, A is checked for singularity.
;               The determinant of a singular array is returned as zero if
;               this keyword is set. Run-time errors may result if A is
;               singular and this keyword is not set.
;
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
;       ZERO:   Use this keyword to set the value of floating-point
;               zero. A floating-point zero on the main diagonal of
;               a triangular matrix results in a zero determinant.
;               For single-precision inputs, the default value is 
;               1.0e-6. For double-precision inputs, the default value 
;               is 1.0e-12.
;
; EXAMPLE:
;       Define an array (a).
;         a = [[ 2.0,  1.0,  1.0], $
;              [ 4.0, -6.0,  0.0], $
;              [-2.0,  7.0,  2.0]]
;       Compute the determinant.
;         result = determ(a)
;       Note:
;            See CRAMER.PRO, in the same directory as this file, for
;            an application of the determinant function.
;
; PROCEDURE:
;       LU decomposition is used to represent the input array in
;       triangular form. The determinant is computed as the product
;       of diagonal elements of the triangular form. Row interchanges
;       are tracked during the LU decomposition to ensure the correct   
;       sign, + or - .
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, February 1994
;       Modified:    GGS, RSI, November 1994
;                    Added CHECK keyword to check for singular arrays.
;                    Changed NR_LUDCMP to LUDC.
;-

function determ, a, check = check, double = double, zero = zero

  on_error, 2  ;Return to caller if error occurs.

  dim = size(a)
  if dim(1) ne dim(2) then $
    message, 'Input matrix is not square.'

  if dim(3) ne 4 and dim(3) ne 5 then $
    message, 'Input matrix must be float or double.'

  dbl = 0
  if keyword_set(double) ne 0 then dbl = 1
  
  if keyword_set(zero) eq 0 and dim(3) eq 4 then $
    zero = 1.0e-6             ;Single-precision zero.
  if keyword_set(zero) eq 0 and dim(3) eq 5 then $
    zero = 1.0e-12            ;Double-precision zero.

  det = 1.0 ;Initialize determinant.

  ;a = transpose(a) Transposing into column format prior to calling
                    ;nr_ludcmp is unneccesary since the determinant
                    ;is unaffected by the transpose operation.
  
  alud = a ;Make a copy of the array for its LU decomposition.

  if keyword_set(check) then begin ;Return a determinant of zero?
    if cond(a) eq -1 then return, 0.0
  endif

  ;Compute LU decomposition.
  ;nr_ludcmp, alud, index, double = dbl, interchanges = sign
  ludc, alud, index, double = dbl, interchanges = sign

  ;Are there any floating-point zeros on the main diagonal?
  ii = where( abs( alud(indgen(dim(1))*(dim(1)+1)) ) le zero, cnt)

  if cnt ne 0 then return, 0 $ ;A zero on the main diagonal results
  else begin                   ;in a zero determinant.
    for k = 0, dim(1)-1 do $
      det = det * alud(k,k)
    return, sign * det
  endelse

end
; $Id: digital_filter.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION DIGITAL_FILTER,FLOW,FHIGH,A,NTERMS
;+
; NAME:
;	DIGITAL_FILTER
;
; PURPOSE:
;	Compute the coefficients of a non-recursive, digital
;	filter.  Highpass, lowpass, bandpass and bandstop
;	filters may be constructed with this function.
;
; CATEGORY:
;	Signal processing.
;
; CALLING SEQUENCE:
;	Coeff = DIGITAL_FILTER(Flow, Fhigh, A, Nterms)  ;To get coefficients.
;
;	Followed by:
;
;	Yout  = CONVOL(Yin, Coeff)	;To apply the filter.
;
; INPUTS:
;	Flow:	The lower frequency of the filter as a fraction of the Nyquist
;		frequency.
;
;	Fhigh:	The upper frequency of the filter as a fraction of the Nyquist
;		frequency.
;
;	A:	The size of Gibbs phenomenon wiggles in -db.  50 is a good 
;		choice.
;
;	Nterms:	The number of terms in the filter formula.  The order
;		of filter.
;
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;		The following conditions are necessary for various types of
;		filters:
;
;		No Filtering:	Flow = 0, Fhigh = 1.
;		Low Pass:	Flow = 0, 0 < Fhigh < 1.
;		High Pass:	0 < Flow < 1, Fhigh =1.
;		Band Pass:	0 < Flow < Fhigh < 1.
;		Band Stop:	0 < Fhigh < Flow < 1.
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;
; OPTIONAL INPUT PARAMETERS:
;	None.
;
; OUTPUTS:
;	Returns a vector of coefficients with (2*nterms + 1) elements.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	This function returns the coefficients of a non-recursive,
;	digital filter for evenly spaced data points.  Frequencies are
;	expressed in terms of the Nyquist frequency, 1/2T, where T
;	is the time between data samples.
;
; MODIFICATION HISTORY:
;	DMS, April, 1985.
;	Adapted from:
;	"Digital Filters", Robert Walraven, 
;	Proceedings of the Digital Equipment User's Society, Fall, 1984.
;	Department of Applied Science, 
;	University of California, Davis, CA 95616.
;	
;-
;
ON_ERROR,2              ;Return to caller if an error occurs
PI = 3.14159265
IF (FHIGH LT FLOW) THEN STOP = 1. ELSE STOP = 0.
;
;	computes Kaiser weights W(N,K) for digital filters.
; W = COEF = returned array of Kaiser weights
; N = value of N in W(N,K), i.e. number of terms
; A = Size of gibbs phenomenon wiggles in -DB.
;
IF (A LE 21.) THEN ALPHA = 0. $
	ELSE IF (A GE 50.) THEN ALPHA = 0.1102 *(A-8.7)  $
	ELSE ALPHA = 0.5842*(A-21.)^0.4 + 0.07886*(A-21.)
;
ARG = (FINDGEN(NTERMS)+1.)/NTERMS
COEF = BESELI(ALPHA*SQRT(1.-ARG^2),0)/BESELI(ALPHA,0)
T = (FINDGEN(NTERMS)+1)*PI
COEF = COEF * (SIN(T*FHIGH)-SIN(T*FLOW))/T
COEF = [REVERSE(COEF),FHIGH-FLOW+STOP,COEF] ;REPLICATE IT
RETURN,COEF
END
; $Id: dissolve.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro DISSOLVE, image, SIZ = siz, X0 = x0, Y0 = y0, DELAY = delay, $
	ORDER = order
;+
; NAME:
;	DISSOLVE
;
; PURPOSE:
;	A digital "dissolve" effect for images.  Copies the pixels (arranged
;	into square tiles) from the image to the display in pseudo-random
;	order.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	DISSOLVE, Image
;
; INPUTS:
;	Image:	The image to be displayed.  It is assumed that the image is
;		already scaled.  Byte-valued images display most rapidly.
;
; OPTIONAL INPUT PARAMETERS:
;	None.
;
; KEYWORD PARAMETERS:
;	SIZ:	Size of square tile.  The default is 32 x 32 pixels.
;
;	X0, Y0: The X and Y offsets of the lower-left corner of the image on 
;		screen.  The defaults are X0 = 0 and Y0 = 0.
;
;	DELAY:	The wait between displaying tiles.  The default is 0.01 secs.
;
;	ORDER:	The Image display order:  	0 = default = bottom up.
;						1 = top-down.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The image is written to the screen.
;
; RESTRICTIONS:
;	None, but the effect is dependent upon the speed of the
;	machine/display.
;
; PROCEDURE:
;	An integer pseudo-random number generator is used to decide
;	which tile to display.  The algorithm is taken from "Graphics Gems",
;	Andrew Glassner, ed., Academic Press, 1990, Page 221.
;
; MODIFICATION HISTORY:
;	DMS, Sept, 1990.
;-

; Do a random dissolve, using the TV command.
; 
if n_elements(siz) le 0 then siz = 32	;Default square size....
if n_elements(x0) le 0 then x0 = 0
if n_elements(y0) le 0 then y0 = 0
if n_elements(delay) le 0 then delay = 0.01
if n_elements(order) le 0 then order = 0

s = size(image)
nx = s(1)
ny = s(2)
siz = siz < nx < ny		;Never smaller than dims

nxs = (nx + siz - 1) / siz	;Squares across
nys = (ny + siz - 1) / siz	;Squares up/down


rwidth = alog(nys)/alog(2)	;Bits/dimension
cwidth = alog(nxs)/alog(2)
if rwidth ne fix(rwidth) then rwidth = rwidth + 1  ;Ceiling fcn
if cwidth ne fix(cwidth) then cwidth = cwidth + 1 
rwidth = fix(rwidth)
cwidth = fix(cwidth)
regwidth = rwidth + cwidth	;Total width

; The shift reg mask
mask = ([ '3'xl, '6'xl, '0c'xl,'14'xl, '30'xl, '60'xl, 'b8'xl, '0110'xl, $
	'240'xl, '500'xl, '0ca0'xl, '01b00'xl, '3500'xl, $
	'6000'xl, 'b400'xl, '12000'xl, '20400'xl, '72000'xl, $
	'90000'xl, '140000'xl, '300000'xl, '400000'xl ])(regwidth-2)

colmask = ishft(1,cwidth) -1	;Mask to extract column

start_seq = long(systime(1) mod ishft(1,regwidth-1)) ;Random starting cell
if start_seq le 0 then start_seq = 1L
seq = start_seq
repeat begin
	row = ishft(seq, -cwidth)	;The row chunk
	col = seq and colmask		;Col chunk
	if (row lt nys) and (col  lt nxs) then begin  ;Within image?
		y00 = row * siz
		x00 = col * siz
		y01 = (y00 + siz-1) < (ny-1)
		x01 = (x00 + siz-1) < (nx-1)
		if order ne 0 then $
		  y02 = ny - y00 - (y01-y00) > 0 else y02 = y00
		tv,image(x00:x01, y00:y01), x00 + x0, y02+y0, order = order
		wait,delay
		endif
	if seq and 1 then seq = ishft(seq, -1) xor mask $
	else seq = ishft(seq, -1)
endrep until seq eq start_seq

if order eq 0 then tv,image(0:siz-1, 0:siz-1),x0,y0 $	;Last chunk
else tv,image(0:siz-1, 0:siz-1),x0, y0 + ny-siz, /order
empty
end
; $Id: dist.pro,v 1.2 1994/04/28 18:14:15 doug Exp $

function dist,n,m  ;Return a rectangular array in which each pixel = euclidian
		;distance from the corner.
;+
; NAME:
;	DIST
;
; PURPOSE:
;	Create a rectangular array in which each element is proportional
;	to its frequency.  This array may be used for a variety
;	of purposes, including frequency-domain filtering and
;	making pretty pictures.
;
; CATEGORY:
;	Signal Processing.
;
; CALLING SEQUENCE:
;	Result = DIST(N [, M])
;
; INPUTS:
;	N = number of columns in result.
;	M = number of rows in result.  If omitted, N is used to return
;		a square array.
;
; OUTPUTS:
;	Returns an (N,M) floating array in which:
;
;	R(i,j) = SQRT(F(i)^2 + G(j)^2)   where:
;		 F(i) = i  IF 0 <= i <= n/2
;		      = n-i  IF i > n/2
;		 G(i) = i  IF 0 <= i <= m/2
;		      = m-i  IF i > m/2
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.  The computation is done a row at a time.
;
; MODIFICATION HISTORY:
;	Very Old.
; 	SMR, March 27, 1991 - Added the NOZERO keyword to increase efficiency.
;				(Recomended by Wayne Landsman)
;	DMS, July, 1992.  - Added M parameter to make non-square arrays.
;-
on_error,2              ;Return to caller if an error occurs
x=findgen(n)		;Make a row
x = (x < (n-x)) ^ 2	;column squares
if n_elements(m) le 0 then m = n

a = FLTARR(n,m,/NOZERO)	;Make array

for i=0L, m/2 do begin	;Row loop
	y = sqrt(x + i^2) ;Euclidian distance
	a(0,i) = y	;Insert the row
	if i ne 0 then a(0, m-i) = y ;Symmetrical
	endfor
return,a
end


; $Id: dl_dos.pro,v 1.2 1993/04/09 23:15:35 ali Exp $

pro doc_file, name, outunit     ; print documentation for file 'name'
    printf, outunit
    printf, outunit, '----- Documentation for ',name
    printf, outunit
    openr, unit, name, /GET_LUN
    line = ""
    outflag = 0
    readf, unit, line
    while not eof(unit) and strpos(line, ";-") ne 0 do begin
      if outflag then printf, outunit, strmid(line, 1, 132)
;
; output lines after line which starts with ";+"
;
      if strpos(line, ";+") eq 0 then outflag = 1
      readf, unit, line
    endwhile
    close, unit
end

pro dl_dos, name, print=printflg, directory = direct
;+NODOCUMENT
; NAME:
;	DL_DOS
;
; PURPOSE:
;	Extract the documentation template of one or more procedures (DOS
;	version).
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	DL_DOS		;For prompting.
;	DL_DOS, Name 	;Extract documentation for procedure Name using
;				the current !PATH.
;
; INPUTS:
;	Name:	A string containing the name of the procedure or "*" for all.
;
; OPTIONAL INPUT PARAMETERS:
;	PRINT:	A keyword parameter which, if set to 1, sends the output
;		of DL_DOS to PRN:.  If PRINT is a string, it specifies the
;		name of a file that will contain the documentation.
;
;   DIRECTORY:	The directory to search.  If omitted, the current directory
;		and !PATH are used.
;
; OUTPUTS:
;	No explicit outputs.  Documentation is output using 'more' format 
;	unless /PRINT is specified.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Output is produced on terminal or printer.  If the current directory
;	is also one of the directories specified in !PATH or DIRECTORY,
;	documentation will be output twice for the specified module(s).
;
; RESTRICTIONS:
;	??
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	SNG, Dec, 1990 - adapted from DOC_LIB_UNIX 
;	AB, 21 September 1992, renamed from DOC_LIB_DOS to DL_DOS to
;		avoid DOS filename limitations.
;-

on_error,2              ;Return to caller if an error occurs
if n_elements(name) eq 0 then begin	;Interactive query?
	name = ''
	printflg = 0	
	read, 'Name of procedure or * for all: ',name
	read, 'Enter 1 for printer, 0 for terminal: ',printflg
	endif

name = strlowcase(name)		;make it always lower case

;
; if DIRECTORY not specified, use !path
;
if n_elements(direct) eq 0 then begin
  cd, current=curr
  curr = strlowcase(curr)       ; make lower case
;
;   add the current directory to the search path if it is not already there 
;
  if strpos(!path, curr) eq -1 then path = ".;" + !path else path = !path
endif else path = direct    ; otherwise use DIRECTORY 
;
; determine where output is going and open as a file
;
if n_elements(printflg) eq 0 then begin
  openw, outunit, filepath(/TERMINAL), /MORE, /GET_LUN   ;terminal
endif else begin
  printflg = strtrim(printflg, 2)
  case printflg of 
    '0':  openw, outunit, filepath(/TERMINAL), /MORE, /GET_LUN  ; terminal
    '1':  openw, outunit, 'prn:', /GET_LUN                      ; printer
    else:   openw, outunit, printflg, /GET_LUN                   ; file
  endcase
endelse
;
; loop for every directory in path
;
while strlen(path) gt 0 do begin ; Find it
    i = strpos(path, ";")
    if i lt 0 then i = strlen(path)
    name_path = strmid(path, 0, i)
    cd, name_path
    name_path = name_path + '\'
;
;           file_list contains all file(s) to document
;
    file_list = findfile(name_path + name + '.pro',count=n_files)
    n_files = n_files - 1                       ; since indexed from zero
    for n = 0, n_files do begin                  ; document every file
        doc_file, file_list(n), outunit
        printf, outunit, ''     ; output form feed to start next at top of page
    endfor
    path = strmid(path, i + 1, 1000)
endwhile
FREE_LUN, outunit
cd, curr
end
; $Id: dl_mac.pro,v 1.1 1994/11/14 23:41:27 davee Exp $

pro doc_file, name, outunit     ; print documentation for file 'name'
  printf, outunit
  printf, outunit, '----- Documentation for ',name
  printf, outunit

  openr, unit, name, /GET_LUN

  line = ""
  outflag = 0
  readf, unit, line
  while not eof(unit) and strpos(line, ";-") ne 0 do begin
    if outflag then $
      printf, outunit, strmid(line, 1, 132)

    ; output lines after line which starts with ";+"
    if strpos(line, ";+") eq 0 then $
      outflag = 1
    readf, unit, line
  endwhile

  close, unit
end

pro DL_MAC, NAME, PRINT=printflag, DIRECTORY = direct

;+NODOCUMENT
; NAME:
;	DL_MAC
;
; PURPOSE:
;	Extract the documentation template of one or more procedures (Macintosh
;	version).
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	DL_MAC		;For prompting.
;	DL_MAC, Name 	;Extract documentation for procedure Name using
;				the current !PATH.
;
; INPUTS:
;	Name:	A string containing the name of the procedure or "*" for all.
;
; OPTIONAL INPUT PARAMETERS:
;
;   DIRECTORY:	The directory to search.  If omitted, the current directory
;		and !PATH are used.
;
;       PRINT:  Name of a file to print to.
;
; OUTPUTS:
;	No explicit outputs.  Documentation is output using 'more' format 
;	unless /PRINT is specified.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Output is produced on terminal or to a file.  If the current directory
;	is also one of the directories specified in !PATH or DIRECTORY,
;	documentation will be output twice for the specified module(s).
;
; RESTRICTIONS:
;	??
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	DJE, 14 Nov 1994, adapted from DL_DOS.PRO
;-

  on_error,2                            ;Return to caller if an error occurs

  ;Interactive query?
  if n_elements(name) eq 0 then begin
    name = ''
    read, 'Name of procedure or * for all: ',name
  endif

  name = strlowcase(name)               ;make it always lower case

  ;
  ; if DIRECTORY not specified, use !path
  ;
  if n_elements(direct) eq 0 then begin
    cd, current=curr

    ; add the current directory to the search path if it is not already there 
    if strpos(!path, curr) eq -1 then $
      path = curr + "," + !path $
    else $
      path = !path
  endif else begin
    path = direct                       ; otherwise use DIRECTORY 
  endelse

  ;
  ; output always goes to the log window
  ;
  outunit=-1
  if n_elements(printflag) ne 0 then $
    openw, outunit, printflag, /GET_LUN

  ;
  ; loop for every directory in path
  ;
  while strlen(path) gt 0 do begin ; Find it
    i = strpos(path, ",")
    if i lt 0 then i = strlen(path)
    name_path = strmid(path, 0, i)
    cd, name_path

    ;
    ;  file_list contains all file(s) to document
    ;
    file_list = findfile(name_path + name + '.pro', count=n_files)
    ; document every file
    for n = 0, n_files-1 do begin
      doc_file, file_list(n), outunit
      printf, outunit
    endfor
    path = strmid(path, i + 1, 1000)
  endwhile

  if n_elements(printflag) ne 0 then $
    close, outunit
  cd, curr

end
; $Id: dl_unix.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro dl_unix, name, print=printflg, directory = direct, multi = multi
;+NODOCUMENT
; NAME:
;	DL_UNIX
;
; PURPOSE:
;	Extract the documentation template of one or more IDL modules
;	(procedures or functions).
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	DL_UNIX		;For prompting.
;	DL_UNIX, Name 	;Extract documentation for procedure Name using
;				the current !PATH.
;
; INPUTS:
;	Name:	The string containing the name of the procedure or "*" for all.
;	
; KEYWORDS:
;	PRINT:	If set, this keyword sends output of DL_UNIX to lpr.  If
;		PRINT is a string, it is interpreted as a shell
;		command used for output with the documentation from 
;		DL_UNIX providing standard input 
;		(i.e., PRINT="cat > junk").
;
;   DIRECTORY:	The directory to search.  If omitted, the current directory
;		and !PATH are used.
;
;	MULTI:	If set, this flag allows printing of more than one file if the
;		requested module exists in more than one directory in the path
;		and the current directory.
;
; OUTPUTS:
;	No explicit outputs.  Documentation is piped through "more" unless
;	/PRINT is specified.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Output is produced on terminal or printer.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	DMS, Feb, 1988.
;	AB, 21 September 1992, renamed from DOC_LIB_UNIX to DL_UNIX to
;		avoid DOS filename limitations.
;-

on_error,2              ;Return to caller if an error occurs
if n_elements(name) eq 0 then begin	;Interactive query?
	name = ''
	printflg = 0	
	read,'Name of procedure or * for all: ',name
	read,'Enter 1 for printer, 0 for terminal: ',printflg
	endif
name = strlowcase(name)		;make it always lower case

if n_elements(direct) eq 0 then path = ".:" + !path $	;Directories to search
	else path = direct
if n_elements(printflg) eq 0 then output = " more " $
else if strtrim(printflg,2) eq '1' then output = " lpr " $
else if strtrim(printflg,2) eq '0' then output = " more " $
else output = "'"+printflg+"' "

if n_elements(multi) le 0 then multi = 0	;Only print once
if strpos(name,"*") ge 0 then begin	;Wild card?
	multi = 1		;allow printing of multiple files
	endif

cmd = !dir + "/bin/doc_library "+output+strtrim(multi,2)+' ' ;Initial cmd
	
while strlen(path) gt 0 do begin ; Find it
	i = strpos(path,":")
	if i lt 0 then i = strlen(path)
	file = strmid(path,0,i)+ "/" + name + ".pro"
;	print,"File: ",file
	path = strmid(path,i+1,strlen(path))
	cmd = cmd + ' ' + file
	endwhile
;print,cmd
spawn,cmd
end
; $Id: dl_vms.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro DL_VMS, NAME, FILE=file, PRINT=printflg, PATH = path, $
	NOFILEMSG=nofilemsg
;+NODOCUMENT
; NAME:
;	DL_VMS
;
; PURPOSE:
;	Extract the documentation template of one or more procedures.
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	DL_VMS		;For prompting.
;	DL_VMS, Name	;Extract documentation for procedure Name using
;				the current !PATH.
;
; INPUTS:
;	Name:   A string containing the name of the procedure.
;
; KEYWORDS:
;	FILE:   If this keyword is set, the output is sent to the file
;		"userlib.doc", in the current directory.
;
;	PRINT:  If set, this keyword sends the  output of DL_VMS to lpr.
;
;	PATH:   An optional directory/library search path.  This keyword uses
;		the same format and semantics as !PATH.  If omitted, !PATH is
;		used.
; OUTPUTS:
;	Documentation is output to terminal or printer.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Output is produced on terminal or printer.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	Written, DMS, Sept, 1982.
;	Added library param, Jul 1987.
;	Unix version, Feb, 1988.
;	Revised for VMS Version 2, 15 December 1989
;	Modified by Jim Pendleton, GRO/OSSE NU, July 30, 1992 to handle
;		!PATH's gt 255 characters.
;	AB, 21 September 1992, renamed from DOC_LIB_VMS to DL_VMS to
;		avoid DOS filename limitations.
;	ACY, 25 January 1993, file should be written with stream mode
;-

on_error,2			 ;Return to caller if an error occurs
params = n_params()
if n_elements(path) eq 0 then path = !path
do_print = keyword_set(printflg)
to_file = keyword_set(file)
do_filemsg = not keyword_set(nofilemsg)
if (to_file) then del_file = 0 else del_file = 1

if n_elements(name) eq 0 then begin	;Interactive query?
  name = ''
  printflg = 0
  read,'Name of procedure: ',name
endif

wild = name eq '*'		 ;True for all modules
;  name = strlowcase(name)	 ;make it always lower case
name = strupcase(name)	  ;make it always upper case

setlog,'_DOCUMENT',' ',table='LNM$JOB'  ;Logical name used for communic
cmd_file = !dir + '[bin]doc_library' ;Name & locn of cmd proc

;;cmd = '@'+ cmd_file + '  "[],'+path+'" '+name  ;To search curr directory
;;;; cmd = '@'+ cmd_file + '  "'+path+'" '+name  ;To omit current directory
;;spawn, cmd

; Convert path into a string array, one path section per array element
bpath = byte(path)
comma = (byte(','))(0)
loc = where(bpath eq comma, n_seg)
if (n_seg eq 0) then begin
  path_arr = path
endif else begin
  path_arr = strarr(n_seg + 1)
  last = 0
  for i = 0, n_seg-1 do begin
    path_arr(i) = string(bpath(last:loc(i)-1))
    last = loc(i)+1
  endfor
  path_arr(n_seg) = string(bpath(last:*))
endelse


; Define the logical IDL_DL_PATH to be a multi-valued logical containing
; the value of path_arr
for i = 0, n_elements(path_arr) - 1 do begin
	setlog, 'IDL_DL_PATH_' + strtrim(i, 2), path_arr(i)
endfor

; Spawn the command file to do the searching
spawn, '@'+ cmd_file + '  ' + name
for i = 0, n_elements(path_arr) - 1 do begin
	dellog, 'IDL_DL_PATH_' + strtrim(i, 2)
endfor
i = trnlog('_DOCUMENT', table='LNM$JOB', status)
if status eq ' ' then message, 'Error executing command file ' + cmd_file

if status eq "?" then message, 'Module ' + name + ' not found in library.'

i = strpos(status,' ')	  ;Found module, process
in_name = strmid(status, 0, i)  ;Input file name
to_delete = strmid(status, i+1,1) eq '1'  ;Delete input file flag
source = strmid(status, i+3, 100)	;Source file

if (to_file or do_print) then begin
  openw,outunit,'userlib.doc', /GET_LUN, PRINT=do_print, DELETE=del_file, $
     /STREAM
  if (to_file and do_filemsg) then $
    message, 'Documentation is in file "userlib.doc".', /INFORMATIONAL
endif else begin
  openw,outunit,'sys$output', /GET_LUN, /MORE
endelse

if not wild then begin
	printf, outunit, '---- Module: ', STRUPCASE(name), ' ----'
	printf, outunit, '---- From:   ', source,'  -----'
	endif

openr,inunit,in_name, /GET_LUN, delete=to_delete ;Read text file, delete when done
A=''
WHILE NOT EOF(inunit) DO BEGIN
  READF,inunit,A
  IF STRMID(A,0,2) EQ ';+' THEN BEGIN
    READF,inunit,A
    WHILE STRMID(A,0,2) NE ';-' DO BEGIN
	 PRINTF,outunit,STRMID(A,1,100) & READF,inunit,A
	 ENDWHILE
    if not wild then goto, done else printf, outunit, " "
    ENDIF
ENDWHILE

done: FREE_LUN, inunit, outunit
END
; $Id: doc_library.pro,v 1.3 1995/01/20 19:41:01 tonyh Exp $

pro doc_library, name, print=printflg, directory = direct, multi = multi, $
	PATH = path, FILE=file
;+
; NAME:
;	DOC_LIBRARY
;
; PURPOSE:
;	Extract the documentation template of one or more IDL modules
;	(procedures or functions).  This command provides a standard interface
;	to the operating-system specific DL_DOS, DL_UNIX, and
;	DL_VMS procedures.
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	DOC_LIBRARY		;For prompting.
;
;	DOC_LIBRARY, Name 	;Extract documentation for procedure Name using
;				the current !PATH.
;
; INPUTS:
;	Name:	The string containing the name of the procedure.
;		Under Unix, Name may be "*" to get information on all routines.
;
; KEYWORDS:
;	PRINT:	If set, this keyword sends the output of DOC_LIBRARY to the
;		default printer.  Under Unix, if PRINT is a string, it is
;		interpreted as a shell command used for output with
;		the documentation from DOC_LIBRARY providing standard input
;		(i.e. PRINT="cat > junk").
;
; UNIX KEYWORDS:
;   DIRECTORY:	The directory to search.  If omitted, the current directory
;		and !PATH are used.
;
;	MULTI:	If set, this flag allows printing of more than one file if the
;		requested module exists in more than one directory in the path
;		and the current directory.
;
; VMS KEYWORDS:
;	FILE:	If this keyword is set, the output is left in the file
;		"userlib.doc", in the current directory.
;
;	PATH:	An optional directory/library search path.  This keyword uses
;		the same format and semantics as !PATH.  If omitted, !PATH is
;		used.
;
; OUTPUTS:
;	Documentation is sent to the standard output unless /PRINT
;	is specified.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Output is produced on terminal or printer.
;
; RESTRICTIONS:
;	The DIRECTORY and MULTI keywords are ignored under VMS. The
;	FILE and PATH keywords are ignored under Unix.
;
; EXAMPLE:
;	To obtain documentation for the User's Library function DIST, enter:
;		DOC_LIBRARY, 'DIST'
;
;	For a graphical interface to DOC_LIBRARY, see the procedure XDL.
;
; MODIFICATION HISTORY:
;	Written, DMS, Sept, 1982.
;	Added library param, Jul 1987.
;	Unix version, DMS, Feb, 1988.
;	New VMS version, DMS, Dec. 1989
;	Wrapper procedure to call the correct version
;		under Unix and VMS, AB, Jan 1990
;       Added support for DOS, SNG, Dec, 1990
;	Added support for Macintosh, DJE, Nov, 1994
;-

on_error,2                        ;Return to caller if an error occurs
case !version.os of
  'vms':	DL_VMS, NAME, PRINT=printflg, FILE=file, PATH=path
  'Win32':	DL_DOS, NAME, DIRECTORY=direct, PRINT=printflg
  'MacOS':	DL_MAC, NAME, DIRECTORY=direct, PRINT=printflg
  else:		DL_UNIX, NAME, DIRECTORY=direct, PRINT=printflg, MULTI = multi
endcase
end
;
; $Id: draw_alloc.pro,v 1.7 1994/06/01 23:08:48 ali Exp $
;
;  WidDraw
;   Widget Draw class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  DRAW_Icon
;       Return the draw toolbar icon
;
FUNCTION DRAW_Icon
  RETURN, [ $
    [ 255b, 255b, 255b, 255b ], $
    [ 31b, 0b, 0b, 128b ], $
    [ 31b, 0b, 0b, 128b ], $
    [ 159b, 219b, 185b, 157b ], $
    [ 153b, 255b, 249b, 159b ], $
    [ 153b, 255b, 255b, 159b ], $
    [ 25b, 255b, 255b, 143b ], $
    [ 153b, 255b, 255b, 159b ], $
    [ 153b, 255b, 255b, 159b ], $
    [ 31b, 255b, 255b, 143b ], $
    [ 159b, 255b, 255b, 135b ], $
    [ 153b, 255b, 255b, 147b ], $
    [ 153b, 127b, 255b, 153b ], $
    [ 25b, 62b, 254b, 132b ], $
    [ 25b, 158b, 124b, 134b ], $
    [ 153b, 207b, 57b, 159b ], $
    [ 159b, 231b, 147b, 159b ], $
    [ 159b, 243b, 199b, 159b ], $
    [ 153b, 249b, 239b, 143b ], $
    [ 153b, 252b, 255b, 159b ], $
    [ 25b, 254b, 255b, 159b ], $
    [ 25b, 255b, 255b, 143b ], $
    [ 153b, 255b, 255b, 159b ], $
    [ 159b, 255b, 249b, 159b ], $
    [ 159b, 219b, 185b, 157b ], $
    [ 31b, 0b, 0b, 128b ], $
    [ 31b, 0b, 0b, 128b ], $
    [ 255b, 255b, 255b, 255b ], $
    [ 255b, 255b, 255b, 255b ], $
    [ 255b, 193b, 96b, 240b ], $
    [ 255b, 193b, 96b, 240b ], $
    [ 255b, 255b, 255b, 255b ]  $
  ]
END


;
;  DRAW_Copy
;   Copy a draw.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO DRAW_Copy, Ptr, Copy
    GenCopy, Ptr, Copy
END


;
;  DRAW_Destroy
;   Release resources for the given draw
;
PRO DRAW_Destroy, Ptr
    GenDestroy, Ptr
END


;
;  DRAW_Event
;   Event handling routine for a draw dialog.  Shares common code
;   (c.f. widbuild.pro)
;
PRO DRAW_Event, Event
    MISC_Event, Event, -1   ; constant is Font Offset in Foci
END


;
;  DRAW_Build
;   Create a dialog box a draw object.  If ptr is nil then
;   create the object as well.
;
PRO DRAW_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    DRAW_Alloc, ParPtr, Ptr                ; Allocate object if necessary
    MgrName = 'WE_DRAW' + STRTRIM(Ptr, 2)  ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(9)

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    BuildXY, Base1, Obj, Foci, 0, /SIZE

    ;   Event Related Info

    Base2   = WIDGET_BASE(Base1,/NONEXCLUSIVE, /ROW)
    Button  = WIDGET_BUTTON(Base2, VALUE='Accept Button Events', $
                    UVALUE='DO_BUTTON')
    IF Obj.DrawBtnEv THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Accept Motion Events', $
                    UVALUE='DO_MOTION')
    IF Obj.DrawMoEv THEN WIDGET_CONTROL, Button, /SET_BUTTON

    Base2   = WIDGET_BASE(Base1, /FRAME, /ROW)
    Lab     = WIDGET_LABEL(Base2, VALUE="Backing Store:")
    Base3   = WIDGET_BASE(Base2, /ROW, /EXCLUSIVE)
    Btns    = LONARR(3)
    Btns(0) = WIDGET_BUTTON(Base3, VALUE='None', UVALUE='NO_STORE', /NO_REL)
    Btns(1) = WIDGET_BUTTON(Base3, VALUE='Server', UVALUE='SVR_STORE', /NO_REL)
    Btns(2) = WIDGET_BUTTON(Base3, VALUE='IDL', UVALUE='IDL_STORE', /NO_REL)
    WIDGET_CONTROL, Btns(Obj.DrawRetain), /SET_BUTTON

    BuildOther, Base, Obj, Foci, 2, /FRAME

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Draw Appearance Controls")
    BuildXY, Base1, Obj, Foci, 5, /OFFSET, /SCROLL
    BuildOkCancel, Base, Obj

    DlgInfo     = { $
        Foci:       Foci, $
        ObjPtr:     Ptr $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='DRAW_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  DRAW_Save
;   Save draw information to a file.
;   This is a simple object to save.
;
PRO DRAW_Save, Unit, Ptr
    GenWrite, Unit, Ptr
END


;
;  DRAW_Restore
;   Read in a draw object from a file
;
PRO DRAW_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "DRAW", 0
END



;
;  DRAW_Generate
;   Create a draw object for previewing
;
PRO DRAW_Generate, Base, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Build a command string

    Cmd = 'Id = WIDGET_DRAW(Base'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IAddCmd, Cmd, Obj.DrawRetain, 'RETAIN'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'
    IAddCmd, Cmd, Obj.XScrollSize, 'X_SCROLL_SIZE'
    IAddCmd, Cmd, Obj.YScrollSize, 'Y_SCROLL_SIZE'

    ; Create draw by executing the command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        Obj2Ptr, Obj, Ptr
        MESSAGE,'Could not create Draw ' + VarName(Ptr)
    ENDIF

    Obj.DrawId  = Id    ; Save widget id for TestDraw

    Obj2Ptr, Obj, Ptr
END


;
;  DRAW_GenWid
;   Create IDL code for creating a DRAW
;
PRO DRAW_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)            ; Get name for draw
    Ptr2Obj, Ptr, Obj               ; Get object information

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_DRAW( ",A)', $
        Name, Parent, /NO_EOL
    ISaveCmd, Unit, Obj.DrawBtnEv, "BUTTON_EVENTS"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    ISaveCmd, Unit, Obj.DrawMoEv, "MOTION_EVENTS"
    ISaveCmd, Unit, Obj.DrawRetain, "RETAIN", /FORCE
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    SSaveCmd, Unit, Obj.Value, "VALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.XScrollSize, "X_SCROLL_SIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    ISaveCmd, Unit, Obj.YScrollSize, "Y_SCROLL_SIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  DRAW_Alloc
;       Allocate a draw object.  Don't allocate if ptr is non-nil
;
PRO DRAW_Alloc, Parent, Ptr
  COMMON WidEd_Comm    

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return

    Ptr = WIDGET_BASE(GROUP=TopDlg)         ; Allocate a pointer

    ;   Create a draw object

    Obj = {                     $
        WE_DRAW,                $
        Type:           'DRAW', $
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; Title or object name
        FrameSize:      0,      $
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        XScrollSize:    0,      $
        YScrollSize:    0,      $
        UValue:         '',     $
        Value:          '',     $
        DrawId:         0L,     $
        DrawBtnEv:      0,      $
        DrawMoEv:       0,      $
        DrawRetain:     0       $
    }
    Obj2Ptr, Obj, Ptr           ; Store object in pointer
END
; $Id: efont.pro,v 1.5 1995/01/26 03:57:53 billo Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.


Function MESSAGE_BOX, msg, YES_NO = yes_no, OK_CANCEL = OK_CANCEL
; Display strings in MSG (may be an array), in a modal dialog box.
; 

a = widget_base(/column)

for i=0, n_elements(msg)-1 do $
	b = widget_text(a, value = msg(i), xsize = strlen(msg(i)))
c = WIDGET_BASE(a, /ROW)
if keyword_set(yes_no) then begin
	r1 = WIDGET_BUTTON(c, value = 'Yes')
	r0 = WIDGET_BUTTON(c, value = 'No')
endif else if keyword_set(ok_cancel) then begin
	r1 = WIDGET_BUTTON(c, value = 'OK')
	r0 = WIDGET_BUTTON(c, value = 'Cancel')
endif else r1 = WIDGET_BUTTON(c, value='OK')

WIDGET_CONTROL, a, /realize
; XMANAGER, 'Message_box', a, EVENT_HANDLER = 'KILL_ME', /MODAL
x = widget_event(a)
widget_control, x.top, /destroy
return, x.id eq r1
end


PRO translate_vects, in, x, y, pen_up   ;Given packed vectors,
; return the X, Y, and Pen_up components.

x = (ishft(in, -7) and 127)	;Get X and Y components
y = (in and 127)
neg = where(x and 64, count)
if count gt 0 then x(neg) = x(neg)-128
neg = where(y and 64, count)
if count gt 0 then y(neg) = y(neg)-128
pen_up = (in and 16384) ne 0		;Pen up bit
end


PRO draw_char, x0, y0, siz, vects, color = c

if vects(0) eq -1 then return  ;Anything?
n = n_elements(vects)
if (vects(0) and 16384) eq 0 then begin	;Scale factor & offset?
	s = vects(0)/500. * siz
	off = vects(1)
	st = 2
endif else begin
	s = siz
	off = 0
	st = 0
endelse

translate_vects, vects, x, y, pen_up

if n_elements(c) le 0 then c = 1
for i=st, n-1 do plots, s * x(i)+x0, s * y(i)+y0+off, /DEVICE, $
	CONTINUE = pen_up(i) eq 0, COLOR = c
end


PRO redraw, map
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

if n_elements(map) gt 0 then begin
	mapped = map
	WIDGET_CONTROL, fdraw, MAP=map eq 0
	WIDGET_CONTROL, cdraw, MAP=map eq 1
endif
	
WIDGET_CONTROL, fnum_txt, SET_VALUE='Font '+strtrim(fnum,2)
if mapped eq 0 then begin
	wset, fwin
	erase
	draw_font
endif else begin
	wset, cwin
	erase
	draw_grid
	plots, [1,1] * sx * cur_chartab.width + x_0, [0, !d.y_size-1], $
		color=4, /DEV, LINES=2
	if cur_vects(0) ne -1 then draw_char, x_0, y_0, sx, cur_vects
	t = '"' + string(byte(cur_char)) + '" = ' + $
	   strtrim(cur_char,2) + '(10) '+ $
	    string(cur_char, format='(O3)') + '(8) ' +  $
	    string(cur_char, format='(Z2)') + '(16). ' + $
	    strtrim(n_elements(cur_vects), 2) + ' Vectors'
	WIDGET_CONTROL, cinfo_txt, SET_VALUE = t
	WIDGET_CONTROL, cwidth_txt, set_value=strtrim(fix(cur_chartab.width),2)
	endelse
END




PRO draw_font
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

for i=0,15 do xyouts, (i+2)*chx, !d.y_size - chy, /DEV, siz=1.5, $
	string(i, format='(z1)')
for i= 2, (nchars+32)/16-1 do begin	;Rows
	y = !d.y_size - (i+0) * chy
	xyouts, 0, y, /DEV, string(i, format='(z1)'), siz=1.5
	for j=0, 15 DO BEGIN
	    c = i*16 + j
	    offset = chartab(c-32).offset
	    nv = chartab(c-32).nvecs
	    if nv ne 0 then begin
		draw_char, (j+2) *chx, y, 1.0, vectors(offset : offset + nv-1)
		endif
	    ENDFOR
	ENDFOR
END


PRO draw_grid, color
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

if n_elements(color) le 0 then color = 3

nx = !d.x_size / sx
ny = !d.y_size / sx
x_0 = (!d.x_size/2 - sx * 16 + sx-1)/sx * sx  ;Grid point of origin
y_0 = (!d.y_size/2 - sx * 16 + sx-1)/sx * sx
c = 3

if sx le 8 then dx = (16/sx) * sx else dx = sx
for i=0,!d.x_size-1, dx do for j=0, !d.y_size-1, dx do $
	plots, i, j, psym=1, color=c, /dev
plots, [0, !d.x_size-1], [y_0, y_0], /DEV, color=2, lines=2
plots, [x_0, x_0], [0, !d.y_size-1], /DEV, color=2, lines=2
return

for i=0, !d.x_size-1, sx do begin
	if (i-x_0 eq 0) or (i-x_0 eq 32*sx) then l = 2 else l = 1
	plots, [i, i], [0, !d.y_size-1], /DEV, color = c, LINES=L
	endfor

for i=0, !d.y_size-1, sx do begin
	if (i-y_0 eq 0) or (i-y_0 eq 32*sx) then l=2 else l =1
	plots, [0, !d.x_size-1], [ i, i],  /DEV, color = c, LINES=l
	endfor
end

PRO ADD_VECTOR, v0, v1		;V0 and v1 are in screen coords..
; dup_move = 0 to add a vector, 1 to move a vector by v1-v0, and 2 to
;  move & duplicate.
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move


x0 = FIX((v0(0) - x_0) / sx) and 127	;To our coords
x1 = FIX((v1(0) - x_0) / sx) and 127
y0 = FIX((v0(1) - y_0) / sx) and 127
y1 = FIX((v1(1) - y_0) / sx) and 127

if x0 eq x1 and y0 eq y1 then return	;Nothing to add
e0 = fix(ishft(x0, 7) + y0)		;Encoded new vects
e1 = fix(ishft(x1, 7) + y1)

if cur_vects(0) eq -1 then begin	;No vectors yet
	cur_vects = [ e0 + 16384, e1]
	return
	endif

if dup_move eq 0 then begin
	cur_vects = [ cur_Vects, e0 + 16384, e1]  ;Dumb way
	return
	endif

translate_vects, cur_vects, x, y, pen_up	;Disassemble
case dup_move of
1:	BEGIN
	x = x + (x1-x0)
	y = y + (y1-y0)
	ENDCASE
2:	BEGIN
	x = [ x, x + (x1-x0)]
	y = [ y, y + (y1-y0)]
	pen_up = [pen_up, pen_up]
	ENDCASE
3:	BEGIN
	x = fix(x * float(x1)/float(x0) + 0.5)
	y = fix(y * float(y1)/float(y0) + 0.5)
	ENDCASE
ENDCASE
cur_vects = ishft(x and 127,7) + (y and 127) + 16384 * pen_up  ;Recombine
dup_move = 0
redraw
end


PRO Order_vectors, ctab, cvects
; Order the vectors for the character, combining where possible.

common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

print,'Segments in  = ', fix(total((cvects and 16384) ne 0))
merge_loop: 
    n = n_elements(cvects)
    bsegs = where((cvects and 16384) ne 0, count)	;Beginning segments
    if count lt 2 then goto, merge_done
    esegs = [ bsegs(1:*) - 1, n-1]		;Ending segments

    b = cvects(bsegs) and 16383
    e = cvects(esegs)
    for i=0, count-2 do for j=i+1,count-1 do begin    ;Dumb search
	if b(i) eq e(j) then begin
	    v = [ cvects(bsegs(j):esegs(j)), cvects(bsegs(i)+1:esegs(i))]
	    goto, merge_vects
	    endif
	if b(i) eq b(j) then begin 
	    v = [ reverse(cvects(bsegs(j):esegs(j))), $
		  cvects(bsegs(i)+1: esegs(i))]
	    goto, merge_vects
	    endif
	if e(i) eq e(j) then begin
	    v = [ cvects(bsegs(i):esegs(i)), $
		reverse(cvects(bsegs(j): esegs(j)-1))]
	    goto, merge_vects
	    endif
	if e(i) eq b(j) then begin
	    v = [ cvects(bsegs(i):esegs(i)), cvects(bsegs(j)+1:esegs(j))]
	merge_vects: v = v and 16383	;Mask off pen up bits
	    v(0) = v(0) or 16384	;Pen up on first pnt
	    if count eq 2 then cvects = v $	;Only two
	    else begin
	        k = replicate(1, n)
	        k(bsegs(j):esegs(j)) = 0
	        k(bsegs(i):esegs(i)) = 0
	        cvects = [ cvects(where(k)), v]	;Combine
	    endelse
	    goto, merge_loop
	endif
    endfor

merge_done: ctab.nvecs = n_elements(cvects)
print,'Segments out = ', fix(total((cvects and 16384) ne 0))
end


Function pnt_line, x0, y0, lx0, ly0, lx1, ly1
;  Return the perpendicular distance between the line thru (lx0, ly0)
;  and (lx1, ly1) and the point x0, y0.
; Add to that distance, the distance to the closest point if the 
; perpendicular is not on the line segment.
; 
p0 = float([x0, y0])
p1 = [lx1, ly1]
lu = [lx0, ly0]

lv = float(p1 - lu)
l = sqrt(total(lv*lv))
if l eq 0 then return, sqrt(total((lu-p0)^2))	;Line is a point
lv = lv / l
ln = [ -lv(1), lv(0) ]
lc = -total(ln * lu)

q = lc + total(ln * p0)
q = p0 - q * ln		;The point on the line....

d= (q - p1) * (q - lu)  ;Both are neg or 0 if on line..
if d(0) gt 0 or d(1) gt 0 then begin
	d1 = sqrt(total((p0-p1)^2))
	d2 = sqrt(total((p0-lu)^2))
	return, d1 < d2
	endif

return, sqrt(total((p0 - q)^2))
end


PRO REMOVE_VECTOR, x0, y0		;Remove the vector closest to x0,y0
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

device, SET_GRAPHICS=6, BYPASS=1  	;To XOR mode
draw_char, x_0, y_0, sx, cur_vects, color = xor_color  ;Erase character

n = n_elements(cur_vects)
if n le 2 then begin			;Only one segment?
	cur_vects = -1
	goto, remove_done
	endif

translate_vects, cur_vects, x, y, pen_up
dmin = 1e6

for i=0, n-2 do $		;Each vector
    if pen_up(i+1) eq 0 then begin  ;dont do next vector
	d = pnt_line(x0, y0, x(i), y(i), x(i+1), y(i+1))
	if d lt dmin then begin
		dmin = d
		j = i
		endif
	endif			;Pen up

first_seg = pen_up(j)
if j eq n-2 then last_seg = 1 else last_seg = pen_up(j+2)

if first_seg and last_seg then to_remove = [j, j+1] $
else if not (first_seg or last_seg) then $	;Split
	cur_vects(j+1) = cur_vects(j+1) + 16384 $
else if first_seg then begin
	to_remove = j			;Remove first
	cur_vects(j+1) = cur_vects(j+1) + 16384  ;and make 2nd first
endif else to_remove = j+1		;Remove last

if n_elements(to_remove) gt 0 then begin	;Remove offending segs
	good = replicate(1, n)	   
	good(to_remove) = 0
	cur_vects = cur_vects(where(good))
	endif

remove_done: draw_char, x_0, y_0, sx, cur_vects, color = xor_color
device, set_graphics = 3, BYPASS = 0	;Back to normal
end


FUNCTION str_to_ccode, t	;Return decimal, hex, or octal number
; Formats:  0nn Octal, 0xnn Hex, else Decimal
; 
if strmid(t,0,2) eq '0x' then begin	;Hex
	fmt = '(z8)'
	t = strmid(t,2,100)
endif else if strmid(t,0,1) eq '0' then fmt = '(o6)' $
else fmt = '(i6)'
on_ioerror, bad_num
i = 0
reads, t, i, format=fmt
return, i
bad_num:  junk = message_box(['Invalid character code. Formats = ', $
		'0xnn for hex, 0nn for octal, nnn for decimal'])
return, -1		;For error
end



PRO VIEW_EVENT, event		;Events from the view base

if event.press ne 0 then begin
	WIDGET_CONTROL, event.top, /DESTROY
endif else begin
	widget_control, event.top, get_uvalue=t	;Get parameters
	x = event.x - t(2)
	y = event.y - t(3)
	z = t(1)			;zoom factor
	if x lt 0 then x = (x - z/2) / z $   ;Round in proper direction
	else x = (x + z/2) / z
	if y lt 0 then y = (y - z/2) / z $
	else y = (y + z/2) / z
	WIDGET_CONTROL, t(0), set_value=strtrim(x,2) + ', '+strtrim(y,2)
endelse
end


PRO CMODE_EVENT, event		;For character editor window
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

if event.id eq cdraw then begin
	x = event.x - x_0
	y = event.y - y_0
	if x lt 0 then x = (x - sx/2) / sx $	 ;Round in proper direction
	else x = (x + sx/2) / sx
	if y lt 0 then y = (y - sx/2) / sx $
	else y = (y + sx/2) / sx

	WIDGET_CONTROL, cpos_txt, set_value=strtrim(x,2) + ', '+strtrim(y,2)
	this = sx * [x,y] + [x_0, y_0]  ;Screen coords
	if event.press eq 1 then begin  ;Initiate dragging a vector
	    drag = this
	    prev = drag
	    buttons = 1
	    return
	    endif
	if event.release eq 1 then begin  ;Done dragging a vector...
	    add_vector, drag, this
	    buttons = 0
	    changed = 1
	    return
	    endif
	if buttons ne 0 then begin
	    if (this(0) eq prev(0)) and (this(1) eq prev(1)) THEN RETURN
	    device, SET_GRAPHICS=6, BYPASS=1  ;To XOR mode
	    if prev(0) ne drag(0) or prev(1) ne drag(1) then $
		plots, [drag(0), prev(0)], [drag(1), prev(1)], /DEV, $
			color = xor_color
		prev = this
		plots, [prev(0), drag(0)], [prev(1), drag(1)], /DEV, $
			color = xor_color
		DEVICE, SET_GRAPHICS=3, BYPASS=0
		endif		;Buttons
	if event.press eq 2 then begin		;Middle button to remove
	    if cur_vects(0) eq -1 then return	;Nothing to remove...
	    changed = 1
	    remove_vector, x, y
	    endif		;Remove
	RETURN
ENDIF

WIDGET_CONTROL, event.id, GET_UVALUE = eventval

dup_move = 0
CASE eventval of
"CCODE": BEGIN		;Formats:  0nn Octal, 0xnn Hex, else Decimal
	WIDGET_CONTROL, cinfo_txt, GET_VALUE=t
	i = str_to_ccode(t(0))
	if i lt 32 or i ge (nchars+32) then return
	cur_char = i
	changed = 1
	cur_chartab = chartab(i-32)
	redraw
	return
	ENDCASE
"SCHAR": BEGIN			;Replace char in font
schar0: changed = 0
	save_char, cur_char, cur_chartab, cur_vects
	redraw, 0
	ENDCASE
"SHRINK": dup_move = 3
"DMOVE": dup_move = 2
"MOVE":  dup_move = 1
"WIDTH": BEGIN
	WIDGET_CONTROL, cwidth_Txt, GET_VALUE=t
	cur_chartab.width = fix(t(0))
	REDRAW, 1
	ENDCASE
"REDRAW": redraw
"VIEW": BEGIN
	if changed then begin
		i = MESSAGE_BOX('Saved changes to character?', /YES_NO)
		if i ne 0 then goto, schar0
		endif
	redraw, 0
	ENDCASE
else:  print, eventval
ENDCASE
END
	
PRO save_char, cindex, ctab, cvects		;Save character whose
;  code is cindex, whose struct is ctab, and whose vectors are cvects
;  in the current font.

common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

if cur_char lt 32 then return
c = cindex - 32

offset = chartab(c).offset		;Old beginning
iend = fix(chartab(c).nvecs) + offset	;Old end

if cvects(0) eq -1 then begin		;Removed character?
    ctab.nvecs = 0		;No vectors
    if offset ne iend then begin	;Remove old?
	good = replicate(1,n_elements(vectors))
	good(offset:iend-1) = 0
	vectors = vectors(where(good))
	endif		
    goto, schar1
    endif
		;Adding a non-zero length character.....
order_vectors, ctab, cvects		;Combine where possible
if offset ne 0 then t = [ vectors(0:offset-1), cvects ] $
else t = cvects
if iend ne n_elements(vectors) then vectors = [t, vectors(iend:*) ] $
else vectors = t

schar1: ctab.offset = offset
 chartab(c) = ctab
 for i=c+1, n_elements(chartab)-1 do $    ;Re-align other chars
	chartab(i).offset = chartab(i-1).offset + fix(chartab(i-1).nvecs)
end



PRO save_font, unit, fonttab, index, vectors, chartab

MAX_FONT = 40
mask = '7fffffff'xl
nchars = n_elements(chartab)
point_lun, unit, 0

k = 320				;Starting offset in each file
f = fonttab			;New font table
save = 0
for i=0, MAX_FONT-1 do begin	;Re-arrange each font
    if i eq index then begin	;This font?
	l = n_elements(vectors) * 2 ;Length in bytes of vectors
	k0 = k			;Where we write
	f(0,i) = k0		;Where we start
	if nchars eq 224 then f(1,i) = l or (not mask) $
	else f(1,i) = l
    endif
    if f(0,i) eq -1 then l = 0 else begin  ;Length
        l = f(1,i) and mask		;# of bytes in vects
        if (f(1,i) and (not mask)) ne 0 then l = 4 * 224 + l $
	else l = 4 * 96 + l
	f(0,i) = k		;Starting pos
	if (i gt index) and save eq 0 then $  ;What we have to save
		save = fonttab(0,i)	 ;Where we read
	endelse
    k = k + l
endfor

byteorder, f, /HTONL			;To Network order
writeu, unit, f				;The fonttable
byteorder, f, /NTOHL			;& Back again

if save ne 0 then begin			;Save following fonts
	point_lun, unit, save
	big = max(fonttab(0,*), last)	;Get # of bytes in file
	big = big + (fonttab(1,last) and mask)	;Last byte + 1 of file
	temp = bytarr(big-save, /nozero)
	readu, unit, temp
	endif
point_lun, unit, k0			;Where we write
off = chartab.offset			;Offsets of characters
byteorder, off, /HTONS			;To network order
tc = chartab
tc.offset = off
writeu, unit, tc, vectors		;Write our font

if save ne 0 then writeu, unit, temp	;Following fonts	
fonttab = f				;New font table
print, 'Saved font', index, ' at:', k0
end


PRO cload_proc, event
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

WIDGET_CONTROL, event.id, GET_UVALUE=b
if n_elements(b) le 0 then return

a = event.top			;Top level widget
WIDGET_CONTROL, a, GET_UVALUE=u	;Widget ID's of text widgets....
WIDGET_CONTROL, u(0), GET_VALUE=Fnum_T
index = str_to_ccode(Fnum_t(0))	;Font index
;   if index lt 0 or index ge MAX_FONT then return
if index lt 3 or index ge 30 then return

CASE b of 
"CLOAD": BEGIN
	changed = 1
	WIDGET_CONTROL, u(1), GET_VALUE=Cnum_T
	ccode = str_to_ccode(Cnum_t(0))
	if ccode lt 32 then return
	read_font, index, fonttab, unit, n, c, v	;Read the font
	if n_elements(c) le 1 then return
	if ccode lt 32 or (ccode-32) ge n then goto, bad_code
	old_offset = cur_chartab.offset		;Prev char
	cur_chartab = c(ccode-32)
	offset = cur_chartab.offset
	cur_chartab.offset = old_offset		;Vectors of current char
	nv = fix(cur_chartab.nvecs)
	if nv gt 0 then cur_vects = v(offset : offset + nv-1) $
	else cur_vects = -1
	redraw, 1
	WIDGET_CONTROL, cwidth_txt, SET_VALUE=STRTRIM(FIX(cur_chartab.width),2)
	WIDGET_CONTROL, coff_txt, SET_VALUE=STRTRIM(cur_char_offset,2)
	WIDGET_CONTROL, cscale_txt, SET_VALUE=STRTRIM(cur_char_scale)
	ENDCASE
"CVIEW": BEGIN			;View a character in a new window
	WIDGET_CONTROL, u(1), GET_VALUE=Cnum_T
	ccode = str_to_ccode(Cnum_t(0))
	if ccode lt 32 then return
	read_font, index, fonttab, unit, n, c, v	;Read the font
	if n_elements(c) le 1 then return
	if ccode lt 32 or (ccode-32) ge n then goto, bad_code
	a = WIDGET_BASE(Title='Font '+strtrim(index,2) + ' Char = ' + $
		string(byte(ccode)), /COLUMN)
	t = WIDGET_TEXT(a, xsize=30, ysize=1)
	b = WIDGET_DRAW(a, xsize=!d.x_size, ysize = !d.y_size, /BUTTON, $
		EVENT_PRO = 'VIEW_EVENT', /MOTION)
	c = c(ccode-32)			;The char
	if c.nvecs eq 0 then return	;Nothing there

	widget_control, a, /realize
	widget_control, b, get_value= pwin	;Preview window
	WIDGET_CONTROL, a, SET_UVALUE=[t, sx, x_0, y_0]	;Save the text widget
	draw_grid
	plots, [1,1] * sx * c.width + x_0, [0, !d.y_size-1], $
		color=4, /DEV, LINES=2
	draw_char, x_0, y_0, sx, v(c.offset: c.offset+c.nvecs -1)
	wset, cwin
	ENDCASE
"FLOAD": BEGIN
	changed = 0
	if fonttab(0,index) eq -1 then goto, bad_code
	read_font, index, fonttab, unit, nchars, chartab, vectors
	fnum = index
	redraw, 0
	ENDCASE
"FSAVE": BEGIN
	changed = 0
	if n_elements(vectors) le 1 then begin
		del = message_box('Current font has no characters')
		goto, done
		endif
	close, unit
	openu, unit, FILEPATH("hersh1.chr", subdir=['resource', 'fonts'])
	save_font, unit, fonttab, index, vectors, chartab
	redraw, 0
	fnum = index
	ENDCASE
ENDCASE

done: WIDGET_CONTROL, event.top, /destroy	;All done
return

bad_code:  junk = message_box("Invalid character or font code.")
return
end




PRO rw_font_char, charflg, writeflg

common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

name = (['Font', 'Character'])(charflg)
ierr = 0

open_again: a = widget_base(Title='Read/Write Individual '+ name, /COLUMN)
if ierr ne 0 then junk = WIDGET_LABEL(a, VALUE=f(0) + ' not found.')
a0 = WIDGET_BASE(a, /row)
junk = WIDGET_LABEL(a0, VALUE='File Name: ')
b = WIDGET_TEXT(a0, /EDIT, xsize=20, ysize=1, /FRAME, UVALUE='OK')
junk = WIDGET_BUTTON(a, VALUE='Cancel', UVALUE='CANCEL')
WIDGET_CONTROL, a, /REAL
event = WIDGET_EVENT(a)
WIDGET_CONTROL, event.id, GET_UVALUE=t

IF t EQ "CANCEL" THEN BEGIN
	WIDGET_CONTROL, a, /DESTROY
	return
	ENDIF

WIDGET_CONTROL, b, GET_VALUE=f
WIDGET_CONTROL, a, /DESTROY

if charflg then begin
    if writeflg then begin	;Save character
	openw, unit, /GET_LUN, f(0), /XDR
	writeu, unit, cur_chartab
	nv = fix(cur_chartab.nvecs)
	offset = cur_chartab.offset
	if nv gt 0 then v = vectors(offset: offset + nv-1) else v = -1
	writeu, unit, v
    endif else begin		;Read character
	print,'read'
	openr, unit, /GET_LUN, f(0), /XDR, ERROR=ierr
	if ierr ne 0 then goto, open_again
	readu, unit, cur_chartab
	nv = fix(cur_chartab.nvecs)
	cur_vects = intarr(nv, /NOZERO)
	readu, unit, cur_Vects
	save_char, cur_char, cur_chartab, cur_vects
    endelse
    redraw, 1
endif else begin		;Fonts....
    if writeflg then begin
	openw, unit, /GET_LUN, f(0), /XDR
	writeu, unit, n_elements(chartab), n_elements(vectors)
	writeu, unit, chartab
	writeu, unit, vectors
    endif else begin		;Read a font...
	openr, unit, /GET_LUN, f(0), /XDR, ERROR=ierr
	if ierr ne 0 then goto, open_again
	nc = 0L
	nv = 0L
	readu, unit, nc, nv
	chartab = replicate({CTAB}, nc)
	readu, unit, chartab
	vectors = intarr(nv, /NOZERO)
	readu, unit, vectors
    endelse
    redraw, 0
endelse

free_lun, unit
end


PRO efont_event, event
common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

WIDGET_CONTROL, event.top, /HOURGLASS

if event.id eq fdraw then begin		;Select a character?
	if event.press ne 0 then return
	x = (event.x) / chx - 2
	y = (!d.y_size - event.y ) / chy + 1
	if (x lt 0) or (x gt 15) or $
		(y lt 2) or (y ge (nchars+32)/16) then return
	cur_char = x + y * 16
	cur_chartab = chartab(cur_char-32)
	offset = cur_chartab.offset   ;Vectors of current char
	WIDGET_CONTROL, cwidth_txt, SET_VALUE=STRTRIM(FIX(cur_chartab.width),2)
	WIDGET_CONTROL, coff_txt, SET_VALUE=STRTRIM(cur_char_offset,2)
	WIDGET_CONTROL, cscale_txt, SET_VALUE=STRTRIM(cur_char_scale)
	nv = fix(cur_chartab.nvecs)
	if nv gt 0 then cur_vects = vectors(offset : offset + nv-1) $
	else cur_vects = -1
	redraw, 1
	return
	endif

dup_move = 0
WIDGET_CONTROL, event.id, GET_UVALUE = eventval

IF STRMID(eventval, 0, 1) eq '@' THEN BEGIN
	junk = execute(strmid(eventval, 1, 100))
	return
	ENDIF

CASE eventval of
"SET8":  BEGIN
	if nchars eq 224 then return
	nchars = 224
	t = chartab(0)
	t.nvecs = 0
	t.width = 16
	t.offset = chartab(95).offset
	chartab = [ chartab, replicate(t, 128) ]
	help, chartab
	if mapped eq 0 then redraw
	ENDCASE

"XLOAD": BEGIN
	window, /free, /pix, xsize=128, ysize=128
	siz = '720'
	device, font='-monotype-gill sans-medium-r-normal-sans-0-' + siz + $
		'-75-75-*'
	xyouts, 64, 64, /DEV, string(byte(cur_char)), /FONT, COLOR=xor_color
	device, font = 'fixed'
	a = tvrd()
	wdelete
	redraw, 1
	zoom = 7
	device, SET_GRAPHICS=6		;Xor mode
	tv, rebin(a, 128*zoom, 128*zoom), x_0-(64*zoom), y_0-(64*zoom)
	device, SET_GRAPHICS=3
	ENDCASE
"CVIEW": BEGIN
	uv = "CVIEW"	
	goto, cload_cview
	ENDCASE
"CLOAD": BEGIN		;Load a character from another font....
	uv = "CLOAD"
cload_cview:	a = WIDGET_BASE(TITLE='Load Hershey character', /column)
	junk = widget_base(a, /row)
	junk1 = WIDGET_LABEL(junk, VALUE = 'Font Number:')
	font_t = WIDGET_TEXT(junk, XSIZE=8, YSIZE=1, /EDIT, $
		VALUE=STRTRIM(fnum,2))
	junk = widget_base(a, /row)
	junk1 = WIDGET_LABEL(junk, VALUE = 'Character Code:')
	char_t = WIDGET_TEXT(junk, XSIZE=8, YSIZE=1, /EDIT)
	junk = WIDGET_BUTTON(a, VALUE="OK", UVALUE=uv)
	WIDGET_CONTROL, a, /REALIZE, SET_UVALUE=[font_t, char_t]
	XMANAGER, 'LoadBox', a, EVENT_HANDLER='CLOAD_PROC', /MODAL
	changed = 1
	ENDCASE
"SCHAR":  rw_font_char, 1, 1		;rw_font_char, char_flag, write_flag
"SFONT":  rw_font_char, 0, 1
"RCHAR":  rw_font_char, 1, 0
"RFONT":  rw_font_char, 0, 0

"FLOAD": BEGIN
	a = WIDGET_BASE(TITLE="Load Font", /COLUMN)
	t = "FLOAD"
get_font_num:
	junk = widget_base(a, /row)
	junk1 = WIDGET_LABEL(junk, VALUE = 'Font Number:')
	font_t = WIDGET_TEXT(junk, XSIZE=8, YSIZE=1, /EDIT, $
		VALUE=strtrim(fnum,2))
	junk = WIDGET_BUTTON(a, VALUE="OK", UVALUE=T)
	WIDGET_CONTROL, a, /REALIZE, SET_UVALUE=[font_t, 0]
	changed = 0
	XMANAGER, 'LoadBox', a, EVENT_HANDLER='CLOAD_PROC', /MODAL
	ENDCASE
"HELP" : XDisplayFile, FILEPATH("efont.txt", subdir=['help', 'widget']), $
                TITLE = "EFONT Help", $
                GROUP = event.top, $
                WIDTH = 72, HEIGHT = 24
"SAVE":	BEGIN
	a = WIDGET_BASE(TITLE="Save Font", /COLUMN)
	t = "FSAVE"
	goto, get_font_num
	ENDCASE
"DONE":  BEGIN
;	save_font_file
bail_out: FREE_LUN, unit
	WIDGET_CONTROL, event.top, /DESTROY
	ENDCASE
;"CANCEL":  goto, bail_out
ELSE: help, eventval
ENDCASE
end


pro read_font, index, fonttab, unit, nchars, ctab, vects
; Read the font numbered index from the open unit.  (We assume a font table
;  of 40 elements.)  Return


nfonts = n_elements(fonttab)/2
if nfonts lt 1 then begin		;Read fonttab?
	nfonts = 40
	fonttab = lonarr(2, nfonts)	;Get font directory
	point_lun, unit, 0
	readu, unit, fonttab
	byteorder, fonttab, /NTOHL	;To our order
	endif

if index lt 0 or index ge nfonts then begin
	junk = MESSAGE_BOX('Font index must be in range of 0 to '+ $
		string(nfonts))
	return
	endif
if fonttab(0,index) eq -1 then begin
	junk = MESSAGE_BOX('Font ' + string(index) + ' does not exist')
	return
	endif

mask = '7fffffff'xl
if (fonttab(1,index) and (not mask)) ne 0 then nchars = 256-32 else $
	nchars = 128-32

len = fonttab(1, index) and mask
ctab = replicate({CTAB, nvecs: 0b, width: 0b, offset: 0}, nchars)

point_lun, unit, fonttab(0,index) and '0fffffff'xl	;Beginning of font
readu, unit, ctab
k = 0				;Current offset
for i=0, nchars-1 do begin	;Un swap shorts
	j = ctab(i).offset
	byteorder, j, /NTOHS
	if j eq 0 then j = k $	;Put empty chars in their proper place
	else if j ne k then print,'Inconsistent vector offset/length, chr = ',$
		i+32
	ctab(i).offset = j
	k = k + fix(ctab(i).nvecs)
	endfor

vects = intarr(len/2)		;Read the vectors
on_ioerror, bad
readu, unit, vects
bad: 
byteorder, vects, /NTOHS
end


pro efont, GROUP = GROUP, init_font
;+
; NAME:
;	EFONT
;
; PURPOSE:
;	This widget provides a vector font editor and display.
;
; CATEGORY:
;	Fonts.
;
; CALLING SEQUENCE:
;	EFONT, Init_font
;
; INPUTS:
;	Init_font: The initial font index, from 3 to 29.  Default = 3.
;
; KEYWORD PARAMETERS:
;	GROUP:     The widget group, if part of a hierarchy.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	efont_com.
;
; SIDE EFFECTS:
;	Reads and modifies a local copy of the file hersh1.chr.
;
; RESTRICTIONS:
;	A basic editor.
;
; PROCEDURE:
;	Call EFONT and press the HELP button for instructions.
;
; MODIFICATION HISTORY:
;	DMS	Nov, 1992.
;	WSO, 1/95, Updated for new directory structure
;-



common efont_com, unit, fonttab, nchars, chartab, vectors, fwin, cwin, fnum, $
	fdraw, cdraw, cur_char, cur_chartab, cur_vects, cur_char_offset, $
	cur_char_scale, chx, chy, x_0, y_0, sx, cpos_txt, cinfo_txt, $
	cwidth_txt, coff_txt, cscale_txt, mapped, MAX_FONT, $
	drag, prev, xor_color, buttons, mask, fnum_txt, changed, $
	dup_move

if XRegistered('efont') ne 0 THEN RETURN

MAX_FONT = 40			;# of fonts in header
zooms = [ 4, 8,12, 16, 20]	;Zoom factors...
chx = 32			;Char cell sizes
chy = 32
sx = 16				;Zoom factor
x_0 = 50
y_0 = 50
mapped = 0
cur_char = 32
cur_char_scale = 1
cur_char_offset = 0
buttons = 0
changed = 0
mask = '7fffffff'xl 		;Low bits for file start
dup_move = 0
if n_elements(init_font) gt 0 then fnum = init_font else fnum = 3

openr, unit, FILEPATH("hersh1.chr", subdir=['resource', 'fonts']), /GET_LUN, ERROR=i
if i ne 0 then begin
	junk = message_box(['Open Failed for hersh1.chr', !ERR_STRING])
	return
	endif

readu, unit, fonttab
byteorder, fonttab, /NTOHL	;To our order

main_base = WIDGET_BASE(Title='Hershey Font Editor', /COLUMN)

top_line = WIDGET_BASE(main_base, /ROW)

junk = WIDGET_BUTTON(top_line, /NO_REL, VALUE='Done', UVALUE='DONE')
junk = WIDGET_BUTTON(top_line, /MENU, VALUE='File')
junk1 = WIDGET_BUTTON(junk, /NO_REL, VALUE='Save Character', UVALUE='SCHAR')
junk1 = WIDGET_BUTTON(junk, /NO_REL, VALUE='Save Font', UVALUE='SFONT')
junk1 = WIDGET_BUTTON(junk, /NO_REL, VALUE='Read Character', UVALUE='RCHAR')
junk1 = WIDGET_BUTTON(junk, /NO_REL, VALUE='Read Font', UVALUE='RFONT')
; junk = WIDGET_BUTTON(top_line, /NO_REL, VALUE='Cancel', UVALUE='CANCEL')
junk = WIDGET_BUTTON(top_line, /NO_REL, VALUE='Help', Uvalue = 'HELP')
junk = WIDGET_BUTTON(top_line, /NO_REL, VALUE='Save Font', UVALUE='SAVE')
junk = WIDGET_BUTTON(top_line, /MENU, VALUE='Load')
junk1 = WIDGET_BUTTON(junk, VALUE='Font', UVALUE="FLOAD")
junk1 = WIDGET_BUTTON(junk, VALUE='Character', UVALUE="CLOAD")
junk1 = WIDGET_BUTTON(junk, VALUE='Character, View Only', UVALUE="CVIEW")
;;;;; junk1 = WIDGET_BUTTON(junk, VALUE='Preview X font', UVALUE='XLOAD')

junk = WIDGET_BASE(top_line, /ROW, /FRAME)
junk1 = WIDGET_LABEL(junk, value = 'Zoom:')
junk1 = WIDGET_BASE(junk, /EXCLUSIVE, /ROW)
for i=0, n_elements(zooms)-1 do BEGIN
    junk2 = WIDGET_BUTTON(junk1, VALUE=strtrim(zooms(i),2), $
	UVALUE = '@sx='+strtrim(zooms(i),2) + '& if mapped then redraw',$
		 /NO_REL)
    if zooms(i) eq sx then WIDGET_CONTROL, junk2, /SET_BUTTON	;Set default
    ENDFOR
junk = WIDGET_BUTTON(top_line, VALUE='Set 8 bits', UVALUE='SET8', /NO_REL)
fnum_txt = WIDGET_TEXT(top_line, value='Font '+strtrim(fnum,2), $
		/FRAME, XSIZE=8)


read_font, fnum, fonttab, unit, nchars, chartab, vectors ;Init font
cur_chartab = chartab(32)		;Any char will do

base = WIDGET_BASE(main_base)
wbases = lonarr(2)
wbases(0) = WIDGET_BASE(base, /COLUMN)
wbases(1) = WIDGET_BASE(base, /COLUMN, EVENT_PRO = 'CMODE_EVENT')
fdraw = WIDGET_DRAW(wbases(0), XSIZE = 640, YSIZE = 640, RETAIN=2, /BUTTON)

c_row = WIDGET_BASE(wbases(1), /ROW)
; Save
; Save as
; Load character
; Draw character
; 
junk = WIDGET_BUTTON(c_row, VALUE="View Font", UVALUE="VIEW", /NO_REL)
junk = WIDGET_BUTTON(c_row, VALUE="Redraw", UVALUE="REDRAW", /NO_REL)
junk = WIDGET_BUTTON(c_row, VALUE="Save", UVALUE="SCHAR", /NO_REL)
junk = WIDGET_BUTTON(c_row, VALUE= 'Move/Scale', /MENU)
junk1 = WIDGET_BUTTON(junk, VALUE='Move', UVALUE='MOVE', /NO_REL)
junk1 = WIDGET_BUTTON(junk, VALUE='Move & Duplicate', UVALUE='DMOVE', /NO_REL)
junk1 = WIDGET_BUTTON(junk, VALUE='Scale', UVALUE='SHRINK', /NO_REL)

junk = WIDGET_LABEL(c_row, VALUE = 'Current Char:')
cinfo_txt = WIDGET_TEXT(c_row, xsize = 36, ysize = 1, /FRAME, /EDIT, $
	UVALUE="CCODE")

c_row = WIDGET_BASE(wbases(1), /ROW)
junk = WIDGET_LABEL(c_row, VALUE = 'Position:')
cpos_txt = WIDGET_TEXT(c_row, xsize=8, ysize=1, /FRAME)

junk = WIDGET_LABEL(c_row, value= 'Width:')
cwidth_txt = WIDGET_TEXT(c_row, xsize=4, ysize= 1, /EDIT, /FRAME, $
	VALUE='16', UVALUE="WIDTH")
junk = WIDGET_LABEL(c_row, value= 'Offset:')
coff_txt = WIDGET_TEXT(c_row, xsize=4, ysize= 1, /EDIT, /FRAME, $
	VALUE='0', UVALUE="OFF")
junk = WIDGET_LABEL(c_row, value= 'Scale:')
cscale_txt = WIDGET_TEXT(c_row, xsize=6, ysize= 1, /EDIT, /FRAME, $
	VALUE='16', UVALUE="SCALE")

cdraw = WIDGET_DRAW(wbases(1), XSIZE = 640, YSIZE = 640, RETAIN=2,  $
	/BUTTON, /MOTION)

WIDGET_CONTROL, main_base, /REALIZE
WIDGET_CONTROL, cdraw, GET_VALUE = cwin
WIDGET_CONTROL, fdraw, GET_VALUE = fwin
WIDGET_CONTROL, wbases(1), MAP=0

wset, fwin
draw_font
loadct, 0, /silent
tek_color
device, translation = junk
xor_color = junk(0) xor junk(1)		;Color to drag with

XMANAGER, 'efont', main_base, EVENT_HANDLER = 'efont_event', $
	GROUP = group
end

;$Id: eigenvec.pro,v 1.1 1994/11/29 18:36:08 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       EIGENVEC
;
; PURPOSE:
;       This function computes the eigenvectors of an N by N real, non-
;       symmetric array using inverse subspace iteration. The result is 
;       a complex array with a column dimension equal to N and a row 
;       dimension equal to the number of eigenvalues.
;
; CATEGORY:
;       Linear Algebra / Eigensystems
;
; CALLING SEQUENCE:
;       Result = Eigenvec(A, Eval)
;
; INPUTS:
;       A:    An N by N nonsymmetric array of type float or double.
;
;    EVAL:    An N-element complex vector of eigenvalues.
;
; KEYWORD PARAMETERS:
;       DOUBLE:  If set to a non-zero value, computations are done in
;                double precision arithmetic.
;
;        ITMAX:  The number of iterations performed in the computation
;                of each eigenvector. The default value is 4.
;
;     RESIDUAL:  Use this keyword to specify a named variable which returns
;                the residuals for each eigenvalue/eigenvector(lambda/x) pair.
;                The residual is based on the definition Ax - (lambda)x = 0
;                and is an array of the same size and type as RESULT. The rows
;                this array correspond to the residuals for each eigenvalue/
;                eigenvector pair. This keyword must be initialized to a non-
;                zero value before calling EIGENVEC if the residuals are 
;                desired.
;
; EXAMPLE:
;       Define an N by N real, nonsymmetric array.
;         a = [[1.0, -2.0, -4.0,  1.0], $
;              [0.0, -2.0,  3.0,  4.0], $
;              [2.0, -6.0, -1.0,  4.0], $
;              [3.0, -3.0,  1.0, -2.0]]
;
;       Compute the eigenvalues of A using double-precision complex arithmetic.
;         eval = HQR(ELMHES(a), /double)
;
;       Print the eigenvalues. The correct solution should be:
;       (0.26366259, -6.1925899), (0.26366259, 6.1925899), $
;       (-4.9384492,  0.0000000), (0.41112397, 0.0000000)
;         print, eval
;
;       Compute the eigenvectors of A. The eigenvectors are returned in the 
;       rows of EVEC. The residual keyword must be initialized as a nonzero
;       value prior to calling EIGENVEC.
;         residual = 1
;         result = EIGENVEC(a, eval, residual = residual)
;
;       Print the eigenvectors.
;         print, evec(*,0), evec(*,1), evec(*,2), evec(*,3)
;
;       The accuracy of each eigenvalue/eigenvector (lamda/x) 
;       pair may be checked by printing the residual array. This array is the
;       same size and type as RESULT and returns the residuals as its rows.
;       The residual is based on the mathematical definition of an eigenvector,
;       Ax - (lambda)x = 0. All residual values should be floating-point zeros.
;         print, residual
;
; PROCEDURE:
;       EIGENVEC computes the set of eigenvectors that correspond to a given 
;       set of eigenvalues using Inverse Subspace Iteration. The eigenvectors 
;       are computed up to a scale factor and are of Euclidean length. The
;       existence and uniqueness of eigenvectors are not guaranteed.
;
; MODIFICATION HISTORY:
;           Written by:  GGS, RSI, December 1994
;-

function eigenvec, a, eval, double = double, itmax = itmax, $
                                             residual = residual

  on_error, 2  ;Return to caller if error occurs.

  if n_params() ne 2 then $
    message, 'Incorrect number of input arguments.'
    
  sa = size(a)
  seval = size(eval)
  if sa(1) ne sa(2) then $
    message, 'Input array must be square.'

  ;Set default values for keyword parameters.
  if keyword_set(double) eq 0 then double =  0
  if keyword_set(itmax)  eq 0 then itmax  =  4

  enum = n_elements(eval)          ;Number of eigenvalues.
  diag = indgen(sa(1)) * (sa(1)+1) ;Diagonal indices.

  ;Double Precision.
  if seval(2) eq 9 or keyword_set(double) ne 0 then begin
    evec = dcomplexarr(sa(1), enum) ;Eigenvector storage array with number
                                    ;of rows equal to number of eigenvalues.
    for k = 0, enum - 1 do begin
      alud = a  ;Create a copy of the array for next eigenvalue computation.
      if imaginary(eval(k)) ne 0 then begin ;Complex eigenvalue.
        alud = dcomplex(alud)
        alud(diag) = alud(diag) - eval(k)
        ;re = double(alud)
        ;im = imaginary(alud)
        ;Avoid intermediate variables.
        comp = [[double(alud), -imaginary(alud)], $
                [imaginary(alud), double(alud)]]
        b = replicate(1.0d, 2*sa(1)) / sqrt(2.0d * sa(1)) ;Initial eigenvector.
        LUDC, comp, index, double = double
        it = 0
        while it lt itmax do begin ;Iteratively compute the eigenvector.
          x = LUSOL(comp, index, b, double = double)
          b = x / sqrt(total(x^2, 1, double = double)) ;Normalize eigenvector.
          it = it + 1
        endwhile
        evec(*, k) = dcomplex(b(0:sa(1)-1), b(sa(1):*)) ;Row vector storage.
      endif else begin ;Real eigenvalue
        alud(diag) = alud(diag) - double(eval(k))
        b = replicate(1.0d, sa(1)) / sqrt(sa(1)+0.0d)
        LUDC, alud, index, double = double
        it = 0
        while it lt itmax do begin
          x = LUSOL(alud, index, b, double = double)
          b = x / sqrt(total(x^2, 1, double = double)) ;Normalize eigenvector.
          it = it + 1
        endwhile
        evec(*, k) = dcomplex(b, 0.0d0) ;Row vector storage.
      endelse
    endfor
    if keyword_set(residual) then begin ;Compute eigenvalue/vector residuals.
      ;Because RESIDUAL is a keyword that envokes functionality and returns
      ;a named variable, it must be initialized before calling EIGENVEC().
      residual = dcomplexarr(sa(1), enum) ;Dimensioned the same as evec.
        for k = 0, enum - 1 do $
          residual(*,k) = (a##evec(*,k)) - (eval(k) * evec(*,k))
    endif
  endif else begin ;Single Precision.
    evec = complexarr(sa(1), enum) ;Eigenvector storage array.
    for k = 0, enum - 1 do begin
      alud = a  ;Create a copy of the array for next eigenvalue computation.
      if imaginary(eval(k)) ne 0 then begin ;Complex eigenvalue.
        alud = complex(alud)
        alud(diag) = alud(diag) - eval(k)
        ;re = float(alud)
        ;im = imaginary(alud)
        ;Avoid intermediate variables.
        comp = [[float(alud), -imaginary(alud)], $
                [imaginary(alud), float(alud)]]
        b = replicate(1.0, 2*sa(1)) / sqrt(2.0 * sa(1)) ;Initial eigenvector.
        LUDC, comp, index, double = double
        it = 0
        while it lt itmax do begin ;Iteratively compute the eigenvector. 
          x = LUSOL(comp, index, b, double = double)
          b = x / sqrt(total(x^2, 1)) ;Normalize eigenvector.
          it = it + 1
        endwhile
        evec(*, k) = complex(b(0:sa(1)-1), b(sa(1):*)) ;Row vector storage.
      endif else begin ;Real eigenvalue 
        alud(diag) = alud(diag) - float(eval(k))
        b = replicate(1.0, sa(1)) / sqrt(sa(1))
        LUDC, alud, index, double = double
        it = 0
        while it lt itmax do begin
          x = LUSOL(alud, index, b, double = double)
          b = x / sqrt(total(x^2, 1))  ;Normalize eigenvector.
          it = it + 1
        endwhile
        evec(*, k) = complex(b, 0.0) ;Row vector storage.
      endelse
    endfor
    if keyword_set(residual) then begin ;Compute eigenvalue/vector residuals.
      ;Because RESIDUAL is a keyword that envokes functionality and returns
      ;a named variable, it must be initialized before calling EIGENVEC().
      residual = complexarr(sa(1), enum) ;Dimensioned the same as evec.
        for k = 0, enum - 1 do $
          residual(*,k) = (a##evec(*,k)) - (eval(k) * evec(*,k))
    endif
  endelse
    
  return, evec
end

; $Id: errplot.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Pro Errplot, X, Low, High, Width = width
;+
; NAME:
;	ERRPLOT
;
; PURPOSE:
;	Plot error bars over a previously drawn plot.
;
; CATEGORY:
;	J6 - plotting, graphics, one dimensional.
;
; CALLING SEQUENCE:
;	ERRPLOT, Low, High	;X axis = point number.
;
;	ERRPLOT, X, Low, High	;To explicitly specify abscissae.
;
; INPUTS:
;	Low:	A vector of lower estimates, equal to data - error.
;	High:	A vector of upper estimates, equal to data + error.
;
; OPTIONAL INPUT PARAMETERS:
;	X:	A vector containing the abscissae.
;
; KEYWORD Parameters:
;	WIDTH:	The width of the error bars.  The default is 1% of plot width.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	An overplot is produced.
;
; RESTRICTIONS:
;	Logarithmic restriction removed.
;
; PROCEDURE:
;	Error bars are drawn for each element.
;
; EXAMPLES:
;	To plot symmetrical error bars where Y = data values and 
;	ERR = symmetrical error estimates, enter:
;
;		PLOT, Y			;Plot data
;		ERRPLOT, Y-ERR, Y+ERR	;Overplot error bars.
;
;	If error estimates are non-symetrical, enter:
;
;		PLOT,Y
;		ERRPLOT, Upper, Lower	;Where Upper & Lower are bounds.
;
;	To plot versus a vector of abscissae:
;
;		PLOT, X, Y		  ;Plot data (X versus Y).
;		ERRPLOT, X, Y-ERR, Y+ERR  ;Overplot error estimates.
;
; MODIFICATION HISTORY:
;	DMS, RSI, June, 1983.
;
;	Joe Zawodney, LASP, Univ of Colo., March, 1986. Removed logarithmic
;	restriction.
;
;	DMS, March, 1989.  Modified for Unix IDL.
;-
	on_error,2                      ;Return to caller if an error occurs
	if n_params(0) eq 3 then begin	;X specified?
		up = high
		down = low
		xx = x
	   endif else begin	;Only 2 params
		up = x
		down = low
		xx=findgen(n_elements(up)) ;make our own x
	   endelse

	if n_elements(width) eq 0 then width = .01 ;Default width
	width = width/2		;Centered
;
	n = n_elements(up) < n_elements(down) < n_elements(xx) ;# of pnts
	xxmin = min(!x.crange)	;X range
	xxmax = max(!x.crange)
	yymax = max(!y.crange)  ;Y range
	yymin = min(!y.crange)

	if !x.type eq 0 then begin	;Test for x linear
		;Linear in x
		wid =  (xxmax - xxmin) * width ;bars = .01 of plot wide.
	    endif else begin		;Logarithmic X
		xxmax = 10.^xxmax
		xxmin = 10.^xxmin
		wid  = (xxmax/xxmin)* width  ;bars = .01 of plot wide
	    endelse
;
	for i=0,n-1 do begin	;do each point.
		xxx = xx(i)	;x value
		if (xxx ge xxmin) and (xxx le xxmax) then begin
			plots,[xxx-wid,xxx+wid,xxx,xxx,xxx-wid,xxx+wid],$
			  [down(i),down(i),down(i),up(i),up(i),up(i)]
			endif
		endfor
	return
end
; $Id: expand.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;+
; NAME:
;	EXPAND
; PURPOSE:
;	Array magnification  (CONGRIDI like except that this really works!)
; CATEGORY:
;	Z4 - IMAGE PROCESSING
; CALLING SEQUENCE:
;	EXPAND,A,NX,NY,RESULT [,MAXVAL=MAXVAL,FILLVAL=FILLVAL]
; INPUTS:
;	A	Array to be magnified
;	NX	Desired size of X Dimension
;	NY	Desired size of Y Dimension
; Keywords:
;	MAXVAL	Largest good value. Elements greater than this are ignored
;	FILLVAL	Value to use when elements larger than MAXVAL are encountered.
;		Defaults to -1.
; OUTPUTS:
;	RESULT	Magnified Floating point image of A array (NX by NY)
; COMMON BLOCKS:
;	NONE
; SIDE EFFECTS:
;	NONE
; RESTRICTIONS:
;	A must be two Dimensional
; PROCEDURE:
;	Bilinear interpolation.
;	Not really fast if you have to swap memory (eg. NX*NY is a big number).
;	OK Postscript users don't forget that postscript pixels are scaleable!
; MODIFICATION HISTORY:
;	Aug 15, 1989	J. M. Zawodny, NASA/LaRC, MS 475, Hampton VA, 23665.
;	Aug 26, 1992	JMZ, Added maxval and fillval keywords.
;	Sep 30, 1992	DMS, RSI, Rewrote to use INTERPOLATE function.
; Please send suggestions and bugreports to zawodny@arbd0.larc.nasa.gov
;-
pro EXPAND,a,nx,ny,result,maxval=maxval,fillval=fillval

	s=size(a)
	if(s(0) ne 2) then begin
		print,'EXPAND: *** array must be 2-Dimensional ***'
		retall  ; This will completely terminate the MAIN program!!!
	endif

   ; Get dimensions of the input array
	ix = s(1)
	iy = s(2)

   ; Calculate the new grid in terms of the old grid
	ux = findgen(nx) * ((ix-1.) / (nx-1.))
	uy = findgen(ny) * ((iy-1.)/ (ny-1.))

   ;  Interpolate the result
	result = INTERPOLATE(a, ux, uy, /GRID)

   ; Are we to look for and ignore bad data?
	if (n_elements(maxval) gt 0) then begin
			;Find where missing points end up
		bad_pts = INTERPOLATE(float(a gt maxval), ux, uy, /GRID)
			;The only Non-zero points are those resulting from
			;bad points.  Get their subscripts in the result
		bad_subs = WHERE(bad_pts, count)	;Any bad pnts
		if count ge n_elements(result) then goto, out	;All bad
		if n_elements(fillval) le 0 then fillval = -1
			;Substitute missing value
		if count gt 0 then result(bad_subs) = fillval
	endif

; Done
return
OUT:	; If we had a problem
print,'Entire input array is greater than MAXVAL, ('+strtrim(maxval,2)+')'
return
end



; $Id: extrac.pro,v 1.2 1993/10/04 20:59:53 doug Exp $

function EXTRAC, Array, P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15
;+
; NAME:
;	EXTRAC
;
; PURPOSE:
;	The EXTRAC function returns as its result any rectangular sub-matrix
;	or portion of the parameter array.  When parts of the specified
;	subsection lie outside the bounds of the array, zeros are
;	entered into these outlying elements.
;
;	EXTRAC was originally a built-in system procedure in the PDP-11
;	version of IDL, and was retained in that form in the original VAX/VMS
;	IDL for compatibility.  Most applications of the EXTRAC function
;	are more concisely written using subscript ranges (e.g., X(10:15)).  In
;	the current release of IDL, EXTRAC has been rewritten as a User Library
;	function that provides the same interface as the previous versions.
;
; CATEGORY:
;	Array Manipulation.
;
; CALLING SEQUENCE:
;	Result = EXTRAC(Array, C1, C2, ..., Cn, S1, S2, ..., Sn)
;
; INPUTS:                 
;	Array:	The array from which the subarray will be copied.
;
;	Ci:	The starting subscript in Array for the subarray. There
;		should be one Ci for each dimension of Array.
;
;	Si:	The size of each dimension.  The result will have dimensions
;		of (S1, S2, ..., Sn). There should be one Si for each
;		dimension of Array.
;
; OUTPUTS:
;	This function returns a two-dimensional, floating-point,
;	interpolated array.
;
; RESTRICTIONS:
;	In order to make the most typical cases run quickly, little error 
;	checking is done on the input.  In particular, the Ci and Si arguments
;	must all be scalar integers, and the Si must be non-negative.
;
;	If you know that the subarray will never lie beyond the edges of
;	the array, it is more efficient to use array subscript ranges
;	to extract the data instead of EXTRAC. 
;
; PROCEDURE:
;	If the subarray lies entirely inside the Array argument, the
;	standard array subscript-range mechanism is used to do the work.
;	Otherwise, a zeroed array of the correct type and size is
;	created, and the overlapping subarray is copied into it.
;
; EXAMPLES:
;	EXAMPLE 1:
;	Define a 1000 point vector with each element initialized to
;	its subscript.  Extract a 300 pt. vector, starting at A(200) and
;	going to A(499).  B(0) will be equal to A(200), B(299) will be
;	equal to A(499).  Enter:
;
;	    A = FINDGEN(1000)
;	    B = EXTRAC(A, 200, 300)
;
;	EXAMPLE 2:
;	Here, the first 49 points extracted (B(0) to B(49)) lie outside
;	the bounds of the vector and are set to 0.  B(50) is set to A(0),
;	B(51) is set to A(1) which is 1, ... Enter:
;
;	    A = FINDGEN(1000)
;	    B = EXTRAC(A, -50, 100)
;
;	EXAMPLE 3:
;	The following commands illustrate the use of EXTRAC with multi-
;	dimensional arrays.  Enter:
;
;	    A = INTARR(64,64)	;Make a 64X64 matrix to play with
;
;	Take out a 32X32 portion starting at A(20,30) by entering:
;
;	    B = EXTRAC(A, 20, 30, 32, 32)
;
;	A better way to perform the same operation as the previous line is:
;
;	    B = A(20:51, 30:61)
;
;	Extract the 20th column and 32nd row of A:
;
;	    B = EXTRAC(A, 19, 0, 1, 64)	; Extract 20th column of A
;	    B = EXTRAC(A, 0, 31, 64, 1)	; Extract 32nd row of A
;
;	Take a 32X32 matrix from A starting at A(40,50).
;
;	    B = EXTRAC(A, 40, 50, 32, 32)
;
;	NOTE: Those points beyond the boundaries of A are set to 0.
;
; REVISION HISTORY:
;	July 18, 1989	Written AB, RSI
;-

on_error, 2			; Return to caller on error

asize = SIZE(Array)
ndim = asize(0)
orig_dims = asize(1:ndim)

; Is it an array?
if (ndim eq 0) then message, 'Target argument must be an array.'

; Is there an appropriate number of arguments present?
if (n_params() ne (ndim * 2 + 1)) then message, 'Wrong number of arguments.'

; Convert the arguments to a more convenient form.
args = intarr(2 * ndim)
;CASE (ndim) of
; 8: BEGIN & args(15) = P15 & args(14) = P14 & GOTO, do_seven & END
;  7: do_seven: BEGIN & args(13) = P13 & args(12) = P12 & GOTO, do_six & END
;  6: do_six: BEGIN & args(11) = P11 & args(10) = P10 & GOTO, do_five & END
;  5: do_five: BEGIN & args(9) = P9 & args(8) = P8 & GOTO, do_four & END
;  4: do_four: BEGIN & args(7) = P7 & args(6) = P6 & GOTO, do_three & END
;  3: do_three: BEGIN & args(5) = P5 & args(4) = P4 & GOTO, do_two & END
;  2: do_two: BEGIN & args(3) = P3 & args(2) = P2 & GOTO, do_one & END
;  1: do_one: BEGIN & args(1) = P1 & args(0) = P0 & END
;ENDCASE
srt = args(0:ndim-1)
dims = args(ndim:*)

; Determine if the subarray extends beyond the edges of the original.
; If not, a simple expression will do the job.
srt_over = where(srt lt 0, s_cnt)
dims_over = where((srt + dims) gt orig_dims, b_cnt)

if ((s_cnt eq 0) and (b_cnt eq 0)) then begin
  ; The extracted array does not go beyond the array boundaries. Use the
  ; normal expression to extract the result.
  bnd = dims + srt - 1
  case (ndim) of
    1: result =  Array(P0:bnd(0))
    2: result =  Array(P0:bnd(0),P1:bnd(1))
    3: result =  Array(P0:bnd(0),P1:bnd(1),P2:bnd(2))
    4: result =  Array(P0:bnd(0),P1:bnd(1),P2:bnd(2),P3:bnd(3))
    5: result =  Array(P0:bnd(0),P1:bnd(1),P2:bnd(2),P3:bnd(3),P4:bnd(4))
    6: result =  Array(P0:bnd(0),P1:bnd(1),P2:bnd(2),P3:bnd(3),P4:bnd(4), $
		       P5:bnd(5))
    7: result =  Array(P0:bnd(0),P1:bnd(1),P2:bnd(2),P3:bnd(3),P4:bnd(4), $
		       P5:bnd(5),P6:bnd(6))
;   8: result =  Array(P0:bnd(0),P1:bnd(1),P2:bnd(2),P3:bnd(3),P4:bnd(4), $
;		       P5:bnd(5),P6:bnd(6),P7:bnd(7))
   endcase
  goto, done
endif

; If we get this far, the sub array extends beyond the source array
; dimensions. Get a zeroed array of the correct type and extract the
; non-zero part of the original into it.
result = make_array(type=asize(ndim + 1), dimension=dims)  ; Get a result array

; Determine the insertion point for the subarray.
isrt = intarr(ndim)
if (s_cnt ne 0) then isrt(srt_over) = abs(srt(srt_over))


; If any of the starting points exceed the dimensions, then we're done.
dims_over = where(isrt ge dims, b_cnt)
srt_over = where(srt ge orig_dims, s_cnt)
if ((b_cnt ne 0) or (s_cnt ne 0)) then goto, done

; Determine the size of the subarray to be inserted. This is the
; lesser of the original size and the room for insertion in the target.
;
; dims - isrt is the availible room in the result array
; orig_dims - srt - is the largest possible subarray we can pull out of ARRAY

t1 = dims - isrt
bnd = (t1 < (orig_dims - srt)) < t1	; Minimum of the two sizes
srt = srt > 0				; Clip starting point to non-negative
bnd = srt + bnd - 1			; Calcualte the actual outer boundary

; Insert the subarray from ARRAY into RESULT
case (ndim) of
  1: result(isrt(0)) =  Array(srt(0):bnd(0))
  2: result(isrt(0),isrt(1)) =  Array(srt(0):bnd(0),srt(1):bnd(1))
  3: result(isrt(0),isrt(1),isrt(2)) = Array(srt(0):bnd(0),srt(1):bnd(1),srt(2):bnd(2))
  4: result(isrt(0),isrt(1),isrt(2),isrt(3)) =  $
	Array(srt(0):bnd(0),srt(1):bnd(1),srt(2):bnd(2),srt(3):bnd(3))
  5: result(isrt(0),isrt(1),isrt(2),isrt(3),isrt(4)) =  $
	Array(srt(0):bnd(0),srt(1):bnd(1),srt(2):bnd(2),srt(3):bnd(3), $
	      srt(4):bnd(4))
  6: result(isrt(0),isrt(1),isrt(2),isrt(3),isrt(4),isrt(5)) = $
	Array(srt(0):bnd(0),srt(1):bnd(1),srt(2):bnd(2),srt(3):bnd(3), $
	      srt(4):bnd(4), srt(5):bnd(5))
  7: result(isrt(0),isrt(1),isrt(2),isrt(3),isrt(4),isrt(5),isrt(6)) = $
	Array(srt(0):bnd(0),srt(1):bnd(1),srt(2):bnd(2),srt(3):bnd(3), $
	      srt(4):bnd(4), srt(5):bnd(5),srt(6):bnd(6))
; 8: result(isrt(0),isrt(1),isrt(2),isrt(3),isrt(4),isrt(5),isrt(6),isrt(7))= $
;	Array(srt(0):bnd(0),srt(1):bnd(1),srt(2):bnd(2),srt(3):bnd(3), $
;	      srt(4):bnd(4), srt(5):bnd(5),srt(6):bnd(6),srt(7):bnd(7))
endcase


done:
  return, result
end







; The rest of this file exists in order to test the EXTRAC procedure above.
; Normally, it won't be compiled when EXTRAC is used because when
; a procedure is automatically pulled out of the user library, only
; enough is compiled to get the desired routine, the rest of the file
; is ignored. Use ".run extrac" to compile everything.


pro extrac_errprint, n, is, want
; extrac_errprint tests a result against the desired value and
; reports it if they don't agree
;
; entry:
;	n - Error identification number.
;	is - Result value.
;	want - Correct value for is.
;
; exit:
;	if (is eq want) then errprint returns quietly. Otherwise,
;	it sends a report to stderr.
;
if (size(is))(0) eq 0 then begin
  if is ne want then begin
    printf,-2,format='($,"ERROR(",a,"): ")', strtrim(n,2)
    printf,-2,format='(" is(",a,"), want(",a,")")',is,want
  endif else goto, is_ok
endif else begin
  s = size(is)
  if s(s(0)+1) eq 7 then $	;Strings?
    x = total(is ne want) $
  else x = total(abs(is-want))
    if x ne 0. then begin
      printf,-2,format='($,"ERROR(",a,"): ")', strtrim(n,2)
      printf,-2,format='(" ARRAY total is(",a,"), want(",a,")")',x,0.0
  endif else goto, is_ok
endelse

return

is_ok:
  printf, -2, format='("OK(", I0, ")")', n

end







pro test_extrac
; Test the EXTRAC procedure. These tests are hardly exhaustive ---
; especially with dimensions above 2.



;;;;;;;;;;; PART 1 --- Vector case
a = findgen(10)			; Test data

; Desired subarray is completely to left of the array
extrac_errprint, 1, extrac(a, -100, 60), fltarr(60)

; Subarray is completely to right of the array
extrac_errprint, 2, extrac(a, 100, 60), fltarr(60)

; Subarray overlaps partly on left
correct = fltarr(10)
correct(5) = a(0:4)
extrac_errprint, 3, extrac(a, -5, 10), correct

; Subarray overlaps partly on right
correct = fltarr(10)
correct(0) = a(5:9)
extrac_errprint, 4, extrac(a, 5, 10), correct

; Border Condition - Just left of array
extrac_errprint, 5, extrac(a, -10, 10), fltarr(10)

; Condition Border - One column overlaps on right
correct = fltarr(10)
correct(9) = a(0)
extrac_errprint, 6, extrac(a, -9, 10), correct

; Border Condition - Just right of array
extrac_errprint, 7, extrac(a, 10, 10), fltarr(10)

; Condition Border - One column overlaps on left
correct = fltarr(10,10)
correct(0) = a(9)
extrac_errprint, 8, extrac(a, 9, 10), correct

; Trivial case --- extract the entire array
extrac_errprint, 9, extrac(a, 0, 10), a

; Extract a completely interior region. This is what the subscript op does
extrac_errprint, 10, extrac(a, 2, 5), a(2:6)


;;;;;;;;;;; PART 2 --- 2D case


a = findgen(10,10)		; Test data

; Desired subarray is completely below the array
extrac_errprint, 11, extrac(a, -100, -100, 60, 60), fltarr(60, 60)

; Subarray is completely above the array
extrac_errprint, 12, extrac(a, 100, 100, 60, 60), fltarr(60, 60)

; Subarray overlaps partly on left
correct = fltarr(10,10)
correct(5,0) = a(0:4, 0:*)
extrac_errprint, 13, extrac(a, -5, 0, 10, 10), correct

; Subarray overlaps partly on right
correct = fltarr(10,10)
correct(0,0) = a(5:9, 0:*)
extrac_errprint, 14, extrac(a, 5, 0, 10, 10), correct

; Subarray overlaps partly on top
correct = fltarr(10,10)
correct(0,5) = a(0:*, 0:4)
extrac_errprint, 15, extrac(a, 0, -5, 10, 10), correct

; Subarray overlaps partly on bottom
correct = fltarr(10,10)
correct(0,0) = a(*, 5:9)
extrac_errprint, 16, extrac(a, 0, 5, 10, 10), correct

; Border Condition - Just left of array
extrac_errprint, 17, extrac(a, -10, 0, 10, 10), fltarr(10,10)

; Condition Border - One column overlaps on right
correct = fltarr(10,10)
correct(9,0) = a(0,*)
extrac_errprint, 18, extrac(a, -9, 0, 10, 10), correct

; Border Condition - Just right of array
extrac_errprint, 19, extrac(a, 10, 0, 10, 10), fltarr(10,10)

; Condition Border - One column overlaps on left
correct = fltarr(10,10)
correct(0,0) = a(9,*)
extrac_errprint, 20, extrac(a, 9, 0, 10, 10), correct

; Trivial case --- extract the entire array
extrac_errprint, 21, extrac(a, 0, 0, 10, 10), a

; Extract a completely interior region. This is what the subscript op does
extrac_errprint, 22, extrac(a, 2, 3, 5, 6), a(2:6,3:8)



;;;;;;;;;;; PART 3 --- 3D case


a = findgen(10,10,10)		; Test data

; Desired subarray is completely below the array
extrac_errprint, 23, extrac(a,-100,-100,-100,60,60,60), fltarr(60,60,60)

; Subarray is completely above the array
extrac_errprint, 24, extrac(a, 100, 100, 100, 60, 60, 60), fltarr(60,60,60)

; Subarray overlaps partly on left
correct = fltarr(10,10,10)
correct(5,0,0) = a(0:4, 0:*, 0:*)
extrac_errprint, 25, extrac(a, -5, 0, 0, 10, 10, 10), correct

; Subarray overlaps partly on right
correct = fltarr(10,10,10)
correct(0,0,0) = a(5:9, 0:*, 0:*)
extrac_errprint, 26, extrac(a, 5, 0, 0, 10, 10, 10), correct

; Subarray overlaps partly on top
correct = fltarr(10,10,10)
correct(0,5,0) = a(0:*, 0:4, 0:*)
extrac_errprint, 27, extrac(a, 0, -5, 0, 10, 10, 10), correct

; Subarray overlaps partly on bottom
correct = fltarr(10,10,10)
correct(0,0,0) = a(*, 5:9,*)
extrac_errprint, 28, extrac(a, 0, 5, 0, 10, 10, 10), correct

; Border Condition - Just left of array
extrac_errprint, 29, extrac(a, -10, 0, 0, 10, 10, 10), fltarr(10,10,10)

; Condition Border - One column overlaps on right
correct = fltarr(10,10,10)
correct(9,0,0) = a(0,*,*)
extrac_errprint, 30, extrac(a, -9, 0, 0, 10, 10, 10), correct

; Border Condition - Just right of array
extrac_errprint, 31, extrac(a, 10, 0, 0, 10, 10, 10), fltarr(10,10,10)

; Condition Border - One column overlaps on left
correct = fltarr(10,10,10)
correct(0,0,0) = a(9,*,*)
extrac_errprint, 32, extrac(a, 9, 0, 0, 10, 10, 10), correct

; Trivial case --- extract the entire array
extrac_errprint, 33, extrac(a, 0, 0, 0, 10, 10, 10), a

; Extract a completely interior region. This is what the subscript op does
extrac_errprint, 34, extrac(a, 2, 3, 4, 5, 6, 7), a(2:6,3:8,4:9)

end
; $Id: extract_slice.pro,v 1.4 1994/11/21 23:52:33 dan Exp $

; Copyright (c) 1992-1993, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	EXTRACT_SLICE
;
; PURPOSE:
;	This function returns a 2-D planar slice extracted from
;       3-D volumetric data. The slicing plane may be oriented at
;       any angle, and may pass through any desired location in the
;       volume.
;
; CATEGORY:
;	Volume Rendering.
;
; CALLING SEQUENCE:
;       Slice = EXTRACT_SLICE(Vol, X_size, Y_size, X_center, Y_center, $
;                             Z_center, X_rot, Y_rot, Z_rot)
;
; INPUTS:
;       Vol:        The three dimensional volume of data to slice.
;                   Data type : Any 3-D array except string or structure.
;       X_size:     The size of the returned slice in X (The returned
;                   slice will have the dimensions X_size by Y_size).
;                   Data type : Long.
;       Y_size:     The size of the returned slice in Y. To preserve
;                   the correct aspect ratio of the data, Y_size should
;                   equal X_size. For optimal results, set X_size and
;                   Y_size to be greater than or equal to the largest of
;                   the three dimensions of Vol.
;                   Data type : Long.
;       X_center:   The X coordinate (index) within the volume that the
;                   slicing plane passes through. The center of the
;                   slicing plane passes through Vol at the coordinate
;                   (X_center, Y_Center, Z_center).
;                   Data type : Any scalar numeric value (usually Long).
;       Y_center:   The Y coordinate (index) within the volume that the
;                   slicing plane passes through.
;                   Data type : Any scalar numeric value (usually Long).
;       Z_center:   The Z coordinate (index) within the volume that the
;                   slicing plane passes through.
;                   Data type : Any scalar numeric value (usually Long).
;       X_rot:      The orientation (X rotation) of the slicing plane.
;                   Before transformation, the slicing plane is parallel
;                   to the X-Y plane. The slicing plane transformations
;                   are performed in the following order :
;                      1. Rotate Z_rot degrees about the Z axis.
;                      2. Rotate Y_rot degrees about the Y axis.
;                      3. Rotate X_rot degrees about the X axis.
;                      4. Translate the center of the plane to
;                         X_center, Y_center, Z_center.
;                   Data type : Float.
;       Y_rot:      The orientation (Y rotation) of the slicing plane.
;                   Data type : Float.
;       Z_rot:      The orientation (Z rotation) of the slicing plane.
;                   Data type : Float.
;	
; KEYWORD PARAMETERS:
;       CUBIC:      If CUBIC is set, then cubic interpolation is used.
;                   The default is to use tri-linear interpolation.
;                   If the SAMPLE keyword is set, then the CUBIC keyword
;                   is ignored.
;       OUT_VAL:    If OUT_VAL is set, then the portions of the returned
;                   slice that lie outside the original volume are set to
;                   the value passed to OUT_VAL.
;                   Data type : Any scalar numeric value (usually the same
;                               type as Vol).
;       RADIANS:    Set this keyword to a non-zero value to indicate that
;                   X_rot, Y_rot, and Z_rot are in radians. The default
;                   is degrees.
;                   Data type : Int.
;       SAMPLE:     If SAMPLE is set to a non-zero value then nearest
;                   neighbor sampling is used to compute the slice.
;                   Otherwise, tri-linear (or cubic) interpolation is used.
;                   A small reduction in execution time will result if
;                   SAMPLE mode is set and the OUT_VAL keyword is NOT
;                   used.
;
; OUTPUTS:
;       This function returns the planar slice as a two dimensional
;       array with the same data type as Vol. The dimensions of the
;       returned array are X_size by Y_size.
;
; EXAMPLE:
;       Display an oblique slice through volumetric data.
;
;       ; Create some data.
;          vol = RANDOMU(s, 40, 40, 40)
;          FOR i=0, 10 DO vol = SMOOTH(vol, 3)
;          vol = BYTSCL(vol(3:37, 3:37, 3:37))
;
;       ; Extract and display a slice.
;          slice = EXTRACT_SLICE(vol, 40, 40, 17, 17, 17, 30.0, 30.0, 0.0, $
;                                OUT_VAL=0B)
;          TVSCL, REBIN(slice, 400, 400)
;
; MODIFICATION HISTORY:
;       Written by:     Daniel Carr. Wed Sep  2 14:47:07 MDT 1992
;       Modified by:    Daniel Carr. Mon Nov 21 14:59:45 MST 1994
;          Improved speed and added the CUBIC keyword.
;-

FUNCTION Extract_Slice, vol, x_size, y_size, $
                        x_center, y_center, z_center, $
                        x_rot, y_rot, z_rot, Radians=radians, $
                        Out_Val=out_val, Sample=p_sample, $
                        Cubic=cubic

; *** Test inputs

sz_vol = Size(vol)
IF (sz_vol(0) NE 3L) THEN BEGIN
   Print, 'Volume array must have three dimensions'
   STOP
ENDIF
vol_type = sz_vol(sz_vol(0)+1)
IF (vol_type EQ 0L) THEN BEGIN
   Print, 'Volume array must be defined'
   STOP
ENDIF
IF (vol_type EQ 7L) THEN BEGIN
   Print, 'Invalid volume array type (string)'
   STOP
ENDIF
IF (vol_type EQ 8L) THEN BEGIN
   Print, 'Invalid volume array type (structure)'
   STOP
ENDIF

x_size = Long(x_size(0))
IF (x_size LT 2L) THEN BEGIN
   Print, 'X_size must be >= 2'
   STOP
ENDIF
y_size = Long(y_size(0))
IF (y_size LT 2L) THEN BEGIN
   Print, 'Y_size must be >= 2'
   STOP
ENDIF

x_center = Float(x_center(0))
IF ((x_center LT 0.0) OR (x_center GE Float(sz_vol(1)))) THEN BEGIN
   Print, 'X_center must be >= 0 and less than the x dimension of vol'
   STOP
ENDIF
y_center = Float(y_center(0))
IF ((y_center LT 0.0) OR (y_center GE Float(sz_vol(2)))) THEN BEGIN
   Print, 'Y_center must be >= 0 and less than the y dimension of vol'
   STOP
ENDIF
z_center = Float(z_center(0))
IF ((z_center LT 0.0) OR (z_center GE Float(sz_vol(3)))) THEN BEGIN
   Print, 'Z_center must be >= 0 and less than the z dimension of vol'
   STOP
ENDIF

x_rot = Float(x_rot(0))
y_rot = Float(y_rot(0))
z_rot = Float(z_rot(0))

IF (N_Elements(radians) GT 0L) THEN BEGIN
   IF (radians(0) NE 0) THEN BEGIN
      x_rot = x_rot * !RADEG
      y_rot = y_rot * !RADEG
      z_rot = z_rot * !RADEG
   ENDIF
ENDIF

; *** Set up the required variables

IF (N_Elements(out_val) GT 0L) THEN set_out = 1B ELSE set_out = 0B

sample = 0B
IF (N_Elements(p_sample) GT 0L) THEN sample = Byte(p_sample(0))

vol_ind = [[Reform((Findgen(x_size) # Replicate(1.0, y_size)), (x_size * y_size))], $
           [Reform((Replicate(1.0, x_size) # Findgen(y_size)), (x_size * y_size))], $
           [Replicate(0.0, (x_size * y_size))], [Replicate(1.0, (x_size * y_size))]]

; *** Extract the slice

save_pt = !P.T
T3d, /Reset
T3d, Translate=[-(Float(x_size-1L)/2.0), -(Float(y_size-1L)/2.0), 0.0]
T3d, Rotate=[0.0, 0.0, z_rot]
T3d, Rotate=[0.0, y_rot, 0.0]
T3d, Rotate=[x_rot, 0.0, 0.0]
T3d, Translate=Float([x_center, y_center, z_center])
vol_ind = vol_ind # !P.T
!P.T = save_pt

IF (sample) THEN BEGIN
   slice = Reform((vol(0>vol_ind(*, 0)<(sz_vol(1)-1), $
                  0>vol_ind(*, 1)<(sz_vol(2)-1), $
                  0>vol_ind(*, 2)<(sz_vol(3)-1))), x_size, y_size)
   IF (set_out) THEN BEGIN
      out_v = Where((((vol_ind(*, 0) LT 0.0) OR $
                      (vol_ind(*, 0) GE sz_vol(1))) OR $
                     ((vol_ind(*, 1) LT 0.0) OR $
                      (vol_ind(*, 1) GE sz_vol(2)))) OR $
                     ((vol_ind(*, 2) LT 0.0) OR (vol_ind(*, 2) GE sz_vol(3))))
      IF (out_v(0) GE 0L) THEN slice(out_v) = out_val
   ENDIF
ENDIF ELSE BEGIN
   IF (set_out) THEN BEGIN
      slice = $
         Reform((Interpolate(vol, $
            vol_ind(*, 0), vol_ind(*, 1), vol_ind(*, 2), $
            Missing=out_val, Cubic=Keyword_Set(cubic))), x_size, y_size)
   ENDIF ELSE BEGIN
      slice = Reform((Interpolate(vol, $
         vol_ind(*, 0), vol_ind(*, 1), vol_ind(*, 2), Cubic=Keyword_Set(cubic))), $
         x_size, y_size)
   ENDELSE
ENDELSE

RETURN, slice
END
;$Id: factorial.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       FACTORIAL
;
; PURPOSE:
;       This function computes the factorial N! as the double-precision 
;       product, (N) * (N-1) * (N-2) * ...... * 3 * 2 * 1. 
;
; CATEGORY:
;       Special Functions.
;
; CALLING SEQUENCE:
;       Result = Factorial(n)
;
; INPUTS:
;       N:    A non-negative scalar of type integer, float or double.
;
; KEYWORD PARAMETERS:
;       STIRLING:    If set to a non-zero value, Stirling's asymptotic 
;                    formula is used to approximate N!. 
;
; EXAMPLE:
;       Compute 20! with and without Stirling's asymptotic formula.
;         result_1 = factorial(20, /stirling)
;         result_2 = factorial(20)
;       
;       Result_1 and result_2 should be 2.4227869e+18 and 2.4329020e+18
;       respectively.
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, November 1994
;-

function factorial, n, stirling = stirling

  ;Computes N! as (N) * (N-1) * (N-2) * ...... * 3 * 2 * 1
  ;Test example: 20! = 2.4329020e+18
  ;Use NR_MACHAR(/DOUBLE) to determine largest floating point number.
  ;Stirling's formula: N! = SQRT(2.0d*!PI*N) * (N/EXP(1.0d))^(N+0.0d)

  on_error, 2

  if n lt 0 then $
    message, 'n must be a non-negative scalar.'

  ;Computes N! as (N) * (N-1) * (N-2) * ...... * 3 * 2 * 1
  if keyword_set(stirling) eq 0 then begin 
    fact = 1.0d
    for k = n+0.0d, 1d, -1d do begin
      fact = fact * k
    endfor
  endif else $ ;Approximate N! using Stirling's formula.
    fact = sqrt(2.0d * !pi * n) * (n / exp(1.0d))^(n+0.0d)

  return, fact

end
;$Id: f_cvf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       F_CVF
;
; PURPOSE:
;       This function computes the cutoff value (v) such that:
;                   Probability(X > v) = p
;       where X is a random variable from the F distribution with
;       (dfn) and (dfd) degrees of freedom.
;
; CALLING SEQUENCE:
;     Result = f_cvf(P, DFN, DFD)
;
; INPUTS:
;       P:    A non-negative scalar, in the interval [0.0, 1.0], of 
;             type float or double that specifies the probability of 
;             occurance or success. 
;
;     DFN:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the F distribution
;             numerator.
;
;     DFD:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the F distribution
;             denominator.
;
; EXAMPLE:
;       Compute the cutoff value (v) such that Probability(X > v) = 0.100
;       from the F distribution with (dfn = 10) and (dfd = 6) degrees of 
;       freedom. The result should be 7.87413
;         result = f_cvf(0.01, 10, 6)        
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function f_cvf, p, dfn, dfd
 
  on_error, 2  ;Return to caller if error occurs.

  if p lt 0. or p gt 1. then message, $
    'p must be in the interval [0.0, 1.0]'

  case 1 of
    dfd eq 1: up = 300.0 
    dfd eq 2: up = 100.0 
    dfd gt 2 and dfd le 5: up = 30.0
    dfd gt 5 and dfd le 14: up = 20.0
    else: up = 12.0
  endcase
  below = 0
  while f_pdf(up, dfn, dfd) lt (1 - p) do begin
    below = up
    up = 2 * up
  endwhile

  return, bisect_pdf([1-p, dfn, dfd], 'f_pdf', up, below)
end

;
; $Id: field_alloc.pro,v 1.8 1995/01/20 19:41:01 tonyh Exp $
;
;  WidField
;   Widget Field class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  FIELD_Icon
;       Return the cw_field toolbar icon
;
FUNCTION FIELD_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 254b, 255b, 255b, 127b ], $
    [ 254b, 255b, 255b, 127b ], $
    [ 6b, 0b, 0b, 96b ], $
    [ 6b, 0b, 0b, 110b ], $
    [ 6b, 0b, 0b, 100b ], $
    [ 6b, 3b, 8b, 100b ], $
    [ 6b, 3b, 8b, 100b ], $
    [ 6b, 3b, 8b, 100b ], $
    [ 134b, 6b, 8b, 100b ], $
    [ 134b, 6b, 8b, 100b ], $
    [ 134b, 134b, 9b, 100b ], $
    [ 70b, 140b, 233b, 100b ], $
    [ 198b, 15b, 24b, 101b ], $
    [ 70b, 12b, 8b, 101b ], $
    [ 38b, 152b, 9b, 101b ], $
    [ 38b, 152b, 9b, 101b ], $
    [ 38b, 24b, 24b, 101b ], $
    [ 118b, 60b, 232b, 100b ], $
    [ 6b, 0b, 0b, 100b ], $
    [ 6b, 0b, 0b, 110b ], $
    [ 6b, 0b, 0b, 96b ], $
    [ 6b, 0b, 0b, 96b ], $
    [ 254b, 255b, 255b, 127b ], $
    [ 254b, 255b, 255b, 127b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  FIELD_Copy
;   Copy a field widget.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO FIELD_Copy, Ptr, Copy
    GenCopy, Ptr, Copy, /HASVALUE
END


;
;  FIELD_Destroy
;   Release resources for the given field
;
PRO FIELD_Destroy, Ptr
    GenDestroy, Ptr, /HASVALUE
END


;
;  FIELD_Event
;   Event handling routine for a field dialog.
;
PRO FIELD_Event, Event

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'LITERAL':      BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 0
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=0
        END
    'CODEBASED':    BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 1
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=1
        END
    'MAINTEXT': WIDGET_CONTROL, Obj.Value1, SET_UVALUE=Event.Value
    'VALUETEXT':Obj.Value2      = Event.Value   ; UNIMPLEMENTED

    'TITLE':    Obj.Title       = Event.Value
    'FONT':     Obj.TitleFont   = Event.Value
    'TEXTFONT': Obj.TextFont    = Event.Value
    'NAME':     Obj.Name        = Event.Value   ; Other
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'XSIZE':    Obj.XSize       = Event.Value   ; XY Stuff
    'YSIZE':    Obj.YSize       = Event.Value

    'STRING':   Obj.FieldType   = 0
    'FLOAT':    Obj.FieldType   = 1
    'INT':      Obj.FieldType   = 2
    'LONG':     Obj.FieldType   = 3

    'NONE':     Obj.FieldEv     = 0
    'CR_EV':    Obj.FieldEv     = 1
    'ALL_EV':   Obj.FieldEv     = 2
    'NOEDIT':   Obj.FieldNoEdit = 1 - Obj.FieldNoEdit
    'ISCOL':    Obj.FieldVertical   = 1 - Obj.FieldVertical

    'XFONT':    BEGIN
        WIDGET_CONTROL, /HourGlass
        NewFontName = XFont()
        IF NewFontName NE '' THEN BEGIN
            WIDGET_CONTROL, Binfo.Foci(1), SET_VALUE=NewFontName
            Obj.TitleFont   = NewFontName
        ENDIF
        END
    'XTFONT':   BEGIN
        WIDGET_CONTROL, /HourGlass
        NewFontName = XFont()
        IF NewFontName NE '' THEN BEGIN
            WIDGET_CONTROL, Binfo.Foci(2), SET_VALUE=NewFontName
            Obj.TextFont    = NewFontName
        ENDIF
        END

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  FIELD_Build
;   Create a dialog box a field object.  If ptr is nil then
;   create the object as well.
;
PRO FIELD_Build, Ptr, ParPtr
  COMMON WidEd_Comm

    FIELD_Alloc, ParPtr, Ptr
    MgrName = 'WE_FIELD' + STRTRIM(Ptr, 2)
    IF XRegistered(MgrName) THEN RETURN

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'

    Ptr2Obj, Ptr, Obj
    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(8)

    Base1   = WIDGET_BASE(Base, /COLUMN, /FRAME)
    ; Lab       = WIDGET_LABEL(Base1, VALUE="Basic Information")
    BuildEdit, Base1, Obj, _EditId, /SINGLE

    Foci(0) = Field(Base1, "Title:", Obj.Title, "TITLE", SIZE=50, /STRING)
    Btns    = LONARR(4)

    Base2   = WIDGET_BASE(Base1, /ROW)
    Label   = WIDGET_LABEL(Base2, VALUE="Field Type:")
    Base3   = WIDGET_BASE(Base2, /ROW, /EXCLUSIVE)
    Btns(0) = WIDGET_BUTTON(Base3, VALUE='String', UVALUE='STRING')
    Btns(1) = WIDGET_BUTTON(Base3, VALUE='Float', UVALUE='FLOAT')
    Btns(2) = WIDGET_BUTTON(Base3, VALUE='Int', UVALUE='INT')
    Btns(3) = WIDGET_BUTTON(Base3, VALUE='Long', UVALUE='LONG')
    WIDGET_CONTROL, Btns(Obj.FieldType), /SET_BUTTON

    Base2   = WIDGET_BASE(Base1, /ROW)
    Label   = WIDGET_LABEL(Base2, VALUE="Field Events:")
    Base3   = WIDGET_BASE(Base2, /ROW, /EXCLUSIVE)
    Btns(0) = WIDGET_BUTTON(Base3, VALUE='None', UVALUE='NONE')
    Btns(1) = WIDGET_BUTTON(Base3, VALUE='Event on <CR>', UVALUE='CR_EV')
    Btns(2) = WIDGET_BUTTON(Base3, VALUE='All Events', UVALUE='ALL_EV')
    WIDGET_CONTROL, Btns(Obj.FieldEv), /SET_BUTTON

    Base2   = WIDGET_BASE(Base1, /ROW, /NONEXCLUSIVE)
    Button  = WIDGET_BUTTON(Base2, VALUE='Field Text Fixed', UVALUE='NOEDIT')
    IF Obj.FieldNoEdit THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Field is Vertical', UVALUE='ISCOL')
    IF Obj.FieldVertical THEN WIDGET_CONTROL, Button, /SET_BUTTON

    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(1) = Field(Base2, "Title Font:", Obj.TitleFont, 'FONT', SIZE=50,/STR)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")

    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(2) = Field(Base2, "Text Font:", Obj.TextFont, 'TEXTFONT',SIZE=50,/STR)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XTFONT")

    BuildOther, Base1, Obj, Foci, 3

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Field Appearance Controls")
    BuildXY, Base1, Obj, Foci, 6, /SIZE
    BuildOkCancel, Base, Obj

    DlgInfo     = {             $
        Foci:       Foci,       $
        EditId:     _EditId,    $
        ObjPtr:     Ptr         $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='FIELD_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  FIELD_Save
;   Save field information to a file.
;   Store value as well: If value is nil, make up a value.
;
;   FORMAT:
;       <field object>
;       <number of elements in value>
;       <value>
;
PRO FIELD_Save, Unit, Ptr
    GenWrite, Unit, Ptr, DEFAULT=""
END


;
;  FIELD_Restore
;   Read in a field object from a file
;
PRO FIELD_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "FIELD", 1
END


;
;  FIELD_Generate
;   Create a field object for previewing
;
PRO FIELD_Generate, Base, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Generate command string

    GetValue, Obj, Names, ""
    Cmd = 'Id = CW_FIELD(Base,VALUE=Names'
    IF Obj.FieldVertical THEN Cmd = Cmd + ',/COLUMN'
    IF Obj.FieldNoEdit THEN Cmd = Cmd + ',/NOEDIT'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    SAddCmd, Cmd, Obj.TitleFont, 'FONT'
    SAddCmd, Cmd, Obj.TextFont, 'FIELDFONT'
    SAddCmd, Cmd, Obj.Title, 'TITLE'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'

    Types   = [ 'STRING', 'FLOAT', 'INTEGER', 'LONG']
    Cmd = Cmd + ',/' + Types(Obj.FieldType)

    Obj2Ptr, Obj, Ptr

    ; Create field widget

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create field ' + VarName(Ptr)
    ENDIF

END


;
;  FIELD_GenWid
;   Create IDL code for creating a field widget
;
PRO FIELD_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)                        ; Get variable name of object
    Ptr2Obj, Ptr, Obj                           ; Get object info

    FieldName   = 'FieldVal' + STRTRIM(Ptr,2)   ; Create value name
    SaveStr, Unit, Ptr, Obj, FieldName, ""      ; Generate value code

    XPRINTF, Unit, FORMAT='("  ",A," = CW_FIELD( ",A,",VALUE=",A)', $
        Name, Parent, FieldName, /NO_EOL
    IF Obj.FieldVertical THEN ISaveCmd, Unit, 1, "COLUMN" $
    ELSE ISaveCmd, Unit, 1, "ROW"

    Types   = [ 'STRING', 'FLOAT', 'INTEGER', 'LONG']
    ISaveCmd, Unit, 1, Types(Obj.FieldType)

    IF Obj.FieldEv EQ 1 THEN ISaveCmd, Unit, 1, "RETURN_EVENTS"
    IF Obj.FieldEv EQ 2 THEN ISaveCmd, Unit, 1, "ALL_EVENTS"

    SSaveCmd, Unit, Obj.TextFont, "FIELDFONT"
    SSaveCmd, Unit, Obj.TitleFont, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, Obj.Title, "TITLE"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  FIELD_Alloc
;       Allocate a field object.  Don't allocate if ptr is non-nil
;
PRO FIELD_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr     = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer
    ValueId = WIDGET_BASE(GROUP=TopDlg)

    Obj     = {                 $
        WE_FIELD,               $
        Type:           'FIELD',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; Title or object name
        Title:          '',     $
        FrameSize:      0,      $
        TitleFont:      '',     $
        TextFont:       '',     $
        UValue:         '',     $
        Value1:         ValueId,$
        Value2:         '',     $ ; UNIMPLEMENTED and unused
        ValueType:      0,      $ ; UNIMPLEMENTED and unused
        XSize:          0,      $
        YSize:          0,      $
        FieldType:      0,      $ ; Enum { String,Float,Int,Long }
        FieldEv:        0,      $ ; Enum { None,<CR>,All }
        FieldNoEdit:    0,      $ ; Set if CANT edit field
        FieldVertical:  0       $ ; Enum { Row,Column }
    }
    Obj2Ptr, Obj, Ptr
END
; $Id: filepath.pro,v 1.9 1995/03/09 17:34:56 davee Exp $

FUNCTION FILEPATH, FILENAME, ROOT_DIR=root_dir, SUBDIRECTORY=subdir, $
	TERMINAL = TERMINAL, TMP = TMP
;+
; NAME:
;	FILEPATH
;
; PURPOSE:
;	Given the name of a file in the IDL distribution,
;	FILEPATH returns the fully-qualified path to use in
;	opening the file. Operating system dependencies
;	are taken into consideration. This routine is used by RSI to
;	make the User Library portable.
;
; CATEGORY:
;	File Management.
;
; CALLING SEQUENCE:
;	Result = FILEPATH('filename' [, SUBDIRECTORY = subdir])
;
; INPUTS:
;    filename:	The lowercase name of the file to be opened. No device
;		or directory information should be included.
;
; KEYWORDS:
;    ROOT_DIR: The name of the directory from which the resulting path
;	should be based. If not present, the value of !DIR is used.
;	This keyword is ignored if TERMINAL or TMP are specified.
;
;    SUBDIRECTORY:	The name of the subdirectory in which the file
;		should be found. If this keyword is omitted, the main
;		directory is used.  This variable can be either a scalar
;		string or a string array with the name of each level of
;		subdirectory depth represented as an element of the array.
;
;		For example, to get a path to the file DETERM in the "userlib"
;		subdirectory to the IDL "lib" subdirectory, enter:
;
;		path = FILEPATH("determ", SUBDIRECTORY = ["lib", "userlib"])
;
;    TERMINAL:	Return the filename of the user's terminal.
;
;	  TMP:	The file is a scratch file.  Return a path to the
;		proper place for temporary files under the current operating
;		system.
;
; OUTPUTS:
;	The fully-qualified file path is returned.  If one of the subdirectory
;	keywords is not specified, the file is assumed to exist in the
;	main distribution directory.
;
; COMMON BLOCKS:
;	None.
;
; RESTRICTIONS:
;	Don't specify more than one of the keywords in a single call.
;
;
; EXAMPLE:
;	To get a path to the file DETERM in the "userlib" subdirectory to the
;	IDL "lib" subdirectory, enter:
;
;		path = FILEPATH("determ", SUBDIRECTORY = ["lib", "userlib"])
;
;	The variable "path" contains a string that is the fully-qualified file
;	path for the file DETERM.
;
; MODIFICATION HISTORY:
;	December, 1989, AB, RSI (Formalized from original by DMS)
;	October, 1990, SG, RSI (added support for MSDOS)
;	February, 1991, SMR, RSI (added string array support for multi-level
;				  directories)
;	21 April 1993, AB, Added ROOT_DIR keyword.
;       14 July  1994, KDB, RSI - Corrected logic error in VMS section
;                                 of the ROOT_DIR keyword. Any
;                                 sub-directory specification was
;                                 being ignored when using ROOT_DIR. Fixed.
;	March, 1995, DJE, Add a ':' if root_dir is specified on the Mac.
;-


ON_ERROR,2		                        ;Return to caller if an error
						;occurs

do_tmp = KEYWORD_SET(TMP)			;get temporary path if existing
path = ''

IF (KEYWORD_SET(TERMINAL)) THEN BEGIN
  CASE !VERSION.OS OF
    'vms': RETURN,'SYS$OUTPUT:'
    'Win32': RETURN,'con'
    'MacOS' : BEGIN
        PRINT, "No terminal device for the Mac"
        RETURN, ''
      END
    ELSE: RETURN,'/dev/tty'
  ENDCASE
ENDIF

IF (do_tmp) THEN BEGIN
  CASE !VERSION.OS OF
    'vms': root_dir = 'SYS$LOGIN:'
    'Win32': root_dir = '\tmp'
    'MacOS': begin
	root_dir = !DIR
	if (n_params() EQ 0) then filename = "IDL Temp File"
      end
    ELSE: root_dir = '/tmp'
  ENDCASE
ENDIF ELSE BEGIN
  IF (not KEYWORD_SET(ROOT_DIR)) THEN root_dir = !DIR
  IF (KEYWORD_SET(SUBDIR)) THEN BEGIN		;if the SUBDIR keyword is set
    SUBDIR = STRLOWCASE(SUBDIR)			;then include each level in the
    CASE !VERSION.OS OF				;path separated by the correct
      'vms': divider = "."			;directory level delimiter for
      'Win32': divider = "\"			;the current O.S.
      'MacOS' : divider = ":"
      ELSE: divider = "/"
    ENDCASE
    FOR i = 0, N_ELEMENTS(SUBDIR) - 1 DO BEGIN
	path = path + SUBDIR(i)
	IF(i NE N_ELEMENTS(SUBDIR) - 1) THEN $
	  path = path + divider
    ENDFOR
    if !VERSION.OS EQ 'MacOS' THEN path = path + divider
  ENDIF
ENDELSE


CASE !VERSION.OS OF
  'vms': BEGIN
      IF (NOT do_tmp) THEN BEGIN
        IF (path EQ '') THEN path = '000000'
        path = '[' + path + ']'

      ; check for a ".]" at the end of our root directory

        IF(( strmid(root_dir, strlen(root_dir)-2, 2) ne ".]") and    $
           ( strmid(root_dir, strlen(root_dir)-1, 1) eq "]") )then   $
           root_dir = strmid(root_dir,0,strlen(root_dir)-1) +'.]'
      ENDIF
    END
  'Win32': BEGIN
      path = '\' + path
      IF (path NE '\') THEN path = path + '\'
    END
  'MacOS': BEGIN
      ; make sure the root dir ends with a separator
      IF (STRMID(root_dir, STRLEN(root_dir) - 1, 1) NE ':') THEN $
	root_dir = root_dir + ':'
    END
  ELSE: BEGIN
      path = '/' + path
      IF (path NE '/') THEN path = path + '/'
    END
ENDCASE
RETURN, root_dir + path + filename

END
; $Id: flick.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro flick,a,b,rate	;Flicker between the two output frames at a given rate.
			; a and b = images scaled from 0 to 255.
			;To terminate, type any key except F or S.
			;Rate = frames per second.
			; Type F to flick faster by a factor of 2
			;  S to flick slower by a factor of 2.
;+
; NAME:
;	FLICK
;
; PURPOSE:
;	Flicker between two output images at a given rate.
;
; CATEGORY:
;	Image display, animation.
;
; CALLING SEQUENCE:
;	FLICK, A, B, Rate
;
; INPUTS:
;	A:	Byte image number 1, scaled from 0 to 255.
;	B:	Byte image number 2, scaled from 0 to 255.
;
; OPTIONAL INPUT PARAMETERS:
;	Rate:	The flicker rate.  The default is 1.0 sec/frame
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Sunview: Modifies the display, changes the write mask.
;	X and Windows: uses two additional pixmaps.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;  SunView:
;	Image A is written to the bottom 4 bits of the display.
;	Image B is written to the top 4 bits.
;	Two color tables are created from the current table, one that
;	shows the low 4 bits using 16 of the original colors, and one
;	that shows the high 4 bits.  The color table is changed to
;	switch between images.
;  Other window systems:
;	two off screen pixmaps are used to contain the images.
;
; MODIFICATION HISTORY:
;	DMS, 3/ 88.
;	DMS, 4/92, Added X window and MS window optimizations.
;-
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
on_error,2                        ;Return to caller if an error occurs

if n_elements(rate) eq 0 then rate = 1.0 ;Parameter there?
ichl = 0
sfact = 1.5		;Speed steps

if !d.name eq "SUN" then begin
	if n_elements(r_orig) eq 0 then begin	;colors defined?
		r_orig=indgen(256) & g_orig = r_orig & b_orig = r_orig
		endif

	p1 = 16 * [[ lindgen(256)/16], [ lindgen(256) and 15]] ;(256,2)

	device, set_write=240	;load top 4 bits
	tv,a
	empty
	device, set_write=15	;load bottom 4 bits
	tv,b/16b
	empty
	device,set_write=255	;re-enable all 8 bits

	while 1 do begin	;loop infinitely over each chl
		p = p1(*,ichl)	;get appropriate table
		tvlct,r_orig(p), g_orig(p), b_orig(p) ;load 4 bit table
		wait,1./rate	;This also empties the graphics buffer
		chr = get_kbrd(0) ;Read character
		case strupcase(chr) of
	"F":	rate = rate*sfact	;Faster
	"S": 	rate = rate/sfact	;Slower
	"":	ichl = 1 - ichl	;Other image
	else:	goto,done
		endcase
	endwhile
;
	done:	tvlct, r_orig, g_orig, b_orig
	empty
	return

ENDIF ELSE BEGIN			;Assume X or Windows
	if !d.window lt 0 then window
	cwin = !d.window
	pix = intarr(2)		;Make 2 pixmaps
	for i=0,1 do begin
		window, /FREE, /PIX, xs = !d.x_size, ys = !d.y_size
		pix(i) = !d.window
		if i eq 0 then tv,a else tv,b
		endfor
	wset, cwin
	while 1 do begin	;loop infinitely over each chl
		device, copy=[0,0,!d.x_size, !d.y_size, 0, 0, pix(ichl)]
		wait,1./rate	;This also empties the graphics buffer
		chr = get_kbrd(0) ;Read character
		case strupcase(chr) of
	"F":	rate = rate*sfact	;Faster
	"S": 	rate = rate/sfact	;Slower
	"":	ichl = 1 - ichl	;Other image
	else:	goto,done1
		endcase
	endwhile
;
done1:	wdelete, pix(0), pix(1)
	return
ENDELSE
end
; $Id: flow3.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro blob3, x0, y0, z0		;Draw a blob at (x0, y0, z0) (may be arrays)
n = n_elements(x0)-1

hfact = .010		;Size of heads
u = 1./[!x.s(1), !y.s(1),!z.s(1)] * hfact	;Size in data coords
u0 = [[1,0,0],[0,1,0],[0,0,1]]	;Directions
for i=0,n-1 do begin
	p0 = [ x0(i), y0(i), z0(i)]
	for j=0,2 do begin
		v = u * u0(*,j)
		plots,[[p0+v],[p0-v]],/T3D
		endfor
	endfor
end


pro arrow3, x0, y0, z0, x1, y1, z1, flags, arrowsize
; Draw an arrow-head at the
; ends of vectors (x0,y0,z0) to (x1, y1, z1).  Params may be arrays.
; Flags(i) = 1 to draw head at end of ith vector.
;
dx = x1-x0
dy = y1-y0
dz = z1-z0
zz = sqrt(dx^2 + dy^2 + dz^2) > 1e-6	;Length


dx = dx/zz		;Cos th
dy = dy/zz		;Sin th

u0 = [-.866/!x.s(1), -.5/!y.s(1), 0]*arrowsize	;Arrow head vectors (XY plane)
u1 = [-.866/!x.s(1),  .5/!y.s(1), 0]*arrowsize

n = n_elements(x0)-1

for i=0,n-1 do if flags(i) then begin	;Heads?
	xx = x1(i)
	yy = y1(i)
	zz = z1(i)
	dx0 = dx(i)
	dy0 = dy(i)
	xx0 = xx + dx0*u0(0) - dy0 * u0(1)
	yy0 = yy + dx0*u0(1) + dy0 * u0(0)
	xx1 = xx + dx0*u1(0) - dy0 * u1(1)
	yy1 = yy + dx0*u1(1) + dy0 * u1(0)
	plots, [xx0,xx,xx1],[yy0,yy,yy1],[zz,zz,zz],/t3d
	endif
end


pro flow3, vx, vy, vz, nvecs=nvecs, nsteps = nsteps, len = len, blob=blob, $
	sx = sx, sy = sy, sz = sz, arrowsize = arrowsize
;+
; NAME:
;	FLOW3 - Draw 3D flow/velocity field.
; PURPOSE:
;	Draw lines representing a 3D flow/velocity field.
; CATEGORY:
;	Graphics.
; CALLING SEQUENCE:
;	FLOW3, vx, vy, vz
; INPUTS:
;	Vx, Vy, Vz = 3D arrays containing X, Y, and Z components
;		of the field.
; KEYWORD PARAMETERS:
;	Sx, Sy, Sz = Optional vectors containing the starting coordinates
;	  of the flow lines. If omitted random starting points are chosen.
;	Nvecs = Number of random flow lines to draw (Default = 200).
;	  Only used if Sx, Sy, Sz are not present.
;	Len = Length of each step used to follow flow lines.  Default = 2.0
;	  Expressed in units of largest field vector, i.e. the length of
;	  the longest step is set to len times the grid spacing.
;	Nsteps = number of steps used to follow the flow lines.  Default =
;	  largest dimension of vx / 5.
;	Blob = 1 to draw a blob at the beginning of each flow line and
;	  suppress the arrows.
;	Arrowsize = size of arrowheads, default = 0.05
; OUTPUTS:
;	None.  Graphics are produced on the currently selected graphics
;	device.
; COMMON BLOCKS:
;	None.
; RESTRICTIONS:
;	Works best with Z buffer output device.
; PROCEDURE:
;	The 3D scaling system must be set before calling this procedure.
;	For example:  scale3, xr=[0,nx-1], yr=[0,ny-1], zr = [0,nz-1]
;	where nx, ny, and nz are the 1st, 2nd, and 3rd dimensions of
;	VX, VY, and VZ.
; MODIFICATION HISTORY:
;	DMS - RSI, Nov, 1991.
;-



s = size(vx)
if s(0) ne 3 then message,'FLOW3: Vx, Vy, and Vz must be 3D arrays'
nx = s(1)
ny = s(2)
nz = s(3)
if n_elements(nsteps) le 0 then nsteps = (nx > ny > nz) /5

if n_elements(sx) le 0 then begin	;Starting points specified?
	if n_elements(nvecs) le 0 then nvecs = 200
	x1 = randomu(seed, nvecs) * nx
	y1 = randomu(seed, nvecs) * ny
	z1 = randomu(seed, nvecs) * nz
endif else begin
	x1 = float(sx)
	y1 = float(sy)
	z1 = float(sz)
	nvecs = n_elements(x1) < n_elements(y1) < n_elements(z1)
endelse

if n_elements(len) le 0 then len = 2.0  ;Default length
if n_elements(arrowsize) le 0 then arrowsize = 0.05

zscale = len/max(sqrt(vx^2+vy^2+vz^2))  ;Make max step = len

flags  = replicate(1b,nvecs)	;TRUE if flow inside cube

for i=0,nsteps do begin		;Draw each element
	x0 = x1
	y0 = y1
	z0 = z1
	x1 = interpolate(vx, x0,y0,z0)*zscale + x0
	y1 = interpolate(vy, x0,y0,z0)*zscale + y0
	z1 = interpolate(vz, x0, y0, z0)*zscale + z0
	out = (x1 lt 0) or (x1 ge nx) or (y1 lt 0) or (y1 ge ny) or $
		(z1 lt 0) or (z1 ge nz)
	flags = flags and (1b-out)
	if (i ne 0) or keyword_set(blob) then $
	   for j=0,nvecs-1 do if flags(j) then $
		plots, [x0(j), x1(j)],[y0(j),y1(j)],[z0(j),z1(j)],/t3d
        if keyword_set(blob) and (i eq 0) then $
		blob3, x0, y0, z0
	if ((i eq 0) or (i eq nsteps)) and (keyword_set(blob) eq 0) then $
		arrow3, x0, y0, z0, x1, y1, z1, flags, arrowsize
	endfor

end
;$Id: f_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;     F_PDF
;
; PURPOSE:
;       This function computes the probabilty (p) such that:
;                   Probability(X <= v) = p
;       where X is a random variable from the F distribution with 
;       (dfn) and (dfd) degrees of freedom.
;
; CATEGORY:
;	Statistics.
;
; CALLING SEQUENCE:
;       Result = f_pdf(V, DFN, DFD)
;
; INPUTS:
;       V:    A scalar of type integer, float or double that specifies
;             the cutoff value.
;
;     DFN:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the F distribution
;             numerator.
;
;     DFD:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the F distribution
;
; EXAMPLE:
;       Compute the probability that a random variable X, from the F 
;       distribution with (dfn = 5) and (dfd = 24) degrees of freedom, 
;       is less than or equal to 3.90. The result should be 0.990059 
;         result = f_pdf(3.90, 5, 24)
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function f_pdf, x, dfn, dfd

  on_error, 2  ;Return to caller if error occurs.

  if x le 0 then return, 1.0 else $
    return, (1.0 - ibeta_pdf(dfd/(dfd+dfn*x), dfd/2.0, dfn/2.0))

end
;
; $Id: fslid_alloc.pro,v 1.7 1994/06/01 23:08:48 ali Exp $
;
;  WidFslider
;   Widget Fslider class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  FSLID_Icon
;       Return the floating point slider toolbar icon
;
FUNCTION FSLID_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 4b, 192b, 1b ], $
    [ 0b, 6b, 224b, 3b ], $
    [ 0b, 7b, 48b, 6b ], $
    [ 128b, 7b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 24b, 12b ], $
    [ 0b, 6b, 48b, 6b ], $
    [ 128b, 31b, 227b, 3b ], $
    [ 192b, 63b, 195b, 1b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 12b, 248b, 127b, 16b ], $
    [ 12b, 8b, 67b, 32b ], $
    [ 12b, 8b, 67b, 16b ], $
    [ 12b, 8b, 67b, 32b ], $
    [ 12b, 8b, 67b, 16b ], $
    [ 12b, 8b, 67b, 32b ], $
    [ 12b, 248b, 127b, 16b ], $
    [ 172b, 170b, 170b, 42b ], $
    [ 84b, 85b, 85b, 21b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  FSLID_Copy
;   Copy a floating point slider.
;
PRO FSLID_Copy, Ptr, Copy
    GenCopy, Ptr, Copy
END


;
; FSLID_Destroy
;   Release resources for the given floating point slider
;
PRO FSLID_Destroy, Ptr
    GenDestroy, Ptr
END


;
;  FSLID_Event
;   Event handling routine for floating point slider dialog
;
PRO FSLID_Event, Event
    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY
    Ptr2Obj, Binfo.ObjPtr, Obj

    CASE Ev OF

    'TITLE':    Obj.Title       = Event.Value
    'SMIN':     Obj.FslidMin    = Event.Value
    'SINIT':    Obj.FslidStart  = Event.Value
    'SMAX':     Obj.FslidMax    = Event.Value
    'NAME':     Obj.Name        = Event.Value
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'FORMAT':   Obj.LabelFormat = Event.Value
    'XSIZE':    Obj.XSize       = Event.Value
    'YSIZE':    Obj.YSize       = Event.Value

    'DO_DRAG':      Obj.FslidDrag       = 1 - Obj.FslidDrag
    'DO_VERTICAL':  Obj.FslidVertical   = 1 - Obj.FslidVertical
    'DO_SUPPRESS':  Obj.FslidSuppress   = 1 - Obj.FslidSuppress

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1
    ;   Goto next input field on a <CR>
    SetNextFocus, Binfo, Event
    Obj2Ptr, Obj, Binfo.ObjPtr
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  FSLID_Build
;   Create a dialog box a floating point slider object.  If ptr is nil then
;   create the object as well.
;
PRO FSLID_Build, Ptr, ParPtr
  COMMON WidEd_Comm

    FSLID_Alloc, ParPtr, Ptr
    MgrName = 'WE_FSLID' + STRTRIM(Ptr, 2)
    IF XRegistered(MgrName) THEN RETURN

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'

    Ptr2Obj, Ptr, Obj
    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(10)

    ;   Event Related Info

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    Foci(0) = Field(Base1, "Slider Title:",Obj.Title,'TITLE',SIZE=50,/STRING)
    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(1) = Field(Base2, "Minimum:", Obj.FslidMin, 'SMIN', SIZE=15, /FLOAT)
    Foci(2) = Field(Base2, "Initial:",Obj.FslidStart,'SINIT',SIZE=15, /FLOAT)
    Foci(3) = Field(Base2, "Maximum:", Obj.FslidMax, 'SMAX', SIZE=15, /FLOAT)

    Base2   = WIDGET_BASE(Base1, /ROW, /NONEXCLUSIVE)
    Button  = WIDGET_BUTTON(Base2, VALUE='Generate Drag Events', $
                            UVALUE='DO_DRAG')
    IF Obj.FslidDrag THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Vertical Slider', $
                            UVALUE='DO_VERTICAL')
    IF Obj.FslidVertical THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Suppress display of current value', $
                            UVALUE='DO_SUPPRESS')
    IF Obj.FslidDrag THEN WIDGET_CONTROL, Button, /SET_BUTTON

    BuildOther, Base1, Obj, Foci, 4, /FRAME

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Slider Appearance Controls")
    Foci(7) = Field(Base1, "Label Format:", Obj.LabelFormat, "FORMAT", $
                    SIZE=30, /STRING)
    BuildXY, Base1, Obj, Foci, 8, /SIZE
    BuildOkCancel, Base, Obj

    DlgInfo     = { $
        Foci:       Foci, $
        ObjPtr:     Ptr $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='FSLID_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  FSLID_Save
;   Save floating point slider information to a file.
;   This is a simple object to save.
;
PRO FSLID_Save, Unit, Ptr
    GenWrite, Unit, Ptr
END


;
;  FSLID_Restore
;   Read in a floating point slider object from a file
;
PRO FSLID_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "FSLID", 0
END


;
;  FSLID_Generate
;   Create a floating point slider object for previewing
;
PRO FSLID_Generate, Base, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Value may not be outside of min/max
    Value   = Obj.FSlidMin > Obj.FSlidStart < Obj.FSlidMax

    Cmd = 'Id = CW_FSLIDER(Base'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IF Obj.FslidMin NE Obj.FslidMax THEN BEGIN
        IAddCmd, Cmd, Obj.FslidMin, 'MINIMUM', /FORCE
        IAddCmd, Cmd, Obj.FslidMax, 'MAXIMUM', /FORCE
    ENDIF
    IAddCmd, Cmd, Obj.FslidSuppress, 'SUPPRESS_VALUE'
    SAddCmd, Cmd, Obj.Title, 'TITLE'
    IAddCmd, Cmd, Value, 'VALUE', /FORCE
    IAddCmd, Cmd, Obj.FslidVertical, 'VERTICAL'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'

    Obj2Ptr, Obj, Ptr

    ; Create fslid
    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Flt Slider ' + VarName(Ptr)
    ENDIF
END

;
;  FSLID_GenWid
;   Create IDL code for creating a floating point slider (CW_FSLIDER)
;
PRO FSLID_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)
    Ptr2Obj, Ptr, Obj

    ;   Value may not be outside of min/max
    Value   = Obj.FSlidMin > Obj.FSlidStart < Obj.FSlidMax

    XPRINTF, Unit, FORMAT='("  ",A," = CW_FSLIDER( ",A)', $
        Name, Parent, /NO_EOL
    ISaveCmd, Unit, Obj.FSlidDrag, "DRAG"
    SSaveCmd, Unit, Obj.LabelFormat, "FORMAT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    IF Obj.FslidMin NE Obj.FslidMax THEN BEGIN
        ISaveCmd, Unit, Obj.FSlidMax, "MAXIMUM", /FORCE
        ISaveCmd, Unit, Obj.FSlidMin, "MINIMUM", /FORCE
    ENDIF
    ISaveCmd, Unit, Obj.FSlidSuppress, "SUPPRESS"
    SSaveCmd, Unit, Obj.Title, "TITLE"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Value, "VALUE", /FORCE
    ISaveCmd, Unit, Obj.FSlidVertical, "VERTICAL"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  FSLID_Alloc
;       Allocate a floating point slider object.  Don't allocate if ptr
;   is non-nil
;
PRO FSLID_Alloc, Parent, Ptr
  COMMON WidEd_Comm    

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN

    Ptr = WIDGET_BASE(GROUP=TopDlg)

    Obj = {                     $
        WE_FSLID,               $
        Type:           'FSLID',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; object name
        Title:          '',     $ ; Fslid title
        FrameSize:      0,      $
        LabelFormat:    '',     $
        XSize:          0,      $
        YSize:          0,      $
        UValue:         '',     $
        FslidDrag:      0,      $ ; slider flags
        FslidVertical:  0,      $
        FslidSuppress:  0,      $
        FslidMin:       0.0,    $ ; slider basic info
        FslidStart:     0.0,    $
        FslidMax:       0.0     $
    }
    Obj2Ptr, Obj, Ptr
END
; $Id: funct.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO	FUNCT,X,A,F,PDER
;+
; NAME:
;	FUNCT
;
; PURPOSE:
;	Evaluate the sum of a Gaussian and a 2nd-order polynomial
;	and optionally return the value of its partial derivatives.
;	Normally, this function is used by CURVEFIT to fit the
;	sum of a line and a varying background to actual data.
;
; CATEGORY:
;	E2 - Curve and surface fitting.
;
; CALLING SEQUENCE:
;	FUNCT, X, A, F [, Pder]
;
; INPUTS:
;	X:	The values of the independent variable.
;	A:	The parameters of the equation described in PROCEDURE below.
;
; OUTPUTS:
;	F:	The value of the function at each X(i).
;
; OPTIONAL OUTPUT PARAMETERS:
;	Pder:	An array of the size (N_ELEMENTS(X),6) that contains the
;		partial derivatives.  Pder(i,j) represents the derivative
;		at the i'th point with respect to j'th parameter.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	F = A(0)*EXP(-Z^2/2) + A(3) + A(4)*X + A(5)*X^2
;	Z = (X-A(1))/A(2)
;
; MODIFICATION HISTORY:
;	WRITTEN, DMS, RSI, SEPT, 1982.
;	Modified, DMS, Oct 1990.  Avoids divide by 0 if A(2) is 0.
;-
	ON_ERROR,2                        ;Return to caller if an error occurs
	if a(2) ne 0.0 then Z = (X-A(1))/A(2) $	;GET Z
	else z= 10.
	EZ = EXP(-Z^2/2.)*(ABS(Z) LE 7.) ;GAUSSIAN PART IGNORE SMALL TERMS
	F = A(0)*EZ + A(3) + A(4)*X + A(5)*X^2 ;FUNCTIONS.
	IF N_PARAMS(0) LE 3 THEN RETURN ;NEED PARTIAL?
;
	PDER = FLTARR(N_ELEMENTS(X),6) ;YES, MAKE ARRAY.
	PDER(0,0) = EZ		;COMPUTE PARTIALS
	if a(2) ne 0. then PDER(0,1) = A(0) * EZ * Z/A(2)
	PDER(0,2) = PDER(*,1) * Z
	PDER(*,3) = 1.
	PDER(0,4) = X
	PDER(0,5) = X^2
	RETURN
END

;$Id: fv_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       FV_TEST
;
; PURPOSE:
;       This function computes the F-statistic and the probability that two 
;       vectors of sampled data have significantly different variances. This
;       type of test is often refered to as the F-variances Test.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = FV_TEST(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An m-element vector of type integer, float or double.
;
; EXAMPLE
;       Define two n-element vectors of tabulated data.
;         X = [257, 208, 296, 324, 240, 246, 267, 311, 324, 323, 263, 305, $
;               270, 260, 251, 275, 288, 242, 304, 267]
;         Y = [201, 56, 185, 221, 165, 161, 182, 239, 278, 243, 197, 271, $
;               214, 216, 175, 192, 208, 150, 281, 196]
;       Compute the F-statistic (of X and Y) and its significance. 
;       The result should be the two-element vector [2.48578, 0.0540116], 
;       indicating that X and Y have significantly different variances.
;         result = fv_test(X, Y)
;
; PROCEDURE:
;       FV_TEST computes the F-statistic of X and Y as the ratio of variances
;       and its significance. X and Y may be of different lengths. The result 
;       is a two-element vector containing the F-statistic and its 
;       significance. The significance is a value in the interval [0.0, 1.0];
;       a small value (0.05 or 0.01) indicates that X and Y have significantly
;       different variances.
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, Aug 1994
;                    FV_TEST is based on the routine: ftest.c described in 
;                    section 14.2 of Numerical Recipes, The Art of Scientific 
;                    Computing (Second Edition), and is used by permission.
;-

function betacf, a, b, x
  on_error, 2
  eps   = 3.0e-7
  fpmin = 1.0e-30
  maxit = 100
  qab = a + b
  qap = a + 1.0
  qam = a - 1.0
    c = 1.0
    d = 1.0 - qab * x / qap
  if(abs(d) lt fpmin) then d = fpmin
  d = 1.0 / d
  h = d
  for m = 1, maxit do begin
    m2 = 2 * m
    aa = m * (b - m) * x / ((qam + m2) * (a + m2))
     d = 1.0 + aa*d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     h = h * d * c
     aa = -(a + m) *(qab + m) * x/((a + m2) * (qap + m2))
     d = 1.0 + aa * d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     del = d * c
     h = h * del
     if(abs(del - 1.0) lt eps) then return, h
  endfor
  message, 'Failed to converge within given parameters.'
end

function gammln, xx
  coff = [76.18009172947146d0,   -86.50532032941677d0,  $
          24.01409824083091d0,    -1.231739572450155d0, $
           0.1208650973866179d-2, -0.5395239384953d-5]
  stp = 2.5066282746310005d0
  x = xx
  y = x
  tmp = x + 5.5d0
  tmp = (x + 0.5d0) * alog(tmp) - tmp
  ser = 1.000000000190015d0
  for j = 0, n_elements(coff)-1 do begin
    y = y + 1.d0
    ser = ser + coff(j) / y
  endfor
  return, tmp + alog(stp * ser / x)
end

function ibeta, a, b, x
  on_error, 2
  if (x lt 0 or x gt 1) then message, $
    'x must be in the interval [0, 1].'
  if (x eq 0  or x eq 1) then bt = 0.0 $
  else $
    bt = exp(gammln(a + b) - gammln(a) - gammln(b) + $
             a * alog(x) + b * alog(1.0 - x))
  if(x lt (a + 1.0)/(a + b + 2.0)) then return, $
    bt * betacf(a, b, x) / a $
  else return, 1.0 - bt * betacf(b, a, 1.0-x) / b
end

function fv_test, x0, x1

  on_error, 2

  nx0 = n_elements(x0)
  nx1 = n_elements(x1)

  if nx0 le 1 or nx1 le 1 then $
    message, 'x0 and x1 must be vectors of length greater than one.'

  type = size(x0)

  mv0 = moment(x0)
  mv1 = moment(x1)

  if mv0(1) gt mv1(1) then begin
    f = mv0(1) / mv1(1)
    df0 = nx0 - 1
    df1 = nx1 - 1
  endif else begin
    f = mv1(1) / mv0(1)
    df0 = nx1 - 1
    df1 = nx0 - 1
  endelse

  prob = 2.0 * ibeta(0.5*df1, 0.5*df0, df1/(df1+df0*f))

  if type(2) ne 5 then prob = float(prob)  
    
  if prob gt 1 then return, [f, 2.0 - prob] $
  else return, [f, prob]

end
;$Id: fx_root.pro,v 1.2 1994/11/29 18:37:26 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       FX_ROOT
;
; PURPOSE:
;       This function computes real and complex roots (zeros) of
;       a univariate nonlinear function.
;
; CATEGORY:
;       Nonlinear Equations/Root Finding
;
; CALLING SEQUENCE:
;       Result = FX_ROOT(X, Func)
;
; INPUTS:
;       X :      A 3-element initial guess vector of type real or complex.
;                Real initial guesses may result in real or complex roots.
;                Complex initial guesses will result in complex roots.
;
;       Func:    A scalar string specifying the name of a user-supplied IDL
;                function that defines the univariate nonlinear function.
;                This function must accept the vector argument X.
;
; KEYWORD PARAMETERS:
;       DOUBLE:  If set to a non-zero value, computations are done in
;                double precision arithmetic. 
;
;       ITMAX:   Set this keyword to specify the maximum number of iterations
;                The default is 100.
;       
;       STOP:    Set this keyword to specify the stopping criterion used to
;                judge the accuracy of a computed root, r(k). 
;                STOP = 0 implements an absolute error criterion between two
;                successively-computed roots, |r(k) - r(k+1)|.
;                STOP = 1 implements a functional error criterion at the 
;                current root, |Func(r(k))|. The default is 0.
;
;       TOL:     Set this keyword to specify the stopping error tolerance.
;                If the STOP keyword is set to 0, the algorithm stops when
;                |x(k) - x(k+1)| < TOL.
;                If the STOP keyword is set to 1, the algorithm stops when 
;                |Func(x(k))| < TOL. The default is 1.0e-4.
;
; EXAMPLE:
;       Define an IDL function named FUNC.
;         function FUNC, x
;           return, exp(sin(x)^2 + cos(x)^2 - 1) - 1 
;         end 
;
;       Define a real 3-element initial guess vector.
;         x = [0.0, -!pi/2, !pi]
;
;       Compute a root of the function using double-precision arithmetic.
;         root = FX_ROOT(x, 'FUNC', /double)
;
;       Check the accuracy of the computed root.
;         print, exp(sin(root)^2 + cos(root)^2 - 1) - 1
;
;       Define a complex 3-element initial guess vector.
;         x = [complex(-!pi/3, 0), complex(0, !pi), complex(0, -!pi/6)]
;
;       Compute a root of the function.
;         root = FX_ROOT(x, 'FUNC')
;
;       Check the accuracy of the computed root.
;         print, exp(sin(root)^2 + cos(root)^2 - 1) - 1
;
; PROCEDURE:
;       FX_ROOT implements an optimal Muller's method using complex 
;       arithmetic only when necessary.
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, March 1994
;       Modified:    GGS, RSI, September 1994
;                    Added support for double-precision complex inputs.
;-

function fx_root, xi, func, double = double, itmax = itmax, $
                            stop = stop, tol = tol  

  on_error, 2 ;Return to caller if error occurs.

  x = xi + 0.0 ;Create an internal floating-point variable, x.
  sx = size(x)
  if sx(1) ne 3 then $
    message, 'x must be a 3-element initial guess vector.'

  ;Initialize keyword parameters.
  if keyword_set(double) ne 0 then begin 
    if sx(2) eq 4 or sx(2) eq 5 then x = x + 0.0d $
    else x = dcomplex(x)
  endif
  if keyword_set(itmax)  eq 0 then itmax = 100
  if keyword_set(stop)   eq 0 then stop = 0
  if keyword_set(tol)    eq 0 then tol = 1.0e-4

  ;Initialize stopping criterion and iteration count.
  cond = 0  &  it = 0
 
  ;Begin to iteratively compute a root of the nonlinear function.
  while (it lt itmax and cond ne 1) do begin
    q = (x(2) - x(1))/(x(1) - x(0))
    pls = (1 + q)
    f = call_function(func, x)
    a = q*f(2) - q*pls*f(1) + q^2*f(0)
    b = (2*q+1)*f(2) - pls^2*f(1) + q^2*f(0)
    c = pls*f(2)
    disc = b^2 - 4*a*c
    roc = size(disc)  ;Real or complex discriminant?
    if roc(1) ne 6 and roc(1) ne 9 then begin  ;Proceed toward real root.   
      if disc lt 0 then begin  ;Switch to complex root.
        ;Single-precision complex.
        if keyword_set(double) eq 0 and sx(2) ne 9 then begin
          r0 = b + complex(0, sqrt(abs(disc)))
          r1 = b - complex(0, sqrt(abs(disc)))
        endif else begin ;Double-precision complex.
          r0 = b + dcomplex(0, sqrt(abs(disc)))
          r1 = b - dcomplex(0, sqrt(abs(disc)))
        endelse
        if abs(r0) gt abs(r1) then div = r0 $  ;Maximum modulus.
          else div = r1
       endif else $
        div = max([abs(b + sqrt(disc)), abs(b - sqrt(disc))]) ;Real root. 
    endif else begin  ;Proceed toward complex root.
      c0 = b + sqrt(disc)
      c1 = b - sqrt(disc)
      if abs(c0) gt abs(c1) then div = c0 $  ;Maximum modulus.
        else div = c1
    endelse
    root = x(2) - (x(2) - x(1)) * (2 * c/div) 
    ;Absolute error tolerance.
    if stop eq 0 and abs(root - x(2)) le tol then cond = 1 $ 
    else $  
    ;Functional error tolerance. 
    if stop ne 0 and abs(call_function(func, root)) le tol then cond = 1
    x = [x(1), x(2), root] 
    it = it + 1
  endwhile
  if it ge itmax and cond eq 0 then $
    message, 'Algorithm failed to converge within given parameters.'
  return, root

end

; $Id: gamma_ct.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro gamma_ct, gamma, CURRENT = current, INTENSITY = intensity
;+
; NAME:
;	GAMMA_CT
;
; PURPOSE:
;	Apply gamma correction to the color table.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	GAMMA, Gamma
;	GAMMA, Gamma, /CURRENT
;
; INPUTS:
;	Gamma:	The value of gamma correction.  A value of 1.0 indicates a
;		linear ramp, i.e., no gamma correction.  Higher values of 
;		gamma give more contrast.  Values less than 1.0 yield lower 
;		contrast.
;
; KEYWORD PARAMETERS:
;     CURRENT:	If this keyword is set, apply correction from the current 
;		table.  Otherwise, apply from the original color table.  When
;		CURRENT is set, the color table input to GAMMA_CT
;		is taken from the R_CURR, G_CURR, and B_CURR variables.
;		Otherwise, input is from R_ORIG, G_ORIG, and B_ORIG.
;		The resulting tables are always saved in the "current" table.
;
;   INTENSITY:	If this keyword is set, correct the individual intensities of 
;		each color in the color table.  Otherwise, shift the colors 
;		according to the gamma function.
;
; OUTPUTS:
;	No explicit outputs.  The modified color table vectors
;	are saved in the COLORS common block, as the variables
;	r_curr, g_curr, and b_curr variables.
;
; COMMON BLOCKS:
;	COLORS:	The IDL color table common block.
;
; SIDE EFFECTS:
;	A new color table is loaded, and its contents are placed
;	in the "current" variables of the COLORS common block.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.  The gamma correction is implemented
;	as x^gamma, where x is the range of color table indices
;	scaled from 0 to 1.
;
; MODIFICATION HISTORY:
;	DMS, Oct, 1990. Added ability shift intensities of colors, rather 
;			than the mapping of the colors.  DMS, April, 1991.
;-
; Copyright (c) 1990, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

n = !d.table_size-1

if n_elements(r_orig) le 0 then begin
	r_orig = indgen(n) & r_curr = r_orig
	g_orig = r_orig & g_curr = g_orig
	b_orig = r_orig & b_curr = b_orig
	endif

if n_elements(gamma) le 0 then gamma = 1.0

if keyword_set(intensity) then begin
  s = byte(256 *((findgen(256)/256.)^gamma))   ;Scale individ intensities
  if keyword_set(current) then begin
	r_curr = s(r_curr)
	g_curr = s(g_curr)
	b_curr = s(b_curr)
  endif else begin
	r_curr = s(r_orig)
	g_curr = s(g_orig)
	b_curr = s(b_orig)
  endelse
endif else begin   ;Scale color mapping, not intensities
  s = long(n*((findgen(n)/n)^gamma))
  if keyword_set(current) then begin
	r_curr = r_curr(s)
	g_curr = g_curr(s)
	b_curr = b_curr(s)
  endif else begin
	r_curr = r_orig(s)
	g_curr = g_orig(s)
	b_curr = b_orig(s)
  endelse
endelse
tvlct,r_curr, g_curr, b_curr
end
; $Id: gamma.pro,v 1.1 1995/07/05 15:33:04 idl Exp $

; Copyright (c) 1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.

;+
; NAME:
;       GAMMA
; PURPOSE:
;	The introduction of the GAMMA function as a built in system routine
;	in IDL 4.0 caused inconvenience to customers with existing code
;	in which GAMMA had been used as a variable, because IDL system
;	routines have precedence over variable names. To minimize this
;	problem, RSI has renamed GAMMA to NR_GAMMA.
;
;	This wrapper serves to make NR_GAMMA available under the name
;	GAMMA as documented in the IDL Reference Manual. However, since
;	IDL library routines have lower precedence than variables, programs
;	that use GAMMA as a variable name will work as before.
;
;	See the documentation for GAMMA in the IDL Reference manual for
;	details on arguments, keywords, and results.
; 
;
; MODIFICATION HISTORY:
;	3 July 1995, AB, RSI.
;-

function gamma, x, _EXTRA=EXTRA_KW

  return, NR_GAMMA(x, _EXTRA=EXTRA_KW)

end
; $Id: gauss2dfit.pro,v 1.1 1995/07/06 22:53:34 dave Exp $
PRO	GAUSS2_FUNCT, X, A, F, PDER
; NAME:
;	GAUSS2_FUNCT
; PURPOSE:
;	Evaluate function for gauss2fit.
; CALLING SEQUENCE:
;	FUNCT,X,A,F,PDER
; INPUTS:
;	X = values of independent variables, encoded as: [nx, ny, x, y]
;	A = parameters of equation described below.
; OUTPUTS:
;	F = value of function at each X(i,j), Y(i,j).
;	Function is:
;		F(x,y) = A0 + A1*EXP(-U/2)
;		where: U= (yp/A2)^2 + (xp/A3)^2
;
;	  If A has 7 elements a rotation of the ellipse is present and:
;		xp = (x-A4) * cos(A6) - (y-A5) * sin(A6)
;		yp = (x-A4) * sin(A6) + (y-A5) * cos(A6)
;	  If A has 6 elements, A6 (theta) is 0, the major and minor axes
;	  of the ellipse are parallel to the XY axes, and:
;		xp = (x-A4)   and   yp = (x-A5)
;
; Optional output parameters:
;	PDER = (n_elements(z),6 or 7) array containing the
;		partial derivatives.  pder(i,j) = derivative
;		at ith point w/respect to jth parameter.
; PROCEDURE:
;	Evaluate the function and then if requested, eval partials.
;
; MODIFICATION HISTORY:
;	WRITTEN, DMS, RSI, June, 1995.
;

nx = long(x(0))		;Retrieve X and Y vectors
ny = long(x(1))

tilt = n_elements(a) eq 7	;TRUE if angle present.
if tilt then begin		;Rotate?
    xp = (x(2:nx+1)-a(4)) # replicate(1.0, ny)	;Expand X values
    yp = replicate(1.0, nx) # (x(nx+2:*)-a(5))	;expand Y values
    s = sin(A(6)) & c = cos(A(6))
    t =  xp * (c/a(2)) - yp * (s/a(2))
    yp = xp * (s/a(3)) + yp * (c/a(3))
    xp = temporary(t)
endif else begin
    xp = (x(2:nx+1)-a(4)) # replicate(1.0/a(2), ny)	;Expand X values
    yp = replicate(1.0/a(3), nx) # (x(nx+2:*)-a(5))	;expand Y values
    s = 0.0 & c = 1.0
endelse

n = nx * ny
u = reform(exp(-0.5 * (xp^2 + yp^2)), n)	;Exp() term, Make it 1D
F = a(0) + a(1) * u

if n_params(0) le 3 then return ;need partial?  No.

PDER = FLTARR(n, n_elements(a))	;YES, make partial array.
PDER(*,0) = 1.0			;And fill.
pder(0,1) = u
u = a(1) * u			;Common term for the rest of the partials
pder(0,2) = u * xp^2 / a(2)
pder(0,3) = u * yp^2 / a(3)
pder(0,4) = u * (c/a(2) * xp + s/a(3) * yp)
pder(0,5) = u * (-s/a(2) * xp + c/a(3) * yp)
if tilt then pder(0,6) = u * xp*yp*(a(2)/a(3)-a(3)/a(2))
END



Function Gauss2dfit, z, a, x, y, NEGATIVE = neg, TILT=tilt
;+
; NAME:
;	GAUSS2DFIT
;
; PURPOSE:
; 	Fit a 2 dimensional elliptical gaussian equation to rectilinearly
;	gridded data.
;		Z = F(x,y) where:
; 		F(x,y) = A0 + A1*EXP(-U/2)
;	   And the elliptical function is:
;		U= (x'/a)^2 + (y'/b)^2
;	The parameters of the ellipse U are:
;	   Axis lengths are 2*a and 2*b, in the unrotated X and Y axes,
;		respectively.
;	   Center is at (h,k).
;	   Rotation of T radians from the X axis, in the CLOCKWISE direction.
;	   The rotated coordinate system is defined as:
;		x' = (x-h) * cos(T) - (y-k) * sin(T)  <rotate by T about (h,k)>
;		y' = (x-h) * sin(T) + (y-k) * cos(T)
;
;	The rotation is optional, and may be forced to 0, making the major/
;	minor axes of the ellipse parallel to the X and Y axes.
;
;	The coefficients of the function, are returned in a seven
;	element vector:
;	a(0) = A0 = constant term.
;	a(1) = A1 = scale factor.
;	a(2) = a = width of gaussian in X direction.
;	a(3) = b = width of gaussian in Y direction.
;	a(4) = h = center X location.
;	a(5) = k = center Y location.
;	a(6) = T = Theta the rotation of the ellipse from the X axis
;		in radians, counterclockwise.
;
;
; CATEGORY:
;	curve / data fitting
;
; CALLING SEQUENCE:
;	Result = GAUSS2DFIT(z, a [,x,y])
;
; INPUTS:
;	Z = dependent variable in a 2D array dimensioned (Nx, Ny).  Gridding
;		must be rectilinear.
;	X = optional Nx element vector containing X values of Z.  X(i) = X value
;		for Z(i,j).  If omitted, a regular grid in X is assumed,
;		and the X location of Z(i,j) = i.
;	Y = optional Ny element vector containing Y values of Z.  Y(j) = Y value
;		for Z(i,j).  If omitted, a regular grid in Y is assumed,
;		and the Y location of Z(i,j) = j.
;
; Optional Keyword Parameters:
;	NEGATIVE = if set, implies that the gaussian to be fitted
;		is a valley (such as an absorption line).
;		By default, a peak is fit.
;	TILT = if set to  1, allow the orientation of the major/minor axes of 
;		the ellipse to be unrestricted.  The default is that
;		the axes of the ellipse must be parallel to the X-Y axes.
;		In this case, A(6) is always returned as 0.
;
; OUTPUTS:
;	The fitted function is returned.
; OUTPUT PARAMETERS:
;	A:	The coefficients of the fit.  A is a seven element vector as
;		described under PURPOSE.
;
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:
;	None.
; RESTRICTIONS:
;	Timing:  Approximately 4 seconds for a 128 x 128 array, on a 
;		Sun SPARC LX.  Time required is roughly proportional to the 
;		number of elements in Z.
;
; PROCEDURE:
;	The peak/valley is found by first smoothing Z and then finding the
;	maximum or minimum respectively.  Then GAUSSFIT is applied to the row
;	and column running through the peak/valley to estimate the parameters
;	of the Gaussian in X and Y.  Finally, CURVEFIT is used to fit the 2D
;	Gaussian to the data.
;
;	Be sure that the 2D array to be fit contains the entire Peak/Valley
;	out to at least 5 to 8 half-widths, or the curve-fitter may not
;	converge.
;
; EXAMPLE:  This example creates a 2D gaussian, adds random noise
;	and then applies GAUSS2DFIT:
;	nx = 128		;Size of array
;	ny = 100
;	;**  Offs Scale X width Y width X cen Y cen  **
;	;**   A0  A1    a       b       h       k    **
;	a = [ 5., 10., nx/6.,  ny/10., nx/2., .6*ny]  ;Input function parameters
;	x = findgen(nx) # replicate(1.0, ny)	;Create X and Y arrays
;	y = replicate(1.0, nx) # findgen(ny)
;	u = ((x-a(4))/a(2))^2 + ((y-a(5))/a(3))^2  ;Create ellipse
;	z = a(0) + a(1) * exp(-u/2)		;to gaussian
;	z = z + randomn(seed, nx, ny)		;Add random noise, SD = 1
;	yfit = gauss2dfit(z,b)			;Fit the function, no rotation
;	print,'Should be:',string(a,format='(6f10.4)')  ;Report results..
;	print,'Is:      :',string(b(0:5),format='(6f10.4)')
;
; MODIFICATION HISTORY:
;	DMS, RSI, June, 1995.
;-
;
on_error,2                      ;Return to caller if an error occurs
s = size(z)
if s(0) ne 2 then $
	message, 'Z must have two dimensions'
n = n_elements(z)
nx = s(1)
ny = s(2)
np = n_params()
if np lt 3 then x = findgen(nx)
if np lt 4 then y = findgen(ny)

if nx ne n_elements(x) then $
    message,'X array must have size equal to number of columns of Z'
if ny ne n_elements(y) then $
    message,'Y array must have size equal to number of rows of Z'

if keyword_set(neg) then q = MIN(SMOOTH(z,3), i) $
    ELSE q = MAX(SMOOTH(z,3), i)	;Dirty peak / valley finder
ix = i mod nx
iy = i / nx
x0 = x(ix)
y0 = y(iy)

xfit = gaussfit(x, z(*,iy), ax, NTERMS=4) ;Guess at params by taking slices
yfit = gaussfit(y, z(ix,*), ay, NTERMS=4)

; First guess, without XY term...
a = [	(ax(3) + ay(3))/2., $		;Constant
	sqrt(abs(ax(0) * ay(0))), $	;Exponential factor
	ax(2), ay(2), ax(1), ay(1)]	;Widths and centers

;  If there's a tilt, add the XY term = 0
if Keyword_set(tilt) then a = [a, 0.0]

;************* print,'1st guess:',string(a,format='(8f10.4)')
result = curvefit([nx, ny, x, y], reform(z, n, /OVERWRITE), $
		replicate(1.,n), a, itmax=50, $
		function_name = "GAUSS2_FUNCT", /NODERIVATIVE)

; If we didn't already have an XY term, add it = 0.0
if Keyword_set(tilt) eq 0 then a = [a, 0.0] $
else a(6) = a(6) mod !pi		;Reduce angle argument
z= REFORM(z, nx, ny, /OVERWRITE)	;Restore dimensions
return, REFORM(result, nx, ny, /OVERWRITE)
end

;$Id: gauss_cvf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       GAUSS_CVF
;
; PURPOSE:
;       This function computes the cutoff value (v) such that:
;                   Probability(X > v) = p
;       where X is a random variable from the standard Gaussian (Normal)
;       distribution with a mean of 0.0 and a variance of 1.0
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Gauss_cvf(P)
;
; INPUTS:
;       P:    A non-negative scalar, in the interval [0.0, 1.0], of type
;             float or double that specifies the probability of occurance
;             or success.
;
; EXAMPLE:
;       Compute the cutoff value (v) such that Probability(X > v) = 0.025
;       from the standard Gaussian (Normal) distribution. The result should 
;       be 1.95997
;         result = gauss_cvf(0.025)
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function gauss_cvf, p

  on_error, 2  ;Return to caller if error occurs.

  if p lt 0. or p gt 1. then message, $
    'p must be in the interval [0.0, 1.0]'
  if p eq 0 then return,  1.0e12
  if p eq 1 then return, -1.0e12

  if (p gt 0.5) then begin
    p = 1 - p
    adjust = 1
  endif else adjust = 0 

  below = 0
  up = 1.0

  while gauss_pdf(up) lt 1.0 - p do begin
    below = up
    up = 2 * up
  endwhile

  x = bisect_pdf([1.0 - p], 'gauss_pdf', up, below)
  if adjust then begin
    p = 1 - p
    return, -x
  endif else return, x
end

; $Id: gaussfit.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO	GAUSS_FUNCT,X,A,F,PDER
; NAME:
;	GAUSS_FUNCT
;
; PURPOSE:
;	EVALUATE THE SUM OF A GAUSSIAN AND A 2ND ORDER POLYNOMIAL
;	AND OPTIONALLY RETURN THE VALUE OF IT'S PARTIAL DERIVATIVES.
;	NORMALLY, THIS FUNCTION IS USED BY CURVEFIT TO FIT THE
;	SUM OF A LINE AND A VARYING BACKGROUND TO ACTUAL DATA.
;
; CATEGORY:
;	E2 - CURVE AND SURFACE FITTING.
; CALLING SEQUENCE:
;	FUNCT,X,A,F,PDER
; INPUTS:
;	X = VALUES OF INDEPENDENT VARIABLE.
;	A = PARAMETERS OF EQUATION DESCRIBED BELOW.
; OUTPUTS:
;	F = VALUE OF FUNCTION AT EACH X(I).
;
; OPTIONAL OUTPUT PARAMETERS:
;	PDER = (N_ELEMENTS(X),6) ARRAY CONTAINING THE
;		PARTIAL DERIVATIVES.  P(I,J) = DERIVATIVE
;		AT ITH POINT W/RESPECT TO JTH PARAMETER.
; COMMON BLOCKS:
;	NONE.
; SIDE EFFECTS:
;	NONE.
; RESTRICTIONS:
;	NONE.
; PROCEDURE:
;	F = A(0)*EXP(-Z^2/2) + A(3) + A(4)*X + A(5)*X^2
;	Z = (X-A(1))/A(2)
; MODIFICATION HISTORY:
;	WRITTEN, DMS, RSI, SEPT, 1982.
;	Modified, DMS, Oct 1990.  Avoids divide by 0 if A(2) is 0.
;	Added to Gauss_fit, when the variable function name to
;		Curve_fit was implemented.  DMS, Nov, 1990.
;
	ON_ERROR,2                        ;Return to caller if an error occurs
	if a(2) ne 0.0 then Z = (X-A(1))/A(2) $	;GET Z
	else z= 10.
	EZ = EXP(-Z^2/2.)*(ABS(Z) LE 7.) ;GAUSSIAN PART IGNORE SMALL TERMS
	F = A(0)*EZ + A(3) + A(4)*X + A(5)*X^2 ;FUNCTIONS.
	IF N_PARAMS(0) LE 3 THEN RETURN ;NEED PARTIAL?
;
	PDER = FLTARR(N_ELEMENTS(X),6) ;YES, MAKE ARRAY.
	PDER(0,0) = EZ		;COMPUTE PARTIALS
	if a(2) ne 0. then PDER(0,1) = A(0) * EZ * Z/A(2)
	PDER(0,2) = PDER(*,1) * Z
	PDER(*,3) = 1.
	PDER(0,4) = X
	PDER(0,5) = X^2
	RETURN
END



Function Gaussfit, x, y, a
;+
; NAME:
;	GAUSSFIT
;
; PURPOSE:
; 	Fit the equation y=f(x) where:
;
; 		F(x) = A0*EXP(-z^2/2) + A3 + A4*x + A5*x^2
; 			and
;		z=(x-A1)/A2
;
;	A0 = height of exp, A1 = center of exp, A2 = sigma (the width).
;	A3 = constant term, A4 = linear term, A5 = quadratic term.
; 	The parameters A0, A1, A2, A3 are estimated and then CURVEFIT is 
;	called.
;
; CATEGORY:
;	?? - fitting
;
; CALLING SEQUENCE:
;	Result = GAUSSFIT(X, Y [, A])
;
; INPUTS:
;	X:	The independent variable.  X must be a vector.
;	Y:	The dependent variable.  Y must have the same number of points
;		as X.
;
; OUTPUTS:
;	The fitted function is returned.
;
; OPTIONAL OUTPUT PARAMETERS:
;	A:	The coefficients of the fit.  A is a six-element vector as 
;		described under PURPOSE.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	The peak or minimum of the Gaussian must be the largest
;	or smallest point in the Y vector.
;
; PROCEDURE:
;	If the (MAX-AVG) of Y is larger than (AVG-MIN) then it is assumed
;	that the line is an emission line, otherwise it is assumed there
;	is an absorbtion line.  The estimated center is the MAX or MIN
;	element.  The height is (MAX-AVG) or (AVG-MIN) respectively.
;	The width is found by searching out from the extrema until
;	a point is found less than the 1/e value.
;
; MODIFICATION HISTORY:
;	DMS, RSI, Dec, 1983.
;-
;
on_error,2                      ;Return to caller if an error occurs
n = n_elements(y)		;# of points.
c = poly_fit(x,y,1,yf)		;fit a straight line.
yd = y-yf			;difference.

ymax=max(yd) & xmax=x(!c) & imax=!c	;x,y and subscript of extrema
ymin=min(yd) & xmin=x(!c) & imin=!c
a=fltarr(6)			;coefficient vector
if abs(ymax) gt abs(ymin) then i0=imax else i0=imin ;emiss or absorp?
i0 = i0 > 1 < (n-2)		;never take edges
dy=yd(i0)			;diff between extreme and mean
del = dy/exp(1.)		;1/e value
i=0
while ((i0+i+1) lt n) and $	;guess at 1/2 width.
	((i0-i) gt 0) and $
	(abs(yd(i0+i)) gt abs(del)) and $
	(abs(yd(i0-i)) gt abs(del)) do i=i+1
a = [yd(i0), x(i0), abs(x(i0)-x(i0+i)), c(0), c(1), 0.] ;estimates
!c=0				;reset cursor for plotting
return,curvefit(x,y,replicate(1.,n),a,sigmaa, $
		function_name = "GAUSS_FUNCT") ;call curvefit
end

;$Id: gauss_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       GAUSS_PDF
;
; PURPOSE:
;       This function computes the probabilty (p) such that:
;                   Probability(X <= v) = p
;       where X is a random variable from the standard Gaussian (Normal) 
;       distribution with a mean of 0.0 and a variance of 1.0
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Gauss_Pdf(V)
;
; INPUTS:
;       V:    A scalar of type integer, float or double that specifies
;             the cutoff value.
;
; EXAMPLES:
;       Compute the probability that a random variable X, from the
;       standard Gaussian (Normal) distribution, is less than or equal 
;       to 2.44. The result should be 0.992656
;         result = gauss_pdf(2.44)
;
;       Compute the probability that a random variable X, from the 
;       standard Gaussian (Normal) distribution, is less than or equal 
;       to 10.0 and greater than or equal to 2.0. The result should be
;       0.0227501 [i.e. Probability(2.0 <= X <= 10.0)]
;         result = gauss_pdf(10.0) - gauss_pdf(2.0)
;
;       Compute the probability that a random variable X, from the 
;       Gaussian (Normal) distribution with a mean of 0.8 and a variance 
;       of 4.0, is less than or equal to 2.44. The result should be 
;       0.793892
;         result = gauss_pdf( (2.44 - 0.80)/sqrt(4.0) )
;
; PROCEDURE:
;       GAUSS_PDF calls GAUSSINT() to evaluate the Gaussian integral.
;       This function was included to provide consistency with the 
;       other probability functions: CHISQR_PDF(), F_PDF(), and T_PDF().
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Written by:   GGS, RSI, July 1994
;-

function gauss_pdf, v

  on_error, 2  ;Return to caller if error occurs.
  return, gaussint(v)

end
; $Id: gethelp.pro,v 1.2 1994/04/28 21:46:47 idl Exp $
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;
;+
; NAME:
;	 GETHELP
;
; PURPOSE:
;	This function is used to get information on variables in the 
;	routine that called this function. The function builts a string array
;	that contains information that follows the format that is used
;	by the IDL HELP command. 
;
; CATEGORY:
;	Help
;
; CALLING SEQUENCE:
;	Result = GetHelp([Vname])
;
; INPUTS:
;	Vname:	Optional parameter that contains the name of a variable
;		the user wants information about.
;
; KEYWORD PARAMETERS:
;	ONELINE:	If a variable name is greater than 15 charaters
;			it is usally returned as 2 two elements of the
;			output array (Variable name in 1st element, 
;			variable info in the 2nd element). Setting this 
;			keyword will put all the information in one string,
;			seperating the name and  data with a space.
;
;	FULLSTRING:	Normally a string that is longer than 45 chars
;			is truncated and followed by "..." just like 
;			the HELP command. Setting this keyword will cause
;			the full string to be returned.
;
;	PROCEDURES:	Setting this keyword will cause the function
;			to return all current IDL compiled procedures.
;
;	FUNCTIONS:	Setting this keyword will cause the function
;			to return all current IDL compiled functions.
;
;	SYS_PROCS:	Setting this keyword will cause the function
;			to return the names of all IDL system (built-in)
;			procedures.
;
;	SYS_FUNCS:	Setting this keyword will cause the function
;			to return the names of all IDL system (built-in)
;			functions.
;
; OUTPUTS:
;	This function returns a string array that normally contains
;	variable data that is in the same format as used by the IDL HELP
;	procedure. The variables in this list are for the routine that
;	called GetHelp(). If other info is requested via keywords, this
;	data is returned.
;
;	Upon an error or if no data is found the function returns an 
;	Null ('') string. 
;
; COMMON BLOCKS:
;	None
;
; SIDE EFFECTS:
;	None
;
; RESTRICTIONS:
;	Due to the diffuculties in determining if a variable is of type
;	associate, the following conditions will result in the variable 
;	being listed as a structure. These conditions are:
;
;	 	o Associate record type is structure.
;		o Associated file is opened for update (openu).
;		o Associate file is not empty.
;
;       Another difference between this routine and the IDL help command
;	is that if a variable is in a common block, the common block name 
;	is not listed next to the variable name. Currently there is no
;	method available to get the common block names used in a routine.
;
; PROCEDURE:
;	This function uses the IDL routine Routine_Names() to get the 
;	names and values of the variables contained in the calling 
;	routine. These values are then placed in a string array using
;	the format of the IDL HELP command. If there are no variables
;	in the calling routine, a null ('') scalar string is returned.
;
; EXAMPLE:
;	To obtain a listing in a help "format" of the variables contained
;	in the current routine you would make the following call:
;
;		HelpData = GetHelp()
;
;	The variable HelpData would be a string array containing the 
;	requested information.
;
; MODIFICATION HISTORY:
;	Initial Coding  April 1994	- KDB
;
;-
;
;=============================================================================

   FUNCTION IS_ASSOC, Unit

; PURPOSE:
;	This function is used to determine if an IDL variable is a
;	Assoc() file variable. This function is needed since there is no
;	built in method for a program to determine if a variable is an
;	associated variable.
;
; OPERATION:
;	This functions depends on several properities of an associate 
;	variable to determine if a variable is one. These properties are:
;
;	   o Size indicates that an associate variable is an array
;	   o N_Elements always returns one for an associate variable
;	   o ON_IOERROR will trap I/O errors that happen during associate
;	     file operations.
;	   o The following command will result in a scalar for a normal
;	     array, an array for an associate variable:
;		 DUM = Var(0)
;	  
; RESTRICTIONS:
;	Due to the diffuculties in determining if a variable is of type
;	associate, the following conditions will result in this function 
;	returning a false. These conditions are:
;
;	 	o Associate record type is structure.
;		o Associated file is opened for update (openu).
;		o Associate file is not empty.
;
; Start by getting the size of the input parameter

  UnitSize = Size(Unit)

; All Assocs are arrays and N_Elements() only returns 1. Check if this 
; variable is a scalar or N_elements() > 1.

  if((UnitSize(0) eq 0)or(N_Elements(Unit) gt 1))then $
     Return, 0  ; no need to continue

; Set up Error handling for input/ouput. This will catch any errors I/O we
; cause with associate variables. This function depends on this trapping.

  On_IOerror, IOERR

; Set the first element of Unit equal to itself. If Unit is an array we
; will continue processing, but if Unit is an associate variable and the 
; file is not open for "update" we will trigger an error which is trapped
; by on_ioerror.

  Unit(0) = Unit(0)

; A single diminsion array would of passed the above test, see if we
; can get the first value of Unit.

  DumVal = Unit(0)
  
; Get the Size of DumVal

  DumSize = Size(DumVal)

; If DumVal is a scalar (So Unit was a 1 dim array) or if DumVal is a 
; struct (so Unit is a struct or assoc to a struct record opened for update)
; return a false.

  if((DumSize(0) eq 0)or(DumSize(N_Elements(DumSize)-2) eq 8))then $
    Return, 0

; The only type of variable that should get here is an associate variable.
; Get the file information for this variable

   UnitStat = Fstat(Unit)

; Make sure that the file is not a tty or has no name

  if((UnitStat.IsAtty eq 1)or(UnitStat.Name eq ''))then  $
       return,0     ;not an assoc

; Anything that gets below this point is an associate variable 

IOERR:

  Return, 1  ; it is an assoc() variable

END

;=============================================================================

 FUNCTION MakeHelpString, Vname, Vvalue, Vsize, ASSOC = ASSOC, $
	 		  ONELINE=ONELINE, FULLSTRING=FULLSTRING

; PURPOSE:
;	This function takes information about a variable and creates
;	a string that contains this information following the IDL HELP
;	format.
;
; INPUTS:
;	Vname:		The name of the Variable
;	Vvalue:		The actual value of the variable
;	Vsize;		The results of the Size() function on Vvalue
;
; KEYWORD PARAMETERS:
;	ASSOC:		Indicates that the variable is an Associate 
;			variable
;	
;	ONELINE:	If a variable name is greater than 15 charaters
;			it is usally returned as 2 a two element array 
;			(Variable name in 1st elements, Variable info
;			in the 2nd element). Setting this keyword
;			will put all the information in one string.
;
;	FULLSTRING:	Normally a string that is longer than 45 chars
;			is truncated and followed by "..." just like 
;			the HELP command. Setting this keyword will cause
;			the full string to be returned.
;
; OUTPUTS:
;	This function returns a string(s) that is in a HELP command format
;	for the given information. A 2 element string array is returned if
;	the Variable name (Vname) is longer that 15 characters and the
;	ONELINE keyword is not set.
;
; Declare the TypeTokens

  TypeTokens = [ 'UNDEFINED', 'BYTE', 'INT', 'LONG', 'FLOAT', $
		 'DOUBLE', 'COMPLEX', 'STRING', 'STRUCT']

  Vtype = Vsize(N_Elements(Vsize)-2) ; Get the type of variable

; See if the variable is not an array (a Scalar or an Undef).

  if( Vsize(0) eq 0 )then BEGIN
   
  ; If the Value is a string we need to put '' around it and add ... to it
  ; if it is longer than 45 chars

    if(Vtype eq 7)then BEGIN

       if( (StrLen(Vvalue) gt 45)and(not Keyword_Set(FULLSTRING)))then  $
	   ValueField = "'" + StrMid(Vvalue, 0, 45) + "'..."  	        $
       else		$
	   ValueField = "'" + Vvalue +"'"

    ENDif else if(Vtype eq 1)then  $  
    ;  have a byte, cant just string it, use integer format code 

       ValueField = String(Vvalue, FORMAT='(I4)')	$

    else	$   ;not a string or a byte, just do a String() to the value

       ValueField = String(Vvalue)      

  ENDif else     $                           
  ;  We have an array, convert the diminsions of the array to strings
  ;  The format statement has a repeat value of 20. Should only need up
  ;  to 8 (the max number of dimensions, but doesnt hurt to have a little
  ;  extra just incase this changes later on.

     ValueField= String( StrCompress(Vsize(1:Vsize(0)), /REMOVE_ALL), $
		        FORMAT = '("Array(",20(a, :, ", ") )' ) +")"

; Now check out the Assoc() variable possibility

  if(Keyword_Set(ASSOC))then BEGIN

  ;  Need to get the filename associated with the variable. Fstat() it.

     StatStruc = Fstat(Vvalue)
  
  ;  An Assoc() can be done on a file that is not open. See if the 
  ;  name is null. If file is closed (name =''), put in HELP closed message

     if(StatStruc.Name eq '')then             $
	StatStruc.Name = "Closed file unit "+ $
		StrCompress(StatStruc.Unit, /REMOVE_ALL)

     ValueField = "File<"+StatStruc.Name+"> "+ValueField

  ENDif

; Is the data a structure?

  if(Vtype eq 8)then 				$
  ;  Add the struct symbol and name to Value Field
     
     ValueField = "-> " + Tag_Names(Vvalue, /STRUCTURE_NAME)+ " " + $
	          ValueField
    
; Now lets build the line and return it. Check for long identifiers

  if( StrLen(Vname) gt 15)then BEGIN
  ;  We have a long indentifier. See if the user want the line on one line
  ;  or 2
   
     if(Keyword_Set(ONELINE))then 				$
	Return, Vname + String(TypeTokens(Vtype), ValueField, 	$
			FORMAT='(" ", A, T11,"= ", A)' )  	$
     else							$
	Return, [Vname, String(TypeTokens(Vtype), ValueField,   $
			FORMAT='(T16," ", A,T27,"= ", A)' )] 
  ENDif 

; Variable name must be < 15 chars. Just return the old fashioned type 
; of listing

  Return, String(Vname, TypeTokens(Vtype), ValueField,$
		 FORMAT= '(A,T16," ", A,T27,"= ", A)' )

END
;=============================================================================

  FUNCTION Gethelp, Uservar, ONELINE=ONELINE, PROCEDURES=PROCEDURES, $
		   FUNCTIONS = FUNCTIONS, SYS_PROCS=SYS_PROCS,       $
		   SYS_FUNCS=SYS_FUNCS, FULLSTRING=FULLSTRING

; PURPOSE:
;	This function is used to get information on variables in the 
;	routine that called this function. The function builts a string array
;	that contains information that follows the format that is 
;	printed out by the IDL HELP command. 
;
; CALLING SEQUENCE:
;	Result = GetHelp([Vname])
;
; INPUTS:
;	Vname:	Optional parameter that contains the name of a variable
;		the user wants information about.
;
; KEYWORD PARAMETERS:
;	ONELINE:	If a variable name is greater than 15 charaters
;			it is usally returned as 2 two elements of the
;			output array (Variable name in 1st elements, 
;			Variable info in the 2nd element). Setting this 
;			keyword will put all the information in one string,
;			seperating the name and  data with a space.
;
;	FULLSTRING:	Normally a string that is longer than 45 chars
;			is truncated and followed by "..." just like 
;			the HELP command. Setting this keyword will cause
;			the full string to be returned.
;
;	PROCEDURES:	Setting this keyword will cause the function
;			to return all current IDL compiled procedures.
;
;	FUNCTIONS:	Setting this keyword will cause the function
;			to return all current IDL compiled functions.
;
;	SYS_PROCS:	Setting this keyword will cause the function
;			to return the names of all IDL system (built-in)
;			procedures.
;
;	SYS_FUNCS:	Setting this keyword will cause the function
;			to return the names of all IDL system (built-in)
;			functions.
;
; OUTPUTS:
;	This function returns a string array that normally contains
;	variable data that is in the same format as used by the IDL HELP
;	procedure. The variables in this list are for the routine that
;	called GetHelp(). If other info is requested via keywords, this
;	data is returned.
;
;	Upon an error the function returns an Null ('') string. 
;
;
; See if the user just wants the names of routines or functions:

  if(Keyword_Set(PROCEDURES))then  $
     Return, Routine_Names(PROCEDURES=-1)
 
  if(Keyword_Set(FUNCTIONS))then   $
     Return, Routine_Names(FUNCTIONS=-1 )

; See if the user wants the system procedure names

  if(Keyword_Set(SYS_PROCS))then   $
     Return, Routine_Names(S_PROCEDURES=-1)

; And now check for system functions

  if(Keyword_Set(SYS_FUNCS))then   $
     Return, Routine_Names(S_FUNCTIONS=-1)

; Start by getting the variable names for the calling procedure

  VarNames = Routine_Names(VARIABLES=-1)

; See if we got any variables. 

  NumVars = N_Elements(VarNames) ; number of variables 

  if( NumVars eq 1)then $
     if(VarNames(0) eq '')then $
	Return,''		;No Variables, Why continue?

; Check for a parameter

  if(N_Params() eq 1)then BEGIN

  ; The user wants the help value for just one variable, See if it 
  ; is in the list of valid variables.

    Vindx = Where(StrUpcase(UserVar) eq VarNames, Vcnt)

    if(Vcnt eq 1)then BEGIN

    ; Just place this variable in place of the found variables

      VarNames = VarNames(Vindx)
      NumVars = 1

    ENDif else Return,''  ; not a valid variable

  ENDif

; Initialize the value of OutText. Check for long parameters.
; For each long parameter ( >15 chars), add a line to the OutText Array. 
; Only check this is if keyword ONELINE is set.

  LongCnt = 0
  if( not KeyWord_Set(ONELINE))then $
      tmp = Where(StrLen(VarNames) gt 15, LongCnt)
  
  OutText = Strarr(NumVars + LongCnt )
  OutCnt = 0 & tmp = 0

; Now loop though each variable, get its value, format its help string and
; place the string into the OutText array.

  for i=0, NumVars-1 do BEGIN

  ;  Get the *size* of the variable value. This will also handle udefs.

     VarSize = Size(Routine_Names( VarNames(i), FETCH=-1) )

  ;  If the variable is not of type undefined, get its value

     if( VarSize(N_Elements(VarSize)-2) ne 0 )then 		$ ;not undef
	VarValue = Routine_Names( VarNames(i), FETCH=-1 ) 	$
     else 							$
	VarValue = '<Undefined>'   ;From help output

  ;  See if the variable is an Assoc() variable. If the variable is 
  ;  an array or struct it might be.

     if( VarSize(0) gt 0 )then        $  ;not undefined and not a scalar
        ASSOC = IS_ASSOC( VarValue )  $  ; ? is it an Assoc()
     else		              $
        ASSOC = 0	;no an associate variable

  ;  Now send the variable name, value and size to MakeHelpString

     TmpTxt = MakeHelpString(VarNames(i), VarValue, VarSize, $
	      ASSOC=ASSOC, ONELINE=ONELINE, FULLSTRING=FULLSTRING ) 

  ;  Place the results in OutText
  ;  Could use [ ] to append, but with large arrays this can be slow.

     OutText(OutCnt) = TmpTxt   ; overload index if need be (TmpTxt is 2 el.)
     OutCnt = OutCnt + N_Elements(TmpTxt)

  ENDfor

; That should be it, return the array.

  Return, OutText

END


















;$Id: gs_iter.pro,v 1.4 1994/04/28 18:20:26 doug Exp $
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       GS_ITER
;
; PURPOSE:
;       This function solves an n by n linear system of equations
;       using Gauss-Seidel iteration.
;
; CATEGORY:
;       Linear Algebra.
;
; CALLING SEQUENCE:
;       Result = GS_ITER(A, B)
;
; INPUTS:
;       A:      An N by N array of type: int, float, or double.
;
;       B:      An N-element vector of type: int, float, or double.
;
; KEYWORD PARAMETERS:
;       CHECK:    An integer value of 0 or 1 that denies or requests
;                 checking A for a diagonally dominant form.
;                 CHECK = 0 (the default) results in no checking.
;                 CHECK = 1  Checks A and reports if it does not
;                            meet the required condition. This is
;                            just a warning. The algorithm will
;                            proceed on the chance it may converge.
;
;       LAMBDA:   A scalar value in the range: [0.0, 2.0]
;                 This value determines the amount of 'RELAXATION'.
;                 Relaxation is a weighting technique that is used
;                 to enhance convergence.
;                 1) LAMBDA = 1.0 (the default) no weighting.
;                 2) A value in the range  0.0 <= LAMBDA < 1.0  improves
;                    convergence in oscillatory and non-convergent systems.
;                 3) A value in the range  1.0 < LAMBDA <= 2.0  improves
;                    convergence in systems known to converge.
;
;       MAX_ITER: The maximum number of iterations allowable for the
;                 algorithm to converge to the solution. The default 
;                 is 30 iterations.
;         
;       X_0:      An N-element vector that provides the algorithm's 
;                 starting point. The default is [1.0, 1.0, ... , 1.0].       
;
;       TOL:      The relative error tolerance between current and past
;                 iterates calculated as:  ABS( (current-past)/current )
;                 The default is 1.0e-4.
;
; SIDE EFFECTS:
;       Upon output A and B are divided by the diagonal elements of A.
;       Integer inputs are converted to floats.
;
; RESTRICTIONS:
;       The equations must be entered in a DIAGONALLY DOMINANT form
;       to guarantee convergence.
;       A system is diagonally dominant if it satisfies the condition:
;                   abs(A(row,row)) > SUM(abs(A(row,col)))
;       where SUM runs col=1,N excluding col = row and A is in row major.
;       This restriction on A is known as a sufficient condition. That is,
;       it is sometimes possible for the algorithm to converge without the
;       condition being satisfied. But, convergence is guaranteed if the
;       condition is satisfied.
;
; EXAMPLE:
;       Define an array (a) in a non-diagonally dominant form.
;         a = [[ 1.0,  7.0, -4.0], $
;              [ 4.0, -4.0,  9.0], $
;              [12.0, -1.0,  3.0]]
;       And right-side vector (b).
;         b = [12.0, 2.0, -9.0]
;       Compute the solution of the system, ax = b.
;         result = gs_iter(a, b)
;       Note: This example fails to converge, because A is not in
;             diagonally dominant form.
;
;       Reorder the array given above into diagonally dominant form.
;         a = [[12.0, -1.0,  3.0], $
;              [ 1.0,  7.0, -4.0], $
;              [ 4.0, -4.0,  9.0]]
;       Make corresponding changes in the ordering of b.
;         b = [-9.0, 12.0, 2.0]
;       Compute the solution of the system, ax = b.
;         result = gs_iter(a, b)
;
; PROCEDURE:
;       GS_ITER.PRO implements the Gauss-Seidel iterative method with
;       over- and under- relaxation to enhance convergence.
;     
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, April 1993
;       Modified:    GGS, RSI, February 1994
;                    1) Format keyword is no longer supported. The matrix
;                       should be supplied in a row major format. 
;                    2) The input/output parameter X has been removed. The 
;                       algorithm's initial starting point is an n-element
;                       vector of 1s. The keyword X_0 has been added to 
;                       override the default.
;                    3) GS_ITER is now called as a function, x = gs_iter( ). 
;-

function GS_ITER, a, b, check = check, lambda = lambda, max_iter = max_iter, $
                        x_0 = x_0, tol = tol

  on_error, 2 ;Return to caller if error occurs.

  dim = size(a)
  if dim(1) ne dim(2) then $
    message, 'Input matrix is not square.'

  ;If inputs are not float or double convert to float.
  if dim(3) ne 4 and dim(3) ne 5 then $
    a = a + 0.0  &  b = b + 0.0 

  ; set default values for keyword parameters
  if keyword_set(lambda)   eq 0 then lambda = 1.0
  if keyword_set(max_iter) eq 0 then max_iter = 30
  if keyword_set(x_0)      eq 0 then x_0 = replicate(1.0, dim(1))
  if keyword_set(tol)      eq 0 then tol = 1.0e-4

  ;Diagonal elements of input matrix.
  diag = a(indgen(dim(1)) * (dim(1)+1))

  if keyword_set(check) ne 0 then begin
    sum = total(abs(a), 1) - abs(diag)
    caution = where(sum ge abs(diag), count)
    if count ne 0 then begin
      print, 'Input matrix is not in Diagonally Dominant form.' & $
      print, 'Algorithm may not converge.'
    endif
  endif

  ;Precondition inputs.
  ;Divide A and B by the diagonal elements of A.
  a = a / (replicate(1, dim(1)) # diag)
  b = b / diag

  cond = 0
  iter = 0

  ;Begin the computational loop and continue WHILE
  ;the number of iterations is less than max_iter
  ;AND the relative error between iterations is
  ;greater than tol.
  while(iter lt max_iter and cond eq 0) do begin
    cond = 1
    iter = iter + 1
  ;Formulate x_0 as the row vectors of A.
  for k = 0, dim(1)-1 do begin
    x_last = x_0(k)
    x_0(k) = lambda * (b(k) - (total(x_0*a(*,k),1)) + (a(k,k) * x_0(k))) + $
             (1.0 - lambda) * x_last
    if cond eq 1 and x_0(k) ne 0.0 then begin
      error = abs((x_0(k) - x_last) / x_0(k))
      if error gt tol then cond = 0
    endif
  endfor
  endwhile

  if iter ge max_iter and cond eq 0 then $
    message, 'Algorithm failed to converge within given parameters.'

  return, x_0

end



;	$Id: hanning.pro,v 1.2 1994/01/17 18:10:21 dave Exp $
function Hanning, N1, N2, Alpha=alpha ;1D or 2D Hanning/Hamming window function
;+
; NAME:
;	HANNING
;
; PURPOSE:
;	Window function for Fourier Transform filtering.  May be used
;		for both the Hanning and Hamming windows.
;
; CATEGORY:
;	Signal, image processing.
;
; CALLING SEQUENCE:
;	Result = HANNING(N1) ;For 1 dimension.
;
;	Result = HANNING(N1, N2) ;For 2 dimensions.
;
; INPUTS:
;	N1:	The number of columns of the result.
;
;	N2:	The number of rows of the result.
;
; Keyword Parameters:
;	Alpha = width parameter of generalized Hamming window.  Alpha
;		must be in the range of 0.5 to 1.0.  If Alpha = 0.5,
;		the default, the function is called the "Hanning" window.
;		If Alpha = 0.54, the result is called the "Hamming" window.
;
; OUTPUTS:
;	Result(i) = 1/2 [1 - COS(2 PI i / (N-1)]
;
;	For two dimensions, the result is the same except that "i" is replaced
;	with "i*j", where i and j are the row and column subscripts.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	DMS, May, 1987.
;	DMS, Jan, 1994. Added generalized width parameter.
;-

on_error,2                              ;Return to caller if an error occurs
if N_elements(alpha) le 0 then alpha = 0.5
a = 2 * !pi / (N1 -1)			;scale factor
If n_params(0) eq 1 then begin		;1d?
	return, (alpha-1.) * cos(findgen(N1)*a) + alpha
   endif else begin			;2d case
	b = 2 * !pi / (n2-1)		;dim 2 scale fact
	row = (alpha-1.) * cos(findgen(n1)*a) + alpha ;One row
	col = (alpha-1.) * cos(findgen(n2)*b) + alpha ;One column
	RETURN,(row # col)
   endelse
end
;
; Copyright (c) 1992, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	HDF_EXISTS
;
; PURPOSE:
;	Test for the existence of the HDF library
;
; CATEGORY:
;	File Formats
;
; CALLING SEQUENCE:
;	Result = HDF_EXISTS()
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	Returns TRUE (1) if the HDF data format library is
;	supported. Returns FALSE(0) if it is not.
;
; EXAMPLE:
;	IF hdf_exists() EQ 0 THEN Fail,"HDF not supported on this machine"
;
; MODIFICATION HISTORY
;	Written by:	Joshua Goldstein,  12/21/92
;
;-

;	A fake function if libraries don't exist
FUNCTION dfp_npals,x
	return,1
END

;
FUNCTION hdf_exists
	exists=0

	x=dfp_npals('.');
	if x LE 0 THEN return,1
	return,0
END
; $Id: h_eq_ct.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro h_eq_ct, image	;Histogram equalize color tables from image
;+
; NAME:
;	H_EQ_CT
;
; PURPOSE:
;	Histogram-equalize the color tables for an image or a region
;	of the display.
;
; CATEGORY:
;	Image processing.
;
; CALLING SEQUENCE:
;	H_EQ_CT, Image	;To histogram equalize from an image.
;	H_EQ_CT		;To histogram equalize from a region
;
; INPUTS:
;	Image:	Image whose histogram is to be used in determining
;		the new color tables.  If this value is omitted, the user 
;		is prompted to mark the diagonal corners of a region of the 
;		display.
;
;		Image MUST be a byte image, scaled the same way as
;		the image loaded to the display.
;
; OUTPUTS:
;	No explicit outputs.  The result is applied to the current color
;	tables.
;
; COMMON BLOCKS:
;	COLORS:	The IDL color table common block.
;
; SIDE EFFECTS:
;	The current color table is modified.
;
; RESTRICTIONS:
;	If a parameter is supplied, it is assumed to be an image that
;	was just displayed.
;
; PROCEDURE:
;	Either the image parameter or the region of the display marked by
;	the user is used to obtain a pixel-distribution histogram.  The
;	cumulative integral is taken and scaled.  This function is applied
;	to the current color tables.
;
; MODIFICATION HISTORY:
;	DMS, March, 1988, written.
;	DMS, May, 1990, added BOX_CURSOR.
;	AB, 21 September 1992,renamed from HIST_EQUAL_CT to H_EQ_CT to
;		avoid DOS filename limitations. HIST_EQUAL_CT is still
;		available as a wrapper to this routine under operating
;		systems that can handle longer file names.
;-

common colors,r,g,b,cur_red,cur_green,cur_blue

on_error,2                      ;Return to caller if an error occurs
nc = !d.table_size	;# of colors in device
if nc eq 0 then message, 'Device has static color tables, Can''t adjust'
if n_elements(image) gt 0 then h = histogram(image) $
	else begin
	box_cursor, x0, y0, xs, ys, /message
	h = histogram(tvrd(x0, y0, xs, ys))
	endelse
for i=1,n_elements(h)-1 do h(i) = h(i)+h(i-1)
h = long(bytscl(h, top = nc-1))
if n_elements(r) le 0 then begin	;color tables defined?
	r=indgen(nc) & g=r & b=r & endif
cur_red = r(h) & cur_green = g(h) & cur_blue = b(h)
tvlct,cur_red, cur_green, cur_blue
return
end

; $Id: h_eq_int.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro h_eq_int, image	;Histogram equalize color tables from image
;+
; NAME:
;	H_EQ_INT
;
; PURPOSE:
;	Interactively histogram-equalize the color tables of an image
;	or a region of the display.  By moving the cursor across
;	the screen, the amount of histogram equalization is varied.
;
; CATEGORY:
;	Image processing.
;
; CALLING SEQUENCE:
;	H_EQ_INT, Image		;To histogram equalize from an image.
;	H_EQ_INT		;To histogram equalize from a region.
;
; INPUTS:
;	Image:	The image whose histogram is to be used in determining
;		the new color tables.  If this value is omitted, the user 
;		is prompted to mark the diagonal corners of a region of the 
;		display.
;
;		Image MUST be a byte image, scaled the same way as
;		the image loaded to the display.
;
; OUTPUTS:
;	No explicit outputs.  The result is applied to the current color
;	tables.
;
; COMMON BLOCKS:
;	COLORS:	The IDL color table common block.
;
; SIDE EFFECTS:
;	The current color table is modified.
;
; RESTRICTIONS:
;	If a parameter is supplied, it is assumed to be an image that
;	was just displayed.
;
; PROCEDURE:
;	Either the image parameter or the region of the display marked by
;	the user is used to obtain a pixel-distribution histogram.  The
;	cumulative integral is taken and scaled.  This function is applied
;	to the current color tables.
;
;	A window is created and the histogram equalization function is 
;	plotted.
;
;	A linear ramp is overplotted.  Move the cursor from left
;	to right to vary the amount of histogram equalization applied to the 
;	color tables from 0 to 100%.  Press the right mouse button to exit.
;
; MODIFICATION HISTORY:
;	DMS, November, 1989, written.
;	AB, 21 September 1992,renamed from HIST_EQUAL_INT to H_EQ_INT to
;		avoid DOS filename limitations. HIST_EQUAL_INT is still
;		available as a wrapper to this routine under operating
;		systems that can handle longer file names.
;	JWG, 14 December 1992,routine did not restore font.
;-

common colors,r,g,b,cur_red,cur_green,cur_blue

on_error,2                      ;Return to caller if an error occurs
nc = !d.table_size	;# of colors in device
if nc eq 0 then message, 'Device has static color tables, Can''t adjust'
if n_elements(image) gt 0 then h = histogram(image) $
	else begin
	print,'Mark opposite corners of area of interest:'
	tvrdc,x,y,/dev,1	;one corner
	wait,.5			;Necessary for fast machines
	tvrdc,x1,y1,/dev,1
	x0 = x < x1
	y0 = y < y1
	x1 = x > x1
	y1 = y > y1
	h = histogram(tvrd(x0,y0,x1-x0+1, y1-y0+1))
	endelse
h(0) = 0		;For 0 backgrounds
for i=1,n_elements(h)-1 do h(i) = h(i)+h(i-1)
h = long(bytscl(h, top = nc-1))

old_window = !d.window
window,xs=400, ys=300,title='Histogram Equalization',/free
plot,h
oplot,[0,nc-1],[0,nc-1]
tvcrs,.5,.5,/norm

!err = 0
fact = 0.0
oldy = findgen(nc)
oldfact = 0.0
x = findgen(nc)
if n_elements(r) le 0 then begin	;color tables defined?
	r=indgen(nc) & g=r & b=r & endif
oldfont = !p.font
!p.font = 0
oldfacts = string(oldfact,format='(f5.3)')+' equalized'
xyouts,.1,.95,/norm,oldfacts

while !err ne 4 do begin
	tvrdc,xx,yy,2		;wait for movement
	fact = float(xx)/nc < 1.0 > 0.0
	if fact ne oldfact then begin
;		oplot,x,oldy,psym=3,color=0	;Erase old
		oldy = long(fact * h + (1.-fact) * x)
;		oplot,x,oldy,psym=3
		cur_red = r(oldy) & cur_green = g(oldy) & cur_blue = b(oldy)
		tvlct,cur_red, cur_green, cur_blue
		xyouts,.1,.95,/norm, oldfacts, col=0
		oldfacts = string(oldfact,format='(f5.3)')+' equalized'
		xyouts,.1,.95,/norm,oldfacts
		oldfact = fact
		endif
	endwhile
wdelete
!p.font = oldfont
wset,old_window
return
end

;+
; NAME:
;	HILBERT
;
; PURPOSE:
;	Return a series that has all periodic terms shifted by 90 degrees. 
;
; CATEGORY:
;	G2 - Correlation and regression analysis
;	A1 - Real arithmetic, number theory.
;
; CALLING SEQUENCE:
;	Result = HILBERT(X [, D])
;
; INPUT:
;	X:	A floating- or complex-valued vector containing any number 
;		of elements.
;
; OPTIONAL INPUT:
;	D:	A flag for rotation direction.  Set D to +1 for a 
;		positive rotation.  Set D to -1 for a negative rotation.
;		If D is not provided, a positive rotation results.
;
; OUTPUTS:
;	Returns the Hilbert transform of the data vector, X.  The output is 
;	a complex-valued vector with the same size as the input vector.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	HILBERT uses FFT() so this procedure exhibits the same side 
;	effects with respect to input arguments as that function.
;
; PROCEDURE:
;	A Hilbert transform is a series	that has had all periodic components 
;	phase-shifted by 90 degrees.  It has the interesting property that the 
;	correlation between a series and its own Hilbert transform is 
;	mathematically zero.
;
;	The method consists of generating the fast Fourier transform using 
;	the FFT() function and shifting the first half of the transform 
;	products by +90 degrees and the second half by -90 degrees.  The 
;	constant elements in the transform are not changed.
;
;	Angle shifting is accomplished by multiplying or dividing by the 
;	complex number, I=(0.0000, 1.0000).  The shifted vector is then
;	submitted to FFT() for transformation back to the "time" domain and the
;	output is divided by the number elements in the vector to correct for
;	multiplication effect peculiar to the FFT algorithm.  
;
; REVISION HISTORY:
;	JUNE, 1985,	Written, Leonard Kramer, IPST (U. of Maryland) on site
;			contractor to NASA(Goddard Sp. Flgt. Cntr.)
;-
	FUNCTION HILBERT,X,D   ; performs the Hilbert transform of some data.
	ON_ERROR,2           ; Return to caller if an error occurs
	Y=FFT(X,-1)	     ; go to freq. domain.
	N=N_ELEMENTS(Y)
	I=COMPLEX(0.0,1.0)
	IF N_PARAMS(X) EQ 2 THEN I=I*D
	N2=N/2-1	     ; effect of odd and even # of elements 
			     ; considered here.
	Y(1)=Y(1:N2)*I       ; multiplying by I rotates counter c.w. 90 deg.
	N2=N-N2
	Y(N2)=Y(N2:N-1)/I
	Y=FFT(Y,1)  ; go back to time domain
	RETURN,Y
END
; Copyright (c) 1992, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
function hist_2d, im1, im2
;+
; NAME:
;	HIST_2D
;
; PURPOSE:
;	Return the density function (histogram) of two variables.
;
; CATEGORY:
;	Image processing, statistics, probability.
;
; CALLING SEQUENCE:
;	Result = hist_2d(V1, V2)
; INPUTS:
;	V1 and V2 = arrays containing the variables.  They must be
;		of byte, integer, or longword type, and contain
;		no negative elements.
;
; OUTPUTS:
;	The two dimensional density function of the two variables,
;	a longword array of dimensions (MAX(v1)+1, MAX(v2)+1).  Result(i,j)
;	is equal to the number of sumultaneous occurences of V1 = i,
;	and V2 = j, at the same element.
;	
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:
;	None.
; RESTRICTIONS:
;	Data must be in byte, integer, or longword form.  To use with
;	floating point data, scale into the range of integers.
;
; PROCEDURE:
;	Creates a combines array from the two variables, equal to the
;	linear subscript in the resulting 2D histogram, then applies
;	the standard histogram function.
;
;	The following pseudo-code shows what the result contains,
;	not how it is computed:
;		r = LONARR(MAX(v1)+1, MAX(v2)+1)  ;Result
;		FOR i=0, N_ELEMENTS(v1)-1 DO $
;		  r(v1(i), v2(i)) = r(v1(i), v2(i)) +1

; EXAMPLE:
;	Return the 2D histogram of two byte images:
;		R = HIST_2D(image1, image2)
;	Return the 2D histogram made from two floating point images
;	with range of -1 to +1, and with 100 bins:
;		R = HIST_2D(long((f1+1) * 50), long((f2+1) * 50))
;
; MODIFICATION HISTORY:
; 	Written by:
;	DMS, Sept, 1992		Written
;-

; Form the 2 dimensional histogram of two byte, integer, or longword
;  images.  They must not contain negative numbers.
; Result(i,j) = density of pixel value i in im1, and pixel value j
;	in im2.
; Input images must be, of course, the same size....
;

s1 = size(im1)		;Check types
s2 = size(im2)
if (s1(s1(0)+1) gt 3) or (s2(s2(0)+1) gt 3) then $
	message, 'Arrays must be byte, integer, or longword'


m1 = max(im1, min=mm1)+1L	;Get size of resulting rows / columns
m2 = max(im2, min=mm2)+1L
if mm1 lt 0 or mm2 lt 0 then message,'Arrays contain negative elements'

sum = m1 * im2 + im1		;Combine with im1 in low part & im2 in high
h = histogram(sum, min = 0, max= m1 * m2 -1)  ;Get the 1D histogram
return, reform(h, m1, m2, /overwrite) ;and make it 2D
end
FUNCTION HIST_EQUAL, A, BINSIZE = binsize, MAXV = MAXV, MINV = MINV, $
	TOP = top, HISTOGRAM_ONLY=histogram_only
;
;+
; NAME:
;	HIST_EQUAL
;
; PURPOSE:
;	Return a histogram-equalized image or vector.
;
; CATEGORY:
;	Z1 - Image processing, spatially invariant.
;
; CALLING SEQUENCE:
;	Result = HIST_EQUAL(A [, MINV = minv] [, MAXV = maxv])
;
; INPUTS:
;	A:	The array to be histogram-equalized.
;
; KEYWORD PARAMETERS:
;     BINSIZE:	Size of bin to use.  If this keyword is omitted, the value 1
;		is used.  Ignored for byte type data.  Default = approx 5000
;		bins.
;
;	HISTOGRAM_ONLY: If set, return the cumulative distribution histogram,
;		rather than the histogram equalized array.  MAXV, MINV, and
;		BINSIZE will be set, describing the scaling of the histogram,
;		if not specified.
;	MAXV:	The maximum value to consider.  If this keyword is omitted,
;		the maximum element is used.  Input elements greater than or
;		equal to MAXV are output as 255.
;
;	MINV:	The minimum value to consider.  If this keyword is omitted,
;		the minimum is computed. Input elements less than or equal
;		to MINV are output as zero.
;
;	TOP:	The maximum value to scale the output array. If this keyword 
;		is omitted, 255 is used.
;
; OUTPUTS:
;	A histogram-equalized byte array is returned.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	The output array is always of byte type and is scaled from 0 to TOP. 
;	Floating-point arrays should not have small ranges, (e.g., less than
;	around 255) unless a binsize is specified.
;
; PROCEDURE:
;	The HISTOGRAM function is used to obtain the density distribution of
;	the input array.  The histogram is integrated to obtain the 
;	cumulative density-propability function and finally the lookup 
;	function is used to transform to the output image.
;
;	The first element of the histogram is always zeroed, to remove
;	the background.
; EXAMPLE:
;	Create a sample image using the IDL DIST function and display it by
;	entering:
;
;		IMAGE = DIST(100)
;		TV, DIST
;	
;	Create a histogram-equalized version of the byte array, IMAGE, and
;	display the new version.  Use a minumum input value of 10, a maximum 
;	input value of 200, and limit the top value of the output array to 
;	220.  Enter:
;
;		NEW = HIST_EQUAL(IMAGE, MINV = 10, MAXV = 200, TOP = 220)
;		TV, NEW 
;
; MODIFICATION HISTORY:
;	August, 1982. Written by DMS, RSI.
;	Feb, 1988, Revised for Sun, DMS.
;	Dec, 1994. DMS. Improved handling offloating/double images with
;			large or small ranges.  Default value for MINV is
;			computed, rather than set to 0.
;-
;
	on_error,2                        ;Return to caller if an error occurs
	if n_elements(top) eq 0 then top = 255
	S = SIZE(A)		;Type of var?
	type = s(s(0)+1)
	If type eq 1 then begin	;byte var?
		if n_elements(binsize) le 0 then binsize = 1
		p = histogram(a, binsize = binsize)
		p(0)=0
		up = n_elements(p)-1	;max value
		if n_elements(minv) ne 0 then p(0:minv) = 0  $
		else minv = 0	
		if n_elements(maxv) ne 0 then begin
		    if up gt maxv then p(maxv:*)=0
		endif else maxv = up
		for i=1,up do p(i)=p(i)+p(i-1) ;integrate
		if keyword_set(histogram_only) then return, p
		P=bytscl(p,top=top)
		RETURN,P(A)			;Transform & return.
	   endif else begin
		if n_elements(maxv) le 0 then maxv = max(a, min=minv1)
		if n_elements(minv) le 0 then begin
		  if n_elements(minv1) eq 1 then minv = minv1 else minv = min(a)
		  endif
		if maxv le minv then $
		  message,'Image max is equal to min, or illegal range'
		if n_elements(binsize) eq 0 then begin	;Calc binsize?
		   if type le 3 then $
			binsize = CEIL((long(maxv)-long(minv)) / 5000.) > 1 $
		   else if type le 5 then $	;Floating or double
			binsize = (maxv-minv) / 5000. $
		   else message,'Complex images not allowed'
		   endif			;Binsize
		p = histogram(a, omin=minv, omax = maxv,bin=binsize)
		p(0) = 0
		for i=1L,n_elements(p)-1 do p(i)=p(i)+p(i-1) ;Cumul. integral
		if keyword_set(histogram_only) then return, p
		P=bytscl(p, top = top)
		if binsize eq 1 then begin
			if minv eq 0 then return,p(a) else RETURN,P(A-minv)
		endif else begin
		    if minv eq 0 then return, p(a/binsize) else $
		    return, P((a-minv)/binsize)
		endelse
	endelse
end

; $Id: hls.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Pro HLS, Litlo, Lithi, Satlo, Sathi, Hue, Loops, Colr
;+
; NAME:
;	HLS
;
; PURPOSE:
;	Make a color table based on the HLS (Hue, Lightness, Saturation) 
;	color system.
;
; CATEGORY:
;	Z4 - Image processing, color table manipulation
;
; CALLING SEQUENCE:
;	HLS, Litlo, Lithi, Satlo, Sathi, Hue, Loops [, Colr]
;
; INPUTS:
;	Litlo:	Starting lightness, from 0 to 100%.
;
;	Lithi:	Ending lightness, from 0 to 100%.
;
;	Satlo:	Starting saturation, from 0 to 100%.
;
;	Sathi:	Ending stauration, from 0 to 100%.
;
;	Hue:	Starting Hue, from 0 to 360 degrees.  Red = 0 degs,
;		green = 120, blue = 240.
;
; 	Loops:	The number of loops through the color spiral.  This 
;		parameter does not have to be an integer.  A negative value
;		causes the loops to traverse the spiral in the opposite 
;		direction.
;
; OUTPUTS:
;	No required outputs.
;
; OPTIONAL OUTPUT PARAMETERS:
;	Colr:	A (256,3) integer array containing the R, G, and B values
;		that were loaded into the color tables.
;		Red = colr(*,0), green = colr(*,1), blue = colr(*,2).
;
; COMMON BLOCKS:
;	COLORS:	Contains the red, green, and blue vectors on exit.
;
; SIDE EFFECTS:
;	The color tables are loaded.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Adapted from program on page 619, Fundamentals of Interactive
;	Computer Graphics, Foley and Van Dam.
;
;	Using the input parameters, a spiral through the double-
;	ended HLS cone is traced.  Points along the cone
;	are converted from HLS to RGB.
;
; MODIFICATION HISTORY:
;	Written, DMS, Jan, 1983.
;	Changed common block, dms, 4/1987.
;-
	common colors,red,green,blue,cur_red,cur_green,cur_blue
	on_error,2                      ;Return to caller if an error occurs
	S = (sathi-satlo)/25600.*findgen(256)+satlo/100.
	L = (Lithi-Litlo)/25600.*findgen(256)+litlo/100.
	HG = Loops*360./256.*findgen(256)+ Hue
	Hmin = Min(hg)/360.
	IF HMIN LT 0. THEN HMIN = FIX(HMIN)-1 ELSE $
		HMIN =FIX(HMIN)
	HG = (HG - Hmin*360.) mod 360.	;Make all positive
	HR = (HG +120) mod 360.
	HB = (HG +240) mod 360.
;
	N2 = (L LE .5)*(L+L*S) + (L GT .5)*(L+S-L*S)
	N1 = 2*L - N2
	N21 = (N2-N1)/60.
	COLR = FLTARR(256,3)
;
	FOR I=0,255 DO BEGIN		;What a mess.
	  IF S(I) EQ 0. THEN COLR(I,*)=L(I) ELSE BEGIN
		IF HR(I) LT 60. THEN COLR(I,0)=N1(I)+N21(I)*HR(I) ELSE $
		IF HR(I) LT 180. THEN COLR(I,0)=N2(I) ELSE $
		IF HR(I) LT 240. THEN COLR(I,0)=N1(I)+N21(I)*(240.-HR(I)) ELSE $
			COLR(I,0)=N1(I)
		IF HG(I) LT 60. THEN COLR(I,1)=N1(I)+N21(I)*HG(I) ELSE $
		IF HG(I) LT 180. THEN COLR(I,1)=N2(I) ELSE $
		IF HG(I) LT 240. THEN COLR(I,1)=N1(I)+N21(I)*(240.-HG(I)) ELSE $
			COLR(I,1)=N1(I)
		IF HB(I) LT 60. THEN COLR(I,2)=N1(I)+N21(I)*HB(I) ELSE $
		IF HB(I) LT 180. THEN COLR(I,2)=N2(I) ELSE $
		IF HB(I) LT 240. THEN COLR(I,2)=N1(I)+N21(I)*(240.-HB(I)) ELSE $
			COLR(I,2)=N1(I)
		ENDELSE
	   ENDFOR
;
	COLR = FIX(COLR*255.)<255		;CVT TO 0, 255.
	RED = COLR(*,0)				;SAVE IN COMMON
	GREEN = COLR(*,1)
	BLUE = COLR(*,2)
	TVLCT,RED,GREEN,BLUE			;LOAD COLORS
	cur_red = red & cur_green = green & cur_blue = blue
	RETURN
END

; $Id: hsv.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Pro HSV, Vlo, Vhi, Satlo, Sathi, Hue, Loops, Colr
;+
; NAME:
;	HSV
;
; PURPOSE:
;	Make a color table based on the HSV (Hue, Saturation, and Value) 
;	color system.
;
; CATEGORY:
;	Z4 - Image processing, color table manipulation
;
; CALLING SEQUENCE:
;	HLS, Vlo, Vhi, Satlo, Sathi, Hue, Loops [, Colr]
;
; INPUTS:
;	Vlo:	Starting value, from 0 to 100%.
;
;	Vhi:	Ending value, from 0 to 100%.
;
;	Satlo:	Starting saturation, from 0 to 100%.
;
;	Sathi:	Ending saturation, from 0 to 100%.
;
;	Hue:	Starting Hue, from 0 to 360 degrees.  Red = 0 degs,
;		green = 120, blue = 240.
;
; 	Loops:	The number of loops through the color spiral.  This
;		parameter does not have to be an integer.  A negative value
;		causes the loops to traverse the spiral in the opposite
;		direction.
;
; OUTPUTS:
;	No required outputs.
;
; OPTIONAL OUTPUT PARAMETERS:
;	Colr:	A (256,3) integer array containing the R, G, and B values
;		that were loaded into the color tables.
;		Red = colr(*, 0), green = colr(*, 1), blue = colr(*, 2).
;
; COMMON BLOCKS:
;	COLORS:	Contains the red, green and blue color vectors on exit.
;
; SIDE EFFECTS:
;	The color tables are loaded.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Adapted from a program on page 616, Fundamentals of Interactive
;	Computer Graphics, Foley and Van Dam.
;
;	Using the input parameters, a spiral through the single-ended HSV 
;	cone is traced.  Points along the cone are converted from HLS to RGB.
;
; MODIFICATION HISTORY:
;	Written, DMS, Jan, 1983.
;	Added common block COLORS, DMS, Dec, 1983 and Apr, 1987.
;-
	common colors,red,green,blue,cur_red,cur_green,cur_blue
	on_error,2                        ;Return to caller if an error occurs
	S = (sathi-satlo)/25600.*findgen(256)+satlo/100.
	V = (Vhi-Vlo)/25600.*findgen(256)+vlo/100.
	H = Loops*360./256.*findgen(256)+ Hue
	Hmin = Min(H)/360.
	IF HMIN LT 0. THEN HMIN = FIX(HMIN)-1 ELSE $
		HMIN =FIX(HMIN)
	H= ((H - Hmin*360.) mod 360.)/60.	;Sector, 0 to 5.
	IH = FIX(H)
	f=h-ih			;fractional part
	x = FIX(255.*[[v*(1.-s)],[v*(1.-s*f)],[v*(1.-s*(1.-f))],[v]]);4 choices
	mat = [[3,2,0],[1,3,0],[0,3,2],[0,1,3],[2,0,3],[3,0,1]] ;selector
;
	colr = intarr(256,3)		;define tables
	for i=0,255 do $
		if s(i) eq 0. then colr(i,*)=255.*v(i) else $
		 for j=0,2 do colr(i,j)=x(i,mat(j,ih(i)))
	red = colr(*,0) & green = colr(*,1) & blue = colr(*,2)
	tvlct,red,green,blue
	cur_red = red & cur_green = green & cur_blue = blue ;save current clrs
	return
end
;$Id: ibeta_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       IBETA_PDF
;
; PURPOSE:
;       This function computes the incomplete beta function.
;       It is called by the probability density functions in 
;       this directory. See the function IBETA() in the "math"
;       subdirectory for the user-callable version of the 
;       incomplete beta function.
;-

function betacf, a, b, x
  ;Continued fractions.
  lc = a + b
  ln = a - 1.0
  lq = a + 1.0
  max = 100
  ja = 1.0 & jn = 1.0 
  ka = 1.0 - lc * x / lq 
  kn = 1.0
  for i = 1, max do begin
    ep  = i + 0.0
    tm  = ep + ep
    d   = ep * (b - ep) * x / ((ln + tm) * (a + tm))
    jq  = ja + d*jn
    kq  = ka + d * kn
    d   = -(a + ep) * (lc + ep) * x / ((lq + tm) * (a + tm))
    jq1 = jq + d * ja
    kq1 = kq + d * ka
    prev= ja
    jn  = jq / kq1
    kn  = kq / kq1
    ja  = jq1 / kq1
    ka  = 1.0
    if(abs(ja - prev) lt 3.0e-7 * abs(ja)) then return, ja
  endfor
end

function ibeta_pdf, x, a, b

  on_error, 2  ;Return to caller if error occurs.

  if x lt 0. or x gt 1. then message, $
    'x must be in the range: [0.0, 1.0]'

  ;gab = gamma(a) * gamma(b) 
  ;gamma(a+b)/gab * exp( a*alog(x) + b*alog(1.0-x))

  if(x ne 0 and x ne 1 ) then temp = $
    exp(lngamma(a+b)-lngamma(a)-lngamma(b)+a*alog(x)+b*alog(1.0-x)) $
  else temp = 0.0

  if(x lt (a+1.0)/(a+b+2.0)) then return, temp * betacf(a, b, x)/a $
    else return, (1.0 - temp * betacf(b, a, 1.0-x)/b)
end

;$Id: ibeta.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       IBETA
;
; PURPOSE:
;       This function computes the incomplete beta function, Ix(a, b).
;
; CATEGORY:
;       Special Functions.
;
; CALLING SEQUENCE:
;       Result = Ibeta(a, b, x)
;
; INPUTS:
;       A:    A positive scalar of type integer, float or double that 
;             specifies the parametric exponent of the integrand.
;
;       B:    A positive scalar of type integer, float or double that
;             specifies the parametric exponent of the integrand.
;
;       X:    A scalar, in the interval [0, 1], of type integer, float 
;             or double that specifies the upper limit of integration.
;
; EXAMPLE:
;       Compute the incomplete beta function for the corresponding elements
;       of A, B, and X.
;       Define the parametric exponents.
;         A = [0.5, 0.5, 1.0, 5.0, 10.0, 20.0]
;         B = [0.5, 0.5, 0.5, 5.0,  5.0, 10.0]
;       Define the the upper limits of integration.
;         X = [0.01, 0.1, 0.1, 0.5, 1.0, 0.8]
;       Allocate an array to store the results.
;         result = fltarr(n_elements(A))
;       Compute the incomplete beta functions.
;         for k = 0, n_elements(A)-1 do $
;           result(k) = Ibeta(A(k), B(k), X(k))
;       The result should be:
;         [0.0637686, 0.204833, 0.0513167, 0.500000, 1.00000, 0.950736]
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1994
;                    IBETA is based on the routines: betacf.c, betai.c and
;                    gammln.c described in section 6.2 of Numerical Recipes,
;                    The Art of Scientific Computing (Second Edition), and is
;                    used by permission.
;-

function betacf, a, b, x
  on_error, 2
  eps   = 3.0e-7
  fpmin = 1.0e-30
  maxit = 100
  qab = a + b
  qap = a + 1.0
  qam = a - 1.0
    c = 1.0
    d = 1.0 - qab * x / qap
  if(abs(d) lt fpmin) then d = fpmin
  d = 1.0 / d
  h = d
  for m = 1, maxit do begin
    m2 = 2 * m
    aa = m * (b - m) * x / ((qam + m2) * (a + m2))
     d = 1.0 + aa*d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     h = h * d * c
     aa = -(a + m) *(qab + m) * x/((a + m2) * (qap + m2))
     d = 1.0 + aa * d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     del = d * c
     h = h * del
     if(abs(del - 1.0) lt eps) then return, h
  endfor
  message, 'Failed to converge within given parameters.'
end

function gammln, xx
  coff = [76.18009172947146d0,   -86.50532032941677d0,  $
          24.01409824083091d0,    -1.231739572450155d0, $
           0.1208650973866179d-2, -0.5395239384953d-5]
  stp = 2.5066282746310005d0
  x = xx
  y = x
  tmp = x + 5.5d0
  tmp = (x + 0.5d0) * alog(tmp) - tmp
  ser = 1.000000000190015d0
  for j = 0, n_elements(coff)-1 do begin
    y = y + 1.d0
    ser = ser + coff(j) / y
  endfor
  return, tmp + alog(stp * ser / x)
end

function ibeta, a, b, x
  on_error, 2
  if (x lt 0 or x gt 1) then message, $
    'x must be in the interval [0, 1].'

  if (a le 0 or b le 0) then message, $
    'a and b must be positive scalars.'

  if (x eq 0  or x eq 1) then bt = 0.0 $
  else $
    bt = exp(lngamma(a + b) - lngamma(a) - lngamma(b) + $
             a * alog(x) + b * alog(1.0 - x))
    ;bt = exp(gammln(a + b) - gammln(a) - gammln(b) + $
    ;         a * alog(x) + b * alog(1.0 - x))
  if(x lt (a + 1.0)/(a + b + 2.0)) then return, $
    bt * betacf(a, b, x) / a $
  else return, 1.0 - bt * betacf(b, a, 1.0-x) / b
end


;$Id: igamma_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       IGAMMA_PDF
;
; PURPOSE:
;       This function computes the incomplete gamma function using a series
;       representation. It is called by the probability density functions
;       in this directory. See the function IGAMMA() in the "math"
;       subdirectory for the user-callable version of the incomplete gamma 
;       function.
;
; MODIFICATION HISTORY:
;       Modified by:  Jong Yi, Sept 1992
;                     Increased iterations in g_series.pro
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code.
;-

pro g_series, result, x, a
  ;Computes incomplete gamma function using a series representation.
  glog = lngamma(a)
  nsample = long(x/50.) > 1000l
  resarray = 1.0/(findgen(nsample) + a)
  resarray(1:*) = x*resarray(1:*)
  sum = 1.0/a
  for i = 1, nsample-1 do begin
    resarray(0) = resarray(0) * resarray(i)
    sum = sum + resarray(0)
    if (abs(resarray(0)) lt abs(sum)*3.0e-7) then begin
      result = sum * exp(-x + a * alog(x) - glog)
      return
    endif
  endfor
  result = -1
  return
end

pro g_fract, result, x, a
  glog = lngamma(a)
  gd = 0.0 & fc = 1.0 & b1 = 1.0
  bo = 0.0 & ao = 1.0
  a1 = x
  for n = 1,100 do begin
    an = float(n)
    ana = an -a
    ao = (a1 +ao * ana) * fc
    bo = (b1 + bo *ana) * fc
    anf = an * fc
    a1 = x * ao + anf * a1
    b1 = x * bo + anf * b1
    if a1 then begin
      fc = 1.0/a1
      g = b1 * fc
      if abs((g-gd)/g) LT 3.0e-7 then begin
        result = exp(-x + a * alog(x) - glog) * g
        return
      endif
      gd = g
    endif
  endfor
  result = -1
  return
end

function igamma_pdf, a, x
  if x lt a+1.0 then begin
    g_series, result, x, a
    return, result
  endif else begin
    g_fract, result, x, a
    if result ne -1 then return, (1.0 - result) $
    else return, -1
  endelse
end
 

  
     



;$Id: igamma.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       IGAMMA
;
; PURPOSE:
;       This function computes the incomplete gamma function, Px(a).
;
; CATEGORY:
;       Special Functions.
;
; CALLING SEQUENCE:
;       Result = Igamma(a, x)
;
; INPUTS:
;       A:    A positive scalar of type integer, float or double that
;             specifies the parametric exponent of the integrand.
;
;       X:    A positive scalar of type integer, float or double that 
;             specifies the upper limit of integration.
;
; KEYWORD PARAMETERS:
;       METHOD:  Use this keyword to specify a named variable which returns
;                the method used to compute the incomplete gamma function.
;                A value of 0 indicates that a power series representation
;                was used. A value of 1 indicates that a continued fractions
;                method was used.
;
; EXAMPLE:
;       Compute the incomplete gamma function for the corresponding elements
;       of A and X.
;       Define the parametric exponents.
;         A = [0.10, 0.50, 1.00, 1.10, 6.00, 26.00]
;       Define the the upper limits of integration.
;         X = [0.0316228, 0.0707107, 5.00000, 1.04881, 2.44949, 25.4951]
;       Allocate an array to store the results.
;         result = fltarr(n_elements(A))
;       Compute the incomplete gamma functions.
;         for k = 0, n_elements(A)-1 do $
;           result(k) = Igamma(A(k), X(k))
;       The result should be:
;         [0.742026, 0.293128, 0.993262, 0.607646, 0.0387318, 0.486387]
;
; PROCEDURE:
;       IGAMMA computes the incomplete gamma function, Px(a), using either
;       a power series representation or a continued fractions method. If X
;       is less than or equal to A+1, a power series representation is used.
;       If X is greater than A+1, a continued fractions method is used. 
; 
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1994
;                    IGAMMA is based on the routines: gser.c, gcf.c, and  
;                    gammln.c described in section 6.2 of Numerical Recipes,
;                    The Art of Scientific Computing (Second Edition), and is
;                    used by permission.
;-

function igamma, a, x, itmax = itmax, method = method

  on_error, 2

  if a le 0 or x le 0 then $
    message, 'a and x must be positive scalars.'

  eps = 3.0e-7
  fpmin = 1.0e-30
  if keyword_set(itmax) eq 0 then itmax = 100

  if x le (a + 1) then begin ;Series Representation.
    method = 0
    ap = a
    sum = 1.0 / a
    del = sum
    for k = 1, itmax do begin
      ap = ap + 1.0
      del = del * x / ap
      sum = sum + del
      if abs(del) lt abs(sum)*eps then return, $
        sum * exp(-x + a * alog(x) - lngamma(a))
    endfor 
  endif else begin ;Continued Fractions.
    method = 1
    b = x + 1.0 - a
    c = 1.0 / fpmin
    d = 1.0 / b
    h = d
    for k = 1, itmax do begin
      an = -k * (k - a)
      b = b + 2
      d = an * d + b
      if abs(d) lt fpmin then d = fpmin
      c = b + an / c
      if abs(c) lt fpmin then c = fpmin
      d = 1.0 / d
      del = d * c
      h = h * del
      if abs(del - 1) lt eps then return, $
        1 - (exp(-x + a * alog(x) - lngamma(a)) * h)
    endfor
  endelse

  message, 'Failed to converge within given parameters.'

end
; $Id: image_cont.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro image_cont, a, WINDOW_SCALE = window_scale, ASPECT = aspect, $
	INTERP = interp
;+
; NAME:
;	IMAGE_CONT
;
; PURPOSE:
;	Overlay an image and a contour plot.
;
; CATEGORY:
;	General graphics.
;
; CALLING SEQUENCE:
;	IMAGE_CONT, A
;
; INPUTS:
;	A:	The two-dimensional array to display.
;
; KEYWORD PARAMETERS:
; WINDOW_SCALE:	Set this keyword to scale the window size to the image size.
;		Otherwise, the image size is scaled to the window size.
;		This keyword is ignored when outputting to devices with 
;		scalable pixels (e.g., PostScript).
;
;	ASPECT:	Set this keyword to retain the image's aspect ratio.
;		Square pixels are assumed.  If WINDOW_SCALE is set, the 
;		aspect ratio is automatically retained.
;
;	INTERP:	If this keyword is set, bilinear interpolation is used if 
;		the image is resized.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The currently selected display is affected.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	If the device has scalable pixels, then the image is written over
;	the plot window.
;
; MODIFICATION HISTORY:
;	DMS, May, 1988.
;-

on_error,2                      ;Return to caller if an error occurs
sz = size(a)			;Size of image
if sz(0) lt 2 then message, 'Parameter not 2D'

	;set window used by contour
contour,[[0,0],[1,1]],/nodata, xstyle=4, ystyle = 4

px = !x.window * !d.x_vsize	;Get size of window in device units
py = !y.window * !d.y_vsize
swx = px(1)-px(0)		;Size in x in device units
swy = py(1)-py(0)		;Size in Y
six = float(sz(1))		;Image sizes
siy = float(sz(2))
aspi = six / siy		;Image aspect ratio
aspw = swx / swy		;Window aspect ratio
f = aspi / aspw			;Ratio of aspect ratios

if (!d.flags and 1) ne 0 then begin	;Scalable pixels?
  if keyword_set(aspect) then begin	;Retain aspect ratio?
				;Adjust window size
	if f ge 1.0 then swy = swy / f else swx = swx * f
	endif

  tvscl,a,px(0),py(0),xsize = swx, ysize = swy, /device

endif else begin	;Not scalable pixels	
   if keyword_set(window_scale) then begin ;Scale window to image?
	tvscl,a,px(0),py(0)	;Output image
	swx = six		;Set window size from image
	swy = siy
    endif else begin		;Scale window
	if keyword_set(aspect) then begin
		if f ge 1.0 then swy = swy / f else swx = swx * f
		endif		;aspect
	tv,poly_2d(bytscl(a),$	;Have to resample image
		[[0,0],[six/swx,0]], [[0,siy/swy],[0,0]],$
		keyword_set(interp),swx,swy), $
		px(0),py(0)
	endelse			;window_scale
  endelse			;scalable pixels

mx = !d.n_colors-1		;Brightest color
colors = [mx,mx,mx,0,0,0]	;color vectors
if !d.name eq 'PS' then colors = mx - colors ;invert line colors for pstscrp
contour,a,/noerase,/xst,/yst,$	;Do the contour
	   pos = [px(0),py(0), px(0)+swx,py(0)+swy],/dev,$
	c_color =  colors
return
end
;$Id: int_2d.pro,v 1.4 1994/11/29 18:40:36 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       INT_2D
;
; PURPOSE:
;       This function computes the double integral of a bivariate
;       function F(x,y) with limits of integration from A to B
;       for x and from P(x) to Q(x) for y.
;
; CATEGORY:
;       Numerical Analysis.
;
; CALLING SEQUENCE:
;       Result = INT_2D(Fxy, AB_Limits, PQ_Limits, Pts)
;
; INPUTS:
;       Fxy:  A scalar string specifying the name of a user-supplied
;             IDL function that defines the bivariate function to be
;             integrated. The function must accept x & y and return
;             a scalar result.
;       AB_Limits:  A two-element vector containing the lower, A, and
;                   upper, B,  limits of integration for x.
;       PQ_Limits:  A scalar string specifying the name of a user-
;                   supplied IDL function that defines the lower, P(x),
;                   and upper, Q(x), limits of integration for y. The
;                   function must accept x and return a two-element
;                   vector result.
;       Pts:  The number of transformation points used in the
;             computation. Possible values are: 6, 10, 20, 48 or 96.
;
; KEYWORD PARAMETERS:
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
; EXAMPLE:
;       Compute the double integral of the bivariate function
;       F(x, y) = exp(-x^2 -y^2) over the circular region:
;       A = -4, B = 4, Px = -sqrt(16 - x^2), Qx = sqrt(16 - x^2).
; 
;       ;Define the bivariate function.
;         function Fxy, x, y
;           return, exp(-x^2. -y^2.)
;         end
;
;       ;Define the limits of integration for y.
;         function PQ_Limits, x
;           return, [-sqrt(16. - x^2), sqrt(16. - x^2)]
;         end
;
;       ;Define the limits of integration for x.
;         AB_Limits = [-4.0, 4.0]
;
;       ;Integrate with 10, 20, 48, and 96 point formulas using double-
;       ;precision arithmetic. 
;         print, INT_2D('Fxy', AB_Limits, 'PQ_Limits', 10, /double)
;         print, INT_2D('Fxy', AB_Limits, 'PQ_Limits', 20, /double)
;         print, INT_2D('Fxy', AB_Limits, 'PQ_Limits', 48, /double) 
;         print, INT_2D('Fxy', AB_Limits, 'PQ_Limits', 96, /double)
;
;       INT_2D with 10 transformation points yields:    3.1208432
;       INT_2D with 20 transformation points yields:    3.1415923
;       INT_2D with 48 transformation points yields:    3.1415923
;       INT_2D with 96 transformation points yields:    3.1415923
;       The exact solution (7 decimal accuracy) yields: 3.1415923
;
; PROCEDURE:
;       INT_2D.PRO computes the double integral of a bivariate function
;       using iterated Gaussian Quadrature. The algorithm's transformation
;       data is provided in tabulated form with 15 decimal accuracy.
;
; REFERENCE:
;       Handbook of Mathematical Functions
;       U.S. Department of Commerce
;       Applied Mathematics Series 55
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, January 1994
;       Modified:    GGS, RSI, September 1994
;                    Added 96 point transformation data.               
;                    Added DOUBLE keyword. Replaced nested FOR loop with
;                    vector operations resulting in faster execution.
;-          

function int_2d, Fxy, AB_Limits, PQ_Limits, pts, double = double

  on_error, 2

; Tabulated transformation data with 15 decimal accuracy.
if pts eq 6 then begin
  ri    = dblarr(pts)          &   wi    = dblarr(pts)
  ri(0) = 0.932469514203152d   &   wi(0) = 0.171324492379170d
  ri(1) = 0.661209386466265d   &   wi(1) = 0.360761573048139d
  ri(2) = 0.238619186083197d   &   wi(2) = 0.467913934572691d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)  
endif else if pts eq 10 then begin
  ri    = dblarr(pts)          &   wi    = dblarr(pts)
  ri(0) = 0.973906528517172d   &   wi(0) = 0.066671344308688d
  ri(1) = 0.865063366688985d   &   wi(1) = 0.149451349150581d
  ri(2) = 0.679409568299024d   &   wi(2) = 0.219086362515982d
  ri(3) = 0.433395394129247d   &   wi(3) = 0.269266719309996d
  ri(4) = 0.148874338981631d   &   wi(4) = 0.295524224714753d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 20 then begin
  ri     = dblarr(pts)         &   wi     = dblarr(pts)
  ri(0)  = 0.993128599185094d  &   wi(0)  = 0.017614007139152d
  ri(1)  = 0.963971927277913d  &   wi(1)  = 0.040601429800386d
  ri(2)  = 0.912234428251325d  &   wi(2)  = 0.062672048334109d
  ri(3)  = 0.839116971822218d  &   wi(3)  = 0.083276741576704d
  ri(4)  = 0.746331906460150d  &   wi(4)  = 0.101930119817240d 
  ri(5)  = 0.636053680726515d  &   wi(5)  = 0.118194531961518d
  ri(6)  = 0.510867001950827d  &   wi(6)  = 0.131688638449176d
  ri(7)  = 0.373706088715419d  &   wi(7)  = 0.142096109318382d
  ri(8)  = 0.227785851141645d  &   wi(8)  = 0.149172986472603d
  ri(9)  = 0.076526521133497d  &   wi(9)  = 0.152753387130725d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 48 then begin
  ri     = dblarr(pts)         &   wi     = dblarr(pts)
  ri(0)  = 0.998771007252426d  &   wi(0)  = 0.003153346052305d
  ri(1)  = 0.993530172266350d  &   wi(1)  = 0.007327553901276d
  ri(2)  = 0.984124583722826d  &   wi(2)  = 0.011477234579234d
  ri(3)  = 0.970591592546247d  &   wi(3)  = 0.015579315722943d
  ri(4)  = 0.952987703160430d  &   wi(4)  = 0.019616160457355d
  ri(5)  = 0.931386690706554d  &   wi(5)  = 0.023570760839324d
  ri(6)  = 0.905879136715569d  &   wi(6)  = 0.027426509708356d
  ri(7)  = 0.876572020274247d  &   wi(7)  = 0.031167227832798d
  ri(8)  = 0.843588261624393d  &   wi(8)  = 0.034777222564770d
  ri(9)  = 0.807066204029442d  &   wi(9)  = 0.038241351065830d
  ri(10) = 0.767159032515740d  &   wi(10) = 0.041545082943464d
  ri(11) = 0.724034130923814d  &   wi(11) = 0.044674560856694d
  ri(12) = 0.677872379632663d  &   wi(12) = 0.047616658492490d
  ri(13) = 0.628867396776513d  &   wi(13) = 0.050359035553854d
  ri(14) = 0.577224726083972d  &   wi(14) = 0.052890189485193d
  ri(15) = 0.523160974722233d  &   wi(15) = 0.055199503699984d
  ri(16) = 0.466902904750958d  &   wi(16) = 0.057277292100403d
  ri(17) = 0.408686481990716d  &   wi(17) = 0.059114839698395d
  ri(18) = 0.348755886292160d  &   wi(18) = 0.060704439165893d
  ri(19) = 0.287362487355455d  &   wi(19) = 0.062039423159892d
  ri(20) = 0.224763790394689d  &   wi(20) = 0.063114192286254d
  ri(21) = 0.161222356068891d  &   wi(21) = 0.063924238584648d
  ri(22) = 0.097004699209462d  &   wi(22) = 0.064466164435950d
  ri(23) = 0.032380170962869d  &   wi(23) = 0.064737696812683d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 96 then begin
  ri     = dblarr(pts)         &   wi     = dblarr(pts)
  ri(0)  = 0.999689503883230d  &   wi(0)  = 0.000796792065552d
  ri(1)  = 0.998364375863181d  &   wi(1)  = 0.001853960788946d
  ri(2)  = 0.995981842987209d  &   wi(2)  = 0.002910731817934d
  ri(3)  = 0.992543900323762d  &   wi(3)  = 0.003964554338444d
  ri(4)  = 0.988054126329623d  &   wi(4)  = 0.005014202742927d
  ri(5)  = 0.982517263563014d  &   wi(5)  = 0.006058545504235d
  ri(6)  = 0.975939174585136d  &   wi(6)  = 0.007096470791153d
  ri(7)  = 0.968326828463264d  &   wi(7)  = 0.008126876925698d
  ri(8)  = 0.959688291448742d  &   wi(8)  = 0.009148671230783d
  ri(9)  = 0.950032717784437d  &   wi(9)  = 0.010160770535008d
  ri(10) = 0.939370339752755d  &   wi(10) = 0.011162102099838d
  ri(11) = 0.927712456722308d  &   wi(11) = 0.012151604671088d
  ri(12) = 0.915071423120898d  &   wi(12) = 0.013128229566961d
  ri(13) = 0.901460635315852d  &   wi(13) = 0.014090941772314d
  ri(14) = 0.886894517402420d  &   wi(14) = 0.015038721026994d
  ri(15) = 0.871388505909296d  &   wi(15) = 0.015970562902562d
  ri(16) = 0.854959033434601d  &   wi(16) = 0.016885479864245d
  ri(17) = 0.837623511228187d  &   wi(17) = 0.017782502316045d
  ri(18) = 0.819400310737931d  &   wi(18) = 0.018660679627411d
  ri(19) = 0.800308744139140d  &   wi(19) = 0.019519081140145d
  ri(20) = 0.780369043867433d  &   wi(20) = 0.020356797154333d
  ri(21) = 0.759602341176647d  &   wi(21) = 0.021172939892191d
  ri(22) = 0.738030643744400d  &   wi(22) = 0.021966644438744d
  ri(23) = 0.715676812348967d  &   wi(23) = 0.022737069658329d
  ri(24) = 0.692564536642171d  &   wi(24) = 0.023483399085926d
  ri(25) = 0.668718310043916d  &   wi(25) = 0.024204841792364d
  ri(26) = 0.644163403784967d  &   wi(26) = 0.024900633222483d
  ri(27) = 0.618925840125468d  &   wi(27) = 0.025570036005349d
  ri(28) = 0.593032364777572d  &   wi(28) = 0.026212340735672d
  ri(29) = 0.566510418561397d  &   wi(29) = 0.026826866725591d
  ri(30) = 0.539388108324357d  &   wi(30) = 0.027412962726029d
  ri(31) = 0.511694177154667d  &   wi(31) = 0.027970007616848d
  ri(32) = 0.483457973920596d  &   wi(32) = 0.028497411065085d
  ri(33) = 0.454709422167743d  &   wi(33) = 0.028994614150555d
  ri(34) = 0.425478988407300d  &   wi(34) = 0.029461089958167d
  ri(35) = 0.395797649828908d  &   wi(35) = 0.029896344136328d
  ri(36) = 0.365696861472313d  &   wi(36) = 0.030299915420827d
  ri(37) = 0.335208522892625d  &   wi(37) = 0.030671376123669d
  ri(38) = 0.304364944354496d  &   wi(38) = 0.031010332586313d
  ri(39) = 0.273198812591049d  &   wi(39) = 0.031316425596861d
  ri(40) = 0.241743156163840d  &   wi(40) = 0.031589330770727d
  ri(41) = 0.210031310460567d  &   wi(41) = 0.031828758894411d
  ri(42) = 0.178096882367618d  &   wi(42) = 0.032034456231992d
  ri(43) = 0.145973714654896d  &   wi(43) = 0.032206204794030d
  ri(44) = 0.113695850110665d  &   wi(44) = 0.032343822568575d
  ri(45) = 0.081297495464425d  &   wi(45) = 0.032447163714064d
  ri(46) = 0.048812985136049d  &   wi(46) = 0.032516118713868d
  ri(47) = 0.016276744849602d  &   wi(47) = 0.032550614492363d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else message,'Pts parameter must be 6, 10, 20, 48 or 96.'

  if keyword_set(double) eq 0 then begin
    ri = float(ri) & wi = float(wi)
  endif

  h1 = (AB_Limits(1) - AB_Limits(0))/2.0
  h2 = (AB_Limits(1) + AB_Limits(0))/2.0
  aj = 0.0
  for i = 0, pts-1 do begin
    x  = h1 * ri(i) + h2
    cf = call_function(PQ_limits, x)
    k1 = (cf(1) - cf(0))/2.0
    k2 = (cf(1) + cf(0))/2.0
    jx = total(wi * call_function(Fxy, x, k1*ri+k2))
    aj = aj + (wi(i) * k1 * jx)
  endfor
  return, (aj * h1)
  ri = 0 & wi = 0
end
;$Id: int_3d.pro,v 1.4 1994/11/29 18:41:25 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       INT_3D
;
; PURPOSE:
;       This function computes the triple integral of a trivariate
;       function F(x,y,z) with limits of integration from A to B
;       for X, from P(x) to Q(x) for Y and from U(x,y) to V(x,y)
;       for Z.
;
; CATEGORY:
;       Numerical Analysis.
;
; CALLING SEQUENCE:
;       Result = INT_3D(Fxyz, AB_Limits, PQ_Limits, UV_Limits, Pts)
;
; INPUTS:
;       Fxyz:  A scalar string specifying the name of a user-supplied
;              IDL function that defines the trivariate function to be
;              integrated. The function must accept x, y & z and return
;              a scalar result.
;       AB_Limits:  A two-element vector containing the lower, A, and
;                   upper, B,  limits of integration for x.
;       PQ_Limits:  A scalar string specifying the name of a user-
;                   supplied IDL function that defines the lower, P(x),
;                   and upper, Q(x), limits of integration for y. The
;                   function must accept x and return a two-element
;                   vector result.
;       UV_Limits:  A scalar string specifying the name of a user-
;                   supplied IDL function that defines the lower, U(x,y),
;                   and upper, V(x,y), limits of integration for z. The
;                   function must accept x & y and return a two-element
;                   vector result.
;        Pts:  The number of transformation points used in the
;              computation. Possible values are: 6, 10, 20, 48 or 96.
;
; KEYWORD PARAMETERS:
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
; EXAMPLE:
;       Compute the triple integral of the trivariate function
;       F(x,y,z) = z * (x^2 + y^2 + z^2)^1.5 over the region:
;       A = -2, B = 2, Px = -sqrt(4 - x^2), Qx = sqrt(4 - x^2),
;       Uxy = 0, Vxy = sqrt(4 - x^2 - y^2).
;      
;       ;Define the trivariate function.
;         function Fxyz, x, y, z
;           return, z * (x^2 + y^2 + z^2)^1.5
;         end
;
;       ;Define the limits of integration for y.
;         function PQ_Limits, x
;           return, [-sqrt(4. - x^2), sqrt(4. - x^2)]
;         end
;
;       ;Define the limits of integration for z.
;         function UV_Limits, x, y
;           return, [0.0, sqrt(4. - x^2 - y^2)]
;         end
;
;       ;Define the limits of integration for x.
;         AB_Limits = [-2.0, 2.0]
;
;       ;Integrate with 10, 20, 48, and 96 point formulas using double-
;       ;precision arithmetic. Notice that it is possible to abbreviate
;       ;keywords.
;         print, INT_3D('Fxyz', AB_Limits, 'PQ_Limits', 'UV_Limits', 10, /d)
;         print, INT_3D('Fxyz', AB_Limits, 'PQ_Limits', 'UV_Limits', 20, /d)
;         print, INT_3D('Fxyz', AB_Limits, 'PQ_Limits', 'UV_Limits', 48, /d)
;         print, INT_3D('Fxyz', AB_Limits, 'PQ_Limits', 'UV_Limits', 96, /d)
;
;       INT_3D with 10 transformation points yields:    57.444248
;       INT_3D with 20 transformation points yields:    57.446201
;       INT_3D with 48 transformation points yields:    57.446265
;       INT_3D with 96 transformation points yields:    57.446266
;       The exact solution (6 decimal accuracy) yields: 57.446267
;
; PROCEDURE:
;       INT_3D.PRO computes the triple integral of a trivariate function
;       using iterated Gaussian Quadrature. The algorithm's transformation
;       data is provided in tabulated form with 15 decimal accuracy.
;
; REFERENCE:
;       Handbook of Mathematical Functions
;       U.S. Department of Commerce
;       Applied Mathematics Series 55
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, January 1994
;       Modified:    GGS, RSI, September 1994
;                    Added 96 point transformation data.
;                    Added DOUBLE keyword. Replaced nested FOR loop with
;                    vector operations resulting in faster execution.
;-

function int_3d, Fxyz, AB_Limits, PQ_Limits, UV_Limits, pts, double = double

  on_error, 2

; Tabulated transformation data with 15 decimal accuracy.
if pts eq 6 then begin
  ri    = dblarr(pts)          &   wi    = dblarr(pts)
  ri(0) = 0.932469514203152d   &   wi(0) = 0.171324492379170d
  ri(1) = 0.661209386466265d   &   wi(1) = 0.360761573048139d
  ri(2) = 0.238619186083197d   &   wi(2) = 0.467913934572691d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 10 then begin
  ri    = dblarr(pts)          &   wi    = dblarr(pts)
  ri(0) = 0.973906528517172d   &   wi(0) = 0.066671344308688d
  ri(1) = 0.865063366688985d   &   wi(1) = 0.149451349150581d
  ri(2) = 0.679409568299024d   &   wi(2) = 0.219086362515982d
  ri(3) = 0.433395394129247d   &   wi(3) = 0.269266719309996d
  ri(4) = 0.148874338981631d   &   wi(4) = 0.295524224714753d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 20 then begin
  ri     = dblarr(pts)         &   wi     = dblarr(pts)
  ri(0)  = 0.993128599185094d  &   wi(0)  = 0.017614007139152d
  ri(1)  = 0.963971927277913d  &   wi(1)  = 0.040601429800386d
  ri(2)  = 0.912234428251325d  &   wi(2)  = 0.062672048334109d
  ri(3)  = 0.839116971822218d  &   wi(3)  = 0.083276741576704d
  ri(4)  = 0.746331906460150d  &   wi(4)  = 0.101930119817240d
  ri(5)  = 0.636053680726515d  &   wi(5)  = 0.118194531961518d
  ri(6)  = 0.510867001950827d  &   wi(6)  = 0.131688638449176d
  ri(7)  = 0.373706088715419d  &   wi(7)  = 0.142096109318382d
  ri(8)  = 0.227785851141645d  &   wi(8)  = 0.149172986472603d
  ri(9)  = 0.076526521133497d  &   wi(9)  = 0.152753387130725d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 48 then begin
  ri     = dblarr(pts)         &   wi     = dblarr(pts)
  ri(0)  = 0.998771007252426d  &   wi(0)  = 0.003153346052305d
  ri(1)  = 0.993530172266350d  &   wi(1)  = 0.007327553901276d
  ri(2)  = 0.984124583722826d  &   wi(2)  = 0.011477234579234d
  ri(3)  = 0.970591592546247d  &   wi(3)  = 0.015579315722943d
  ri(4)  = 0.952987703160430d  &   wi(4)  = 0.019616160457355d
  ri(5)  = 0.931386690706554d  &   wi(5)  = 0.023570760839324d
  ri(6)  = 0.905879136715569d  &   wi(6)  = 0.027426509708356d
  ri(7)  = 0.876572020274247d  &   wi(7)  = 0.031167227832798d
  ri(8)  = 0.843588261624393d  &   wi(8)  = 0.034777222564770d
  ri(9)  = 0.807066204029442d  &   wi(9)  = 0.038241351065830d
  ri(10) = 0.767159032515740d  &   wi(10) = 0.041545082943464d
  ri(11) = 0.724034130923814d  &   wi(11) = 0.044674560856694d
  ri(12) = 0.677872379632663d  &   wi(12) = 0.047616658492490d
  ri(13) = 0.628867396776513d  &   wi(13) = 0.050359035553854d
  ri(14) = 0.577224726083972d  &   wi(14) = 0.052890189485193d
  ri(15) = 0.523160974722233d  &   wi(15) = 0.055199503699984d
  ri(16) = 0.466902904750958d  &   wi(16) = 0.057277292100403d
  ri(17) = 0.408686481990716d  &   wi(17) = 0.059114839698395d
  ri(18) = 0.348755886292160d  &   wi(18) = 0.060704439165893d
  ri(19) = 0.287362487355455d  &   wi(19) = 0.062039423159892d
  ri(20) = 0.224763790394689d  &   wi(20) = 0.063114192286254d
  ri(21) = 0.161222356068891d  &   wi(21) = 0.063924238584648d
  ri(22) = 0.097004699209462d  &   wi(22) = 0.064466164435950d
  ri(23) = 0.032380170962869d  &   wi(23) = 0.064737696812683d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else if pts eq 96 then begin
  ri     = dblarr(pts)         &   wi     = dblarr(pts)
  ri(0)  = 0.999689503883230d  &   wi(0)  = 0.000796792065552d
  ri(1)  = 0.998364375863181d  &   wi(1)  = 0.001853960788946d
  ri(2)  = 0.995981842987209d  &   wi(2)  = 0.002910731817934d
  ri(3)  = 0.992543900323762d  &   wi(3)  = 0.003964554338444d
  ri(4)  = 0.988054126329623d  &   wi(4)  = 0.005014202742927d
  ri(5)  = 0.982517263563014d  &   wi(5)  = 0.006058545504235d
  ri(6)  = 0.975939174585136d  &   wi(6)  = 0.007096470791153d
  ri(7)  = 0.968326828463264d  &   wi(7)  = 0.008126876925698d
  ri(8)  = 0.959688291448742d  &   wi(8)  = 0.009148671230783d
  ri(9)  = 0.950032717784437d  &   wi(9)  = 0.010160770535008d
  ri(10) = 0.939370339752755d  &   wi(10) = 0.011162102099838d
  ri(11) = 0.927712456722308d  &   wi(11) = 0.012151604671088d
  ri(12) = 0.915071423120898d  &   wi(12) = 0.013128229566961d
  ri(13) = 0.901460635315852d  &   wi(13) = 0.014090941772314d
  ri(14) = 0.886894517402420d  &   wi(14) = 0.015038721026994d
  ri(15) = 0.871388505909296d  &   wi(15) = 0.015970562902562d
  ri(16) = 0.854959033434601d  &   wi(16) = 0.016885479864245d
  ri(17) = 0.837623511228187d  &   wi(17) = 0.017782502316045d
  ri(18) = 0.819400310737931d  &   wi(18) = 0.018660679627411d
  ri(19) = 0.800308744139140d  &   wi(19) = 0.019519081140145d
  ri(20) = 0.780369043867433d  &   wi(20) = 0.020356797154333d
  ri(21) = 0.759602341176647d  &   wi(21) = 0.021172939892191d
  ri(22) = 0.738030643744400d  &   wi(22) = 0.021966644438744d
  ri(23) = 0.715676812348967d  &   wi(23) = 0.022737069658329d
  ri(24) = 0.692564536642171d  &   wi(24) = 0.023483399085926d
  ri(25) = 0.668718310043916d  &   wi(25) = 0.024204841792364d
  ri(26) = 0.644163403784967d  &   wi(26) = 0.024900633222483d
  ri(27) = 0.618925840125468d  &   wi(27) = 0.025570036005349d
  ri(28) = 0.593032364777572d  &   wi(28) = 0.026212340735672d
  ri(29) = 0.566510418561397d  &   wi(29) = 0.026826866725591d
  ri(30) = 0.539388108324357d  &   wi(30) = 0.027412962726029d
  ri(31) = 0.511694177154667d  &   wi(31) = 0.027970007616848d
  ri(32) = 0.483457973920596d  &   wi(32) = 0.028497411065085d
  ri(33) = 0.454709422167743d  &   wi(33) = 0.028994614150555d
  ri(34) = 0.425478988407300d  &   wi(34) = 0.029461089958167d
  ri(35) = 0.395797649828908d  &   wi(35) = 0.029896344136328d
  ri(36) = 0.365696861472313d  &   wi(36) = 0.030299915420827d
  ri(37) = 0.335208522892625d  &   wi(37) = 0.030671376123669d
  ri(38) = 0.304364944354496d  &   wi(38) = 0.031010332586313d
  ri(39) = 0.273198812591049d  &   wi(39) = 0.031316425596861d
  ri(40) = 0.241743156163840d  &   wi(40) = 0.031589330770727d
  ri(41) = 0.210031310460567d  &   wi(41) = 0.031828758894411d
  ri(42) = 0.178096882367618d  &   wi(42) = 0.032034456231992d
  ri(43) = 0.145973714654896d  &   wi(43) = 0.032206204794030d
  ri(44) = 0.113695850110665d  &   wi(44) = 0.032343822568575d
  ri(45) = 0.081297495464425d  &   wi(45) = 0.032447163714064d
  ri(46) = 0.048812985136049d  &   wi(46) = 0.032516118713868d
  ri(47) = 0.016276744849602d  &   wi(47) = 0.032550614492363d
  ri(indgen(pts/2) + (pts/2)) = - ri((pts/2) - indgen(pts/2) -1)
  wi(indgen(pts/2) + (pts/2)) =   wi((pts/2) - indgen(pts/2) -1)
endif else message,'Pts parameter must be 6, 10, 20, 48 or 96.'

  if keyword_set(double) eq 0 then begin
    ri = float(ri) & wi = float(wi)
  endif

  h1 = (AB_Limits(1) - AB_Limits(0))/2.0
  h2 = (AB_Limits(1) + AB_Limits(0))/2.0
  aj = 0.0
  for i = 0, pts-1 do begin
    x  = h1 * ri(i) + h2
    jx = 0.0
    cf = call_function(PQ_Limits, x)
    k1 = (cf(1) - cf(0))/2.0
    k2 = (cf(1) + cf(0))/2.0
    for j = 0, pts-1 do begin
      y  = k1 * ri(j) + k2
      cf = call_function(UV_Limits, x, y)
      l1 = (cf(1) - cf(0)) / 2.0
      l2 = (cf(1) + cf(0)) / 2.0
      jy = total(wi * call_function(Fxyz, x, y, l1*ri+l2))
      jx = jx + wi(j) * l1 * jy
    endfor
    aj = aj + wi(i) * k1 * jx
  endfor
  return, aj * h1
  ri = 0 & wi = 0
end
; $Id: interpol.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION INTERPOL, V, X, U
;+
; NAME:
;	INTERPOL
;
; PURPOSE:
;	Linearly interpolate vectors with a regular or irregular grid.
;
; CATEGORY:
;	E1 - Interpolation
;
; CALLING SEQUENCE:
;	Result = INTERPOL(V, N) 	;For regular grids.
;
;	Result = INTERPOL(V, X, U)	;For irregular grids.
;
; INPUTS:
;	V:	The input vector can be any type except string.
;
;	For regular grids:
;	N:	The number of points in the result when both input and
;		output grids are regular.  The output grid absicissa values
;		equal FLOAT(i)/N_ELEMENTS(V), for i = 0, n-1.
;
;	Irregular grids:
;	X:	The absicissae values for V.  This vecotr must have same # of
;		elements as V.  The values MUST be monotonically ascending 
;		or descending.
;
;	U:	The absicissae values for the result.  The result will have 
;		the same number of elements as U.  U does not need to be 
;		monotonic.
;	
; OPTIONAL INPUT PARAMETERS:
;	None.
;
; OUTPUTS:
;	INTERPOL returns a floating-point vector of N points determined
;	by linearly interpolating the input vector.
;
;	If the input vector is double or complex, the result is double 
;	or complex.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Result(i) = V(x) + (x - FIX(x)) * (V(x+1) - V(x))
;
;	where 	x = i*(m-1)/(N-1) for regular grids.
;		m = # of elements in V, i=0 to N-1.
;
;	For irregular grids, x = U(i).
;		m = number of points of input vector.
;
; MODIFICATION HISTORY:
;	Written, DMS, October, 1982.
;	Modified, Rob at NCAR, February, 1991.  Made larger arrays possible 
;		and correct by using long indexes into the array instead of
;		integers.
;-
;
	on_error,2              ;Return to caller if an error occurs
	m = N_elements(v)	;# of input pnts
	if N_params(0) eq 2 then begin	;Regular?
		r = findgen(x)*(m-1)/(x-1>1) ;Grid points in V
		rl = long(r)		;Cvt to integer
		dif = v(1:*)-v		;V(i+1)-v(i)
		return, V(rl) + (r-rl)*dif(rl) ;interpolate
		endif
;
	if n_elements(x) ne m then $ 
		stop,'INTERPOL - V and X must have same # of elements'
	n= n_elements(u)	;# of output points
	m2=m-2			;last subs in v and x
	r= fltarr(n)+V(0)	;floating, dbl or cmplx result

	if x(1) - x(0) ge 0 then s1 = 1 else s1=-1 ;Incr or Decr X
;
	ix = 0L			;current point
	for i=0L,n-1 do begin	;point loop
		d = s1 * (u(i)-x(ix))	;difference
		if d eq 0. then r(i)=v(ix) else begin  ;at point
		  if d gt 0 then while (s1*(u(i)-x(ix+1)) gt 0) and $
			(ix lt m2) do ix=ix+1 else $
			while (s1*(u(i)-x(ix)) lt 0) and (ix gt 0) do $
			  ix=ix-1
		  r(i) = v(ix) + (u(i)-x(ix))*(v(ix+1)-v(ix))/(x(ix+1)-x(ix))
		  endelse
	endfor
	return,r
end

; Copyright (c) 1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       INT_TABULATED
;
; PURPOSE:
;       This function integrates a tabulated set of data { x(i) , f(i) },
;       on the closed interval [min(X) , max(X)].
;
; CATEGORY:
;       Numerical Analysis.
;
; CALLING SEQUENCE:
;       Result = INT_TABULATED(X, F)
;
; INPUTS:
;       X:  The tabulated X-value data. This data may be irregularly
;           gridded and in random order. If the data is randomly ordered
;	    you must set the SORT keyword to a nonzero value.
;       F:  The tabulated F-value data. Upon input to the function
;           X(i) and F(i) must have corresponding indices for all
;	    values of i. If X is reordered, F is also reordered.
;
;       X and F must be of floating point or double precision type.
;
; KEYWORD PARAMETERS:
;       SORT:   A zero or non-zero scalar value.
;               SORT = 0 (the default) The tabulated x-value data is
;                        already in ascending order.
;               SORT = 1 The tabulated x-value data is in random order
;                        and requires sorting into ascending order. Both
;			 input parameters X and F are returned sorted.
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
; OUTPUTS:
;       This fuction returns the integral of F computed from the tabulated
;	data in the closed interval [min(X) , max(X)].
;
; RESTRICTIONS:
;       Data that is highly oscillatory requires a sufficient number
;       of samples for an accurate integral approximation.
;
; PROCEDURE:
;       INT_TABULATED.PRO constructs a regularly gridded x-axis with a
;	number of segments as an integer multiple of four. Segments
;	are processed in groups of four using a 5-point Newton-Cotes
;	integration formula.
;       For 'sufficiently sampled' data, this algorithm is highly accurate.
;
; EXAMPLES:
;       Example 1:
;       Define 11 x-values on the closed interval [0.0 , 0.8].
;         x = [0.0, .12, .22, .32, .36, .40, .44, .54, .64, .70, .80]
;
;       Define 11 f-values corresponding to x(i).
;         f = [0.200000, 1.30973, 1.30524, 1.74339, 2.07490, 2.45600, $
;              2.84299,  3.50730, 3.18194, 2.36302, 0.231964]
;
;       Compute the integral.
;         result = INT_TABULATED(x, f)
;
;       In this example, the f-values are generated from a known function,
;       (f = .2 + 25*x - 200*x^2 + 675*x^3 - 900*x^4 + 400*x^5)
;
;       The Multiple Application Trapazoid Method yields;  result = 1.5648
;       The Multiple Application Simpson's Method yields;  result = 1.6036
;				INT_TABULATED.PRO yields;  result = 1.6232
;         The Exact Solution (4 decimal accuracy) yields;  result = 1.6405
;
;	Example 2: 
;       Create 30 random points in the closed interval [-2 , 1].
;         x = randomu(seed, 30) * 3.0 - 2.0
;
;       Explicitly define the interval's endpoints.
;         x(0) = -2.0  &  x(29) = 1.0
;
;       Generate f(i) corresponding to x(i) from a given function.
;         f = sin(2*x) * exp(cos(2*x))
;
;       Call INT_TABULATED with the SORT keyword.
;         result = INT_TABULATED(x, f, /sort)
;
;       In this example, the f-values are generated from the function,
;       f = sin(2*x) * exp(cos(2*x))
;
;       The result of this example will vary because the x(i) are random.
;       Executing this example three times gave the following results:
;		               INT_TABULATED.PRO yields;  result = -0.0702
;		               INT_TABULATED.PRO yields;  result = -0.0731
;		               INT_TABULATED.PRO yields;  result = -0.0698
;        The Exact Solution (4 decimal accuracy) yields;  result = -0.0697
;
; MODIFICATION HISTORY:
;           Written by:  GGS, RSI, September 1993
;           Modified:    GGS, RSI, November  1993
;                        Use Numerical Recipes cubic spline interpolation 
;                        function NR_SPLINE/NR_SPLINT. Execution time is 
;                        greatly reduced. Added DOUBLE keyword. The 'sigma' 
;                        keyword is no longer supported.
;           Modified:    GGS, RSI, April  1995
;                        Changed cubic spline calls from NR_SPLINE/NR_SPLINT
;                        to SPL_INIT/SPL_INTERP. Improved double-precision
;                        accuracy. 
;-

function int_tabulated, x, f, double = double, sort = sort

  ;Return to caller if an error occurs.
  on_error, 2 

  x_elems = n_elements(x)
  x_sgmts = x_elems - 1L

  if x_elems ne n_elements(f) then $
    message, 'x and f must be vectors of equal length.'

  ;Sort vectors into ascending order.
  if keyword_set(sort) ne 0 then begin
    i = sort(x)
    x = x(i)
    f = f(i)
  endif

  while (x_sgmts mod 4L) ne 0L do $
    x_sgmts = x_sgmts + 1L

  xmin = min(x)
  xmax = max(x)

  ;Single-precision computations.
  if keyword_set(double) eq 0 then begin 
    ;Uniform step size.
    h = (xmax - xmin) / (x_sgmts + 0.)
    ;x values of interpolates.
    xgrid = h * findgen(x_sgmts + 1L) + xmin
    ;Compute the interpolates.
    z = spl_interp(x, f, spl_init(x, f), xgrid)
    i = 4L
    intgrl = 0.0
    z_sgmts = n_elements(z) - 1L
    ;Compute the integral using the 5-point Newton-Cotes formula.
    while i le z_sgmts do begin
      intgrl = intgrl + $
               2. * h * (7. * (z(i-4) + z(i)) + $
               32. * (z(i-3) + z(i-1)) + 12. * z(i-2)) / 45.
      i = i + 4L
    endwhile
  endif $
  ;Double-precision computations.
  else begin
    ;Uniform step size.
    h = (xmax - xmin) / (x_sgmts + 0.0d)
    ;x values of interpolates.
    xgrid = h * dindgen(x_sgmts + 1L) + xmin
    ;Compute the interpolates.
    z = spl_interp(x, f, spl_init(x, f, /double), xgrid, /double)
    i = 4L
    intgrl = 0.0d
    z_sgmts = n_elements(z) - 1L
    ;Compute the integral using the 5-point Newton-Cotes formula.
    while i le z_sgmts do begin
      intgrl = intgrl + $
               2d * h * (7d * (z(i-4) + z(i)) + $
               32d * (z(i-3) + z(i-1)) + 12d * z(i-2)) / 45d
      i = i + 4L
    endwhile
  endelse
 
  return, intgrl

end

; $Id: julday.pro,v 1.2 1993/04/28 14:14:12 dave Exp $

function JULDAY, MONTH, DAY, YEAR
;+
; NAME:
;	JULDAY
;
; PURPOSE:
;	Calculate the Julian Day Number for a given month, day, and year.
;	This is the inverse of the library function CALDAT.
;	See also caldat, the inverse of this function.
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	Result = JULDAY(Month, Day, Year)
;
; INPUTS:
;	MONTH:	Number of the desired month (1 = January, ..., 12 = December).
;
;	DAY:	Number of day of the month.
;
;	YEAR:	Number of the desired year.
;
; OPTIONAL INPUT PARAMETERS:
;	None.
;
; OUTPUTS:
;	JULDAY returns the Julian Day Number (which begins at noon) of the 
;	specified calendar date.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; MODIFICATION HISTORY:
;	Translated from "Numerical Recipies in C", by William H. Press,
;	Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling.
;	Cambridge University Press, 1988 (second printing).
;
;	AB, September, 1988
;-
;
ON_ERROR, 2		; Return to caller if errors

MONTHS = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG', $
	  'SEP','OCT','NOV','DEC']

; Gregorian Calander was adopted on Oct. 15, 1582
GREG = 15L + 31L * (10L + 12L * 1582L)

; Process the input, if all are missing, use todays date.
NP = n_params()
case NP of
	0: begin
	    DATE = systime()
	    L_MONTH = long(where(strupcase(strmid(DATE, 4, 3)) eq MONTHS))
	    L_MONTH = L_MONTH(0) + 1	; Scalarize it...
	    L_DAY = long(strmid(DATE, 8, 2))
	    L_YEAR = long(strmid(DATE, 20, 4))
	    end
	3: begin
	    L_MONTH = LONG(MONTH)
	    L_DAY = LONG(DAY)
	    L_YEAR=LONG(YEAR)
	    if (L_YEAR eq 0) then message, 'There is no year zero.'
	    end
	else: message, 'Wrong number of parameters.'
	endcase



if (L_YEAR lt 0) then L_YEAR = L_YEAR + 1
if (L_MONTH gt 2) then begin
	JY = L_YEAR
	JM = L_MONTH + 1
    endif else begin
	JY = L_YEAR - 1
	JM = L_MONTH + 13
    endelse

JUL = long(365.25 * JY) + long(30.6001 * JM) + L_DAY + 1720995

; Test whether to change to Gregorian Calandar.
if ((L_DAY + 31L * (L_MONTH + 12L * L_YEAR)) ge GREG) then begin
	JA = long(0.01 * JY)
	JUL = JUL + 2 - JA + long(0.25 * JA)
	endif

	return, JUL

end
; 
; Copyright (c) 1993, Research Systems, Inc. All rights reserved. 
;	Unauthorized reproduction prohibited. 

FUNCTION Krig_expon, d, t       ;Return Exponential Covariance Fcn
r = t(2) * exp((-3./t(0)) * d)
z = where(d eq 0.0, count)
if count gt 0 then r(z) = t(1) + t(2)
return, r
end

FUNCTION Krig_sphere, d, t      ;Return Spherical Covariance Fcn
r = d/t(0) < 1.0                ;Normalized distance
r = t(2) * (1. - 1.5 * r + 0.5 * r^3)
z = where(d eq 0.0, count)
if count gt 0 then r(z) = t(1) + t(2)
return, r
end

FUNCTION krig2d, z, x, y, REGULAR = regular, XGRID=xgrid, $
	XVALUES = xvalues, YGRID = ygrid, YVALUES = yvalues, $
	GS = gs, BOUNDS = bounds, NX = nx0, NY = ny0, EXPONENTIAL = ex, $
	SPHERICAL = sp, NESTED = nest, C0 = C0

;+ 
; NAME: 
;	KRIG_2D 
; 
; PURPOSE: 
;	This function interpolates a regularly or irregularly gridded
;	set of points Z = F(X,Y) using kriging.
;
; CATEGORY: 
;	Interpolation, Surface Fitting 
;
; CALLING SEQUENCE: 
;	Result = KRIG2D(Z [, X, Y]) 
;
; INPUTS: 
;	X, Y, Z:  arrays containing the X, Y, and Z coordinates of the 
;		  data points on the surface. Points need not be 
;		  regularly gridded. For regularly gridded input data, 
;		  X and Y are not used: the grid spacing is specified 
;		  via the XGRID and YGRID (or XVALUES and YVALUES) 
;		  keywords, and Z must be a two dimensional array. 
;		  For irregular grids, all three parameters must be
;		  present and have the same number of elements. 
;
; KEYWORD PARAMETERS: 
;   Model Parameters:
;	EXPONENTIAL: if set (with parameters [A, C0, C1]), use an exponential
;		     semivariogram model.
;	SPHERICAL:   if set (with parameters [A, C0, C1]), use a spherical
;		     semivariogram model.
;
;   Both models use the following parameters:
;	A:	  the range. At distances beyond A, the semivariogram 
;		  or covariance remains essentialy constant. 
;		  See the definition of the functions below. 
;	C0:	  the "nugget," which provides a discontinuity at the
;		  origin. 
;	C1:	  the covariance value for a zero distance, and the variance
;		  of the random sample Z variable. If only a two element
;		  vector is supplied, C1 is set to the sample variance.
;		  (C0 + C1) = the "sill," which is the variogram value for
;		  very large distances.
;
;  Input grid description:
;	REGULAR:  if set, the Z parameter is a two dimensional array 
;		  of dimensions (N,M), containing measurements over a 
;		  regular grid. If any of XGRID, YGRID, XVALUES, YVALUES 
;		  are specified, REGULAR is implied. REGULAR is also 
;		  implied if there is only one parameter, Z. If REGULAR is 
;		  set, and no grid (_VALUE or _GRID) specifications are 
;		  present, the respective grid is set to (0, 1, 2, ...). 
;	XGRID:    contains a two element array, [xstart, xspacing], 
;		  defining the input grid in the X direction. Do not
;		  specify both XGRID and XVALUES. 
;	XVALUES:  if present, XVALUES(i) contains the X location 
;		  of Z(i,j). XVALUES must be dimensioned with N elements. 
;	YGRID:    contains a two element array, [ystart, yspacing], 
;		  defining the input grid in the Y direction. Do not
;		  specify both YGRID and YVALUES. 
;	YVALUES:  if present, YVALUES(i) contains the Y location 
;		  of Z(i,j). YVALUES must be dimensioned with N elements. 
;
;  Output grid description:
;	GS:	  If present, GS must be a two-element vector [XS, YS],
;		  where XS is the horizontal spacing between grid points
;		  and YS is the vertical spacing. The default is based on
;		  the extents of X and Y. If the grid starts at X value
;		  Xmin and ends at Xmax, then the default horizontal
;		  spacing is (Xmax - Xmin)/(NX-1). YS is computed in the
;		  same way. The default grid size, if neither NX or NY
;		  are specified, is 26 by 26. 
;	BOUNDS:   If present, BOUNDS must be a four element array containing
;		  the grid limits in X and Y of the output grid:
;		  [Xmin, Ymin, Xmax, Ymax]. If not specified, the grid
;		  limits are set to the extent of X and Y. 
;	NX:       The output grid size in the X direction. NX need not
;	  	  be specified if the size can be inferred from GS and
;		  BOUNDS. The default value is 26.
;	NY:       The output grid size in the Y direction. See NX. 
; 
; OUTPUTS: 
;	This function returns a two dimensional floating point array
;	containing the interpolated surface, sampled at the grid points.
;
; RESTRICTIONS:
;	The accuracy of this function is limited by the single precision
;	floating point accuracy of the machine.
;
;		SAMPLE EXECUTION TIMES (measured on a Sun IPX)
;	# of input points	# of output points	Seconds
;	10			676			1.1
;	20			676			1.5
;	40			676			2.6
;	80			676			7.8
;	10			1024			1.6
;	10			4096			5.9
;	10			16384			23
;
; PROCEDURE: 
;	Ordinary kriging is used to fit the surface described by the
;	data points X,Y, and Z. See: Isaaks and Srivastava,
;	"An Introduction to Applied Geostatistics," Oxford University
;	Press, 1989, Chapter 12.
;
;	The parameters of the data model, the range, nugget, and
;	sill, are highly dependent upon the degree and type of spatial
;	variation of your data, and should be determined statistically.
;	Experimentation, or preferrably rigorus analysis, is required.
;
;	For N data points, a system of N+1 simultaneous
;	equations are solved for the coefficients of the 
;	surface. For any interpolation point, the interpolated value 
;	is: 
;          F(x,y) = Sum( w(i) * C(x(i),y(i), x, y)
;
;	Formulas used to model the variogram functions:
;		d(i,j) = distance from point i to point j.
;		V = variance of samples.
;		C(i,j) = Covariance of sample i with sample j.
;               C(x0,y0,x1,y1) = Covariance of point (x0,y0) with (x1,y1).
;
;       Exponential covar: C(d) = C1 * EXP(-3*d/A)   if d ne 0.
;                               = C1 + C0          if d eq 0.
;
;       Spherical covar:   C(d) = (1.0 - 1.5 * d/a + 0.5 * (d/a)^3)
;                               = C1 + C0           if d eq 0.
;                               = 0                 if d > a.
;
; EXAMPLES:
; Example 1: Irregularly gridded cases 
;	Make a random set of points that lie on a gaussian: 
;	  n = 15		;# random points
;	  x = RANDOMU(seed, n) 
;	  y = RANDOMU(seed, n) 
;	  z = exp(-2 * ((x-.5)^2 + (y-.5)^2))	;The gaussian 
;
; 	get a 26 by 26 grid over the rectangle bounding x and y: 
;	  e = [ 0.25, 0.0]	;Range and nugget are 0.25, and 0.
;				;(These numbers are dependent upon
;				;your data model.)
;	  r = krig2d(z, x, y, EXPON = e)	;Get the surface. 
;
; 	Or: get a surface over the unit square, with spacing of 0.05: 
;	  r = krig2d(z, x, y, EXPON=e, GS=[0.05, 0.05], BOUNDS=[0,0,1,1])
;
; 	Or: get a 10 by 10 surface over the rectangle bounding x and y: 
;	  r = krig2d(z, x, y, EXPON=e, NX=10, NY=10) 
; 
; Example 2: Regularly gridded cases 
;	  s = [ 10., 0.2]			;Range and sill, data dependent.
;	  z = randomu(seed, 5, 6)		;Make some random data

;	interpolate to a 26 x 26 grid: 
;	  CONTOUR, krig2d(z, /REGULAR, SPHERICAL = s)
; 
; MODIFICATION HISTORY: 
;	DMS, RSI, March, 1993. Written.
;-

on_error, 2

s = size(z)		;Assume 2D
nx = s(1)
ny = s(2)

reg = keyword_set(regular) or (n_params() eq 1)

if n_elements(xgrid) eq 2 then begin
	x = findgen(nx) * xgrid(1) + xgrid(0)
	reg = 1
endif else if n_elements(xvalues) gt 0 then begin
	if n_elements(xvalues) ne nx then $
		message,'Xvalues must have '+string(nx)+' elements.'
	x = xvalues
	reg = 1
endif

if n_elements(ygrid) eq 2 then begin
	y = findgen(ny) * ygrid(1) + ygrid(0)
	reg = 1
endif else if n_elements(yvalues) gt 0 then begin
	if n_elements(yvalues) ne ny then $
		message,'Yvalues must have '+string(ny)+' elements.'
	y = yvalues
	reg = 1
endif

if reg then begin
	if s(0) ne 2 then message,'Z array must be 2D for regular grids'
	if n_elements(x) ne nx then x = findgen(nx)
	if n_elements(y) ne ny then y = findgen(ny)
	x = x # replicate(1., ny)	;Expand to full arrays.
	y = replicate(1.,nx) # y
	endif

n = n_elements(x)
if n ne n_elements(y) or n ne n_elements(z) then $
	message,'x, y, and z must have same number of elements.'

if keyword_set(ex) then begin       ;Get model params
    t = ex
    fname = 'KRIG_EXPON'
endif else if keyword_set(sp) then begin
    t = sp
    fname = 'KRIG_SPHERE'
endif else MESSAGE,'Either EXPONENTIAL or SPHERICAL model must be selected.'

if n_elements(t) eq 2 then begin    ;Default value for variance?
    mz = total(z) / n		;Mean of z
    var = total((z - mz)^2)/n	;Variance of Z
    t = [t, var-t(1)]	;Default value for C1
    endif

m = n + 1			;# of eqns to solve
a = fltarr(m, m)

for i=0, n-2 do for j=i,n-1 do begin  ;Only upper diagonal elements
    d = (x(i)-x(j))^2 + (y(i)-y(j))^2  ;Distance squared
    a(i,j) = d & a(j,i) = d             ;symmetric
    endfor

a = call_function(fname, sqrt(a), t)        ;Get coefficient matrix
a(n,*) = 1.0            ;Fill edges
a(*,n) = 1.0
a(n,n) = 0.0

; c = invert(a)           ;Solution using inverse
ludcmp, a, indx, even_odd       ;Solution using LU decomposition

if n_elements(nx0) le 0 then nx0 = 26	;Defaults for nx and ny
if n_elements(ny0) le 0 then ny0 = 26

xmin = min(x, max = xmax)		;Make the grid...
ymin = min(y, max = ymax)

if n_elements(gs) lt 2 then $
	gs = [(xmax-xmin)/(nx0-1.), (ymax-ymin)/(ny0-1.)]
if n_elements(bounds) lt 4 then bounds = [xmin, ymin, xmax, ymax]

nx = ceil((bounds(2)-bounds(0))/gs(0))+1	;# of elements
ny = ceil((bounds(3)-bounds(1))/gs(1))+1

d = fltarr(m)                       ;One extra for lagrange constranint
r = fltarr(nx,ny,/nozero)           ;Result

for j=0,ny-1 do begin               ;Each output point
  y0 = bounds(1) + gs(1) * j
  for i=0,nx-1 do begin
    x0 = bounds(0) + gs(0) * i
    d(0) = sqrt((x-x0)^2 + (y-y0)^2) ;distance
    d = call_function(fname, d, t)          ;Get rhs
    d(n) = 1.0                              ;lagrange constr
    lubksb, a, indx, d
    r(i,j) = total(d * z)
  endfor
endfor
return, r
end
;$Id: kw_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       KW_TEST
;
; PURPOSE:
;       This function tests the hypothesis that three or more sample 
;       popultions have the same mean of distribution against the
;       hypothesis that they differ. The popultions may be of equal
;       or unequal lengths. The result is a two-element vector containing 
;       the test statistic H and the one-tailed probability of obtaining 
;       a value of H or greater from a chi-square distribution. This type 
;       of test is often refered to as the Kruskal-Wallis H-Test.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = KW_test(X)
;
; INPUTS:
;       X:    An array of m-columns (m >= 3) and n-rows of type integer, 
;             float or double. The columns of this two dimensional array 
;             correspond to the sample popultions. If the sample popultions
;             are of unequal length, all vectors must be appended up to a
;             common length of n using a user-specified missing value. This
;             method requires the use of the MISSING keyword.
;
; KEYWORD PARAMETERS:
;      DF:    Use this keyword to specify a named variable which returns
;             the degrees of freedom used to compute the probability of
;             obtaining a value of H or greater from the corresponding 
;             chi-square distribution
;
; MISSING:    Use this keyword to specify a non-zero numeric value which
;             is used to appended popultions of unequal length up to a 
;             common length of n.
;
; EXAMPLE:
;       Test the hypothesis that three sample popultions have the same mean 
;       of distribution against the hypothesis that they differ at the 0.05 
;       significance level.
;         sp0 = [24.0, 16.7, 22.8, 19.8, 18.9]
;         sp1 = [23.2, 19.8, 18.1, 17.6, 20.2, 17.8]
;         sp2 = [18.2, 19.1, 17.3, 17.3, 19.7, 18.9, 18.8, 19.3]
;       Since the sample popultions are of unequal lengths, a missing value
;       must be appended to sp0 and sp1. In this example the missing value
;       is -1.0 and the 3-column, 8-row input array is defined as:
;         x = [[24.0, 23.2, 18.2], $
;              [16.7, 19.8, 19.1], $
;              [22.8, 18.1, 17.3], $
;              [19.8, 17.6, 17.3], $
;              [18.9, 20.2, 19.7], $
;              [-1.0, 17.8, 18.9], $
;              [-1.0, -1.0, 18.8], $
;              [-1.0, -1.0, 19.3]]
;         result = kw_test(x, missing = -1)
;       The result should be the 2-element vector:
;         [1.65862, 0.436351]
;       The computed probability (0.436351) is greater than the 0.05
;       significance level and therefore we do not reject the hypothesis
;       that the three sample popultions s0, s1 and s2 have the same mean 
;       of distribution.
;
; PROCEDURE:
;       KW_TEST computes the nonparametric Kruskal-Wallis H-Test for three or
;       more populations of equal or unequal size. This test is an extension
;       of the Rank Sum Test implemented in the RS_TEST function. When each 
;       sample population contains at least five observations, the H test
;       statistic is approximated very well by a chi-square distribution with
;       DF degrees of freedom. The hypothesis that three of more sample 
;       populations have the same mean of distribution is rejected if two or
;       more populations differ with statistical significance. 
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1994
;-

pro crank, w, s
  ;Replace elements of the sorted array "w" by their rank.
  ;Identical observations ("ties") are ranked according to their means.
  ;s = f^3 - f (f is the number of elements in identical observations.)
  n = n_elements(w)
  w = [0.0, w]  ;operate on elements w(1), ... , w(n) of the shifted
                ;n+1 element float array (w).
  s = 0.0
  j = 1
  while(j lt n) do begin
    if(w(j+1) ne w(j)) then begin
      w(j) = j
      j = j+1
    endif else begin
      for jt = j+1, n do $
        if (w(jt) ne w(j)) then goto, case2
      jt = n + 1
      case2:
      rank = 0.5 * (j + jt - 1)
      for ji = j, jt-1 do $
        w(ji) = rank
      t = jt - j
      s = s + t^3 - t
      j = jt
    endelse
  endwhile
  if(j eq n) then w(n) = n
  w = w(1:*)
end

function kw_test, x, df = df, missing = missing

  on_error, 2

  sx = size(x)
  if sx(0) + 1 lt 3 then $
    message, 'x must be a two-dimensional array with 3 or more columns.'

  ;Redimension x as a column vector.
  xx = reform(transpose(x), 1, sx(4))

  if keyword_set(missing) eq 0 then begin
    ;Equal length samples.
    ixx = sort(xx) ;Sort and rank the combined vector.
    xx = xx(ixx)
    crank, xx
    xx = xx(sort(ixx))
    crs = total(reform(xx, sx(2), sx(1)), 1) ;Compute the individual column 
                                             ;rank sums by reforming xx.
    n = sx(4)
    h = 12.0/(n*(n+1))*total(crs^2 / sx(2)) - 3*(n+1)
    df = sx(1) - 1
    prob = 1 - chisqr_pdf(h, df)
    return, [h, prob]
  endif else begin
    ;Unequal length samples.
    ixx = where(xx ne missing, nxx) ;Eliminate missing data.
    if nxx ne sx(4) then xx = xx(ixx)
    ixx = sort(xx) ;Sort and rank the combined vector.
    xx = xx(ixx)
    crank, xx
    xx = xx(sort(ixx))
    mvi = lonarr(sx(1))
    if sx(3) eq 5 then crs = dblarr(sx(1)) else $
      crs = fltarr(sx(1))
    top = 0L
    for k = 0, sx(1)-1 do begin 
      imiss = where(x(k,*) eq missing, nmiss)
      mvi(k) = nmiss ;Number of missing values per column vector.
      bot = top + sx(2) - mvi(k) - 1L     
      crs(k) = total(xx(top:bot)) ;Column rank sum.
      top = bot + 1L
    endfor
    h = 12.0/(nxx*(nxx+1))*total(crs^2 / (sx(2)-mvi)) - 3*(nxx+1)
    df = sx(1) - 1
    prob = 1 - chisqr_pdf(h, df)
    return, [h, prob]
  endelse

end
;
; $Id: label_alloc.pro,v 1.8 1995/01/20 19:41:01 tonyh Exp $
;
;  WidLabel
;   Widget Label class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  LABEL_Icon
;       Return the label toolbar icon
;
FUNCTION LABEL_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 128b, 1b, 0b ], $
    [ 0b, 128b, 1b, 0b ], $
    [ 0b, 128b, 1b, 0b ], $
    [ 0b, 64b, 3b, 0b ], $
    [ 0b, 64b, 3b, 0b ], $
    [ 0b, 64b, 3b, 0b ], $
    [ 0b, 32b, 6b, 0b ], $
    [ 0b, 32b, 6b, 0b ], $
    [ 0b, 32b, 6b, 0b ], $
    [ 0b, 16b, 12b, 0b ], $
    [ 0b, 240b, 15b, 0b ], $
    [ 0b, 16b, 12b, 0b ], $
    [ 0b, 8b, 24b, 0b ], $
    [ 0b, 8b, 24b, 0b ], $
    [ 0b, 8b, 24b, 0b ], $
    [ 0b, 28b, 60b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  LABEL_Copy
;   Copy a label.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO LABEL_Copy, Ptr, Copy
    GenCopy, Ptr, Copy
END


;
;  LABEL_Destroy
;   Release resources for the given label
;
PRO LABEL_Destroy, Ptr
    GenDestroy, Ptr
END


;
;  LABEL_Event
;   Event handling routine for a label dialog.  Shares common code
;   (c.f. widbuild.pro)
;
PRO LABEL_Event, Event
    MISC_Event, Event, 1    ; constant is Font Offset in Foci
END



;
;  LABEL_Build
;   Create a dialog box a label object.  If ptr is nil then
;   create the object as well.
;
PRO LABEL_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    LABEL_Alloc, ParPtr, Ptr                ; Allocate object if necessary
    MgrName = 'WE_LABEL' + STRTRIM(Ptr, 2)  ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(9)

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    Foci(0) = Field(Base1, "Label Text:", Obj.Value, 'VALUE', SIZE=50, /STRING)
    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(1) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")


    BuildOther, Base, Obj, Foci, 2, /FRAME

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Label Appearance Controls")
    BuildXY, Base1, Obj, Foci, 5, /SIZE, /OFFSET
    BuildOkCancel, Base, Obj

    DlgInfo     = { $
        Foci:       Foci, $
        ObjPtr:     Ptr $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='LABEL_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  LABEL_Save
;   Save label information to a file.
;   This is a simple object to save.
;
PRO LABEL_Save, Unit, Ptr
    GenWrite, Unit, Ptr
END


;
;  LABEL_Restore
;   Read in a label object from a file
;
PRO LABEL_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "LABEL", 0
END


;
;  LABEL_Generate
;   Create a label object for previewing
;
PRO LABEL_Generate, Base, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Build a command string

    Cmd = 'Id = WIDGET_LABEL(Base'
    SAddCmd, Cmd, Obj.Font, 'FONT'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    SAddCmd, Cmd, Obj.Value, 'VALUE'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'

    Obj2Ptr, Obj, Ptr

    ; Create label by executing the command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Label ' + VarName(Ptr)
    ENDIF
END


;
;  LABEL_GenWid
;   Create IDL code for creating a LABEL
;
PRO LABEL_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)            ; Get name for label
    Ptr2Obj, Ptr, Obj               ; Get object information

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_LABEL( ",A)', $
        Name, Parent, /NO_EOL
    SSaveCmd, Unit, Obj.Font, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    SSaveCmd, Unit, Obj.Value, "VALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  LABEL_Alloc
;       Allocate a label object.  Don't allocate if ptr is non-nil
;
PRO LABEL_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr = WIDGET_BASE(GROUP=TopDlg)         ; Make a pointer

    Obj = {                     $
        WE_LABEL,               $
        Type:           'LABEL',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; object name
        FrameSize:      0,      $
        Font:           '',     $
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        UValue:         '',     $
        Value:          ''      $
    }
    Obj2Ptr, Obj, Ptr
END
; $Id: label_date.pro,v 1.2 1993/10/05 17:34:48 doug Exp $
FUNCTION LABEL_DATE, axis, index, x, DATE_FORMAT = format, MONTHS = months
;+
; NAME:
;	LABEL_DATE
;
; PURPOSE:
;	This function labels axes with dates.
;
; CATEGORY:
;	Plotting.
;
; CALLING SEQUENCE:
;	To set up:
;		dummy = LABEL_DATE(DATE_FORMAT='string')
;	To use:
;		PLOT, x, y, XTICKFORMAT='LABEL_DATE'
;
; INPUTS:
;	No explicit user defined inputs. When called from the plotting
;	routines, the input parameters are (Axis, Index, Value)
;
; KEYWORD PARAMETERS:
;	DATE_FORMAT: a format string which may contain the following:
;		       %M for month (3 character abbr)
;		       %N for month (2 digit abbr)
;		       %D for day of month,
;		       %Y for 4 digit year.
;		       %Z for last two digits of year.
;		       %% is %.
;		     Other characters are passed directly thru.
;		     For example, '%M %D, %Y' prints DEC 11, 1993
;		       '%M %2Y' yields DEC 93
;		       '%D-%M' yields 11-DEC
;		       '%D/%N/%Y' yields 11/12/1993
;		       '%M!C%Y' yields DEC on the top line, 1993 on
;		       the bottom (!C is the new line graphic command).
;
;	MONTHS:      The names of the months, a twelve element string array.
;		     If omitted, use Jan, Feb, ..., Dec.
;
; OUTPUTS:
;	The date string to be plotted.
;
; COMMON BLOCKS:
;	LABEL_DATE_COM.
;
; RESTRICTIONS:
;	Only one date axis may be simultaneously active.
;
; PROCEDURE:
;	Straightforward.
;
; EXAMPLE:
;	For example, to plot from Jan 1, 1993, to July 12, 1994:
;	  Start_date = julday(1, 1, 1993)
;	  End_date = julday(7, 12, 1994)
;	  Dummy = LABEL_DATE(DATE_FORMAT='%N/%D')  ;Simple mm/dd
;	  x = findgen(end_date+1 - start_date) + start_date ;Time axis
;	  PLOT, x, sqrt(x), XTICKFORMAT = 'LABEL_DATE', XSTYLE=1
;	  (Plot with X axis style set to exact.)
;	
; MODIFICATION HISTORY:
;	DMS, RSI.	April, 1993.	Written.
;-

COMMON label_date_com, fmt, month_chr

if keyword_set(format) then begin	;Save format string?
	if keyword_set(months) then month_chr = months $
	else month_chr = ['Jan','Feb','Mar', 'Apr', 'May', 'Jun', 'Jul', $
		'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
	fmt = format
	return, 0
	endif

if n_elements(month_chr) ne 12 or n_elements(fmt) le 0 then $
	message,' Not initialized.'

caldat, long(x), month, day, year	;Get the calendar date from julian
n = strlen(fmt)
out = ''

for i=0, n-1 do begin			;Each format character...
    c = strmid(fmt, i, 1)		;The character.
    if c eq '%' then begin
	i = i + 1
	c = strmid(fmt, i, 1)		;The function
	case c of		;format character?
	'M' : out = out + month_chr(month-1)
	'N' : out = out + string(format='(i2.2)', month)
	'D' : out = out + string(format='(i2.2)', day)
	'Y' : out = out + string(format='(i4)', year)
	'Z' : out = out + string(format='(i2.2)', year  mod 100)
	'%' : out = out + '%'
	else : message, 'Illegal character in date format string: '+fmt
	endcase
    endif else out = out + c
endfor
return, out
end
;$Id: ladfit.pro,v 1.5 1995/07/20 19:35:46 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       LADFIT
;
; PURPOSE:
;       This function fits the paired data {X(i), Y(i)} to the linear model,
;       y = A + Bx, using a "robust" least absolute deviation method. The 
;       result is a two-element vector containing the model parameters, A 
;       and B.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = LADFIT(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An n-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
;  ABSDEV:    Use this keyword to specify a named variable which returns the
;             mean absolute deviation for each data-point in the y-direction.
;
; EXAMPLE:
;       Define two n-element vectors of paired data.
;         x = [-3.20, 4.49, -1.66, 0.64, -2.43, -0.89, -0.12, 1.41, $
;               2.95, 2.18,  3.72, 5.26]
;         y = [-7.14, -1.30, -4.26, -1.90, -6.19, -3.98, -2.87, -1.66, $
;              -0.78, -2.61,  0.31,  1.74]
;       Compute the model parameters, A and B.
;         result = ladfit(x, y, absdev = absdev)
;       The result should be the two-element vector:
;         [-3.15191, 0.930440]
;       The keyword parameter should be returned as:
;         absdev = 0.636851
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1994
;       Modified:    GGS, RSI, July 1995
;                    Corrected an infinite loop condition that occured when
;                    the X input parameter contained mostly negative data.
;-

function sign, z, d
  ;if d lt 0 then z = -abs(z) $
  ;else if d eq 0 then z = 0 $
  ;else if d gt 0 then z = abs(z)
  ;return, z
  return, abs(z) * d / abs(d)
end

function mdfunc, b, x, y, arr, aa, absdev, nx
  on_error, 2
  eps = 1.0e-7
  arr = y - b*x
  if nx mod 2 eq 0 then $;X is of even length.
    ;j = nx / 2
    ;Average Kth and K-1st medians.
    aa = 0.5 * (median(arr(0:nx-2)) + median(arr)) $
  else $
    aa = median(arr)
  sum = 0
  absdev = 0

  ;for k = 0L, nx-1 do begin
  ;  d = y(k) - (b * x(k) + aa)
  ;  absdev = absdev + abs(d)
  ;  if y(k) ne 0 then d = d / abs(y(k))
  ;  if abs(d) gt eps then sum = sum + sign(x(k), d)
  ;endfor

  d = y - (b * x + aa)
  absdev = total(abs(d))
  zeros = where(y ne 0)
  d = d(zeros) / abs(y(zeros))  
  zeros = where(abs(d) gt eps, nzeros)
  if nzeros ne 0 then $
    sum = total(x(zeros)*sign(replicate(1.0, nzeros), d(zeros))) 
  return, sum
end

function ladfit, x, y, absdev = absdev
  on_error, 2

  nx = n_elements(x)
  if nx ne n_elements(y) then $
    message, 'x and y must be vectors of equal length.'

  sx = total(x)
  sy = total(y)
  sxy = total(x*y)
  sxx = total(x*x)
  del = nx * sxx - sx^2
  aa = (sxx * sy - sx * sxy) / del
  bb = (nx * sxy - sx * sy) / del
  chisqr = total((y - (aa + bb*x))^2)
  sigb = sqrt(chisqr / del)
  b1 = bb
  f1 = mdfunc(b1, x, y, arr, aa, absdev, nx)
  b2 = bb + sign(3.0 * sigb, f1) 
  f2 = mdfunc(b2, x, y, arr, aa, absdev, nx)
  while f1*f2 gt 0 do begin
    bb = 2.0 * b2 - b1
    b1 = b2
    f1 = f2
    b2 = bb
    f2 = mdfunc(b2, x, y, arr, aa, absdev, nx)
  endwhile
  sigb = 0.01 * sigb
  while abs(b2-b1) gt sigb do begin
    bb = 0.5 * (b1 + b2)
    if bb eq b1 or bb eq b2 then begin
      absdev = absdev / nx
      return, [aa, bb]
    endif else begin
      f = mdfunc(bb, x, y, arr, aa, absdev, nx)
      if f*f1 ge 0 then begin
        f1 = f
        b1 = bb
      endif else begin
        f2 = f
        b2 = bb
      endelse
    endelse
  endwhile
  absdev = absdev / nx
  return, [aa, bb]
end

; $Id: leefilt.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function Leefilt, A, N, Sig
;+
; NAME:
;	LEEFILT
;
; PURPOSE:
;	Performs the Lee filter algorithm on an image array using a 
;	box of size 2N+1.  This function can also be used on vectors.
;
; CATEGORY:
;	E3 Smoothing (image).
;
; CALLING SEQUENCE:
;	Result = LEEFILT(A [, N, Sig])
;
; INPUTS:
;	A:	The input image array or one-dimensional vector.
;
; OPTIONAL INPUT PARAMETERS:
;	N:	The size of the filter box is 2N+1.  The default value is 5.
;
;	Sig:	Estimate of the standard deviation.  The default is 5.
;		If Sig is negative the procedure requests a value to be 
;		entered, and displays the resulting image.  This cycle 
;		continues until a zero value of Sig is entered.
;
; OUTPUTS:
;	The filtered image or vector is returned.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Displays the filtered image in an IDL window using TVSCL if Sig
;	was negative.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	The LEE (Computer Graphics 197?) technique smooths additive
;	image noise by generating statistics in a local neighborhood
;	and comparing them to the expected values.
;
; MODIFICATION HISTORY:
;	Written, 24-Nov-1982, by R. A. Howard, Naval Research Lab,
;				 Washington, DC 20375
;-
;
on_error,2                      ;Return to caller if an error occurs
NP = N_params(0)
if np lt 3 then Sig = 5.	;supply defaults
if np lt 2 then n = 5
pl = sig le 0.			;true if interactive mode
mean = smooth(float(a),2*n+1)	;make mean
f = (a-mean)^2			;deviation
var = smooth(f,2*n+1)
loop:
	if pl then read,'Type in <sigma> ',sig
	if sig eq 0 then goto,endp
	sig = sig ^2
	var = var/(var+sig)
	f = a - mean
	f=f*var
	f = mean+f
	if pl then begin
		tvscl,f
		goto , loop
		endif
endp:	return,f
end

;$Id: linfit.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       LINFIT
;
; PURPOSE:
;       This function fits the paired data {X(i), Y(i)} to the linear model,
;       y = A + Bx, by minimizing the chi-square error statistic. The result
;       is a two-element vector containing the model parameters, A and B. 
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = LINFIT(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An n-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
;  CHISQR:    Use this keyword to specify a named variable which returns the
;             chi-square error statistic as the sum of squared errors between
;             Y(i) and A + BX(i). If individual standard deviations are 
;             supplied, then the chi-square error statistic is computed as
;             the sum of squared errors divided by the standard deviations.
;
;    PROB:    Use this keyword to specify a named variable which returns the
;             probability that the computed fit would have a value of CHISQR 
;             or greater. If PROB is greater than 0.1, the model parameters 
;             are "believable". If PROB is less than 0.1, the accuracy of the
;             model parameters is questionable.
;
;    SDEV:    An n-element vector of type integer, float or double that 
;             specifies the individual standard deviations for {X(i), Y(i)}.
;
;  SIG_AB:    Use this keyword to specify a named variable which returns a 
;             two-element vector of probable uncertainties for the model par-
;             ameters A and B, respectively. 
;
; EXAMPLE:
;       Define two n-element vectors of paired data.
;         x = [-3.20, 4.49, -1.66, 0.64, -2.43, -0.89, -0.12, 1.41, $
;               2.95, 2.18,  3.72, 5.26]
;         y = [-7.14, -1.30, -4.26, -1.90, -6.19, -3.98, -2.87, -1.66, $
;              -0.78, -2.61,  0.31,  1.74]
;       Define a vector of standard deviations with a constant value of 0.85
;         sdev = replicate(0.85, n_elements(x))
;       Compute the model parameters, A and B.
;         result = linfit(x, y, chisqr = chisqr, prob = prob, sdev = sdev)
;       The result should be the two-element vector:
;         [-3.44596, 0.867329]
;       The keyword parameters should be returned as:
;         chisqr = 11.4998, prob = 0.319925
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, September 1994
;                    LINFIT is based on the routines: fit.c, gammq.c, gser.c,
;                    and gcf.c described in section 15.2 of Numerical Recipes,
;                    The Art of Scientific Computing (Second Edition), and is
;                    used by permission.
;-

function linfit, x, y, chisqr = chisqr, prob = prob, sdev = sdev, $
                                                   sig_ab = sig_ab

  on_error, 2

  nx = n_elements(x)

  if nx ne n_elements(y) then $
    message, 'x and y must be vectors of equal length.'

  nsdev = n_elements(sdev)

  if nsdev eq nx then begin ;Standard deviations are supplied.
    wt = 1.0 / sdev^2
    ss = total(wt)
    sx = total(wt * x)
    sy = total(wt * y)
    t =  (x - sx/ss) / sdev
    st2 = total(t^2)
    b = total(t * y / sdev)
  endif else if nsdev eq 0 then begin
    ss = nx + 0.0
    sx = total(x)
    sy = total(y)
    t = x - sx/ss
    st2 = total(t^2)
    b = total(t * y)
  endif else $
    message, 'sdev and x must be vectors of equal length.'

  b = b / st2
  a = (sy - sx * b) / ss
  sdeva = sqrt((1.0 + sx * sx / (ss * st2)) / ss)
  sdevb = sqrt(1.0 / st2)

  if nsdev ne 0 then begin
    chisqr = total( ((y - a - b * x) / sdev)^2 )
    prob = 1 - igamma(0.5*(nx-2), 0.5*chisqr)
  endif else begin
    chisqr = total( (y - a - b * x)^2 )
    prob = 1.0
    sdevdat = sqrt(chisqr / (nx-2))
    sdeva = sdeva * sdevdat
    sdevb = sdevb * sdevdat
  endelse

  sig_ab = [sdeva, sdevb]
  return, [a, b]

end
;
; $Id: list_alloc.pro,v 1.7 1995/01/20 19:41:01 tonyh Exp $
;
;  WidList
;   Widget List class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  LIST_Icon
;       Return the list toolbar icon
;
FUNCTION LIST_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 4b, 0b, 64b, 47b ], $
    [ 228b, 207b, 199b, 63b ], $
    [ 228b, 207b, 199b, 63b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 228b, 255b, 65b, 38b ], $
    [ 228b, 255b, 65b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 252b, 255b, 127b, 38b ], $
    [ 252b, 255b, 127b, 38b ], $
    [ 28b, 96b, 120b, 38b ], $
    [ 28b, 96b, 120b, 38b ], $
    [ 252b, 255b, 127b, 38b ], $
    [ 252b, 255b, 127b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 228b, 255b, 67b, 38b ], $
    [ 228b, 255b, 67b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 228b, 255b, 207b, 63b ], $
    [ 228b, 255b, 207b, 63b ], $
    [ 4b, 0b, 64b, 47b ], $
    [ 4b, 0b, 64b, 38b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  LIST_Copy
;   Copy a list.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO LIST_Copy, Ptr, Copy
    GenCopy, Ptr, Copy, /HASVALUE
END


;
;  TEXT_Destroy
;   Release resources for the given list widget.
;
PRO LIST_Destroy, Ptr
    GenDestroy, Ptr, /HASVALUE
END


;
;  LIST_Event
;   Event handling routine for list dialog
;
PRO LIST_Event, Event

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'LITERAL':      BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 0
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=0
        END
    'CODEBASED':    BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 1
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=1
        END
    'MAINTEXT': WIDGET_CONTROL, Obj.Value1, SET_UVALUE=Event.Value
    'VALUETEXT':Obj.Value2      = Event.Value   ; UNIMPLEMENTED

    'FONT':     Obj.Font        = Event.Value
    'NAME':     Obj.Name        = Event.Value   ; Other
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'YSIZE':    Obj.YSize       = Event.Value   ; XY Stuff. Note: No X Size
    'XOFFSET':  Obj.XOffset     = Event.Value
    'YOFFSET':  Obj.YOffset     = Event.Value

    'XFONT':    DoXFont, Obj, Binfo.Foci(1)

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        ; WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        ; WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  LIST_Build
;   Create a dialog box a list object.  If ptr is nil then
;   create the object as well.
;
PRO LIST_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    LIST_Alloc, ParPtr, Ptr                 ; Allocate object if necessary
    MgrName = 'WE_LIST' + STRTRIM(Ptr, 2)   ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    Foci    = LONARR(7)

    Base1   = WIDGET_BASE(Base, /COLUMN, /FRAME)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    BuildEdit, Base1, Obj, _EditId

    Foci(0) = Field(Base1, "Y Size:", Obj.YSize, 'YSIZE', SIZE=8, /INT)
    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(1) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")

    BuildOther, Base1, Obj, Foci, 2

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="List Appearance Controls")
    BuildXY, Base1, Obj, Foci, 5, /OFFSET
    BuildOkCancel, Base, Obj

    DlgInfo     = {             $
        Foci:       Foci,       $
        EditId:     _EditId,    $
        ObjPtr:     Ptr         $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='LIST_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  LIST_Save
;   Save list information to a file.
;   Store value as well: If value is nil, make up a value.
;
;   FORMAT:
;       <list object>
;       <number of elements in value>
;       <value>
;
PRO LIST_Save, Unit, Ptr
    GenWrite, Unit, Ptr, DEFAULT='<Nil LIST>'
END


;
;  LIST_Restore
;   Read in a list object from a file
;
PRO LIST_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "LIST", 1
END


;
;  LIST_Generate
;   Create a list object for previewing
;
PRO LIST_Generate, Base, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    GetValue, Obj, Names, '<Nil LIST>'        ; Get Value (or use default)

    ;   Generate command string

    Cmd = 'Id = WIDGET_LIST(Base,VALUE=Names'

    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    SAddCmd, Cmd, Obj.Font, 'FONT'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'

    Obj2Ptr, Obj, Ptr

    ; Create LIST widget

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create LIST ' + VarName(Ptr)
    ENDIF
END


;
;  LIST_GenWid
;   Create IDL code for creating a list widget
;
PRO LIST_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)                ; Get variable name of object
    Ptr2Obj, Ptr, Obj                   ; Get object info

    ListName    = 'ListVal' + STRTRIM(Ptr,2)    ; Create value name
    SaveStr, Unit, Ptr, Obj, ListName, ""       ; Generate value code

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_LIST( ",A,",VALUE=",A)', $
        Name, Parent, ListName, /NO_EOL
    SSaveCmd, Unit, Obj.Font, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  LIST_Alloc
;       Allocate a list object.  Don't allocate if ptr is non-nil
;
PRO LIST_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr     = WIDGET_BASE(GROUP=TopDlg)
    ValueId = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer for the value too

    Obj     = {                 $
        WE_LIST,                $
        Type:           'LIST',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; Title or object name
        Font:           '',     $
        FrameSize:      0,      $
        UValue:         '',     $
        Value1:         ValueId,$
        Value2:         '',     $ ; UNIMPLEMENTED and unused
        ValueType:      0,      $ ; UNIMPLEMENTED and unused
        YSize:          1,      $
        XOffset:        0,      $
        YOffset:        0       $
    }
    Obj2Ptr, Obj, Ptr
END
; $Id: ljlct.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro ljlct
;+
; NAME:
;	LJLCT
;
; PURPOSE:
;	Load standard color tables for LJ-250/252 printer.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	LJLCT
;
; OUTPUTS:
;	No explicit outputs.
;
; SIDE EFFECTS:
;	The color tables are modified if the current device is 'LJ'.
;
; LIMITATIONS:
;	The default color maps used are for the 90dpi color palette.
;	There are only 8 colors colors availible at 180 dpi.
;
; PROCEDURE:
;	If the current device is 'LJ', !D.N_COLORS is used to determine
;	how many bit planes are in use (1 to 4). The standard
;	color map for that number of planes is loaded. These maps are 
;	described in Chapter 7 of the "LJ250/LJ252 Companion Color
;	Printer Programmer Reference Manual", Table 7-5.  That manual gives
;	the values scaled from 1 to 100, LJLCT scales them from 0 to 255.
;
; MODIFICATION HISTORY:
;	AB, 29 July 1990.
;-

if (!d.name eq 'LJ') then begin
  case (!D.N_COLORS) of
  2: TVLCT, [10B, 229B], [10B, 224B], [15B, 217B]
  4: TVLCT, [10B, 135B, 8B, 229B], [10B, 20B, 66B, 224B], [15B, 36B, 56B, 217B]
  8: TVLCT, [10B, 135B, 8B, 227B, 10B, 135B, 5B, 229B], $
	[10B, 20B, 66B, 212B, 10B, 13B, 56B, 224B], $
	[15B, 36B, 56B, 33B, 74B, 64B, 163B, 217B]
  16: TVLCT, [10B, 135B, 8B, 227B, 10B, 135B, 5B, 184B, $
	      31B, 31B, 38B, 110B, 133B, 8B, 227B, 229B], $
	[10B, 20B, 66B, 212B, 10B, 13B, 56B, 105B, $
	 15B, 20B, 41B, 110B, 15B, 25B, 222B, 224B], $
	[15B, 36B, 56B, 33B, 74B, 64B, 163B, 33B, $
	 61B, 25B, 46B, 115B, 48B, 117B, 79B, 217B]
  endcase
endif
end
; $Id: ll_arc_distance.pro,v 1.3 1994/06/10 21:07:53 dan Exp $

FUNCTION LL_ARC_DISTANCE, lon_lat0, arc_dist, az, DEGREES = degs
;+
; NAME:
;	LL_ARC_DISTANCE
;
; PURPOSE:
; 	This function returns the longitude and latitude [lon, lat] of
;	a point a given arc distance (-pi <= Arc_Dist <= pi), and azimuth (Az),
;	from a specified location Lon_lat0.
;
; CATEGORY:
;	Mapping, geography.
;
; CALLING SEQUENCE:
;	Result = LL_ARC_DISTANCE(Lon_lat0, Arc_Dist, Az)
;
; INPUTS:
;    	Lon_lat0: A 2-element vector containing the longitude and latitude
;		  of the starting point. Values are assumed to be in radians
;		  unless the keyword DEGREES is set.
;    	Arc_Dist: The arc distance from Lon_lat0. The value must be between
;		  -!PI and +!PI. To express distances in arc units, divide
;		  by the radius of the globe expressed in the original units.
;		  For example, if the radius of the earth is 6371 km, divide
;		  the distance in km by 6371 to obtain the arc distance.    
;    	Az:	  The azimuth from Lon_lat0. The value is assumed to be in
;		  radians unless the keyword DEGREES is set.
;
; KEYWORD PARAMETERS:
;    	DEGREES:  Set this keyword to express all measurements and
;		  results in degrees.
;
; OUTPUTS:
;	This function returns a two-element vector containing the
;	longitude and latitude of the resulting point. Values are
;	in radians unless the keyword DEGREES is set.
;
; PROCEDURE:
;	Formula from Map Projections - a working manual.  USGS paper
;	1395.  Equations (5-5) and (5-6).
;
; EXAMPLE:
;	Lon_lat0 = [1.0, 2.0]		; Initial point specified in radians	
;	Arc_Dist = 2.0			; Arc distance in radians
;	Az = 1.0			; Azimuth in radians
;	Result = LL_ARC_DISTANCE(Lon_lat0, Arc_Dist, Az)
;	PRINT, Result
;     	  2.91415    -0.622234
;
; MODIFICATION HISTORY:
;	DMS, Aug, 1992.  Written.
;       DJC, Jun, 1994.  Added test for zero arc distance.
;                        Renamed "dist" variable to "arc_dist" for
;                        compatibility with IDL "Dist" function.
;-

; Return the [lon, lat] of the point a given arc distance 
;	(-pi <= arc_dist <= pi),
; and azimuth (az), from lon_lat0.
;

if (arc_dist eq 0) then return, lon_lat0

cdist = cos(arc_dist)		;Arc_Dist is always in radians.
sdist = sin(arc_dist)

if keyword_set(degs) then s = !dtor else s = 1.0

ll = lon_lat0 * s	;To radians
sinll1 = sin(ll(1))
cosll1 = cos(ll(1))
phi = asin(sinll1 * cdist + cosll1 * sdist * cos(az * s))
lam = ll(0) + atan(sdist * sin(az * s), $
	cosll1*cdist - sinll1 * sdist * cos(az * s))
while lam lt -!pi do lam = lam + 2 * !pi
while lam gt !pi do lam = lam - 2 * !pi
return, [lam, phi] / s
end



; $Id: loadct.pro,v 1.4 1995/01/25 22:25:05 billo Exp $

PRO loadct, table_number, SILENT = silent, GET_NAMES = rnames, FILE=file, $
	NCOLORS = nc1, BOTTOM=bottom
;+
; NAME:
;	LOADCT
;
; PURPOSE:
;	Load predefined color tables.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	LOADCT [, Table]
;
; OPTIONAL INPUTS:
;	Table:	The number of the pre-defined color table to load, from 0 
;		to 15.  If this value is omitted, a menu of the available 
;		tables is printed and the user is prompted to enter a table 
;		number.
;
; KEYWORD PARAMETERS:
;	FILE:	If this keyword is set, the file by the given name is used
;		instead of the file colors1.tbl in the IDL directory.  This
;		allows multiple IDL users to have their own color table file.
;		The specified file must exist.
;	GET_NAMES: If this keyword is present AND DEFINED, the names
;		of the color tables are returned as a string array.
;		No changes are made to the color table.
;	NCOLORS = number of colors to use.  Use color indices from 0
;		to the smaller of !D.TABLE_SIZE-1 and NCOLORS-1.
;		Default = !D.TABLE_SIZE = all available colors.
;	SILENT:	If this keyword is set, the Color Table message is suppressed.
;	BOTTOM = first color index to use. Use color indices from BOTTOM to
;		BOTTOM+NCOLORS-1.  Default = 0.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	COLORS:	The IDL color common block.
;
; SIDE EFFECTS:
;	The color tables of the currently-selected device are modified.
;
; RESTRICTIONS:
;	Works from the file: $IDL_DIR/resource/colors/colors1.tbl or the file specified
;	with the FILE keyword.
;
; PROCEDURE:
;	The file "colors1.tbl" or the user-supplied file is read.  If
;       the currently selected device doesn't have 256 colors, the color
;	data is interpolated from 256 colors to the number of colors
;	available.
;
;	The colors loaded into the display are saved in the common
;	block COLORS, as both the current and original color vectors.
;
;	Interpolation:  If the current device has less than 256 colors,
;	the color table data is interpolated to cover the number of
;	colors in the device.
;
; MODIFICATION HISTORY:
;	Old.  For a widgetized version of this routine, see XLOADCT in the IDL
;		widget library.
;	DMS, 7/92, Added new color table format providing for more than
;		16 tables.  Now uses file colors1.tbl.  Old LOADCT procedure
;		is now OLD_LOADCT.
;	ACY, 9/92, Make a pixmap if no windows exist for X windows to
;		determine properly the number of available colors.
;		Add FILE keyword.
;	WSO, 1/95, Updated for new directory structure
;
;-
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr


on_ioerror, bad
on_error, 2		;Return to caller if error
get_lun, lun

if !d.name eq 'X' and !d.window eq -1 then begin  ;Uninitialized?
;	If so, make a dummy window to determine the # of colors available.
	window,/free,/pixmap,xs=4, ys=4
	wdelete, !d.window
	endif

if n_elements(bottom) gt 0 then cbot = bottom > 0 < (!D.TABLE_SIZE-1) $
	else cbot = 0
nc = !d.table_size - cbot
if n_elements(nc1) gt 0 then nc = nc < nc1

if nc eq 0 then message, 'Device has static color tables.  Can''t load.'

if (n_elements(file) GT 0) then filename = file $
else filename = filepath('colors1.tbl', subdir=['resource', 'colors'])

openr,lun, filename, /block

ntables = 0b
readu, lun, ntables

IF	(n_params() eq 0) or $		;Read names?
	(n_elements(rnames) ge 1) or $
	(not keyword_set(silent)) then begin
		names = bytarr(32, ntables)
		point_lun, lun, ntables * 768L + 1	;Read table names
		readu, lun, names
		names = strtrim(names, 2)
	ENDIF

IF n_elements(rnames) ge 1 THEN BEGIN	;Return names?
	rnames = names
	goto, close_file
	ENDIF


if n_params() lt 1 then begin	;Summarize table?
	nlines = (ntables + 2) / 3	;# of lines to print
	for i=0, nlines-1 do $		;Print each line
	  print, format="(i2,'- ',a17, 3x, i2,'- ',a17, 3x, i2,'- ',a17)", $
	    i, names(i), i+nlines, names(i+nlines), i+2*nlines < (ntables-1), $
		names(i+2*nlines < (ntables-1))
	read,'Enter table number: ',table_number
	endif

if (table_number ge ntables) or (table_number lt 0) then begin
  message, 'Table number must be from 0 to ' + strtrim(ntables-1, 2)
  end


if n_elements(r_orig) lt (nc+cbot) then begin	;Tables defined?
	r_orig = BYTSCL(indgen(nc+cbot))
	g_orig = r_orig
	b_orig = r_orig
	endif


if keyword_set(silent) eq 0 then $
	message,'Loading table ' + names(table_number),/INFO
aa=assoc(lun, bytarr(256),1)	;Read 256 long ints
r = aa(table_number*3)
g = aa(table_number*3+1)
b = aa(table_number*3+2)

if nc ne 256 then begin	;Interpolate
	p = (lindgen(nc) * 255) / (nc-1)
	r = r(p)
	g = g(p)
	b = b(p)
	endif

r_orig(cbot) = r
g_orig(cbot) = g
b_orig(cbot) = b
r_curr = r_orig
g_curr = g_orig
b_curr = b_orig
tvlct,r, g, b, cbot
goto, close_file

bad:
  message,'Error reading file: ' + filename + ', ' + !err_string

close_file:
  free_lun,lun
  return
end
;$Id: lu_complex.pro,v 1.6 1994/11/29 18:42:55 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       LU_COMPLEX
;
; PURPOSE:
;       This function solves an N by N complex linear system using
;       LU decomposition. The result is an N-element complex vector.
;       Alternatively, this function computes the generalized inverse 
;       of an N by N complex array using LU decomposition. The result 
;       is an N by N complex array.
;
; CATEGORY:
;       Complex Linear Algebra.
;
; CALLING SEQUENCE:
;       Result = LU_COMPLEX(A, B)
;
; INPUTS:
;       A:    An N by N complex array.
;
;       B:    An N-element right-side vector (real or complex).
;     
; KEYWORD PARAMETERS:
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
;      INVERSE: If set to a non-zero value, the generalized inverse of A
;               is computed. In this case the input parameter B is ignored.
;
;       SPARSE: If set to a non-zero value, the input array is converted
;               to row-indexed sparse storage format. Computations are
;               done using the iterative biconjugate gradient method.
;               This keyword is effective only when solving complex linear
;               systems. This keyword has no effect when calculating the
;               generalized inverse.
;
; EXAMPLE:
;       1) Define a complex array (A) and right-side vector (B).
;            A = [[complex(1, 0), complex(2,-2), complex(-3,1)], $
;                 [complex(1,-2), complex(2, 2), complex(1, 0)], $
;                 [complex(1, 1), complex(0, 1), complex(1, 5)]]
;            B =  [complex(1, 1), complex(3,-2), complex(1,-2)]
;
;          Solve the complex linear system (Az = B) for z.
;            z = LU_COMPLEX(a, b)
;
;        2) Compute the generalized inverse of A.
;            inv = LU_COMPLEX(a, b, /inverse)
;
; PROCEDURE:
;       LU_COMPLEX solves the complex linear system Az = b using
;       LU decomposition. If the SPARSE keyword is set, the coefficient
;       array is converted to row-indexed sparse storage format and the 
;       system is solved using the iterative biconjugate gradient method.
;       LU_COMPLEX computes the generalized inverse of the complex
;       array A using LU decomposition if B is supplied as an arbitrary
;       scalar value or if the INVERSE keyword is set.
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, October 1993
;       Modified:    GGS, RSI, February 1994
;                    Transposing the array prior to calling LU_COMPLEX
;                    is no longer necessary. LU_COMPLEX is now able to
;                    compute the generalized inverse of an N by N complex
;                    array using LU decomposition.
;       Modified:    GGS, RSI, June 1994
;                    Included support for sparse complex arrays using the
;                    Numerical Recipes functions NR_SPRSIN and NR_LINBCG.
;       Modified:    GGS, RSI, Decemberber 1994
;                    Added support for double-precision complex inputs.
;                    Reduced internal memory allocation requirements.
;                    Added INVERSE keyword. New documentation header.
;-

function lu_complex, a, b, double = double, inverse = inverse, sparse = sparse

  on_error, 2  ;Return to caller if error occurs.

  if n_params() ne 2 then $ 
    message, 'Incorrect number of input parameters.'

  dimension = size(a)
  if dimension(1) ne dimension(2) then $
    message, 'Input array must be square.'

  if keyword_set(double) eq 0 then double = 0 else $
    double = 1

  ;Double-precision complex.
  if dimension(3) eq 9 or keyword_set(double) ne 0 then begin
    comp = [[double(a), -imaginary(a)], $
            [imaginary(a), double(a)]]

    ;Generalized inverse of A (does not depend upon SPARSE keyword).
    if n_elements(b) eq 1 or keyword_set(inverse) then begin
      vec = dblarr(2L*dimension(1))
      inv = dcomplexarr(dimension(1), dimension(1))
      ;Compute the LU decomp only once and iterate on it!
      ludc, comp, index, double = double
      for k = 0, dimension(1)-1 do begin
        vec(k) = 1.0d
        sol = lusol(comp, index, vec, double = double)
        vec(k) = 0.0d
        inv(k, *) = dcomplex(sol(0:dimension(1)-1), sol(dimension(1):*))
      endfor
      return, inv
      inv = 0 & sol = 0 & vec = 0;Clean up intermediate variables.
    endif else begin ;Solve Az = b
      s = size(b)
      ;Rhs complex?
      if s(s(0)+1) ne 6 and s(s(0)+1) ne 9 then $
        vec = [b, dblarr(n_elements(b))] $ ;No.
      else vec = [double(b), imaginary(b)] ;Yes.
      if keyword_set(SPARSE) eq 0 then begin ;Dense coefficient array.
        ludc, comp, index, double = double
        sol = lusol(comp, index, vec, double = double)
      endif else begin ;Sparse coefficient array.
        sol = linbcg(sprsin(comp), vec, replicate(1.0d, 2L*s(3)), $
                                                           double = double)
      endelse
      return, dcomplex(sol(0:dimension(1)-1), sol(dimension(1):*))
      sol = 0 & vec = 0;Clean up intermediate variables.
    endelse
  ;Single-precision complex.
  endif else if dimension(3) eq 6 then begin
    comp = [[float(a), -imaginary(a)], $
            [imaginary(a), float(a)]]

    ;Generalized inverse of A (does not depend upon SPARSE keyword).
    if n_elements(b) eq 1 or keyword_set(inverse) then begin
      vec = fltarr(2L*dimension(1))
      inv = complexarr(dimension(1), dimension(1))
      ;Compute the LU decomp only once and iterate on it!
      ludc, comp, index, double = double
      for k = 0, dimension(1)-1 do begin
        vec(k) = 1.0
        sol = lusol(comp, index, vec, double = double)
        vec(k) = 0.0
        inv(k, *) = complex(sol(0:dimension(1)-1), sol(dimension(1):*))
      endfor
      return, inv
      inv = 0 & sol = 0 & vec = 0 ;Clean up intermediate variables.
    endif else begin ;Solve Az = b
      s = size(b)
      ;Rhs complex?
      if s(s(0)+1) ne 6 and s(s(0)+1) ne 9 then $
        vec = [b, fltarr(n_elements(b))] $  ;No.
        else vec = [float(b), imaginary(b)] ;Yes.
      if keyword_set(SPARSE) eq 0 then begin ;Dense coefficient array.
        ludc, comp, index, double = double
        sol = lusol(comp, index, vec, double = double)
      endif else begin ;Sparse coefficient array.
        sol = linbcg(sprsin(comp), vec, replicate(1.0, 2L*s(3)), $
                                                         double = double)
      endelse
      return, complex(sol(0:dimension(1)-1), sol(dimension(1):*))
      sol = 0 & vec = 0;Clean up intermediate variables.
    endelse
  endif else message, 'Input array must be of complex type.'

end
; $Id: man_proc.pro,v 1.2 1993/05/17 16:45:04 ali Exp $

;+
; NAME:
;	MAN_PROC
;
; PURPOSE:
;	Provide online documentation for IDL topics.  If the current
;	graphics device supports widgets, a graphical user interface
;	is used.  Otherwise, a more basic version that is a cross
;	between the Unix man pages and VMS online help is used.  The
;	help is organized in a two-level hierarchy.  Level 1 is the
;	global subject, and Level 2 supplies help on subjects within
;	each global subject.
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	MAN_PROC [, Request]
;
; INPUTS:
;     Request:	A scalar string containing the item for which help is desired.
;		This string can contain one or two (whitespace separated) 
;		words.  The first word is taken as the global topic and the 
;		second as the topic within the scope of the first.  The user
;		is prompted for missing words.
;
; OUTPUTS:
;	The widget version uses a text widget to display the help
;	text.  The basic version sends help text to the standard output.
;
; COMMON BLOCKS:
;	None.
;
; RESTRICTIONS:
;	The help text is derived from the LaTeX files used to produce
;	the reference manual.  However, it is not possible to produce
;	exactly the same output as found in the manual due to the limitations
;	of text-oriented terminals.  Therefore, the text used is considerably
;	abbreviated.  Always check the manual if the online help is
;	insufficient. 
;
; MODIFICATION HISTORY:
;	4 January 1991, AB	Renamed the old MAN_PROC to MP_BASIC and added
;		 		MP_WIDGETS to handle the widget interface.
;	3 September 1992, AB	Switched from the IDLwidgets version
;				(MP_WIDGETS) to the builtin help. This allows
;				help and the IDL> prompt to work simultaneously
;	17 May 1993, AB		Reverted to using MP_WIDGETS for the Sun 3
;				because it is stuck at OpenWindows 2.0 and
;				recent changes to online help will not be
;				ported to that platform.
;-
;

PRO MAN_PROC, REQUEST

  ; If the current graphics device supports widgets, use them. Otherwise,
  ; use the basic version. Sun 3s use the old MP_WIDGETS
  if ((!D.FLAGS and 65536) eq 0) then begin
    MP_BASIC, REQUEST
  endif else begin
    if ((!version.os eq 'sunos') and (!version.arch eq 'mc68020')) then begin
      MP_WIDGETS, REQUEST
    endif else begin
      WIDGET_OLH, REQUEST
    endelse
  endelse

end























FUNCTION map_getindex,indx
;
; Used to read in the index file for
; each map data file
;
openr, lun, indx, /xdr, /get_lun
segments=0L & readu, lun, segments

dx_map=replicate({ fptr:0L, npts:0L,latmax:0.,latmin:0.,$
                   lonmax:0.,lonmin:0. },segments )

readu, lun, dx_map & free_lun, lun
free_lun,lun
return, dx_map
END

pro fmap_horizon, xr, yr, zr
; Return the horizon (limb) of a map in U,V
; different from map_horizon in that the 
; coords are clockwise. This is used for
; clipping of the polygons

n = 360		;# of vertices

proj = !map.projection
if proj eq 5 or proj eq 3 then begin
        xr = fltarr(n+1) & yr = fltarr(n+1) & zr = fltarr(n+1)
        return
endif

p = map_uv_bounds(proj)
a = findgen(n+1) * (2 * !pi / n)

;		Projections that map to a circle or ellipse
;          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
circle = [ 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1]

if proj eq 7 and !map.sat(2) ne 0 then begin	;Satellite projection, tilted
    map_satellite_limit, 360, xr, yr
endif else if circle(proj) then begin		;Std circular projection
    xr = (p(2)-p(0))/2. * cos(a)
    yr = (p(3)-p(1))/(-2.) * sin(a)
endif else if proj eq 14 then begin		;Sinusoidal
    flon = (!map.out(3)-!map.out(2))/360.
    xr = flon * !pi * cos(a)
    yr = fltarr(n+1)
    k = fix(a/(!pi/2))			;Quadrant
    yr = temporary(a)
    q12 = where(k eq 1 or k eq 2)
    yr(q12) = !pi - yr(q12)
    q4 = where(k eq 3)
    yr(q4) = yr(q4) - 2*!pi
    yr(n) = 0.0
endif else begin		;Rectangular

  dx0= p(2)+findgen(n/4)*(p(0)-p(2))/(n/4.)
  dx1= replicate(p(0),(n/4))
  dx2= p(0)+findgen(n/4)*(p(2)-p(0))/(n/4.)
  dx3= replicate(p(2),(n/4))
  xr= [dx0,dx1,dx2,dx3,dx0(0)]

  dy0= replicate(p(1),(n/4))
  dy1= p(1)+findgen(n/4)*(p(3)-p(1))/(n/4.)
  dy2= replicate(p(3),(n/4))
  dy3= p(3)+findgen(n/4)*(p(1)-p(3))/(n/4.)
  yr= [dy0,dy1,dy2,dy3,dy0(0)]

;  xr = [p(0), p(2), p(2), p(0), p(0)]
;  yr = [p(1), p(1), p(3), p(3), p(1)]
endelse

zr = yr < 0.5 > 0.5
END

pro poly_process,xy,poly_type,color,zvalue,t3d,spacing,orientation
common map_continents, xhor, yhor, zhor, limits
;
; Process the input polygon and plot it.
; --------------------------------------
;
; *  Identify the non-visible points of the polgon.
;        ( the bad array )
; *  If there are no bad points, plot it
;
; *  If there are bad points, fill in the holes with horizon pts.
;
;
	 n=n_elements(xy(0,*))
      FFMT='(4(f8.4,x),a,i4,a,4(f8.4,x))'
    bad=intarr(n)
;
;   Prepare the Jump arrays to determine wrapping.
;
     pt=convert_coord(xy(1,*),xy(0,*),/TO_NORM,/DATA)
     jumpx=[reform(abs(pt(0,0:n-2)-pt(0,1:n-1))),0]
     jumpy=[reform(abs(pt(1,0:n-2)-pt(1,1:n-1))),0]
     max_x=0.1 & max_y=0.1

for i=0,n-1 do begin

    if ((pt(1,i) eq 1E12) or (pt(0,i) eq 1E12)) then begin
       bad(i)=1 
    endif else begin
      if ((jumpx(i) gt max_x ) or (jumpy(i) gt max_y )) then bad(i)=2
     p=convert_coord(xy(1,i),xy(0,i),/TO_NORM,/DATA)
      m0=!map.out(0) & m1=!map.out(1)
      del=0.0
      if ((m1 gt limits(3)-del) or (m1 lt limits(1)+del) or $
          (m0 gt limits(2)-del) or (m0 lt limits(0)+del)) then $
          bad(i)= 3
;         ((xy(0,i) gt !map.out(5)) or (xy(0,i) lt !map.out(4)) or $
;          (xy(1,i) gt !map.out(3)) or (xy(1,i) lt !map.out(2)) ) then begin
;            bad(i)=3
;      endif
    endelse
endfor

    bad_close,bad,xy,poly_type,color,zvalue,t3d,spacing,orientation
end

pro bad_close,bad,xy,poly_type,color,tzvalue,t3d,spacing,orientation
;
;
;
index=where(bad ge 1,badcount)
n=n_elements(xy(0,*))

if n_elements(tzvalue) ne n then  $
         tzvalue=fltarr(n) > 0.5

if badcount eq 0 then begin
   poly_draw,xy,poly_type,color,tzvalue,t3d,spacing,orientation,2
;   spoly_draw,xy,poly_type,color,tzvalue,t3d,spacing,orientation
endif else if badcount lt n then begin
;
;  Go to first bad point, rotate all arrays so that
;  bad=[1,1,1,......,0,....,0,1]
;
   firstbad=-1*index(0) 
   if firstbad ne 0 then begin ; reform the xy array
       xy(0,*)=shift(xy(0,*),firstbad)
       xy(1,*)=shift(xy(1,*),firstbad)
       bad=shift(bad,firstbad)
       tzvalue=shift(tzvalue,firstbad)
   endif
;
; OK start with first zero
;
j=0
  while j lt n-2 do begin
      if bad(j) eq 0 then begin
         ind=where(bad(j:n-2) ge 1,more_count)
         if more_count eq 0 then  begin
            if n-1-j gt 5 then begin
             poly_close,xy(*,j:n-2),poly_type,color,tzvalue(j:n-2),$
                      t3d,spacing,orientation
            endif else begin
             plots,xy(*,j:n-2),color=color,/data,t3d=t3d
            endelse
	    goto, done
         endif else begin
            if ind(0) gt 20 then begin
             poly_close,xy(*,j:ind(0)+j),poly_type,color,tzvalue(j:ind(0)+j),$
                      t3d,spacing,orientation
            endif else begin
             plots,xy(*,j:ind(0)+j),color=color,/data,t3d=t3d
            endelse
            j=j+ind(0)
         endelse
      endif
     j=j+1
  endwhile
endif
done:
end



pro poly_close,xy,poly_type,color,zvalue,t3d,spacing,orientation
common map_continents, xhor, yhor, zhor, limits

;
; This program closes the input polygon with the current horizon.
; (the start and end points need to be connected)
; 
; Requirements:
;
; xy is at least a (2,3) array of lats and longs
; Mercator and Molleweide projections give inconsistant results
;
; xy(0,*) are the lats
; xy(1,*) are the lons
;

n=n_elements(xy(0,*))

del_lat=xy(0,n-1)-xy(0,0)
ave_lat=(xy(0,n-1)+xy(0,0))/2.0

rdel_lon=(xy(1,n-1)-xy(1,0))
del_lon=rdel_lon*cos(ave_lat*!dtor)

;
;  Obtain the coordinates of the coordinate polygon in map
;  coordinates
;
for i=0,n-1 do begin
    pt=convert_coord(xy(1,i),xy(0,i),/TO_NORM,/DATA)
    m0=!map.out(0) & m1=!map.out(1)
    xy(1,i)=m0 & xy(0,i)=m1
endfor
;
; Only use coordinates at least ldiff away from an edge
; ldiff=0.05
;
 ldiff=0.02
gindex=where((xy(0,*) lt limits(3)-ldiff) and $
             (xy(0,*) gt limits(1)+ldiff) and $
             (xy(1,*) lt limits(2)-ldiff) and $
             (xy(1,*) gt limits(0)+ldiff),n)
if n lt 5 then goto,skipit
;
; Reform the xy and zvalue arrays
;
xy=xy(*,gindex) & zvalue=zvalue(gindex)
;
; find horizon point closest to each of the extremes
;

diff=sqrt((xhor-xy(1,0))^2. + (yhor-xy(0,0))^2.)
min0=min(diff,diff_s0)

diff=sqrt((xhor-xy(1,n-1))^2. + (yhor-xy(0,n-1))^2.)
min0=min(diff,diff_s1)

nhorizon=n_elements(xhor)
test_1=0    & test_2 =0

if abs(diff_s0-diff_s1) le nhorizon/2. then test_1 = 1

if diff_s1 le diff_s0 then test_2 =1

ddiff=abs(diff_s1-diff_s0)

nsegs=min([ddiff,nhorizon-ddiff])
;
; Setup the temporary xy (new) and zvalue (newz) arrays
;
new=fltarr(2,n+nsegs) & newz=fltarr(n+nsegs)
new(*,0:n-1)=xy & newz(0:n-1)=zvalue
;
; Create/insert the horizon patching segment
;

if test_1 xor test_2 then begin ; go down
   for i=0,nsegs-1 do begin
        idd=diff_s1-i
        if idd lt 0 then idd=idd+nhorizon
        if idd gt nhorizon then idd=idd-nhorizon
	new(1,n+i)=xhor(idd)
	new(0,n+i)=yhor(idd)
        newz(n+i)=zhor(idd)
   endfor
endif else begin ; go up
   for i=0,nsegs-1 do begin
        idd=diff_s1+i
        if idd lt 0 then idd=idd+nhorizon
        if idd gt nhorizon-1 then idd=idd-nhorizon
	new(1,n+i)=xhor(idd)
	new(0,n+i)=yhor(idd)
        newz(n+i)=zhor(idd)
   endfor
;
; xy     = new
; zvalue = newz
;
endelse

poly_draw,new,poly_type,color,newz,t3d,spacing,orientation,0
skipit:
end

pro poly_draw,xy,poly_type,color,zvalue,t3d,spacing,orientation,intype
;
; CLIP IN DEVICE COORDINATES, THEN PLOT WITH POLYFILL
;
 !x.type=intype
     out=convert_coord(xy(1,*),xy(0,*),/TO_DEVICE)
   winll=convert_coord(!x.window(0),!y.window(0),/NORM,/TO_DEVICE)
   winur=convert_coord(!x.window(1),!y.window(1),/NORM,/TO_DEVICE)

   index=where(out(0,*) gt winll(0) and $
               out(0,*) lt winur(0) and $
               out(1,*) gt winll(1) and $
               out(1,*) lt winur(1),count)

   if count gt 3 then begin
      CASE poly_type OF
            2: polyfill,out(0,index),out(1,index),out(2,index),/DEVICE,$
                   color=color,spacing=spacing,orientation=orientation,$
                   /LINE_FILL
         ELSE: polyfill,out(0,index),out(1,index),out(2,index),/DEVICE,$
                   color=color
      ENDCASE
   endif
 !x.type=2
end



pro spoly_draw,xy,poly_type,color,zvalue,t3d,spacing,orientation
lonmin = !map.out(2) 
lonmax = !map.out(3) 

latmin = !map.out(4) > (-89.99) < 89.99
latmax = !map.out(5) > (-89.99) < 89.99

if abs(lonmax-lonmin) ge 360 or (lonmin eq lonmax) then begin
   lonmin=-179.99 & lonmax=179.99
endif

climits=[lonmin,latmin,lonmax,latmax]

     CASE poly_type OF
       2: polyfill, ((xy(1,*) > lonmin) <lonmax ), $
                    ((xy(0,*) > latmin) <latmax ), $
                    /DATA, zvalue, CLIP=climits, NOCLIP=0, t3d=t3d, $
                    spacing=spacing,orientation=orientation, $
                    /LINE_FILL,color=color
          
     ELSE: polyfill, ( (xy(1,*) > lonmin) <lonmax), $
                     ( (xy(0,*) > latmin) <latmax), $
                   /DATA, zvalue, CLIP=climits, NOCLIP=0, t3d=t3d, $
                  color = color
     ENDCASE
end

pro map_continents, MLINESTYLE = mlinestyle, COLOR = color, T3D=t3d, $
	MLINETHICK = mlinethick, USA = kusa, CONTINENTS = kcont, $
	ZVALUE=zvalue, RIVERS=krivers, HIRES=khires, $
	COUNTRIES=kcountries,SPACING=spacing,$
        FILL_CONTINENTS=kfill_continents,COASTS=kcoasts, $
	ORIENTATION=korientation
;
;
;       if fill_continents =1 you get solid polygons
;       if fill_continents =2 you get lines
;

common map_continents, xhor, yhor, zhor, limits

;  t0 = systime(1)
cont = keyword_set(kcont)
usa = keyword_set(kusa)
rivers = keyword_set(krivers)
coasts = keyword_set(kcoasts)
countries = keyword_set(kcountries)
hires = keyword_set(khires)
if not keyword_set(kfill_continents) then $
                    fill_continents = 0 else $
                    fill_continents=kfill_continents 
if not keyword_set(korientation) then $
                    orientation = 0 else $
                    orientation=korientation 
if (usa+countries+coasts+rivers eq 0) then cont = 1
if n_elements(spacing) eq 0 then spacing = 0.5     ; cm
if n_elements(zvalue) eq 0 then zvalue = 0

if (!x.type NE 2) THEN message,'Map transform not established.'
; if (fill_continents ne 0 and (!map.projection eq 7 $
;      or !map.projection eq 3 or !map.projection eq 5)) then begin 
;      print,'----------------------------------------------------'
;      print,'  Sorry, but continent filling does not work well   '
;      print,'         in the current projection. You can still   '
;      print,'         get continental outlines by using fill=0.  '
;      print,'----------------------------------------------------'
;endif
;
;md=0.03
md=0.01
;
latmin = !map.out(4)-md & latmax = !map.out(5)+md
lonmin = !map.out(2)+md & lonmax = !map.out(3)-md
if lonmax le lonmin then lonmax = lonmax + 360.
test_lon = ((lonmax-lonmin) mod 360.) ne 0.0

if n_elements(mlinestyle) EQ 0 THEN mlinestyle=0
if N_Elements(mlinethick) EQ 0 THEN mlinethick=1
if n_elements(t3d) le 0 then t3d = 0
if n_elements(color) le 0 then begin	;Default color?
	if (!d.flags and 512) ne 0 then color = 0 else color = !d.n_colors-1
	endif

maxlat=0. & minlat=0. & maxlon=0. & minlon=0.
minlon=lonmin
if lonmax gt 180.  then lonmin=180.-lonmax
if minlon lt -180. then lonmax=360.+minlon

map_file=FILEPATH('supmap.dat',subdir=['resource','maps'])
openr, lun, /get, map_file,/xdr,/stream
npts = 0L
; 	cont us_only  both
fbyte = [ 0, 71612L, 165096L]
nsegs = [ 283, 325, 594 ]

ij = 0			;Default = continents only
if rivers ne 0 then begin
   if (hires ne 0) then begin
     rfile=FILEPATH('rhigh.ndx',subdir=['resource','maps','high'])
     a=findfile(rfile,count=file_count) 
     rdat=FILEPATH('rhigh.dat',subdir=['resource','maps','high'])
     b=findfile(rdat,count=dat_count) 
;
;    Make sure that the hires files are present, drop to low
;    resolution if that are missing.
; 
     if (file_count eq 1 and dat_count eq 1) then begin
           rndx=map_getindex(rfile)
     endif else begin
       print,' '
       print,' Warning: Hi Resolution Map Files could not be located. '
       print,'  Attempting to substitute low resolution Rivers file. '
       print,' '
       rndx=map_getindex(FILEPATH('rlow.ndx',subdir=['resource','maps','low']))
       rdat=FILEPATH('rlow.dat',subdir=['resource','maps','low'])
     endelse
   endif else begin
      rndx=map_getindex(FILEPATH('rlow.ndx',subdir=['resource','maps','low']))
      rdat=FILEPATH('rlow.dat',subdir=['resource','maps','low'])
   endelse

	openr,riv,/get,rdat,/xdr,/stream
        rindex=where( (rndx.latmin lt latmax) and $
                      (rndx.latmax gt latmin) and $
                      (rndx.lonmin lt lonmax) and $
                     ((rndx.lonmax gt lonmin)  or $
                      (rndx.lonmax gt lonmax-360.)) ,rcount)

	if rcount ge 0 then begin
	 for i=0,rcount-1 do begin
;		point_lun,riv,rndx(rindex(i)).fptr
;                xy=fltarr(2,rndx(rindex(i)).npts)
		readu,riv,xy
	 plots,xy(1,*),xy(0,*),zvalue,NOCLIP=0,t3d=t3d,thick=mlinethick, $
	      linestyle=mlinestyle,color=color,/data
        endfor
	endif
	free_lun,riv
endif

if countries ne 0 then begin
   if (hires ne 0) then begin
     bfile=FILEPATH('bhigh.ndx',subdir=['resource','maps','high'])
     a=findfile(bfile,count=file_count) 
     bdat=FILEPATH('bhigh.dat',subdir=['resource','maps','high'])
     b=findfile(bdat,count=dat_count) 
;
;    Make sure that the hires files are present, drop to low
;    resolution if that are missing.
; 
     if (file_count eq 1 and dat_count eq 1) then begin
           bndx=map_getindex(bfile)
     endif else begin
       print,' '
       print,' Warning: Hi Resolution Map Files could not be located. '
       print,'  Attempting to substitute low resolution Countries file. '
       print,' '
       bndx=map_getindex(FILEPATH('blow.ndx',subdir=['resource','maps','low']))
       bdat=FILEPATH('blow.dat',subdir=['resource','maps','low'])
     endelse
   endif else begin
       bndx=map_getindex(FILEPATH('blow.ndx',subdir=['resource','maps','low']))
       bdat=FILEPATH('blow.dat',subdir=['resource','maps','low'])
   endelse
	openr,biv,/get,bdat,/xdr,/stream
        bindex=where( (bndx.latmin lt latmax) and $
                      (bndx.latmax gt latmin) and $
                      (bndx.lonmin lt lonmax) and $
                     ((bndx.lonmax gt lonmin)  or $
                      (bndx.lonmax gt lonmax-360.)) ,bcount)
	if bcount ge 0 then begin
	 for i=0,bcount-1 do begin
;		point_lun,biv,bndx(bindex(i)).fptr
;                xy=fltarr(2,bndx(bindex(i)).npts)
		readu,biv,xy
	 plots,xy(1,*),xy(0,*),zvalue,NOCLIP=0,t3d=t3d,thick=mlinethick, $
	      linestyle=mlinestyle,color=color,/data
        endfor
	endif
	free_lun,biv
endif

if coasts ne 0 then begin
   if (hires ne 0) then begin
     cfile=FILEPATH('chigh.ndx',subdir=['resource','maps','high'])
     a=findfile(cfile,count=file_count) 
     cdat=FILEPATH('chigh.dat',subdir=['resource','maps','high'])
     b=findfile(cdat,count=dat_count) 
;
;    Make sure that the hires files are present, drop to low
;    resolution if that are missing.
; 
     if (file_count eq 1 and dat_count eq 1) then begin
           cndx=map_getindex(cfile)
     endif else begin
       print,' '
       print,' Warning: Hi Resolution Map Files could not be located. '
       print,'  Attempting to substitute low resolution Coastal file. '
       print,' '
       cndx=map_getindex(FILEPATH('clow.ndx',subdir=['resource','maps','low']))
       cdat=FILEPATH('clow.dat',subdir=['resource','maps','low'])
     endelse
   endif else begin
       cndx=map_getindex(FILEPATH('clow.ndx',subdir=['resource','maps','low']))
       cdat=FILEPATH('clow.dat',subdir=['resource','maps','low'])
   endelse
	openr,civ,/get,cdat,/xdr,/stream
        cindex=where( (cndx.latmin lt latmax) and $
                      (cndx.latmax gt latmin) and $
                      (cndx.lonmin lt lonmax) and $
                     ((cndx.lonmax gt lonmin)  or $
                      (cndx.lonmax gt lonmax-360.)) ,ccount)
	if ccount ge 0 then begin
	 for i=0,ccount-1 do begin
;		point_lun,civ,cndx(cindex(i)).fptr
;                xy=fltarr(2,cndx(cindex(i)).npts)
		readu,civ,xy

	 plots,xy(1,*),xy(0,*),zvalue,NOCLIP=0,t3d=t3d,thick=mlinethick, $
	      linestyle=mlinestyle,color=color,/data
        endfor
	endif
	free_lun,civ
endif

if (cont ne 0 or fill_continents ne 0) then begin
    fmap_horizon, xhor, yhor, zhor
    limits = map_uv_bounds(!map.projection)
    clipsave = !p.clip
    !p.clip=limits
   if (hires ne 0 ) then begin
     pfile=FILEPATH('phigh.ndx',subdir=['resource','maps','high'])
     a=findfile(pfile,count=file_count) 
     pdat=FILEPATH('phigh.dat',subdir=['resource','maps','high'])
     b=findfile(pdat,count=dat_count) 
;
;    Make sure that the hires files are present, drop to low
;    resolution if that are missing.
; 
     if (file_count eq 1 and dat_count eq 1) then begin
           pndx=map_getindex(pfile)
     endif else begin
       print,' '
       print,' Warning: Hi Resolution Map Files could not be located. '
       print,'  Attempting to substitute low resolution polygon file. '
       print,' '
       pndx=map_getindex(FILEPATH('plow.ndx',subdir=['resource','maps','low']))
       pdat=FILEPATH('plow.dat',subdir=['resource','maps','low'])
     endelse
   endif else begin
       pndx=map_getindex(FILEPATH('plow.ndx',subdir=['resource','maps','low']))
       pdat=FILEPATH('plow.dat',subdir=['resource','maps','low'])
   endelse
   openr,piv,/get,pdat,/xdr,/stream
   pindex=where( (pndx.latmin lt latmax) and $
                 (pndx.latmax gt latmin) and $
                 (pndx.lonmin lt lonmax) and $
                ((pndx.lonmax gt lonmin)  or  $
                 (pndx.lonmax gt lonmax-360.)), pcount)

   if pcount ge 0 then begin
      for i=0,pcount-1 do begin
;	point_lun,piv,pndx(pindex(i)).fptr
;        xy=fltarr(2,pndx(pindex(i)).npts)
        readu,piv,xy

      CASE fill_continents OF
        1: poly_process,xy,fill_continents,color,zvalue,t3d,$
		spacing,orientation
        2: poly_process,xy,fill_continents,color,zvalue,t3d,$
		spacing,orientation
        ELSE: plots,xy(1,*),xy(0,*),zvalue,NOCLIP=1,t3d=t3d,thick=mlinethick, $
	      linestyle=mlinestyle,color=color,/data
      ENDCASE
      endfor
    endif
    free_lun,piv
    !p.clip = clipsave
endif

if usa ne 0 then begin
	if cont then ij = 2 else ij = 1

  point_lun, lun, fbyte(ij)

  for i=1,nsegs(ij) do begin	;Draw each segment
	READU, lun, npts,maxlat,minlat,maxlon,minlon
	npts = npts / 2		;# of points
	xy = fltarr(2,npts)
	READU, lun, xy
	if (maxlat lt latmin) or (minlat gt latmax) then goto,skipit
	if test_lon then $
	  if ((maxlon lt lonmin) or (minlon gt lonmax)) then BEGIN
            if (lonmax gt 180. and maxlon + 360. ge lonmin) then goto,goon
            goto, skipit
          ENDIF
  goon:	plots, xy(1,*), xy(0,*), zvalue, NOCLIP=0, t3d=t3d, $
		THICK=mlinethick,linestyle=mlinestyle, color = color
  skipit:
  endfor
endif
FREE_LUN, lun
;  print, systime(1) - t0, ' seconds'
end
; $Id: map_image.pro,v 1.8 1995/07/27 22:42:42 stevep Exp $

; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

function map_image_missing, image_orig, max_value, min_value
;
; Return an array of 1's where the data are outside the range of min_value
; to max_value.  Max_value and/or min_value may be undefined.  If both are
; undefined, return a -1.
;
k = n_elements(max_value) * 2 + n_elements(min_value)
case k of
0: return, -1
1: return, Image_orig le min_value
2: return, Image_orig ge max_value
3: return, (Image_orig ge max_value) or (Image_orig le min_value)
endcase
end


function  map_image, Image_Orig, startx, starty, xsize, ysize, $
                LATMIN = latmin,   LATMAX = latmax,  $
                LONMIN = lonmin,   LONMAX = lonmax,  $
                COMPRESS = compress, BILINEAR = bilin, $
		WHOLE_MAP = whole_map, SCALE = scalef, $
		MISSING = missing, MAX_VALUE = max_value, MIN_VALUE=min_value
;+NODOCUMENT
;NAME:
;     map_image
;PURPOSE:
;       This function returns the Image_Orig image warped to fit
;       the map specified by the system variable !Map. Image_Orig
;       must be centered at 0.
;Category:
;        Mapping
;Calling Sequence:
;        result = map_image(Image_Orig [, xstart, ystart [, xsize, ysize]])
;INPUT:
;      Image_Orig--- A two-dimensional array representing geographical
;               image to be overlayed on map.  It has Nx columns,
;		and Ny rows.
;KEYWORDS:
;	LATMIN --- the latitude corresponding to the first row of Image_Orig.
;		The default value is -90.  Latitude and Longitude values
;		refer to the CENTER of each cell.
;	LATMAX --- the latitude corresponding to last row of Image_Orig. The
;		default is  90 - (180. / Ny).
;	LONMIN --- the longitude corresponding to the first column of
;		Image_Orig. The default value is -180.
;	LONMAX --- the longitude corresponding to the last column
;		of Image_Orig. The default is  180. - (360./Nx).
;		For images crossing the international dateline, lonmax
;		will be less than lonmin.
;		If the longitude of the last column is equal to 
;		(lonmin - (360. /Nx)) MODULO 360.
;		it is assumed that the image covers all longitudes.
;	BILINEAR --- A flag, if set, to request bilinear interpolation. The
;		default is nearest neighbor.
;	COMPRESS --- Interpolation compression flag.  Setting this to
;		a higher number saves time --- lower numbers produce
;		more accurate results.  Setting this to 1
;		solves the inverse map transformation for every
;		pixel of the output image.  Default = 4 for output devices
;		with fixed pixel sizes. Fix is used to make this an int.
;	WHOLE_MAP = Set to defeat the code that determines the extent
;		of the image on the map.  Some projections are so
;		tricky (especially the satellite) that it is difficult
;		to find where the image goes on the map.  Setting this
;		keyword computes the entire map, at the cost of more
;		time.  For images which cover the entire map, setting
;		this keyword produces no penalty.
;	SCALE = pixel / graphics scale factor for devices with scalable
;		pixels (e.g. PostScript).  Default = 0.02 pixels/graphic_coord.
;		This yields an approximate output image size of 350 x 250.
;		Make this number larger for more resolution (and larger
;		PostScript files, and images), or smaller for faster
;		and smaller, less accurate images.
;	MISSING = value to set areas outside the valid map coordinates.
;		If omitted, areas outside the map are set to 255 (white) if
;		the current graphics device is PostScript, or 0 otherwise.
;	MAX_VALUE = values in Image_Orig greater than or equal to MAX_VALUE
;		are considered missing.  Pixels in the output image
;		that depend upon missing pixels will be set to MISSING.
;	MIN_VALUE = values in Image_Orig less than or equal to MIN_VALUE
;		are considered missing.
; Optional Output Parameters:
;	xstart --- the  x coordinate where the left edge of the image
;		should be placed on the screen.
;	ystart --- the y coordinate where th bottom edge of the image
;		should be placed on the screen.
;	xsize ---  returns the width of the resulting image expressed in
;		graphic coordinate units.  If current graphics device has
;		scalable pixels,  the value of XSIZE and YSIZE should
;		be passed to the TV procedure.
;	ysize ---  returns the pixel height of the resulting image, if the
;		current graphics device has scalable pixels. 
;
;Output:
;      The warped image is returned.
;
; Procedure:  An image space algorithm is used, so the time required
;	is roughly proportional to the size of the final image.
;
;MODIFICATION HISTORY:
;       CAB, Feb, 1992. Map_image has been changed to handle images
;       	crossing the international dateline in a more convenient way.
;       	Specifically, it no longer requires that the keyword LONMIN be
;       	greater than or equal to -180 or the keyword LONMAX be
;		less than or equal to 180.
;	DMS, Aug, 1992.  Completly rewritten.  Uses different algorithms.
;	DMS, Dec, 1992.  Coordinates were off by part of a pixel bin.
;		Also, round when not doing bi-linear interpolation.
;	DMS, Sep, 1993.  Added MAX_VALUE keyword.
;	DMS, Nov, 1994.  Added MIN_VALUE keyword.
;       SVP, Mar, 1995.  Compress is now fix()'d. y is now scaled correctly.
;-

ON_ERROR,2

;t0 = systime(1)
if (!x.type NE 2) THEN  $        ;Need Mapping Coordinates
   message, "Current window must have map coordinates"

s = size(Image_Orig)
if s(0) ne 2 THEN message, " Image must be a two- dimensional array."
s1 = s(1)           ; # of columns
s2 = s(2)           ; # of rows
if s(1) le 1 or s(2) le 1 THEN $
    message, 'Each dimension must be greater than 1.'

; If both latmin & latmax are missing, assume image covers entire globe,
;       without duplication
if N_ELEMENTS(latmin) eq 0 then latmin = -90.
; if N_ELEMENTS(latmax) EQ 0 THEN latmax = 90. - 180./s2
if N_ELEMENTS(latmax) EQ 0 THEN latmax = 90.

; If both lonmin & lonmax are missing, assume image covers all longitudes
;       without duplication.
if N_ELEMENTS(lonmin) EQ 0 THEN lonmin = -180.
;if N_ELEMENTS(lonmax) EQ 0 THEN lonmax = lonmin - 360./s1 + 360.
if N_ELEMENTS(lonmax) EQ 0 THEN lonmax = 180.

latmin = float(latmin) 	&	lonmin = float(lonmin)
latmax = float(latmax) 	&	lonmax = float(lonmax)

;	Does image wrap around globe?
wrap = ((lonmin - 360./s1 + 720.) mod 360.) - ((lonmax + 720.) mod 360.)
wrap = abs(wrap) lt 1e-4	;Allow for roundoff

;
;       Map.out(2:3) contains   Longitude min, max of current projection
;				always in range of -180 to +180.
;       Map.out(4:5) contains   Latitude min, max

;Extents of projection on map
lnmin = !map.out(2)            & lnmax = !map.out(3)
ltmin = !map.out(4) 	       & ltmax = !map.out(5)

if ((ltmin eq -90) or (ltmax eq 90)) then begin     
      lnmin=-180 & lnmax= 180 
      wrap=1                                                  
endif       

                ;Intersection of two rectangles in lat/lon
ltlim = [ltmin > latmin, ltmax < latmax]

if wrap eq 0 then lnlim = [lnmin > lonmin, lnmax < lonmax] $
	else lnlim = [-180, 180]

; Find the extent of the our limits in the map on the screen by
;       making a n x n array of lon/lats spaced over the extent of
;       the image and saving the extrema.


scale = !d.flags and 1		;TRUE if device has scalable pixels
if n_elements(scalef) le 0 then scalef = 0.02   ;PostScript scale factor
IF scale THEN BEGIN		;Fudge for postscript?
	!x.s = !x.s * scalef
	!y.s = !y.s * scalef
ENDIF ELSE scalef = 1

if keyword_set(compress) then compress=fix(compress)
if n_elements(compress) le 0 then compress = 4  ;Default value

; Missing data value should equal the background or user-supplied value.
if n_elements(missing) le 0 then begin
  if (!d.flags and 512 ne 0) then missing = !d.n_colors-1 else missing = 0
  endif

xw = scalef * !x.window * !d.x_size         ;Map extent on screen
yw = scalef * !y.window * !d.y_size

IF KEYWORD_SET(whole_map) THEN BEGIN
	x = [0, (!d.x_size-1) * scalef]	;Use whole area
	y = [0, (!d.y_size-1) * scalef]
ENDIF ELSE BEGIN		;Try to figure it out 
  n = 31                        ;Subdivisions
  x = (findgen(n) * ((lnlim(1)-lnlim(0))/float(n-1)) + lnlim(0)) # replicate(1,n)
  y = replicate(1,n) # (findgen(n) * ((ltlim(1)-ltlim(0))/float(n-1)) + ltlim(0))
  x = convert_coord(x,y, /DATA, /TO_DEVICE)       ;Latlon to device
  
  y = reform(x(1,*), n^2, /OVER)          ;Get device coords separately
  x = reform(x(0,*), n^2, /OVER)
  good = where((x lt 1e10) and (y lt 1e10))
  x = x(good) & y = y(good)
ENDELSE

screen_x = fix([ xw(0) > min(x), xw(1) < max(x) ]);Screen extent of our image
screen_y = fix([ yw(0) > min(y), yw(1) < max(y) ])

;       Get next larger multiple of compress for resulting image size.
nx = (screen_x(1) - screen_x(0)+compress)/compress
ny = (screen_y(1) - screen_y(0)+compress)/compress
                        ;X and Y screen coordinates
x = (findgen(nx) * compress) # replicate(1.0,ny) + screen_x(0)
y = replicate(1.0, nx) # (findgen(ny) * compress) + screen_y(0)

x = convert_coord(x, y, /DEVICE, /TO_DATA)      ;Screen to lat/lon

y = reform(x(1,*), nx, ny, /OVER)       ;Separate lat/longit
x = reform(x(0,*), nx, ny, /OVER)

w = where(x lt lonmin, count)        ;Handle longitude wrap-around
while count gt 0 do begin
        x(w) = x(w) + 360.0
        w = where(x lt lonmin, count)
        endwhile


sx = ((s1-1.)/(lonmax - lonmin))  ;Scale from lat/lon to pixels
sy = ((s2-1.)/(latmax - latmin))


;               Now interpolate the screen image from the original.
if KEYWORD_SET(bilin) THEN BEGIN
; If the image wraps around the globe, we must treat those pixels
; after the last column and before the first column specially. 

    badb = map_image_missing(image_orig, max_value, min_value)
    x = (x - lonmin) * sx		;To pixels
    y = (y - latmin) * sy

    if wrap then begin
	col1 = where(x gt (s1-1), count)	;Wrap around elements
	if count le 0 then goto, full_image
	threecol = [Image_Orig(s1-1,*), Image_Orig(0:1,*)]
	col1x = x(col1) - (s1-1)	;Interpolate value
	if badb(0) ne -1 then begin	;Missing data value?
	    bad = interpolate(float(badb), x, y, miss=0)
	    bad(col1) = interpolate(float([badb(s1-1,*), badb(0:1,*)]), $
			col1x, y(col1), miss=0)
	    bad = where(bad, count)
	    x = interpolate(Image_Orig, x, y, miss = missing) ; full image
		;Add in points that wrapped in X between s1-1 and s1.
	    x(col1) = interpolate(threecol, col1x, y(col1), miss = missing)
	    if count gt 0 then x(bad) = missing
	endif else begin			;badb
	    x = interpolate(Image_Orig, x, y, miss = missing) ; full image
		;Add in points that wrapped in X between s1-1 and s1.
	    x(col1) = interpolate(threecol, col1x, y(col1), miss = missing)
	endelse
    endif else begin
  full_image:
	if badb(0) ne -1 then begin
	    bad = where(interpolate(float(badb), x, y, miss = 0), count)
	    x = interpolate(Image_Orig, x, y, miss = missing) ;No wrap
	    if count gt 0 then x(bad) = missing
	endif else x = interpolate(Image_Orig, x, y, miss = missing) ;No wrap
    endelse
ENDIF ELSE BEGIN
;  Scale to pixel coords & round.  
;  This is the same as: x = (x-lonmin) * sx + 0.5, but faster for arrays.
	x = (x - (lonmin - .5/sx)) * sx
	y = (y - (latmin - .5/sy)) * sy
	bad = where(x lt 0 or x ge s1 or y lt 0 or y ge s2, count)
	if count gt 0 then begin
	    x(bad) = 0
	    y(bad) = 0
	    x = Image_Orig(x, y)
	    badb = map_image_missing(x, max_value, min_value)
	    if badb(0) ne -1 then begin
		worse = where(badb, count)
		if count gt 0 then x(worse) = missing
		endif		;Max value
	    x(bad) = missing
	endif else begin
	    x = Image_Orig(x,y)
	    badb = map_image_missing(x, max_value, min_value)
	    if badb(0) ne -1 then begin
		bad = where(badb, count)
		if count gt 0 then x(bad) = missing
		endif		;Max value
	endelse			;Count
ENDELSE

startx = fix(screen_x(0) / scalef)
starty = fix(screen_y(0) / scalef)
xsize = fix(nx / scalef * compress)
ysize = fix(ny / scalef * compress)

if compress ne 1 then $		;Resample to screen?
   x = rebin(x, nx*compress, ny*compress)  ;Interpolate screen image if necess.
;print,systime(1)-t0,' seconds'

IF scale THEN BEGIN		;Unfudge scale factors
	!x.s = !x.s / scalef
	!y.s = !y.s / scalef
	ENDIF	
return, x
end

; $Id: map_patch.pro,v 1.2 1995/06/30 15:22:19 dave Exp $
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

function reduce_360, a		;Reduce an angle to the range of +- 180.
b = a
r = (b+180.)/360.
t = where(r lt 0.0, count)
if count gt 0 then b(t) = b(t) + ceil(-r(t))*360
t = where(r gt 1.0, count)
if count gt 0 then b(t) = b(t) - floor(r(t))*360
return, b
end


FUNCTION  map_patch, Image_Orig, Lons, Lats, $
		XSTART = xstart, YSTART = ystart, $
		XSIZE = xsize, YSIZE = ysize, $
		LON0 = lon0, LON1 = lon1, $
		LAT0 = lat0, LAT1 = lat1, $
		MISSING = missing, MAX_VALUE = max_value, $
		TRIANGULATE=triangulate, DEBUG = debug
;+
;NAME:
;     map_patch
;PURPOSE:
;	This function returns an interpolated grid in device space,
;	given a set of rectangularly gridded values, in latitude/longitude 
;	space on the globe.
;Category:
;        Mapping
;Calling Sequence:
;        result = map_patch(Image_Orig [, Lons] [, Lats])
;INPUT:
;      Image_Orig- A two-dimensional array containing the data
;               to be overlayed on map.  It has Nx columns,
;		and Ny rows.  The cell connectivity must be rectangular.
;		Computations are performed in floating point.
;		Rows and columns must arranged in increasing longitude
;		and latitude order.
;	Lons-	An Nx element vector containing the longitude
;		of each column.  lon(image_orig(i,j)) = Lons(i).
;		This optional parameter may be omitted if the
;		longitudes are equally spaced and are
;		specified with the LON0 and LON1 keywords.
;	Lats-	An Ny element vector containing the latitude for each
;		row. lat(image_orig(i,j)) = lats(j)  This optional
;		parameter may be omitted if the latitudes are equally
;		spaced and are specified with the LAT0 and LAT1 keywords.
;KEYWORDS:
;	LAT0-	The latitude of the first column of data.  Default=-90.
;	LAT1-	The latitude of the last column of data.  Default=+90.
;	LON0-	The longitude of the first row of data.  Default=-180.
;	LON1-	The longitude of the last row of data.  Default=180-360/Ny.
;	MISSING = value to set areas outside the valid map coordinates.
;		If omitted, areas outside the map are set to 255 (white) if
;		the current graphics device is PostScript, or 0 otherwise.
;	MAX_VALUE = values in Image_Orig greater than MAX_VALUE
;		are considered missing.  Pixels in the output image
;		that depend upon missing pixels will be set to MISSING.
;	TRIANGULATE = if set, the points are converted to device space
;		and then triangulated.  Specify this keyword if the connectivity
;		of the points is not rectangular AND monotonic in device space.
; Optional Output Keywords:
;	xstart --- the  x coordinate where the left edge of the image
;		should be placed on the screen.
;	ystart --- the y coordinate where th bottom edge of the image
;		should be placed on the screen.
;	xsize ---  returns the width of the resulting image expressed in
;		graphic coordinate units.  If current graphics device has
;		scalable pixels,  the value of XSIZE and YSIZE should
;		be passed to the TV procedure.
;	ysize ---  returns the pixel height of the resulting image, if the
;		current graphics device has scalable pixels. 
;
; Restrictions:
;    The four corner points of each cell must be contiguous.  This
;	means that the seam of a map must lie on a cell boundary,
;	not in its interior, splitting the cell.
;	
; Output:
;      The warped image is returned.
;
; Procedure:  An image space algorithm is used, so the time required
;	is roughly proportional to the size in pixels of the final image.
;	This routine often produces better results than MAP_IMAGE, because
;	it works in image (graphic) space, rather than in object (data)
;	space.  Each rectangular cell is divided by a diagonal,
;	into two triangles.  The trianges are then interpolated into
;	the image array using TRIGRID.
;
;MODIFICATION HISTORY:
;	DMS of RSI, July, 1994.		Written.
;-

ON_ERROR,2

; t0 = systime(1)
if (!x.type NE 2) THEN  $        ;Need Mapping Coordinates
   message, "Current window must have map coordinates"

s = size(Image_Orig)
if s(0) ne 2 THEN message, " Image must be a two- dimensional array."
Nx = s(1)           ; # of columns
Ny = s(2)           ; # of rows
Nx1 = Nx-1

n = N_elements(Image_orig)
if Nx le 1 or Ny le 1 THEN $
    message, 'Each dimension must be greater than 1.'

if n_elements(lons) le 0 then begin	;Make longitudes?
    if n_elements(lon0) le 0 then lon0 = -180.
    if n_elements(lon1) le 0 then lon1 = lon0 - 360./nx + 360.
    dx = lon1-lon0
    if dx le 0 then dx = dx + 360.
    lons = findgen(nx) * (dx/(nx-1.)) + lon0
    endif

if n_elements(lats) le 0 then begin	;Make lats?
    if n_elements(lat0) le 0 then lat0 = -90.
    if n_elements(lat1) le 0 then lat1 = 90.
    lats = findgen(ny) * ((lat1-lat0)/(ny-1.)) + lat0
    endif

if n_elements(lats) ne ny then message, "Lats has incorrect size"
if n_elements(lons) ne nx then message, "Lons has incorrect size"

mlonmin = !map.out(2)		;Extent of map limits
mlonmax = !map.out(3)
mlatmin = !map.out(4)
mlatmax = !map.out(5)
iproj = !map.projection

;	stereographic orthog	    lambert eq area
hemis = iproj eq 1 or iproj eq 2 or iproj eq 4   ;TRUE if hemispheric map

equatorial = !map.p0lat eq 0.0		;True if cen on equator
polar = abs(!map.p0lat) eq 90.		;True if cen on pole
;	True if data covers all longitudes
wrap = abs(reduce_360(lons(nx-1) + 360./nx)-lons(0)) lt 1e-4

ll = reduce_360(lons - mlonmin)
junk = ll ge 0			;Look for 0 to 1 transition...
junk = junk - shift(junk,1)
junk = where(junk eq 1, count)
ixstart = junk(0)

junk = reduce_360(mlonmax-lons) gt 0
junk = junk - shift(junk,1)
junk = where(junk eq 255b, count)
ixend = junk(0)
if lons(ixend) gt mlonmax then ixend = (ixend+nx-1) mod nx
;print, 'lonmin, lonmax, ixstart, ixend = ', mlonmin, mlonmax, ixstart, ixend

;		Default ranges.
if  ixend le ixstart then nxx = ixend-ixstart + nx + 1 $
else nxx = ixend-ixstart+1
goodx = (lindgen(nxx) + ixstart) mod nx
if wrap and (not (hemis and equatorial)) and $
	reduce_360(mlonmax - mlonmin) eq 0.0 and $
	(goodx(0) ne goodx(nxx-1))then goodx = [goodx, goodx(0)]
goody = lindgen(ny)

if polar then goody = where(lats ge mlatmin and lats le mlatmax)
y = lons(goodx)

; This kludge takes care of the left edge being mapped on the right edge
if y(0) ge mlonmax then y(0) = reduce_360(y(0)+.0001)

nx1 = n_elements(goodx)
ny1 = n_elements(goody)
lo = y # replicate(1.0, ny1)
la = replicate(1.0, nx1) # lats(goody)

; Image elements we want
image1 = image_orig(goodx # replicate(1L,ny1) + replicate(nx,nx1) # goody)

scale = !d.flags and 1		;TRUE if device has scalable pixels

IF scale THEN BEGIN		;Fudge for postscript?
	scalef = 0.02		;PostScript scale factor
	scale_orig = [!x.s, !y.s]
	!x.s = !x.s * scalef
	!y.s = !y.s * scalef
ENDIF ELSE scalef = 1

;***** print,systime(1)-t0, ' seconds (before coord convers)'
		;Get XY device coords of data points
y = (convert_coord(lo, la, /data, /to_device))(0:1,*)

if scale then begin		;Restore scale
	!x.s = scale_orig(0:1) & !y.s = scale_orig(2:3)
	endif

x = reform(y(0,*), nx1, ny1)		;Back to nx by ny
y = reform(y(1,*), nx1, ny1)
;print, systime(1)-t0, ' seconds (after coord convers)'

xlim = !d.x_size * !x.window * scalef
ylim = !d.y_size * !y.window * scalef

good = (x gt xlim(0)) and (x lt xlim(1)) and (y gt ylim(0)) and (y le ylim(1))
if n_elements(max_value) gt 0 then good = good and (image1 le MAX_VALUE)
if n_elements(missing) le 0 then missing = 0
bad = where(good eq 0b, count)
;   print, count, ' bad elements'
good = where(good)

if keyword_set(triangulate) then begin  ;Make our own triangulation?
    if count gt 0 then begin
	x = x(good)
	y = y(good)
	image1=image1(good)
	count = 0
	endif
    triangulate, x, y, triangles
endif else begin		;Make a regular triangular grid
    i = (nx1-1) * 6			;Vertices / row
    t = lonarr(i, /NOZERO)
    triangles = lonarr(i, ny1-1,/NOZERO)
    ; Create 1st row of indices of triangular patches
    for i=0, nx1-2 do t(i*6) = [i,i+1,i,i,i+1,i+1] + [0,nx1,nx1,0,nx1,0]
    for iy=0L, ny1-2 do triangles(0,iy) = t + iy * nx1
      ;**** print,systime(1)-t0, ' seconds (Triangles)'
endelse

; Show grid structure.
if keyword_set(debug) then for i=0L, n_elements(triangles)/3-1 do begin
    t = triangles(i*3+[0,1,2,0])
    plots,x(t),y(t), /dev
    endfor

if count gt 0 then begin
	xstart = floor(min(x(good), max=maxx))
	ystart = floor(min(y(good), max=maxy))
	rect = [xstart, ystart, ceil(maxx), ceil(maxy)]
	good = float(image1)
	good(bad) = 1.0e12
	good = trigrid(x,y,good, triangles, [1.,1.], rect, MAX_VALUE=1.0e10, $
		MISSING = missing)
endif else begin
	xstart = floor(min(x, max=maxx))
	ystart = floor(min(y, max=maxy))
	rect = [xstart, ystart, ceil(maxx), ceil(maxy)]
	good = trigrid(x,y,image1, triangles, [1.,1.], rect, MISSING = missing)
endelse

xsize = ceil((rect(2) - rect(0))/scalef)
ysize = ceil((rect(3) - rect(1))/scalef)

xstart = long(xstart / scalef)
ystart = long(ystart / scalef)

;print,systime(1)-t0, ' seconds'
return, good
end
; $Id: map_set.pro,v 1.33 1995/06/28 19:19:27 dave Exp $
; Copyright (c) 1993-1994, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

FUNCTION map_uv_bounds, iproj
;
; Return the UV limits of the map, [umin, vmin, umax, vmax],
;	for the given projection.

  st = !map.sat(0) > 1.0
  st = sqrt((st-1.)/(st+1.))	;Map limit radius for satellite projection
  s2 = sqrt(2.0)
				;mercator limit in V @ map limit
  mvl = alog(tan((!map.out(5) < 89.9 > (-89.9)+ 90.)*!dtor/2.))
  mvll= alog(tan((!map.out(4) < 89.9 > (-89.9)+ 90.)*!dtor/2.))
;		This table contains the UV limits for each projection....
;         stereo(1-0)     ortho(2-1)	   conic(3-2)
;	    lamb(4-3)       gnomic(5-4)    azimuthal(6-5)
  bounds = [[-1.,-1.,1.,1.],    [-1.,-1.,1.,1.], [-180.,-1.,180.,1.], $
	    [-s2,-s2,s2,s2],[-2.,-2.,2.,2.], [-!pi,-!pi,!pi,!pi]]
;
;	    satell(7-6)   cylindrical(8-7) mercator(9-8)
;	    mollweide(10-9)  Sinusoidal(14-10)	   Aitoff(15-11)
  bounds = [[bounds],  $
           [-st,-st,st,st],[-180.,-90.,180.,90.],    [-!pi,mvll,!pi,mvl], $
           [-2.,-1.,2.,1.], [-!pi,-!pi/2.,!pi,!pi/2.], [-2.*s2,-s2,2.*s2,s2]]

;
;   Simple projections???
;
  k = iproj
  if iproj eq 18 or iproj eq 11 or iproj eq 12 or iproj eq 13 then k = iproj-3
  if k eq 15 then k = 11 $       ;Special case  Aitoff
  else if k eq 14 then k = 10 $  ;Sinusoidal
  else k = k - 1
  plimit = bounds(*,k)
;
;	SPECIAL CASE for tilted satellite proj:
;
  if iproj eq 7 and !map.sat(2) ne 0 then begin
    map_satellite_limit, 30, xr, yr
    plimit = [min(xr, max=xrmax), min(yr, max=yrmax), xrmax, yrmax]
    endif

return, plimit
END

pro map_satellite_limit, n, xr, yr
; Return n or less points, defining the limit of the limb of a satellite
; projection
    a = findgen(n) * (2 * !pi / (n-1))
    st = !map.sat(0) > 1.0
    st = sqrt((st-1.)/(st+1.))	;Map limit radius for satellite projection
    xr = cos(a) * st		;Taken from Snyder Pg. 175
    yr = sin(a) * st
    t = yr * !map.sat(5) + xr * !map.sat(4)
    a = t * !map.sat(2)/(!map.sat(0)-1.0) + !map.sat(3)
    good = where(a gt 0.0, count)
    if count lt n then begin	;Extract & shift so pnts on map are contiguous
	i0 = 0			;Get 1st good pnt following a bad pnt
	for i=1,count-1 do if good(i-1)+1 ne good(i) then i0 = i
	good = shift(good,-i0)
    endif
    t = t(good) & a = a(good)
    xr = (xr(good) * !map.sat(5) - yr(good) * !map.sat(4))*!map.sat(3)/a
    yr = t/a
end


pro map_horizon, FILL=fill, _EXTRA=Extra ;Draw/fill the horizon (limb) of a map

proj = !map.projection
if proj eq 5 or proj eq 3 then return	;Cant do gnomic or conic

p = map_uv_bounds(proj)
n = 360		;# of vertices
a = findgen(n+1) * (2 * !pi / n)

;		Projections that map to a circle or ellipse
;          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
circle = [ 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1]

if proj eq 7 and !map.sat(2) ne 0 then begin	;Satellite projection, tilted
    map_satellite_limit, 360, xr, yr
endif else if circle(proj) then begin		;Std circular projection
    xr = (p(2)-p(0))/2. * cos(a)
    yr = (p(3)-p(1))/2. * sin(a)
endif else if proj eq 14 then begin		;Sinusoidal
    flon = (!map.out(3)-!map.out(2))/360.
    xr = flon * !pi * cos(a)
    yr = fltarr(n+1)
    for i=0,n do case fix(a(i)/(!pi/2)) of
0:	yr(i) = a(i)
1:	yr(i) = !pi-a(i)
2:	yr(i) = !pi-a(i)
3:	yr(i) = a(i)-2*!pi
4:	yr(i) = 0.0		;Last pnt
	endcase
endif else begin		;Rectangular

  dx0= p(0)+findgen(n/4)*(p(2)-p(0))/(n/4.)
  dx1= replicate(p(2),(n/4))
  dx2= p(2)+findgen(n/4)*(p(0)-p(2))/(n/4.)
  dx3= replicate(p(0),(n/4))
  xr= [dx0,dx1,dx2,dx3,dx0(0)]

  dy0= replicate(p(1),(n/4))
  dy1= p(1)+findgen(n/4)*(p(3)-p(1))/(n/4.)
  dy2= replicate(p(3),(n/4))
  dy3= p(3)+findgen(n/4)*(p(1)-p(3))/(n/4.)
  yr= [dy0,dy1,dy2,dy3,dy0(0)]

;  xr = [p(0), p(2), p(2), p(0), p(0)]
;  yr = [p(1), p(1), p(3), p(3), p(1)]
endelse

!x.type=0			;Plot in UV space
if keyword_set(fill) then $
   polyfill, xr, yr, _EXTRA=Extra $
else plots, xr, yr, _EXTRA=Extra
!x.type=2
end

pro mapp_set, latmin, latmax, lonmin, lonmax, p0lon, p0lat, rot, $
	iproj, limit, t3d=t3d, zvalue=zvalue, $
	border = border, title = title, sat_p = sat_p,    $
	xmargin = xmargin, ymargin = ymargin, $
	position=position, color=color, isotropic = isotropic

!x.s = [0,1]		;normal coverage for uv plane
!y.s = [0,1]

if (n_elements(zvalue) eq 0) then zvalue = 0
if (n_elements(color)  eq 0) then $
    if (!d.flags and 512) ne 0 then color = 0 else color = !d.n_colors-1

dtor = acos(0.0d0)/90.			;Need a double precision !DTOR

if iproj eq 3 then begin		;Conic?
	!map.phioc = rot		;Parameter order is diff
	!map.p0lat = (p0lat + p0lon)/2.	;Center latitude
	if !map.p0lat lt 0.0 then !map.sino = -1 else !map.sino = 1
	chi1 = (90. - !map.sino * p0lat) * dtor
	if p0lat eq p0lon then !map.coso = cos(chi1) $
	else begin
	    chi2 = (90. - !map.sino * p0lon) * dtor
	    !map.coso = alog(sin(chi1)/sin(chi2))/ $
			alog(tan(0.5*chi1)/tan(0.5*chi2))
	    endelse
        !map.out(8)=p0lat * dtor	;Ucen
        !map.out(9)=p0lon * dtor	;Vcen
	goto, get_bounds
endif

;		Not conic, all other projections

x1 = rot   * dtor		; Need the extra precision -KDB 10/93
x2 = p0lat * dtor

if (iproj ge 8) then  BEGIN
 !map.out(8) = x1		;ucen
 !map.out(11) = x2		;vrng
ENDIF ELSE !map.out(8)=x2

!map.out(9) = p0lon * dtor	;vcen
sinr = sin(x1)			;Stash cos / sin of map center lat and rotation

;		Try to avoid round-off errors, test for special cases
if abs(rot) eq 90.0 then cosr = 0.0 else cosr = cos(x1)
if (p0lat mod 180.) eq 0.0 then sino = 0.0 else sino = sin(x2)
if abs(p0lat) eq 90.0 then coso = 0.0 else coso = cos(x2)
del1 = .0001
!map.sat = 0.0		;Clear satellite proj params

if iproj ge 8 and iproj ne 14 then begin   ;Cylindrical projections
  if (abs(p0lat) ge del1) or $	;Simple case?
	((abs(rot) ge del1) and (abs(abs(rot)-180.) ge del1))  THEN BEGIN
	sint = coso * cosr	;NO...  complicated case
	cost = sqrt(1.-sint*sint)
	tmp1 =  sinr / cost
	tmp2 =  sino / cost
	!map.phioc = p0lon - atan(tmp1, - cosr * tmp2) * !radeg
	sinr = tmp1 * coso
	cosr = -tmp2
	sino = sint
	coso = cost
  endif else begin		;Simple cases
	if abs(rot) lt del1 then sino = 1.0 else begin 
	   sino = -1.
	   !map.phioc = p0lon + 180.
	   endelse
	coso = 0.0
	sinr = 0.0
	cosr = 1.0
	!map.projection = iproj+3	;Make a simple projection
  endelse
endif			;Cylindrical projections

if iproj eq 7 then begin	;Special params for satellite projection.
	!map.sat(0) = sat_p(0)	;Salt = sat_p(0)
	    ;Save em.  sat(1) = TRUE for simple case (Vertical perspective)
	!map.sat(1) = (sat_p(1) eq 0.0) and (sat_p(2) eq 0.0)
	!map.sat(2) = sin(dtor * sat_p(1))	;Salpha = sat_p(1)
	!map.sat(3) = cos(dtor * sat_p(1))	;calpha
	!map.sat(4) = sin(dtor * sat_p(2))	;Sbeta = sat_p(2)
	!map.sat(5) = cos(dtor * sat_p(2))	;cbeta
	endif	

!map.coso =  coso
!map.sinr = sinr
!map.sino = sino
!map.cosr = cosr
if (iproj eq 2) then !map.sat(0) =0.


GET_BOUNDS:
IF n_elements(limit) lt 4 THEN BEGIN	;Explicit limits?
  plimit = map_uv_bounds(iproj)
  umin = plimit(0) & umax = plimit(2)
  vmin = plimit(1) & vmax = plimit(3)
ENDIF ELSE IF n_elements(limit) eq 4 and abs(p0lat) eq 90 and $
   (limit(3)-limit(1) ge 180.) then begin  ;Polar?
				;Special case for polar projections
  p0 = convert_coord(limit(1), p0lat, /to_norm, /data)  ;Center
  umin = p0(0) & umax=umin
  vmin = p0(1) & vmax = vmin
  if p0lat eq 90 then lat = limit(0) else lat = limit(2)  ;Other latitude
  del = (lonmax-lonmin)/16. < 15.0
  for lon=float(lonmin), lonmax, del do begin
	p0 = convert_coord(lon, lat, /to_norm, /data) ;Edges
	if max(!map.out(0:1)) ge 1e3 then message, $
		'Map_set, limit point not mappable, lat,lon='+ $
		strtrim(lat,2) + ',' + strtrim(lon,2)
	umin = umin < p0(0) & umax = umax > p0(0)
	vmin = vmin < p0(1) & vmax = vmax > p0(1)
	endfor  
ENDIF ELSE BEGIN  			;4 or 8 element limit specified

;	8 point limit:
; limit =  [ lat0, lon0, lat1, lon1, lat2, lon2, lat3, lon3] specify
; four points on the map which give, respectively,
; the leftmost, topmost, rightmost, and bottom
; most points to be shown.

; 	4 point limit:
; limit = [latmin, lonmin, latmax, lonmax]
;  Get the rectangular coordinates of the limit.
	if n_elements(limit) eq 8 then begin
	    x = convert_coord(limit(1), limit(0), /TO_NORM, /DATA)
	    umin = !map.out(0)		;Left
	    x = convert_coord(limit(3), limit(2), /TO_NORM, /DATA)
	    vmax = !map.out(1)		;top
	    x = convert_coord(limit(5), limit(4), /TO_NORM, /DATA)
	    umax = !map.out(0)		;Right
	    x = convert_coord(limit(7), limit(6), /TO_NORM, /DATA)
	    vmin = !map.out(1)		;bottom
	    if (max([umin, vmax, umax, vmin]) gt 1.0e3) then $
		message, 'Map_set, limit point not mappable.', /CONTINUE
	endif else begin		;4 Point limit
;		Cover the four corners + the midpoints.
	    lat0 = (limit(0)+limit(2))/2.  ;Midpoints
	    lon0 = (limit(1)+limit(3))/2.
	    lats = [ limit([0,0,0]), lat0, limit([2,2,2]),lat0]
	    lons = [ limit(1), lon0, limit([3,3,3]), lon0, limit([1,1])]
	    umin=1.0e12
	    umax=-1.0e12
	    vmin = umin
	    vmax = umax
	    for i=0,7 do begin		;Use 4 corners + midpoints
		x = convert_coord(lons(i), lats(i), /TO_NORM, /DATA)
;********* print, lons(i), lats(i), !map.out(0:1)
		if max(!map.out(0:1)) ge 1e3 then $
		    message, 'Map_set, limit point not mappable, lat,lon='+ $
		      strtrim(lats(i),2) + ',' + strtrim(lons(i),2), /CONTINUE $
		else begin
		  umin = !map.out(0) < umin
		  umax = !map.out(0) > umax
		  vmin = !map.out(1) < vmin
		  vmax = !map.out(1) > vmax
		endelse
	        endfor
	endelse			;4 point limit
ENDELSE

if iproj eq 3 then  BEGIN		;Set tolerance for detecting wraps.
   ueps = 135.				;Conic?
   umin = umin / 180.			;Scale to units of pi
   umax = umax / 180.
endif else ueps = 0.75 * ABS(umax-umin)
veps = 0.75 * ABS(vmax-vmin)
plimit = [umin, vmin, umax, vmax]

!map.out(6) = ueps
!map.out(7) = veps

if n_elements(xmargin) ne 2 THEN xmargin = [1,1]
if n_elements(ymargin) ne 2 THEN ymargin = [1,2]
if not N_Elements(title) THEN title =" "

fudge = 0.01			;was 0.01
eps = (umax - umin) * fudge		;Extend the axes by a Fudge factor
umax = umax + eps
umin = umin - eps
eps = (vmax - vmin) * fudge
vmax = vmax + eps
vmin = vmin - eps

; print, umin, vmin, umax, vmax
;
; This establishes the plot scaling between uv coordinates and the 
;  plot range.

if keyword_set(position) then  $
    plot, [umin,umax], [vmin,vmax], xsty=5, ysty=5, /nodata,    $
	title=title, /noerase, position=position $
else begin			;Position not set
    plot, [umin,umax], [vmin,vmax], xsty=5, ysty=5, /nodata,    $
         xmargin= xmargin, ymargin= ymargin, title=title, /noerase
endelse

if keyword_set(isotropic) then begin
    aspect = !d.x_size*(!x.window(1)-!x.window(0))/(plimit(2)-plimit(0))/$
	(!d.y_size * (!y.window(1)-!y.window(0))/(plimit(3)-plimit(1)))
    if aspect gt 1 then begin	;Fudge to make isotropic
	   !x.s(1) = !x.s(1)/aspect	;Make narrower
	   t = .5*(1.-1./aspect) * (!x.window(1)-!x.window(0))	;Width
	   !x.window = !x.window + [t,-t]
	   !x.s(0) = !x.window(0) - umin * !x.s(1)
	   !p.clip([0,2]) = !x.window * !d.x_size
	endif else begin
	   !y.s(1) = !y.s(1)*aspect
	   t = .5 * (1.-aspect) * (!y.window(1)-!y.window(0))  ;Height
	   !y.window = !y.window + [t,-t]
	   !y.s(0) = !y.window(0) - vmin * !y.s(1)
	   !p.clip([1,3]) = !y.window * !d.y_size
	endelse
endif			;Isotropic

!x.type = 2			;Reset mapping type
if keyword_set(border) then  $
	plots ,!x.window([0,1,1,0,0]), color=color,   $
	       !y.window([0,0,1,1,0]), zvalue, /norm, /noclip, t3d=t3d
end



function map_grid_incr, span

if span eq 0 then return, 45.
ipow = 0
t = span < 450.
while t lt 5 do begin t = t * 10 & ipow = ipow +1 & endwhile
increments = [ 1., 2., 4., 5., 10., 15., 30., 45.]
i = 0
while t gt (increments(i) * 10) do i = i + 1
return, increments(i) / 10^ipow
end


pro map_grid, label=label,  latdel = latdel, no_grid=no_grid, zvalue=zvalue,$
       londel=londel, glinestyle = glinestyle, glinethick = glinethick,   $
       color = color, lonlab = lonlab, latlab = latlab, lonalign = lonalign,$
       latalign = latalign, charsize = charsize, t3d=t3d, $
	whole_map=whole_map
;
; Put a grid on a previously established map projection.
;
if (!x.type NE 2) THEN $  ; make sure we have mapping coordinates
   message, 'map_grid---Current ploting device must have mapping coordinates'

; no grid? - in case someone wants just to put labels
if not keyword_set(no_grid) then no_grid = 0

if n_elements(zvalue) eq 0 then zvalue = 0

; Get lat/lon ranges from !MAP
lonmin = !map.out(2) & lonmax1 = !map.out(3)
if lonmax1 le lonmin then lonmax1 = lonmax1 + 360.
latmin = !map.out(4) & latmax = !map.out(5)

if n_elements(t3d) le 0 then t3d = 0

if n_elements(latdel) eq 0 then latd = 1 else latd = latdel
if n_elements(londel) eq 0 then lond = 1 else lond = londel

; if WHOLE_MAP specified, or the deltas are < 1,
; do not convert the limits into integers
if (not keyword_set(whole_map)) then begin
   if abs(latmax - latmin) gt 5. and latd ge 1 then begin ;Make range integers
	latmin = float(floor(latmin))
	latmax = ceil(latmax)
	endif
   if abs(lonmax1 - lonmin) gt 5 and lond ge 1 then begin
	lonmin = float(floor(lonmin))
	lonmax1 = ceil(lonmax1)
;;	!map.out(3) = lonmax1 	;Save it...
	endif
endif

			;Default grid spacings...
if n_elements(latdel) eq 0 then latdel = map_grid_incr(latmax-latmin)
if n_elements(londel) eq 0 then londel = map_grid_incr(lonmax1-lonmin)

if N_Elements(glinestyle) EQ 0 THEN glinestyle =1
if N_Elements(glinethick) EQ 0 THEN glinethick =1

if n_elements(color) le 0 then begin	;Default color?
	if (!d.flags and 512) ne 0 then color = 0 else color = !d.n_colors-1
	endif

if N_Elements(label) NE 0 OR (N_ELEMENTS(Latlab) ne 0) $
	OR (N_Elements(LonLab) NE 0) THEN BEGIN
	printno = 1  
	printno2 = 1
	if N_Elements(Latlab) eq 0 THEN Latlab = (lonmin + lonmax1)/2
	if N_ELements(LonLab) eq 0 THEN LonLab = (latmin +latmax)/2
endif ELSE BEGIN
	printno = -1
	printno2 = -1
ENDELSE
                                    ; of grid numbers
if n_elements(latalign) eq 0 THEN latalign = .5	;Text alignment of lat labels
if n_elements(lonalign) eq 0 THEN lonalign = .5 ;Text alignment of lon labels
if n_elements(charsize) eq 0 THEN charsize =  1

step = 4 < (latmax - latmin)/10.
len = long((latmax-latmin) / step + 1)
lati = (float(latmax-latmin) / (len-1.)) * findgen(len) + latmin   ;lats


First = 1

for lon = lonmin, lonmax1, londel do begin
    if (lon lt -180) then lon2 =lon +360  $
    	else if (lon gt 180) then lon2 = -360 +lon $
    	else lon2 = lon
    pres = convert_coord(lon, latmin,/to_norm)
    pres = !map.out(0:1)
    pres1 = convert_coord(lon, latmax,/to_norm)
    pres1 = !map.out(0:1)
    lon1 = lon
    if First eq 1  THEN First = 0 else $
      if abs(pres(0) - past(0)) GE !map.out(6)   OR  $
         abs(pres(1) - past(1)) GE !map.out(7)   OR  $
         abs(pres1(0) - past1(0)) GE !map.out(6) OR  $
         abs(pres1(1) - past1(1)) GE !map.out(7)     $
      THEN BEGIN
       if(lon ge 0) then dd = .0001 else dd = -.0001
       lon1 = lon - dd
      ENDIF  
    past = pres
    past1 = pres1
    
    if (not no_grid) then plots, lon1, lati, zvalue, $
	color = color, t3d=t3d, NOCLIP=0,linestyle=glinestyle,thick=glinethick

    if lon2 ne long(lon2) then fmt = '(f7.2)' else fmt = '(i4)'
    if (printno eq 1) and $  ;Dont repeat -180....
	((lonmin ne -180) or (lonmax1 ne 180) or (lon ne -180)) then $
	xyouts,lon, LonLab, z=zvalue, ali=lonalign, t3d=t3d, color=color,$
          strtrim(string(lon2,format=fmt),2), charsize = charsize
    printno  = 1 - printno
 endfor

step = 4 < (lonmax1 - lonmin)/10.
len = (lonmax1-lonmin)/step + 1
loni = findgen(len)*step + lonmin

if (loni(len-1) NE lonmax1) THEN  BEGIN
    loni = [loni, lonmax1]
    len = len + 1
ENDIF

for lat = float(latmin), latmax, latdel do begin
   if lat ne long(lat) then fmt = '(f7.2)' else fmt = '(i4)'
   if printno2 eq 1 then xyouts,latlab,lat, z=zvalue, ali=latalign, t3d=t3d, $
	strtrim(string(lat, format=fmt),2), charsize = charsize, color=color
   printno2 = 1 - printno2
   if (not no_grid) then plots,loni, lat, zvalue, $
	NOCLIP=0,linestyle=glinestyle,color = color, thick=glinethick, t3d=t3d
 endfor
;    !map.out(5) = latmax

end

PRO map_limits, latmin, latmax, lonmin, lonmax, p0lon,p0lat, iproj, Rot
;
;  Sets map limits if none are specified...
;

if iproj eq 3 then begin	;Conic???
    lonmin = Rot - 180.
    lonmax = Rot + 180.
ENDIF ELSE BEGIN		;Not Conic
    lonmin = P0lon - 180.
    lonmax = P0lon + 180.
    latmax  = 90.
    latmin = -90.
ENDELSE

;
;stereo, ortho, lambert (covers a hemisphere) ??
;
if iproj eq 1 or iproj eq 2 or iproj eq 4 THEN BEGIN
    if p0lat eq 0.0 then begin	;Equatorial?
	lonmax = p0lon + 90 	;center on p0lon
	lonmin = p0lon - 90
    endif else begin		;Center on latitude
	latmin = p0lat - 90. > (-90.)
	latmax = p0lat + 90. < 90.
    endelse
endif			;Hemispheric coverage.

IF iproj eq 5 THEN BEGIN		;gnomic
  if p0lat eq 0.0 then BEGIN ; center on equator
	lonmax = p0lon + 60
	lonmin = p0lon - 60
	latmin = p0lat - 60
	latmax = p0lat + 60
	ENDIF
  if p0lat eq 90.0  then  begin
	latmin = 30
	latmax = 90.0
	ENDIF
  IF p0lat eq -90.0 then BEGIN
	latmin = -90.0
	latmax = -30.0
	ENDIF
  ENDIF					;Gnomic

IF iproj eq 3 THEN BEGIN		;Conic
	sgn = (p0lat ge 0) * 2 - 1	; + 1 or -1
	t0 = sgn * 15.
	t1 = sgn * 75.
        latmin = t0 < t1
        latmax = t0 > t1
        lonmin = -180. + Rot
        lonmax = 180.  + Rot
	ENDIF				;Conic

IF iproj eq 9 or iproj eq 12 THEN BEGIN  ;mercator, merc/simple
	latmin = -80
	latmax = 80
	ENDIF

;		Reduce longitudes
 while lonmin gt 180.    do lonmin = lonmin - 360.
 while lonmin lt (-180.) do lonmin = lonmin + 360.
 while lonmax gt 180.    do lonmax = lonmax - 360.
 while lonmax lt (-180.) do lonmax = lonmax + 360.
; Wrap around?  Allow for round-off.
 if (lonmax-1.0e-5) lt lonmin then lonmax = lonmax + 360.
;;;;;; *************** print,lonmin, lonmax
END


pro map_set, p0lat, p0lon, rot, proj = proj, $
	CYLINDRICAL = cyl,      MERCATOR = merc,  $
	MOLLWEIDE = moll,       STEREOGRAPHIC = stereo,  $
        ORTHOGRAPHIC = ortho,   Conic = cone,            $
	LAMBERT = lamb,         GNOMIC = gnom,           $
        AZIMUTHAL = azim,       SATELLITE = satel,       $
        SINUSOIDAL = sinu,      AITOFF = aitoff,          $
  latdel = latdel, londel = londel, limit = limit,       $
  Sat_P = Sat_p, title = title, noborder = noborder,        $
  noerase = noerase, label = label, $
  glinestyle = glinestyle, glinethick=glinethick,       $
  mlinestyle=mlinestyle, mlinethick=mlinethick,		$
  color = color, con_color = con_color,hires=hires,     $
  continents = continents, grid = grid, xmargin = xmargin, $
  ymargin = ymargin, lonlab = lonlab, latlab = latlab, $
  lonalign = lonalign, latalign = latalign, charsize = charsize, $
  advance = advance, usa=usa, t3d=t3d, position=position, zvalue=zvalue, $
  whole_map = whole_map, isotropic = isotropic, horizon = horizon
;+NODOCUMENT
; NAME:
;      map_set
; PURPOSE:
;        The procedure map_set establishes
;        the axis type and coordinate conversion mechanism
;        for mapping  points on the earth's surface, expressed
;        in latitude and longitude, to points on a plane, according
;        to one of ten possible map projections. The user may 
;        may select the map projection, the map center, polar rotation
;        and geographical limits.
;
;        The user may request map_set to plot the
;        graticule and continental boundaries by setting
;        the keywords Grid and Continent.
;
; CATEGORY:
;           Mapping
; CALLING SEQUENCE:
;                 map_set, p0lat, p0lon, rot, proj = proj,            $
;              	     CYLINDRICAL = cyl,      MERCATOR = merc,         $
;   	             MOLLWEIDE = moll,       STEREOGRAPHIC = stereo,  $
;                    ORTHOGRAPHIC = ortho,   Conic = cone,            $
;   	             LAMBERT = lamb,         GNOMIC = gnom,           $
;                    AZIMUTHAL = azim,       SATELLITE = satel,       $
;                    SINUSOIDAL = sinu,      AITOFF  = aitoff,         $
;                    latdel = latdel, londel = londel, limit = limit, $
;                    Sat_p = Sat_p, $
;                     title = title, noborder = noborder, $
;                    noerase = noerase, label = label,                $
;                    glinestyle = glinestyle, glinethick=glinethick,  $
;                    mlinestyle=mlinestyle, mlinethick=mlinethick,    $
;                    color = color, con_color = con_color, 	      $
;		     continents = continents, grid = grid, lonlab = lonlab,$
;                    latlab = latlab, lonalign = lonalign,           $
;                    latalign = latalign, charsize = charsize,hires=hires
;
; OPTIONAL INPUT:
;               P0lat--- For all but Lambert's conformal conic projection
;                        with two standard parallels, P0lat should be set
;                        to the latitude of the point on the earth's surface
;                        to be mapped to the center of the projection plane.
;                        If the projection type is sinusoidal, P0lat must be
;                        0. -90 <= P0lat <= 90. If P0lat is not set, the
;                        default value is 0. If the user has selected
;                        Lambert's conformal conic projection with two
;                        standard parallels, P0lat should be set to the
;                        latitude in degrees of one of the parallels.
;                        If not both P0lat and P0lon are defined, P0lat is
;                        20 by default.
;
;               P0lon--- For all but Lambert's conformal conic projection with
;                        two standard parallels, P0lon should be set
;                        by the user to the longitude of the point on the
;                        earth's surface to be mapped to the center of
;                        the map projection. -180 <= P0lon <= 180. If P0lon
;                        is not set, the default value is zero.
;
;              Rot-----  The user should set the argument Rot to the angle
;                        through which the North direction should be
;                        rotated around the line L between the earth's center
;                        and the point (P0lat, P0lon). Rot is measured in 
;                        degrees with the positive direction being clockwise
;                         rotation around L. Default value is 0.
;
; KEYWORDS:
;
;         Advance       = if set, advance to the next frame, when finished,
;			  when there are multiple plots on the screen.
;         Azimuthal     = azimuthal equidistant projection
;         Conic         = Conic projection
;         Cylindrical   = cylindrcal equidistant projection
;         Gnomic        = gnomonic projection
;         Lambert       = Lambert's equal area projection
;         Mercator      = Mercator's projection
;         Mollweide     = Mollweide type projection
;         Orthographic  = Orthographic projection
;	  Satellite	= Satellite (General perspective) projection
;         Sinusoidal    = sinsoidal projection
;         Stereographic = stereographic projection
;         Aitoff        = Aitoff's projection
;         charsize      = size of characters in labels.
;         Color         = color of the map boundary.
;	  con_color	= color of continents.
;         Continents    = flag to signal that continental boundaries
;                         should be drawn.         
;         Glinestyle    = linestyle of gridlines. (default = 1 = dotted)
;         Glinethick    = thickness of gridlines. (default = 1 = normal)
;         Grid          = flag to signal that gridlines should be drawn.
;	  Horizon	= if set, draw the horizon (limb) around the map.
;	  Isotropic	= if set, map will be made isotropic and 
;			  X and Y will have a 1:1 aspect ratio.
;         Label         = flag to signal labeling of parallels and 
;                         meridians in the grid.
;
;         latalign     = the aligment of the text baseline for
;                        latitude labels. A value of 0.0 left justifies
;                        the label, 1.0 right justifies it and
;                         0.5 centers. The default value is .5.
;                         
;         Latdel        = if set, spacing of parallels drawn on grid. 
;			  Default is 10 <  (latmin - latmax) / 10).
;         LatLab       =  if set, longitude at which to place latitude
;                         labels. Default is longitude of center.
;         Limit         =  A four or eight element vector.
;			  If a four element vector, [Latmin, Lonmin, Latmax,
;                          Lonmax] specifying the boundaries of the region
;                          to be mapped. (Latmin, Lonmin) and (Latmax,
;                          Lonmax) are the latitudes and longitudes of
;                          two diagonal points on the boundary with
;                          Latmin < Latmax and Lonmin < Lonmax.
;			   For maps that cross the international dateline,
;			   specify west longitudes as angles between
;			   180 and 360.
;			  If an eight element vector: [ lat0, lon0, 
;			    lat1, lon1, lat2, lon2, lat3, lon3] specify
;			    four points on the map which give, respectively,
;			    the location of a point on the left edge, 
;			    top edge, right edge, and bottom edge of
;			    the map extent.
;         lonalign     = the aligment of the text baseline for
;                        longitude labels. A value of 0.0 left justifies
;                        the label, 1.0 right justifies it and
;                         0.5 centers it. Default value is .5.
;        Londel         = if set, spacing of meridians drawn on grid.
;                         Y axis, and the screen border
;        LonLab       =  if set, latitude at which to place longitude
;                         labels. Default is longitude of center.
;        Mlinethick     = thickness of continental boundaries. Default is 1.
;        Mlinestyle     = linestyle of continental boundaries. Default is
;                         0 = normal.
;        Noborder       = if set, no border is drawn around the map.
;        Noerase        = flag to signal that map_set should not erase the
;                         current plot window. Default is to erase.
; 
;	Position	= Optional POSITION keyword for PLOT to specify the
;			  location of the map in the drawing area. See manual.
;	Sat_p		= an three element array of additional parameters
;			  required by the satellite projection.  The parameters
;			  are:  [ P, omega, gamma], where:  P = distance of
;			  viewpoint from center of globe, in units of the 
;			  globe's radius (P may be negative).
;			  Gamma = rotation of 
;			  projection plane clockwise from north.
;			  Omega = downward tilt of the 
;			  viewing plane in degrees.  The
;			  projection plane is first rotated gamma degrees 
;			  clockwise from north, and then tilted down
;			  omega degrees.  If both gamma and omega are zero,
;			  a Vertical Perspective projection results.
;	T3D 		= 1 to use the existing 3D transformation, 0 
;			  or omitted for normal.
;       Title           = Title of plot to be centered over plot window.
;       XMargin         = if set, a two element vector that specifies
;                         in character units the vertical margin between
;                         the map and the screen border.
;       YMargin         = if set, a two element vector that specifies
;                         in character units the horizontal margin between
;                         the map and the screen border.
;       Usa             = If set draw the state boundries
;	zvalue		= This keyword goes with T3D and specifies
;			  the height of the mapping plane.
;	whole_map	= in some cases where the limit is small, the gridlines
;			  will not cover the whole map.  This keyword can be
;			  specified to eliminate that problem.
;       hires           = Use the High Resolution CIA database for
;                         drawing the continents. Use map_continents to
;                         get the rivers, coasts, & boundaries
;
; Modification history:
;			Written, Ann Bateson, 1991
;	SMR, 10-'91	Added a check for additional satelite parameters
;			   when /SATELITE is set.
;       UCSB, ESRG,5-92 Added USA flag to check and map state boundries
;	DMS,  6-92	Fixed bug that incorrectly printed grid values with
;				small lat/lon ranges.
;	DMS, 8-92	Added 8 element lat/lon keyword, fixed problems
;				with Satellite, conics with 1 std parallel,
;				smaller and/or wierd maps
;	DMS, 3-93	Extended axes by a fudge factor, improved labelling.
;	JIY, 4-93	Added ZVALUE keyword to work with T3D.
;			Added NO_GRID keyword to MAP_GRID for displaying
;			labels only.
;			Added WHOLE_MAP keyword to make the gridlines cover
;			the entire map area when the limit is small
;			COLOR now works with map border and labels.
;   	KDB, 10-93	Fixed bug that would cause divide by zero errors
;			when P0lat was small and Rot equal to 0.0.
;       KDB,  5-94	Removed FONT=0 from plot calls. All vector fonts
;			can now be used. Font selection now depends on 
;			the value of !p.font
;	DMS, 6-94	Added HORIZON and ISOTROPIC keywords.  Cleaned
;			up a lot of logic.  Limits for maps of the entire
;			globe are done more cleanly and a lot quicker.
;       MWR, 12-94	Automatically create a window if !D.WINDOW=-1.
;			Calculations for [XY]MARGIN depend on valid !D values.
;       SVP,  2-95      Changed to CIA World Maps, added HIRES KEYWORD
;                       Also added Rivers, Coasts, Polygons, and Countries
;                       Thanks Thomas.
;-
;
; !Map.out coorespondence:
;  float p, q;			/* (0,1) u,v coordinates of last point */
;  float umin, umax;		/* (2,3) longitude min & max.  umin represents
;				   the longitude on the left edge of the
;				   map and is always <= umax. umin may equal
;				   umax for whole globe coverage.  */
;  float vmin, vmax;		/* (4,5) latitude min & max */
;  float ueps, veps;		/* (6,7) Epsilon for wrap-around detection */
;  float ucen, vcen;		/* (8,9) Center & rotation.. */
;  float UNUSED, vrng;		/* (10,11) Center latitude */

on_error, 2

multi_save = !p.multi(0)

; Set Hires to zero if not called
if not keyword_set(hires) then hires=0
;  Determine the projection
if n_elements(proj) ne 0 then iproj = proj $        
  else if keyword_set(stereo) then iproj =1 $
  else if keyword_set(ortho ) then iproj =2 $
  else if keyword_set(cone  ) then iproj =3 $
  else if keyword_set(lamb  ) then iproj =4 $
  else if keyword_set(gnom  ) then iproj =5 $
  else if keyword_set(azim  ) then iproj =6 $
  else if keyword_set(satel ) then iproj =7 $
  else if keyword_set(merc  ) then iproj =9 $
  else if keyword_set(moll  ) then iproj =10 $
  else if keyword_set(sinu  ) then iproj =14 $
  else if keyword_set(aitoff) then iproj =15 $
  else iproj=8		                         	;Assume cylindrical

IF (iproj eq 7) and (NOT(KEYWORD_SET(sat_p))) THEN $
    MESSAGE, "Satellite parameters must be set for satellite projection."

border = keyword_set(noborder) eq 0

; Supply defaults for p0lat p0lon = center of projection.
if iproj eq 3 then $		;Conic?
   if n_elements(p0lat) eq 0 or n_elements(p0lon) eq 0 then begin
	p0lat = 20.
	p0lon = 60.
   endif

if n_elements(p0lat) eq 0 then p0lat = 0.0
if n_elements(p0lon) eq 0 then p0lon = 0.0

if abs(p0lat) gt 90.0 then $
   message,'Latitude must be in range of +/- 90 degrees'
if abs(p0lon) gt 360.0 then $
   message,'Longitude must be in range of +/- 360 degrees'

IF n_elements(limit) eq 4 then BEGIN
	latmin = limit(0) & latmax = limit(2)
	lonmin = limit(1) & lonmax = limit(3)
ENDIF ELSE if n_elements(limit) eq 8 then BEGIN
	latmin = min([limit([0,2,4,6]), p0lat], max=latmax)
	lonmin = min([limit([1,3,5,7]), p0lon], max=lonmax)
ENDIF

if !P.multi(0) eq 0 and keyword_set(advance) then erase

if n_elements(rot) eq 0 then rot = 0.	;Default rotation
if n_elements(t3d) le 0 then t3d = 0

IF (iproj eq 14) THEN BEGIN		;Sinusoidal must have rot=0, p0lat=0
    if P0lat NE 0 THEN  $
      message,'MAP_SET--- Sinusoidal projection must have P0lat = 0',/CONT
    if Rot NE 0 THEN   $
      message,'MAP_SET--- Sinusoidal projection must have Rot = 0',/CONT
ENDIF


; Need to create a new window if the currect graphics device is
; X and there are no valid windows.  Subsequent calculations for
; [XY]MARGIN depend on current and valid values in !D.

IF (!D.WINDOW EQ -1) AND ((!D.FLAGS and 256) ne 0) THEN WINDOW

if KEYWORD_SET(xmargin) THEN BEGIN	;Check for margins > screen
   csize = !d.X_SIZE/!d.X_CH_SIZE	;1/Char width in normalized units
   if total(xmargin) gt csize THEN message,'map_set--- xmargin too large'
ENDIF

IF KEYWORD_SET(ymargin) THEN BEGIN
   csize = !d.Y_SIZE/!d.Y_CH_SIZE
   if total(ymargin) gt csize THEN message,'map_set--- ymargin too large'
ENDIF

!map.projection = iproj		;Set mapping parameters
!x.type = 2			;Indicates map transform
!map.phioc = p0lon		;Save Center longitude /lat for internals
!map.p0lat = p0lat

if (not KEYWORD_SET(noerase)) and (not KEYWORD_SET(advance)) THEN erase

if (N_Elements(limit) ne 4) and (N_Elements(limit) ne 8) then $
	map_limits, latmin, latmax, lonmin, lonmax, p0lon, p0lat, iproj, Rot

!map.out(2) = lonmin	& !map.out(3) = lonmax
!map.out(4) = latmin	& !map.out(5) = latmax

mapp_set,latmin,latmax,lonmin,lonmax,p0lon,p0lat,rot,iproj, limit,  $
      border=border, title =title, sat_p = sat_p, xmargin = xmargin, $
      ymargin = ymargin, t3d=t3d, position = position, zvalue=zvalue, $
      color=color, Isotropic = isotropic

if keyword_set(grid) or keyword_set(label) then $		;Grid?
	map_grid, label=label, latdel=latdel, zvalue=zvalue, $
          londel = londel , glinestyle = glinestyle, $
          glinethick = glinethick, color = color, latlab = latlab,$
          lonlab = lonlab, lonalign = lonalign, latalign = latalign, $
          charsize = charsize, t3d=t3d, whole_map=whole_map, $
	  no_grid = (not keyword_set(grid))

if keyword_set(horizon) then map_horizon, color=color

if keyword_set(continents) then begin		;Continents?
	if n_elements(con_color) le 0 then begin
	    if n_elements(color) gt 0 then con_color = color $
		else begin
		  if (!d.flags and 512) ne 0 then color = 0 $
		    else color = !d.n_colors-1
		endelse
        endif		;con_color
	    map_continents,color=con_color,t3d=t3d,hires=hires, $
             continents=continents,mlinestyle=mlinestyle, $
             mlinethick=mlinethick,zvalue=zvalue
endif

if keyword_set(usa) ne 0 then $			;US State outlines?
        map_continents, color = con_color, t3d=t3d, $
        mlinestyle = mlinestyle, mlinethick = mlinethick, us=usa, zvalue=zvalue

if KEYWORD_SET(ADVANCE) and !P.Multi(0) gt 0 THEN $
     !P.Multi(0) = !P.Multi(0) - 1 $
else !p.multi(0) = !p.multi(1) * !p.multi(2) - 1
       
RETURN
END
;$Id: m_correlate.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       M_CORRELATE
;
; PURPOSE:
;       This function computes the multiple correlation coefficient of a
;       dependent variable and two or more independent variables.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE: 
;       Result = M_correlate(X, Y)
;                           
; INPUTS:
;       X:    An array of m-columns and n-rows of type integer, float or double
;             that specifies the independent variable data. The columns of this
;             two dimensional array correspond to the n-element vectors of 
;             independent variable data.
;
;       Y:    An n-element vector of type integer, float or double that
;             specifies the dependent variable data.
;
; EXAMPLE:
;       Define the independent (X) and dependent (Y) data.
;         X = [[0.477121, 2.0, 13.0], $
;              [0.477121, 5.0,  6.0], $
;              [0.301030, 5.0,  9.0], $
;              [0.000000, 7.0,  5.5], $
;              [0.602060, 3.0,  7.0], $
;              [0.698970, 2.0,  9.5], $
;              [0.301030, 2.0, 17.0], $
;              [0.477121, 5.0, 12.5], $
;              [0.698970, 2.0, 13.5], $
;              [0.000000, 3.0, 12.5], $
;              [0.602060, 4.0, 13.0], $
;              [0.301030, 6.0,  7.5], $
;              [0.301030, 2.0,  7.5], $
;              [0.698970, 3.0, 12.0], $
;              [0.000000, 4.0, 14.0], $
;              [0.698970, 6.0, 11.5], $
;              [0.301030, 2.0, 15.0], $
;              [0.602060, 6.0,  8.5], $
;              [0.477121, 7.0, 14.5], $
;              [0.000000, 5.0, 9.5]]
;
;          Y = [97.682, 98.424, 101.435, 102.266,  97.067,  97.397, 99.481, $
;               99.613, 96.901, 100.152,  98.797, 100.796,  98.750, 97.991, $
;              100.007, 98.615, 100.225,  98.388,  98.937, 100.617]
;
;       Compute the multiple correlation of Y on the first column of X.
;       The result should be 0.798816
;         result = m_correlate(X(0,*), Y)
;
;       Compute the multiple correlation of Y on the first two columns of X.
;       The result should be 0.875872
;         result = m_correlate(X(0:1,*), Y)
;
;       Compute the multiple correlation of Y on all columns of X.
;       The result should be 0.877197
;         result = m_correlate(X, Y)
;         
; PROCEDURE:
;       M_CORRELATE uses relationships based upon partial correlation to
;       compute the multiple correlation coefficient of linear models with
;       two or more independent variables: y(x0, x1), y(x0, x1, ... , xn-1).   
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Written by:   GGS, RSI, July 1994
;-

function  m_correlate, x, y

  on_error, 2  ;Return to caller if an error occurs.

  sx = size(x)

  if sx(0) ne 2 then $
    message, 'x must be two-dimensional array.'
  if sx(2) ne n_elements(y) then $ 
    message, 'x and y have incompatible dimensions.'

  nvars = sx(1) ;Number of independent variables (columns of x).

  comd = (1 - correlate(x(0,*), y)^2)

  for k = 0, nvars-2 do $
    ;Compute the Coefficient of Multiple Determination using a product
    ;of partial correlations.
    comd = comd * (1 - p_correlate(transpose(x(k+1,*)), y, x(0:k,*))^2)
 
    ;For example:
    ;The Coefficient of Multiple Determination for a model with 5 
    ;independent parameters y(x0, x1, x2, x3, x4) is computed as:
    ;comd = (1 - correlate(x(0,*), y)^2) * $
    ;       (1 - p_correlate(transpose(x(1,*)), y, x(0,*))^2)   * $
    ;       (1 - p_correlate(transpose(x(2,*)), y, x(0:1,*))^2) * $
    ;       (1 - p_correlate(transpose(x(3,*)), y, x(0:2,*))^2) * $
    ;       (1 - p_correlate(transpose(x(4,*)), y, x(0:3,*))^2)  

  return, sqrt(1 - comd)

end
;$Id: md_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       MD_TEST
;
; PURPOSE:
;       This function tests the hypothesis that a sample population
;       is random against the hypothesis that it is not random. The 
;       result is a two-element vector containing the nearly-normal
;       test statistic Z and the one-tailed probability of obtaining
;       a value of Z or greater. This test is often refered to as the
;       Median Delta Test.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = MD_test(X)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
;   ABOVE:    Use this keyword to specify a named variable which returns
;             the number of sample population values greater than the
;             median of X.
;
;   BELOW:    Use this keyword to specify a named variable which returns
;             the number of sample population values less than the
;             median of X.
;
;     MDC:    Use this keyword to specify a named variable which returns
;             the number of Median Delta Clusters; sequencial values of
;             X above and below the median.
;
; EXAMPLE:
;       Define a sample population.
;         x = [2.00,  0.90, -1.44, -0.88, -0.24,  0.83, -0.84, -0.74,  0.99, $
;             -0.82, -0.59, -1.88, -1.96,  0.77, -1.89, -0.56, -0.62, -0.36, $
;             -1.01, -1.36]
;
;       Test the hypothesis that X represents a random population against the
;       hypothesis that it does not represent a random population at the 0.05
;       significance level.
;         result = md_test(x, mdc = mdc)
;
;       The result should be the 2-element vector:
;         [0.722745, 0.234918]
;
;       The computed probability (0.234918) is greater than the 0.05
;       significance level and therefore we do not reject the hypothesis 
;       that X represents a random population. 
;
; PROCEDURE:
;       MD_TEST computes the nonparametric Median Delta Test. Each sample
;       in the population is tagged with either a 1 or a 0 depending on
;       whether it is above or below the population median. Samples that
;       are equal to the median are removed and the population size is 
;       corresponding reduced. This test is an extension of the Runs Test 
;       for Randomness. 
;
; REFERENCE:
;       APPLIED NONPARAMETRIC STATISTICAL METHODS
;       Peter Sprent
;       ISBN 0-412-30610-7
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, November 1994
;-

function md_test, x, above = above, below = below, mdc = mdc

  on_error, 2

  nx = n_elements(x)

  if nx le 10 then message, $
    'Not defined for input vectors of 10 or fewer elements.'

  if nx mod 2 eq 0 then $ ;x is of even length.
    ;Average Kth and K-1st medians.
    medx = 0.5 * (median(x(0:nx-2)) + median(x)) $
  else medx = median(x)

  ;Eliminate values of x equal to median(x).
  xx = x(where(x ne medx))

  ;Values of xx above and below median(x).
  ia = where(xx gt medx, above)
  ib = where(xx lt medx, below)

  ;Values above are tagged 1.
  if above ne 0 then xx(ia) = 1

  ;Values below are tagged 0.
  if below ne 0 then xx(ib) = 0

  ;sxx = above + below
  sxx = size(xx)

  h0 = where(xx eq 0, n0)
  if n0 ne 0 then hi = where(h0+1 ne shift(h0, -1), nn0) $
  else nn0 = 0L

  ;above median
  n1 = sxx(1) - n0

  if xx(sxx(1)-1) ne xx(0) then nn1 = nn0 $
  else if xx(0) eq 1 then nn1 = nn0 + 1 $
  else nn1 = nn0 - 1

  if n0 eq 0 or n1 eq 0 then message, $
    'x is a sequence of identically distributed data.'

  ;Formulate the Median Delta test statistic.
  mdc = nn0 + nn1
  if sxx(2) eq 5 then n0 = n0 + 0.0d
  e = 2.0 * n0 * n1 / (n0 + n1) + 1.0
  v = 2.0 * n0 * n1 * (2.0 * n1 * n0 - n0 - n1) / $
      ((n0 + n1 - 1.0) * (n1 + n0)^2)
  z = (mdc - e) / sqrt(v)

  ;Probability from a Gaussian Distribution.
  prob = 1.0 - gauss_pdf(abs(z))

  return, [z, prob]

end
; $Id: mesh_obj.pro,v 1.1 1994/04/05 17:22:40 dan Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       MESH_OBJ
;
; PURPOSE:
;       MESH_OBJ generates a polygon mesh (vertex list and polygon list) that
;       represent the desired primitive object. The available primitive
;       objects are: triangulated surface, rectangular surface, polar surface,
;       cylindrical surface, spherical surface, surface of extrusion, surface
;       of revolution, and ruled surface.
;
; CATEGORY:
;       Graphics.
;
; CALLING SEQUENCE:
;       MESH_OBJ, Type, Vertex_List, Polygon_List, Array1, Array2
;
; INPUTS:
;
;       Type:   An integer which specifies what type of object to create.
;
;                  TYPE CODE:      SURFACE TYPE:
;                  ----------      -------------
;
;                  0               TRIANGULATED
;                  1               RECTANGULAR
;                  2               POLAR
;                  3               CYLINDRICAL
;                  4               SPHERICAL
;                  5               EXTRUSION
;                  6               REVOLUTION
;                  7               RULED
;
;                  ELSE            none
;
;       Vertex_List:
;               On input, Vertex_List may be undefined. On output, it contains
;               the mesh vertices. Vertex_List and Polygon_List have the same
;               format as the lists returned by the SHADE_VOLUME procedure.
;
;       Polygon_List:
;               On input, Polygon_List may be undefined. On output, it contains
;               the mesh indexes.
;
;       Array1:
;               An array whose use depends on the type of object being created.
;
;                  SURFACE TYPE:   Array1 type
;                  -------------   --------------------------------------------
;
;                  TRIANGULATED    A (3, n) array containing random [x, y, z]
;                                  points to build a triangulated surface from.
;                                  The resulting polygon mesh will have n
;                                  vertices. When shading a triangulated mesh,
;                                  the shading array should have (n) elements.
;
;                  RECTANGULAR     A two dimensional (n, m) array containing
;                                  z values. The resulting polygon mesh will
;                                  have n*m vertices.
;                                  When shading a rectangular mesh, the shading
;                                  array should have (n, m) elements.
;
;                  POLAR           A two dimensional (n, m) array containing
;                                  z values. The resulting polygon mesh will
;                                  have n*m vertices. The n dimension of the
;                                  array is mapped to the polar angle, and the
;                                  m dimension is mapped to the polar radius.
;                                  When shading a polar mesh, the shading array
;                                  should have (n, m) elements.
;
;                  CYLINDRICAL     A two dimensional (n, m) array containing
;                                  radius values. The resulting polygon mesh
;                                  will have n*m vertices. The n dimension of
;                                  the array is mapped to the polar angle,
;                                  and the m dimension is mapped to the Z axis.
;                                  When shading a cylindrical mesh, the shading
;                                  array should have (n, m) elements.
;
;                  SPHERICAL       A two dimensional (n, m) array containing
;                                  radius values. The resulting polygon mesh
;                                  will have n*m vertices. The n dimension of
;                                  the array is mapped to the longitude (0.0 to
;                                  360.0 degrees), and the m dimension is
;                                  mapped to the latitude (-90.0 to +90.0
;                                  degrees).
;                                  When shading a spherical mesh, the shading
;                                  array should have (n, m) elements.
;
;                  EXTRUSION       A (3, n) array of connected 3-D points which
;                                  define the shape to extrude. The resulting
;                                  polygon mesh will have n*(steps+1) vertices
;                                  (where steps is the number of "segments" in
;                                  the extrusion). (See the P1 keyword).
;                                  If the order of the elements in Array1 is
;                                  reversed, then the polygon facing is
;                                  reversed.
;                                  When shading an extrusion mesh, the shading
;                                  array should have (n, steps+1) elements.
;
;                  REVOLUTION      A (3, n) array of connected 3-D points which
;                                  define the shape to revolve. The resulting
;                                  polygon mesh will have n*((steps>3)+1)
;                                  vertices (where steps is the number of
;                                  "steps" in the revolution). (See the P1
;                                  keyword). If the order of the elements in
;                                  Array1 is reversed, then the polygon facing
;                                  is reversed.
;                                  When shading a revolution mesh, the shading
;                                  array should have (n, (steps>3)+1) elements.
;
;                  RULED           A (3, n) array of connected 3-D points which
;                                  define the shape of the first ruled vector.
;                                  The optional (3, m) Array2 parameter defines
;                                  the shape of the second ruled vector. The
;                                  resulting polygon mesh will have
;                                  (n>m)*(steps+1) vertices (where steps is the
;                                  number of intermediate "steps"). (See the P1
;                                  keyword).
;                                  When shading a ruled mesh, the shading
;                                  array should have (n>m, steps+1) elements.
;
; OPTIONAL INPUTS:
;
;       Array2:
;               If the object type is 7 (Ruled Surface) then Array2 is a (3, m)
;               array containing the 3-D points which define the second ruled
;               vector. If Array2 has fewer elements than Array1 then Array2 is
;               processed with CONGRID to give it the same number of elements
;               as Array1. If Array1 has fewer elements than Array2 then Array1
;               is processed with CONGRID to give it the same number of
;               elements as Array2.
;               Array2 MUST be supplied if the object type is 7. Otherwise,
;               Array2 is ignored.
;
; KEYWORD PARAMETERS:
;
;       P1 - P5:
;               The meaning of the keywords P1 through P5 vary depending upon
;               the object type.
;
;                  SURFACE TYPE:   Keywords
;                  -------------   --------------------------------------------
;
;                  TRIANGULATED    P1, P2, P3, P4, and P5 are ignored.
;
;                  RECTANGULAR     If Array1 is an (n, m) array, and if P1 has
;                                  n elements, then the values contained in
;                                  P1 are the X coordinates for each column of
;                                  vertices. Otherwise, FINDGEN(n) is used for
;                                  the X coordinates. If P2 has m elements,
;                                  then the values contained in P2 are the Y
;                                  coordinates for each row of vertices.
;                                  Otherwise, FINDGEN(m) is used for the Y
;                                  coordinates. The polygon facing is reversed
;                                  if the order of either P1 or P2 (but not
;                                  both) is reversed.
;                                  P3, P4, and P5 are ignored.
;
;                  POLAR           P1 specifies the polar angle of the first
;                                  column of Array1 (the default is 0). P2
;                                  specifies the polar angle of the last column
;                                  of Array1 (the default is 2*PI). If P2 is
;                                  less than P1 then the polygon facing is
;                                  reversed. P3 specifies the radius of the
;                                  first row of Array1 (the default is 0). P4
;                                  specifies the radius of the last row of
;                                  Array1 (the default is m-1). If P4 is less
;                                  than P3 then the polygon facing is reversed.
;                                  P5 is ignored.
;
;                  CYLINDRICAL     P1 specifies the polar angle of the first
;                                  column of Array1 (the default is 0). P2
;                                  specifies the polar angle of the last column
;                                  of Array1 (the default is 2*PI). If P2 is
;                                  less than P1 then the polygon facing is
;                                  reversed. P3 specifies the Z coordinate of
;                                  the first row of Array1 (the default is 0).
;                                  P4 specifies the Z coordinate of the last
;                                  row of Array1 (the default is m-1). If P4 is
;                                  less than P3 then the polygon facing is
;                                  reversed. P5 is ignored.
;
;                  SPHERICAL       P1 specifies the longitude of the first
;                                  column of Array1 (the default is 0). P2
;                                  specifies the longitude of the last column
;                                  of Array1 (the default is 2*PI). IF P2 is
;                                  less than P1 then the polygon facing is
;                                  reversed. P3 specifies the latitude of the
;                                  first row of Array1 (the default is -PI/2).
;                                  P4 specifies the latitude of the last row of
;                                  Array1 (the default is +PI/2). If P4 is less
;                                  than P3 then the polygon facing is reversed.
;                                  P5 is ignored.
;
;                  EXTRUSION       P1 specifies the number of steps in the
;                                  extrusion (the default is 1). P2 is a three
;                                  element vector specifying the direction
;                                  (and length) of the extrusion (the default
;                                  is [0, 0, 1]). P3, P4, and P5 are ignored.
;
;                  REVOLUTION      P1 specifies the number of "facets" in the
;                                  revolution (the default is 3). If P1 is less
;                                  than 3 then 3 is used. P2 is a three element
;                                  vector specifying a point that the rotation
;                                  vector passes through (the default is
;                                  [0, 0, 0]). P3 is a three element vector
;                                  specifying the direction of the rotation
;                                  vector (the default is [0, 0, 1]). P4
;                                  specifies the starting angle for the
;                                  revolution (the default is 0). P5 specifies
;                                  the ending angle for the revolution (the
;                                  default is 2*PI). If P5 is less than P4 then
;                                  the polygon facing is reversed.
;
;                  RULED           P1 specifies the number of "steps" in the
;                                  ruling (the default is 1).
;                                  P2, P3, P4, and P5 are ignored.
;
;       DEGREES:   If set, then the input parameters are in degrees
;                  (where applicable). Otherwise, the angles are in
;                  radians.
;
; EXAMPLE:
;
;       ; Create a 48x64 cylinder with a constant radius of 0.25.
;       MESH_OBJ, 3, Vertex_List, Polygon_List, Replicate(0.25, 48, 64), $
;          P4=0.5
;
;       ; Transform the vertices.
;       T3d, /Reset
;       T3d, Rotate=[0.0, 30.0, 0.0]
;       T3d, Rotate=[0.0, 0.0, 40.0]
;       T3d, Translate=[0.25, 0.25, 0.25]
;       Vertex_List = Vert_T3d(Vertex_List)
;
;       ; Create the window and view.
;       Window, 0, Xsize=512, Ysize=512
;       Create_View, Winx=512, Winy=512
;
;       ; Render the mesh.
;       Set_Shading, Light=[-0.5, 0.5, 2.0], Reject=0
;       Tvscl, Polyshade(Vertex_List, Polygon_List, /Normal)
;
;
;       ; Create a cone (surface of revolution).
;       MESH_OBJ, 6, Vertex_List, Polygon_List, $
;          [[0.75, 0.0, 0.25], [0.5, 0.0, 0.75]], P1=16, P2=[0.5, 0.0, 0.0]
;
;       ; Create the window and view.
;       Window, 0, Xsize=512, Ysize=512
;       Create_View, Winx=512, Winy=512, Ax=30.0, Ay=(140.0), Zoom=0.5
;
;       ; Render the mesh.
;       Set_Shading, Light=[-0.5, 0.5, 2.0], Reject=0
;       Tvscl, Polyshade(Vertex_List, Polygon_List, /Data, /T3d)
;
; MODIFICATION HISTORY:
;       Written by:     Daniel Carr, Thu Mar 31 19:16:43 MST 1994
;-

PRO MESH_OBJ, obj_type, vertex_list, polygon_list, array1, array2, $
              P1=p1, P2=p2, P3=p3, P4=p4, P5=p5, $
              Degrees=degrees

CASE obj_type OF

   0: BEGIN ; Triangulated surface.
      sz_array = Size(array1)
      IF (sz_array(1) GE 3L) THEN vertex_list = array1 $
      ELSE vertex_list = [array1, Replicate(0.0, 1, sz_array(2))]
      
      Triangulate, vertex_list(0, *), vertex_list(1, *), tri
      polygon_list = [Replicate(3L, 1L, (N_Elements(tri) / 3L)), Temporary(tri)]
      polygon_list = polygon_list(*)

      RETURN
   END

   1: BEGIN ; Rectangular surface.
      sz_array = Size(array1)
      dim_x = sz_array(1)
      dim_y = sz_array(2)
      vert_num = dim_x * dim_y
      indx_num = (dim_x - 1L) * (dim_y - 1L)
      poly_num = 5L * indx_num

      vertex_list = Fltarr(3, vert_num, /Nozero)

      IF (N_Elements(p1) EQ dim_x) THEN $
         vertex_list(0, *) = p1 # Replicate(1.0, dim_y) $
      ELSE vertex_list(0, *) = Findgen(dim_x) # Replicate(1.0, dim_y)

      IF (N_Elements(p2) EQ dim_y) THEN $
         vertex_list(1, *) = Replicate(1.0, dim_x) # p2 $
      ELSE vertex_list(1, *) = Replicate(1.0, dim_x) # Findgen(dim_y)

      vertex_list(2, *) = Float(array1)

      polygon_list = Lonarr(poly_num, /Nozero)

      p_ind = 5L * Lindgen(indx_num)
      y_inc = Replicate(1L, (dim_x - 1L)) # Lindgen(dim_y - 1L)

      polygon_list(p_ind) = 4L
      p_ind = p_ind + 1L
      polygon_list(p_ind) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 1L) = polygon_list(p_ind) + 1L
      p_ind = p_ind + 1L
      polygon_list(p_ind + 1L) = polygon_list(p_ind) + dim_x
      p_ind = p_ind + 1L
      polygon_list(p_ind + 1L) = polygon_list(p_ind) - 1L
      p_ind = 0

      RETURN
   END

   2: BEGIN ; Polar surface.
      sz_array = Size(array1)
      dim_x = sz_array(1)
      dim_y = sz_array(2)
      vert_num = dim_x * dim_y

      vertex_list = Fltarr(3, vert_num, /Nozero)

      min_ang = 0.0
      max_ang = 2.0 * !PI
      min_rad = 0.0
      max_rad = Float(dim_y - 1L)
      IF (N_Elements(p1) GT 0L) THEN BEGIN
         min_ang = Float(p1)
         IF (Keyword_Set(degrees)) THEN min_ang = min_ang * !Dtor
      ENDIF
      IF (N_Elements(p2) GT 0L) THEN BEGIN
         max_ang = Float(p2)
         IF (Keyword_Set(degrees)) THEN max_ang = max_ang * !Dtor
      ENDIF
      IF (N_Elements(p3) GT 0L) THEN min_rad = Float(p3)
      IF (N_Elements(p4) GT 0L) THEN max_rad = Float(p4)

      min_rad = min_rad > 1.0E-4
      max_rad = max_rad > 1.0E-4
      IF (min_ang EQ max_ang) THEN max_ang = max_ang + (2.0 * !PI)

      vertex_list(2, *) = Float(array1)
      vertex_list(1, *) = Replicate(1.0, dim_x) # $
         (min_rad + ((max_rad - min_rad) * Findgen(dim_y) / Float(dim_y - 1L)))
      vertex_list(0, *) = $
         (min_ang + ((max_ang - min_ang) * Findgen(dim_x) / $
         Float(dim_x - 1L))) # Replicate(1.0, dim_y)

      indx_num = (dim_x - 1L) * (dim_y - 1L)
      poly_num = 5L * indx_num

      polygon_list = Lonarr(poly_num, /Nozero)
      y_inc = Replicate(1L, (dim_x - 1L)) # Lindgen(dim_y - 1L)

      p_ind = 5L * Lindgen(indx_num)

      polygon_list(p_ind) = 4L
      polygon_list(p_ind + 1L) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 2L) = polygon_list(p_ind + 1L) + dim_x
      polygon_list(p_ind + 3L) = polygon_list(p_ind + 2L) + 1L
      polygon_list(p_ind + 4L) = polygon_list(p_ind + 3L) - dim_x
      p_ind = 0

      vertex_list = CV_COORD(From_Cylin=vertex_list, /To_Rect)
      RETURN
   END

   3: BEGIN ; Cylindrical surface.
      sz_array = Size(array1)
      dim_x = sz_array(1)
      dim_y = sz_array(2)
      vert_num = dim_x * dim_y

      vertex_list = Fltarr(3, vert_num, /Nozero)

      min_ang = 0.0
      max_ang = 2.0 * !PI
      min_len = 0.0
      max_len = Float(dim_y - 1L)
      IF (N_Elements(p1) GT 0L) THEN BEGIN
         min_ang = Float(p1)
         IF (Keyword_Set(degrees)) THEN min_ang = min_ang * !Dtor
      ENDIF
      IF (N_Elements(p2) GT 0L) THEN BEGIN
         max_ang = Float(p2)
         IF (Keyword_Set(degrees)) THEN max_ang = max_ang * !Dtor
      ENDIF
      IF (N_Elements(p3) GT 0L) THEN min_len = Float(p3)
      IF (N_Elements(p4) GT 0L) THEN max_len = Float(p4)

      IF (min_ang EQ max_ang) THEN max_ang = max_ang + (2.0 * !PI)

      vertex_list(1, *) = Float(array1)
      vertex_list(2, *) = Replicate(1.0, dim_x) # $
         (min_len + ((max_len - min_len) * Findgen(dim_y) / Float(dim_y - 1L)))
      vertex_list(0, *) = $
         (min_ang + ((max_ang - min_ang) * Findgen(dim_x) / $
         Float(dim_x - 1L))) # Replicate(1.0, dim_y)

      indx_num = (dim_x - 1L) * (dim_y - 1L)
      poly_num = 5L * indx_num

      polygon_list = Lonarr(poly_num, /Nozero)
      y_inc = Replicate(1L, (dim_x - 1L)) # Lindgen(dim_y - 1L)

      p_ind = 5L * Lindgen(indx_num)

      polygon_list(p_ind) = 4L
      polygon_list(p_ind + 1L) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 2L) = polygon_list(p_ind + 1L) + 1L
      polygon_list(p_ind + 3L) = polygon_list(p_ind + 2L) + dim_x
      polygon_list(p_ind + 4L) = polygon_list(p_ind + 3L) - 1L
      p_ind = 0

      vertex_list = CV_COORD(From_Cylin=vertex_list, /To_Rect)
      RETURN
   END

   4: BEGIN ; Spherical surface.
      sz_array = Size(array1)
      dim_x = sz_array(1)
      dim_y = sz_array(2)
      vert_num = dim_x * dim_y

      vertex_list = Fltarr(3, vert_num, /Nozero)

      min_lon = 0.0
      max_lon = 2.0 * !PI
      min_lat = (-!PI) / 2.0
      max_lat = (+!PI) / 2.0
      IF (N_Elements(p1) GT 0L) THEN BEGIN
         min_lon = Float(p1)
         IF (Keyword_Set(degrees)) THEN min_lon = min_lon * !Dtor
      ENDIF
      IF (N_Elements(p2) GT 0L) THEN BEGIN
         max_lon = Float(p2)
         IF (Keyword_Set(degrees)) THEN max_lon = max_lon * !Dtor
      ENDIF
      IF (N_Elements(p3) GT 0L) THEN BEGIN
         min_lat = Float(p3)
         IF (Keyword_Set(degrees)) THEN min_lat = min_lat * !Dtor
      ENDIF
      IF (N_Elements(p4) GT 0L) THEN BEGIN
         max_lat = Float(p4)
         IF (Keyword_Set(degrees)) THEN max_lat = max_lat * !Dtor
      ENDIF

      min_lat = (min_lat > (((-!PI) / 2.0) + 1.0E-4)) < $
                           (((+!PI) / 2.0) - 1.0E-4)
      max_lat = (max_lat > (((-!PI) / 2.0) + 1.0E-4)) < $
                           (((+!PI) / 2.0) - 1.0E-4)
      IF (min_lon EQ max_lon) THEN max_lon = max_lon + (2.0 * !PI)

      vertex_list(2, *) = Float(array1)
      vertex_list(1, *) = Replicate(1.0, dim_x) # $
         (min_lat + ((max_lat - min_lat) * Findgen(dim_y) / Float(dim_y - 1L)))
      vertex_list(0, *) = $
         (min_lon + ((max_lon - min_lon) * Findgen(dim_x) / $
         Float(dim_x - 1L))) # Replicate(1.0, dim_y)

      indx_num = (dim_x - 1L) * (dim_y - 1L)
      poly_num = 5L * indx_num

      polygon_list = Lonarr(poly_num, /Nozero)
      y_inc = Replicate(1L, (dim_x - 1L)) # Lindgen(dim_y - 1L)

      p_ind = 5L * Lindgen(indx_num)

      polygon_list(p_ind) = 4L
      polygon_list(p_ind + 1L) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 2L) = polygon_list(p_ind + 1L) + 1L
      polygon_list(p_ind + 3L) = polygon_list(p_ind + 2L) + dim_x
      polygon_list(p_ind + 4L) = polygon_list(p_ind + 3L) - 1L
      p_ind = 0

      vertex_list = CV_COORD(From_Sphere=vertex_list, /To_Rect)
      RETURN
   END

   5: BEGIN ; Surface of extrusion.
      sz_array = Size(array1)
      max_ind = sz_array(2) - 1L
      steps = 1L
      IF (N_Elements(p1) GT 0L) THEN steps = Long(p1) > 1L

      vert_num = sz_array(2) * (steps + 1L)

      indx_num = max_ind * steps
      poly_num = 5L * indx_num

      polygon_list = Lonarr(poly_num, /Nozero)
      y_inc = Replicate(1L, max_ind) # Lindgen(steps)

      p_ind = 5L * Lindgen(indx_num)

      polygon_list(p_ind) = 4L
      polygon_list(p_ind + 1L) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 2L) = polygon_list(p_ind + 1L) + 1L
      polygon_list(p_ind + 3L) = polygon_list(p_ind + 2L) + sz_array(2)
      polygon_list(p_ind + 4L) = polygon_list(p_ind + 3L) - 1L
      p_ind = 0

      ex_vec = [0.0, 0.0, 1.0]
      IF (N_Elements(p2) GT 0L) THEN ex_vec = Float(p2)
      len = Sqrt(ex_vec(0)^2 + ex_vec(1)^2 + ex_vec(2)^2)
      IF (len EQ 0.0) THEN BEGIN
         ex_vec = [0.0, 0.0, 1.0]
         len = 1.0
      ENDIF
      len = Sqrt(ex_vec(0)^2 + ex_vec(1)^2 + ex_vec(2)^2)
      ex_vec = ex_vec / len

      z_ang = 0.0
      y_len = Sqrt(ex_vec(0)^2 + ex_vec(1)^2)
      IF (y_len GT 0.0) THEN $
         z_ang = Atan(ex_vec(1), ex_vec(0)) * !Radeg
      y_ang = 0.0
      IF ((ex_vec(2) NE 0.0) OR (y_len GT 0.0)) THEN $
         y_ang = Atan(ex_vec(2), y_len) * !Radeg

      save_pt = !P.T
      T3d, /Reset
      T3d, Rotate=[0.0, 0.0, (-z_ang)]
      T3d, Rotate=[0.0, (y_ang), 0.0]
      T3d, Rotate=[0.0, (-90.0), 0.0]

      IF (sz_array(1) EQ 2L) THEN $
         perim = Vert_T3d([array1(0, *), array1(1, *), $
                          Replicate(0.0, 1L, sz_array(2))]) $
      ELSE perim = Vert_T3d(array1)

      vertex_list = Fltarr(3, vert_num, /Nozero)
      vertex_list(0, *) = Reform(perim(0, *)) # Replicate(1.0, (steps + 1L))
      vertex_list(1, *) = Reform(perim(1, *)) # Replicate(1.0, (steps + 1L))
      vertex_list(2, *) = $
         (Reform(perim(2, *)) # Replicate(1.0, (steps + 1L))) + $
         Replicate(1.0, sz_array(2)) # $
         (len * Findgen(steps + 1L) / Float(steps))

      T3d, /Reset
      T3d, Rotate=[0.0, (90.0), 0.0]
      T3d, Rotate=[0.0, (-y_ang), 0.0]
      T3d, Rotate=[0.0, 0.0, (z_ang)]

      vertex_list = Vert_T3d(vertex_list, /No_Copy)
      !P.T = save_pt

      RETURN
   END

   6: BEGIN ; Surface of revolution.
      sz_array = Size(array1)
      max_ind = sz_array(2) - 1L
      steps = 3L
      IF (N_Elements(p1) GT 0L) THEN steps = p1 > 3L

      vert_num = sz_array(2) * (steps + 1L)

      indx_num = max_ind * steps
      poly_num = 5L * indx_num

      polygon_list = Lonarr(poly_num, /Nozero)
      y_inc = Replicate(1L, max_ind) # Lindgen(steps)

      p_ind = 5L * Lindgen(indx_num)

      polygon_list(p_ind) = 4L
      polygon_list(p_ind + 1L) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 2L) = polygon_list(p_ind + 1L) + sz_array(2)
      polygon_list(p_ind + 3L) = polygon_list(p_ind + 2L) + 1L
      polygon_list(p_ind + 4L) = polygon_list(p_ind + 3L) - sz_array(2)
      p_ind = 0

      min_ang = 0.0
      max_ang = 2.0 * !PI
      IF (N_Elements(p4) GT 0L) THEN BEGIN
         min_ang = Float(p4)
         IF (Keyword_Set(degrees)) THEN min_ang = min_ang * !Dtor
      ENDIF
      IF (N_Elements(p5) GT 0L) THEN BEGIN
         max_ang = Float(p5)
         IF (Keyword_Set(degrees)) THEN max_ang = max_ang * !Dtor
      ENDIF

      IF (min_ang EQ max_ang) THEN max_ang = max_ang + (2.0 * !PI)

      rot_point = [0.0, 0.0, 0.0]
      IF (N_Elements(p2) GT 0L) THEN rot_point = Float(p2)
      rot_vec = [0.0, 0.0, 1.0]
      IF (N_Elements(p3) GT 0L) THEN rot_vec = Float(p3)
      len = Sqrt(rot_vec(0)^2 + rot_vec(1)^2 + rot_vec(2)^2)
      IF (len EQ 0.0) THEN BEGIN
         rot_vec = [0.0, 0.0, 1.0]
         len = 1.0
      ENDIF
      len = Sqrt(rot_vec(0)^2 + rot_vec(1)^2 + rot_vec(2)^2)
      rot_vec = rot_vec / len

      z_ang = 0.0
      y_len = Sqrt(rot_vec(0)^2 + rot_vec(1)^2)
      IF (y_len GT 0.0) THEN $
         z_ang = Atan(rot_vec(1), rot_vec(0)) * !Radeg
      y_ang = 0.0
      IF ((rot_vec(2) NE 0.0) OR (y_len GT 0.0)) THEN $
         y_ang = Atan(rot_vec(2), y_len) * !Radeg

      save_pt = !P.T
      T3d, /Reset
      T3d, Translate=[(-rot_point(0)), (-rot_point(1)), (-rot_point(2))]
      T3d, Rotate=[0.0, 0.0, (-z_ang)]
      T3d, Rotate=[0.0, (y_ang - 90.0), 0.0]

      IF (sz_array(1) EQ 2L) THEN $
         sweep = Vert_T3d([array1(0, *), array1(1, *), $
                          Replicate(0.0, 1L, sz_array(2))]) $
      ELSE sweep = Vert_T3d(array1)

      neg_ind = Where(sweep(0, *) LT 0.0)
      sweep(0, *) = Abs(sweep(0, *)) > 1.0E-4
      IF (neg_ind(0) GE 0L) THEN sweep(0, neg_ind) = sweep(0, neg_ind) * (-1.0)
      neg_ind = 0

      vertex_list = Fltarr(3, vert_num, /Nozero)
      vertex_list(0, *) = Reform(sweep(0, *)) # Replicate(1.0, (steps + 1L))
      vertex_list(1, *) = Reform(sweep(1, *)) # Replicate(1.0, (steps + 1L))
      vertex_list(2, *) = Reform(sweep(2, *)) # Replicate(1.0, (steps + 1L))

      perim_ind = Lindgen(sz_array(2))

      FOR i=0L, steps DO BEGIN
         T3d, /Reset
         T3d, Rotate=[0.0, 0.0, (!Radeg * $
            ((Float(i) * (max_ang - min_ang) / Float(steps)) + min_ang))]
         vertex_list(*, perim_ind) = Vert_T3d(vertex_list(*, perim_ind))

         perim_ind = perim_ind + sz_array(2)
      ENDFOR
      perim_ind = 0

      T3d, /Reset
      T3d, Rotate=[0.0, (90.0 - y_ang), 0.0]
      T3d, Rotate=[0.0, 0.0, (z_ang)]
      T3d, Translate=[rot_point(0), rot_point(1), rot_point(2)]

      vertex_list = Vert_T3d(vertex_list, /No_Copy)
      !P.T = save_pt

      RETURN
   END

   7: BEGIN ; Ruled surface.
      sz_array = Size(array1)
      sz_array2 = Size(array2)
      IF (sz_array(1) EQ 2L) THEN $
         start_rule = [array1(0, *), array1(1, *), $
                       Replicate(0.0, 1L, sz_array(2))] $
      ELSE start_rule = array1
      IF (sz_array2(1) EQ 2L) THEN $
         end_rule = [array2(0, *), array2(1, *), $
                     Replicate(0.0, 1L, sz_array2(2))] $
      ELSE end_rule = array2

      IF (sz_array(2) GT sz_array2(2)) THEN $
         end_rule = Congrid(end_rule, 3, sz_array(2), /Interp, /Minus_One)

      IF (sz_array(2) LT sz_array2(2)) THEN BEGIN
         start_rule = Congrid(start_rule, 3, sz_array2(2), /Interp, /Minus_One)
         sz_array = Size(start_rule)
      ENDIF

      steps = 1L
      IF (N_Elements(p1) GT 0L) THEN steps = Long(p1) > 1L

      dim_x = sz_array(2)
      dim_y = steps + 1L

      vert_num = dim_x * dim_y
      indx_num = (dim_x - 1L) * (dim_y - 1L)
      poly_num = 5L * indx_num

      vertex_list = Fltarr(3, vert_num, /Nozero)

      strip_ind = Lindgen(dim_x)
      FOR i=0L, steps DO BEGIN
         fac = Float(i) / Float(steps)
         vertex_list(0, strip_ind) = $
            ((1.0 - fac) * start_rule(0, *)) + (fac * end_rule(0, *))
         vertex_list(1, strip_ind) = $
            ((1.0 - fac) * start_rule(1, *)) + (fac * end_rule(1, *))
         vertex_list(2, strip_ind) = $
            ((1.0 - fac) * start_rule(2, *)) + (fac * end_rule(2, *))

         strip_ind = strip_ind + dim_x
      ENDFOR

      polygon_list = Lonarr(poly_num, /Nozero)

      p_ind = 5L * Lindgen(indx_num)
      y_inc = Replicate(1L, (dim_x - 1L)) # Lindgen(dim_y - 1L)

      polygon_list(p_ind) = 4L
      p_ind = p_ind + 1L
      polygon_list(p_ind) = Lindgen(indx_num) + y_inc(*)
      y_inc = 0
      polygon_list(p_ind + 1L) = polygon_list(p_ind) + dim_x
      p_ind = p_ind + 1L
      polygon_list(p_ind + 1L) = polygon_list(p_ind) + 1L
      p_ind = p_ind + 1L
      polygon_list(p_ind + 1L) = polygon_list(p_ind) - dim_x
      p_ind = 0

      RETURN
   END

   ELSE:
ENDCASE

RETURN
END
; $Id: min_curve_surf.pro,v 1.6 1993/10/25 18:08:08 dave Exp $

FUNCTION min_curve_surf, z, x, y, REGULAR = regular, XGRID=xgrid, $
	XVALUES = xvalues, YGRID = ygrid, YVALUES = yvalues, $
	GS = gs, BOUNDS = bounds, NX = nx0, NY = ny0, XOUT=xout, $
	YOUT=yout, XPOUT=xpout, YPOUT=ypout, TPS=tps
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	MIN_CURVE_SURF
;
; PURPOSE:
;	This function Interpolates a regularly- or irregularly-gridded
;	set of points with either a minimum curvature surface or
;	a thin-plate-spline surface.
;
; CATEGORY:
;	Mathematical functions, Interpolation, Surface Fitting
;
; CALLING SEQUENCE:
;	Result = MIN_CURVE_SURF(Z [, X, Y])
;
; INPUTS: 
;	X, Y, Z:  arrays containing the X, Y, and Z coordinates of the 
;		  data points on the surface. Points need not be 
;		  regularly gridded. For regularly gridded input data, 
;		  X and Y are not used: the grid spacing is specified 
;		  via the XGRID and YGRID (or XVALUES and YVALUES) 
;		  keywords, and Z must be a two dimensional array. 
;		  For irregular grids, all three parameters must be
;		  present and have the same number of elements. 
;
; KEYWORD PARAMETERS:
;	TPS:	If set, use the thin-plate-spline method, otherwise
;		use the minimum curvature surface method.
;  Input grid description:
;	REGULAR:  if set, the Z parameter is a two dimensional array 
;		  of dimensions (N,M), containing measurements over a 
;		  regular grid. If any of XGRID, YGRID, XVALUES, YVALUES 
;		  are specified, REGULAR is implied. REGULAR is also 
;		  implied if there is only one parameter, Z. If REGULAR is 
;		  set, and no grid (_VALUE or _GRID) specifications are 
;		  present, the respective grid is set to (0, 1, 2, ...). 
;	XGRID:    contains a two element array, [xstart, xspacing], 
;		  defining the input grid in the X direction. Do not
;		  specify both XGRID and XVALUES. 
;	XVALUES:  if present, XVALUES(i) contains the X location 
;		  of Z(i,j). XVALUES must be dimensioned with N elements. 
;	YGRID:    contains a two element array, [ystart, yspacing], 
;		  defining the input grid in the Y direction. Do not
;		  specify both YGRID and YVALUES. 
;	YVALUES:  if present, YVALUES(i) contains the Y location 
;		  of Z(i,j). YVALUES must be dimensioned with N elements. 
;
;  Output grid description:
;	GS:	  If present, GS must be a two-element vector [XS, YS],
;		  where XS is the horizontal spacing between grid points
;		  and YS is the vertical spacing. The default is based on
;		  the extents of X and Y. If the grid starts at X value
;		  Xmin and ends at Xmax, then the default horizontal
;		  spacing is (Xmax - Xmin)/(NX-1). YS is computed in the
;		  same way. The default grid size, if neither NX or NY
;		  are specified, is 26 by 26. 
;	BOUNDS:   If present, BOUNDS must be a four element array containing
;		  the grid limits in X and Y of the output grid:
;		  [Xmin, Ymin, Xmax, Ymax]. If not specified, the grid
;		  limits are set to the extent of X and Y. 
;	NX:       The output grid size in the X direction. NX need not
;	  	  be specified if the size can be inferred from GS and
;		  BOUNDS. The default value is 26.
;	NY:       The output grid size in the Y direction. See NX. 
;	XOUT:	  If present, XOUT must be a vector containing the output
;		  grid X values. If this parameter is supplied, GS, BOUNDS,
;		  and NX are ignored for the X output grid. Use this
;		  parameter to specify irregular spaced output grids.
;	YOUT:	  If present, YOUT must be a vector containing the output
;		  grid Y values. If this parameter is supplied, GS, BOUNDS,
;		  and NY are ignored for the Y output grid. Use this
;		  parameter to specify irregular spaced output grids.
;	XPOUT:	  If present, the arrays XPOUT and YPOUT contain the X and Y
;	YPOUT:	  values for the output points. With these keywords, the
;		  output grid need not be regular, and all other output
;		  grid parameters are ignored. XPOUT and YPOUT must have
;		  the same number of points, which is also the number of
;		  points returned in the result.
;
; OUTPUTS:
;	This function returns a two-dimensional floating point array
; 	containing the interpolated surface, sampled at the grid points.
;
; RESTRICTIONS:
;	The accuracy of this function is limited by the single precision
;	floating point accuracy of the machine.
;
;		SAMPLE EXECUTION TIMES  (measured on a Sun IPX)
;	# of input points	# of output points	Seconds
;	16			676			0.19
;	32			676			0.42
;	64			676			1.27
;	128			676			4.84
;	256			676			24.6
;	64			256			1.12
;	64			1024			1.50
;	64			4096			1.97
;	64			16384			3.32
;
; PROCEDURE:
;	A minimum curvature spline surface is fitted to the data points
;	described by X, Y, and Z.  The basis function:
;		C(x0,x1, y0,y1) = d^2 log(d^k),
;	where d is the distance between (x0,y0), (x1,y1), is used,
;	as described by Franke, R., "Smooth interpolation of scattered
;	data by local thin plate splines," Computers Math With Applic.,
;	v.8, no. 4, p. 273-281, 1982.  k = 1 for minimum curvature surface,
;	and 2 for Thin Plate Splines.  For N data points, a system of N+3 
;	simultaneous equations are solved for the coefficients of the 
;	surface.  For any interpolation point, the interpolated value
;	is:
;	  F(x,y) = b(0) + b(1)*x + b(2)*y + Sum(a(i)*C(X(i),x,Y(i),y))
;
;	The results obtained the thin plate spline (TPS) or the minimum
;	curvature surface (MCS) methods are very similar.  The only 
;	difference is in the basis functions: TPS uses d^2*alog(d^2),
;	and MCS uses d^2*alog(d), where d is the distance from 
;	point (x(i),y(i)).
;
; EXAMPLES:
; Example 1: Irregularly gridded cases
;	Make a random set of points that lie on a gaussian:
;	  n = 15				;# random points
;	  x = RANDOMU(seed, n)
;	  y = RANDOMU(seed, n)
;	  z = exp(-2 * ((x-.5)^2 + (y-.5)^2)) 	 ;The gaussian
;
; 	get a 26 by 26 grid over the rectangle bounding x and y:
;	  r = min_curve_surf(z, x, y)	;Get the surface.
;
; 	Or: get a surface over the unit square, with spacing of 0.05:
;	  r = min_curve_surf(z, x, y, GS=[0.05, 0.05], BOUNDS=[0,0,1,1])
;
; 	Or: get a 10 by 10 surface over the rectangle bounding x and y:
;	  r = min_curve_surf(z, x, y, NX=10, NY=10)
;
; Example 2: Regularly gridded cases
;	Make some random data
;	  z = randomu(seed, 5, 6)
;
;	interpolate to a 26 x 26 grid:
;	  CONTOUR, min_curve_surf(z, /REGULAR)
;
; MODIFICATION HISTORY:
;	DMS, RSI, March, 1993.  Written.
;	DMS, RSI, July, 1993.   Added XOUT and YOUT, XPOUT and YPOUT.
;-


ON_ERROR, 2
s = size(z)		;Assume 2D
nx = s(1)
ny = s(2)

reg = keyword_set(regular) or (n_params() eq 1)

if n_elements(xgrid) eq 2 then begin
	x = findgen(nx) * xgrid(1) + xgrid(0)
	reg = 1
endif else if n_elements(xvalues) gt 0 then begin
	if n_elements(xvalues) ne nx then $
		message,'Xvalues must have '+string(nx)+' elements.'
	x = xvalues
	reg = 1
endif

if n_elements(ygrid) eq 2 then begin
	y = findgen(ny) * ygrid(1) + ygrid(0)
	reg = 1
endif else if n_elements(yvalues) gt 0 then begin
	if n_elements(yvalues) ne ny then $
		message,'Yvalues must have '+string(ny)+' elements.'
	y = yvalues
	reg = 1
endif

if reg then begin
	if s(0) ne 2 then message,'Z array must be 2D for regular grids'
	if n_elements(x) ne nx then x = findgen(nx)
	if n_elements(y) ne ny then y = findgen(ny)
	x = x # replicate(1., ny)	;Expand to full arrays.
	y = replicate(1.,nx) # y
	endif

n = n_elements(x)
if n ne n_elements(y) or n ne n_elements(z) then $
	message,'x, y, and z must have same number of elements.'

m = n + 3			;# of eqns to solve
a = fltarr(m, m)		;LHS

; For thin-plate-splines, terms are r^2 log(r^2).  For min curve surf,
; terms are r^2 log(r).
if keyword_set(tps) then k = 1.0 else k = 0.5

for i=0, n-2 do for j=i+1,n-1 do begin
	d = (x(i)-x(j))^2 + (y(i)-y(j))^2 > 1.0e-8  ;Distance squared...
	d = d * alog(d)* k	;d^2 * alog(d^(1./k))
	a(i+3,j) = d
	a(j+3,i) = d
	endfor

a(0,0:n-1) = 1		; fill rest of array
a(1,0:n-1) = reform(x,1,n)
a(2,0:n-1) = reform(y,1,n)

a(3:m-1,n) = 1.
a(3,n+1) = reform(x, n, 1)
a(3,n+2) = reform(y, n, 1)

b = fltarr(m)		;Right hand side
b(0) = reform(z,n,1)

c = b # invert(a)	;Solution using inverse
;  c = svd_solve(transpose(a),b)	;solution using svd

if n_elements(XPOUT) gt 0 then begin	;Explicit output locations?
  if n_elements(YPOUT) ne n_elements(XPOUT) then $
	message, 'XPOUT and YPOUT must have same number of points'
endif else begin			;Regular grid
  if n_elements(bounds) lt 4 then begin	;Bounds specified?
	xmin = min(x, max = xmax)
	ymin = min(y, max = ymax)
	bounds = [xmin, ymin, xmax, ymax]
	endif

  if n_elements(gs) lt 2 then begin	;GS specified?  No.
    if n_elements(nx0) le 0 then nx = 26 else nx = nx0 ;Defaults for nx and ny
    if n_elements(ny0) le 0 then ny = 26 else ny = ny0
    gs = [(bounds(2)-bounds(0))/(nx-1.), $
	   (bounds(3)-bounds(1))/(ny-1.)]
  endif else begin			;GS is specified?
    if n_elements(nx0) le 0 then $
	nx = ceil((bounds(2)-bounds(0))/gs(0)) + 1 $
    else nx = nx0
    if n_elements(ny0) le 0 then $
	ny = ceil((bounds(3)-bounds(1))/gs(1)) + 1 $
    else ny = ny0
  endelse


  if n_elements(xout) gt 0 then begin		;Output grid specified?
	nx = n_elements(xout)
	xpout = xout
  endif else xpout = gs(0) * findgen(nx) + bounds(0)

  if n_elements(yout) gt 0 then begin
	ny = n_elements(yout)
	ypout = yout
  endif else ypout = gs(1) * findgen(ny) + bounds(1)
  xpout = xpout # replicate(1.,ny)
  ypout = replicate(1., nx) # ypout
endelse					;Regular grid

; For min_curve_surf, divide c(3:*) by 2 cause we use d^2 rather than d.
if keyword_set(tps) eq 0 then c(3) = c(3:*)/2.0
			;common scale factor
s = c(0) + c(1) * xpout + c(2) * ypout		;First terms
for i=0, n-1 do begin
	d = (xpout-x(i))^2 + (ypout-y(i))^2 > 1.0e-8  ;Distance squared
	s = s + d * alog(d)* c(i+3)
	endfor
return, s
end
; $Id: mk_html_help.pro,v 1.6 1995/07/20 15:52:59 griz Exp $
;+
; NAME:
;	MK_HTML_HELP
;
; PURPOSE:
;	Given a list of IDL procedure files (.PRO), VMS text library 
;       files (.TLB), or directories that contain such files, this procedure 
;       generates a file in the HTML format that contains the documentation 
;       for those routines that contain a DOC_LIBRARY style documentation 
;       template.  The output file is compatible with World Wide Web browsers.
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	MK_HTML_HELP, Sources, Outfile
;
; INPUTS:
;     Sources:  A string or string array containing the name(s) of the
;		.pro or .tlb files (or the names of directories containing 
;               such files) for which help is desired.  If a source file is 
;               a VMS text library, it must include the .TLB file extension.  
;               If a source file is an IDL procedure, it must include the .PRO
;               file extension.  All other source files are assumed to be
;               directories.
;     Outfile:	The name of the output file which will be generated.
;
; KEYWORDS:
;     TITLE:	If present, a string which supplies the name that
;		should appear as the Document Title for the help.
;     VERBOSE:	Normally, MK_HTML_HELP does its work silently.
;		Setting this keyword to a non-zero value causes the procedure
;		to issue informational messages that indicate what it
;		is currently doing. !QUIET must be 0 for these messages
;               to appear.
;     STRICT:   If this keyword is set to a non-zero value, MK_HTML_HELP will 
;               adhere strictly to the HTML format by scanning the 
;               the document headers for characters that are reserved in 
;               HTML (<,>,&,").  These are then converted to the appropriate 
;               HTML syntax in the output file. By default, this keyword
;               is set to zero (to allow for faster processing).
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A help file with the name given by the Outfile argument is
;	created.
;
; RESTRICTIONS:
;	The following rules must be followed in formatting the .pro
;	files that are to be searched.
;		(a) The first line of the documentation block contains
;		    only the characters ";+", starting in column 1.
;               (b) There must be a line which contains the string "NAME:",
;                   which is immediately followed by a line containing the
;                   name of the procedure or function being described in
;                   that documentation block.  If this NAME field is not
;                   present, the name of the source file will be used.
;		(c) The last line of the documentation block contains
;		    only the characters ";-", starting in column 1.
;		(d) Every other line in the documentation block contains
;		    a ";" in column 1.
;
;       Note that a single .pro file can contain multiple procedures and/or
;       functions, each with their own documentation blocks. If it is desired
;       to have "invisible" routines in a file, i.e. routines which are only
;       for internal use and should not appear in the help file, simply leave
;       out the ";+" and ";-" lines in the documentation block for those
;       routines.
;
;	No reformatting of the documentation is done.
;
; MODIFICATION HISTORY:
;       July 5, 1995, DD, RSI. Original version.
;       July 13, 1995, Mark Rivers, University of Chicago. Added support for
;               multiple source directories and multiple documentation
;               headers per .pro file.
;       July 17, 1995, DD, RSI. Added code to alphabetize the subjects;
;               At the end of each description block in the HTML file,
;               added a reference to the source .pro file.
;       July 18, 1995, DD, RSI. Added STRICT keyword to handle angle brackets.
;       July 19, 1995, DD, RSI. Updated STRICT to handle & and ".
;               Changed calling sequence to accept .pro filenames, .tlb
;               text librarie names, and/or directory names.
;               Added code to set default subject to name of file if NAME
;               field is not present in the doc header.
;
;-
;

;----------------------------------------------------------------------------
PRO mhh_strict, txtlines
;
; Replaces any occurrence of HTML reserved characters (<,>,&,") in the
; given text lines with the appropriate HTML counterpart.
;
; entry:
;       txtlines - String array containing the text line(s) to be altered.
; exit:
;	txtlines - Same as input except that reserved characters have been 
;                  replaced with the appropriate HTML syntax.
;
 count = N_ELEMENTS(txtlines)
 FOR i=0,count-1 DO BEGIN
  txt = txtlines(i) 

  ; Ampersands get replaced with &amp.  Must do ampersands first because
  ; they are used to replace other reserved characters in HTML.
  spos = STRPOS(txt,'&')
  WHILE (spos NE -1) DO BEGIN
   newtxt = STRMID(txt,0,spos)+'&amp;'+STRMID(txt,spos+1,STRLEN(txt)-spos+1)
   txt = newtxt
   spos = STRPOS(txt,'&',spos+1)
  ENDWHILE
  txtlines(i) = txt

  ; Left angle brackets get replaced with &lt;
  spos = STRPOS(txt,'<')
  WHILE (spos NE -1) DO BEGIN
   newtxt = STRMID(txt,0,spos)+'&lt;'+STRMID(txt,spos+1,STRLEN(txt)-spos+1)
   txt = newtxt
   spos = STRPOS(txt,'<',spos+1)
  ENDWHILE
  txtlines(i) = txt

  ; Right angle brackets get replaced with &gt;
  spos = STRPOS(txt,'>')
  WHILE (spos NE -1) DO BEGIN
   newtxt = STRMID(txt,0,spos)+'&gt;'+STRMID(txt,spos+1,STRLEN(txt)-spos+1)
   txt = newtxt
   spos = STRPOS(txt,'>',spos+1)
  ENDWHILE
  txtlines(i) = txt

  ; Double quotes get replaced with &quot;
  spos = STRPOS(txt,'"')
  WHILE (spos NE -1) DO BEGIN
   newtxt = STRMID(txt,0,spos)+'&quot;'+STRMID(txt,spos+1,STRLEN(txt)-spos+1)
   txt = newtxt
   spos = STRPOS(txt,'"',spos+1)
  ENDWHILE
  txtlines(i) = txt
 ENDFOR
END

;----------------------------------------------------------------------------
PRO  mhh_grab_hdr,name,dict,infile_indx,libfile_indx,txt_file,verbose,$
     strict
;
; Searches an input file for all text between the ;+ and ;- comments, and
; updates the scratch text file appropriately. Note that this routine
; will extract multiple comment blocks from a single source file if they are
; present.
;
; entry:
;	name - Name of file containing documentation header(s).
;       dict[] - Dictionary entries for each documentation block in the .PRO
;               file.  Each dictionary entry is a structure with an index to 
;               the source filename, an index to the extracted library 
;               filename (useful only for VMS text libraries), a subject name,
;               scratch file offset, unique id (for duplicate names), and 
;               number of lines of documentation text.  
;               This parameter may be originally undefined at entry.
;       infile_indx - Index of the source .pro or .tlb filename.
;       libfile_indx - Index of extracted library filename.  If the source
;               filename was not a VMS text library, this value should be
;               set to -1L. 
;	txt_file - Scratch file to which the documentation header will
;               be written.
;	verbose - TRUE if the routine should output a descriptive message
;		when it finds the documentation header.
;       strict - If nonzero, the routine will adhere strictly to HTML format.
;                The document headers will be scanned for characters that are
;                reserved in HTML (<,>,&,"), which are then converted to the 
;                appropriate HTML syntax in the output file.
;
; exit:
;	txt_file -  Updated as necessary. Positioned at EOF.
;       dict[] - Updated array of new dictionary entries.
;

 ; Under DOS, formatted output ends up with a carriage return linefeed
 ; pair at the end of every record. The resulting file would not be
 ; compatible with Unix. Therefore, we use unformatted output, and
 ; explicity add the linefeed, which has ASCII value 10.
 LF=10B

 IF (libfile_indx NE -1L) THEN $
  OPENR, in_file, /GET, FILEPATH('mkhtmlhelp.scr',/TMP), /DELETE $
 ELSE $
  OPENR, in_file, /GET, name

 IF (verbose NE 0) THEN MESSAGE,/INFO, 'File = '+name
 WHILE (1) DO BEGIN
  ; Find the opening line of the next header.
  tmp = ''
  found = 0
  num = 0
  header = ''
  ON_IOERROR, DONE
  WHILE (NOT found) DO BEGIN
   READF, in_file, tmp
   IF (STRMID(tmp,0,2) EQ ';+') THEN found = 1
  ENDWHILE

  IF (found) THEN BEGIN
   ; Find the matching closing line of the header.
   found = 0
   WHILE (NOT found) DO BEGIN
    READF,in_file,tmp
    IF (STRMID(tmp,0,2) EQ ';-') THEN BEGIN
     found =1
    ENDIF ELSE BEGIN
     tmp = strmid(tmp, 1, 1000)
     header = [header, tmp]
     num = num + 1
    ENDELSE
   ENDWHILE

   IF (strict) THEN mhh_strict,header
   ; Done with one block of header

   ; Keep track of current scratch file offset, then write doc text.
   POINT_LUN,-txt_file,pos
   FOR i=1, num DO BEGIN
    WRITEU, txt_file, header(i),LF
   ENDFOR

   ; Search for the subject. It is the line following name.
   index = WHERE(STRTRIM(header, 2) EQ 'NAME:', count)
   IF (count eq 1) THEN BEGIN
    sub = STRUPCASE(STRTRIM(header(index(0)+1), 2))
    IF (verbose NE 0) THEN MESSAGE,/INFO, 'Routine = '+sub

   ; If the NAME field was not present, set the subject to the name of the 
   ; source text file.
   ENDIF ELSE BEGIN
    MESSAGE,/INFO,'Properly formatted NAME entry not found...'
    ifname = name

    CASE !VERSION.OS_FAMILY OF
     'Windows': tok = '\'
     'MacOS': tok = ':'
     ELSE: tok = '/'
    ENDCASE

    ; Cut the path.
    sp0 = 0
    spos = STRPOS(ifname,tok,sp0)
    WHILE (spos NE -1) DO BEGIN
     sp0 = spos+1
     spos = STRPOS(ifname,tok,sp0)
    ENDWHILE
    ifname = STRMID(ifname,sp0,(STRLEN(ifname)-sp0))

    ; Cut the suffix.
    spos = STRPOS(ifname,'.')
    IF (spos NE -1) THEN ifname = STRMID(ifname,0,spos(0))
    IF (strict) THEN mhh_strict, ifname
    sub = STRUPCASE(ifname)
    MESSAGE,/INFO,'  Setting subject to filename: '+sub+'.'
   ENDELSE

   ; Calculate unique id in case of duplicate subject names.
   IF (N_ELEMENTS(dict) EQ 0) THEN $
    ndup=0 $
   ELSE BEGIN
    dpos = WHERE(dict.subject EQ sub,ndup)
    IF (ndup EQ 1) THEN BEGIN
     dict(dpos(0)).id = 1
     ndup = ndup + 1
    ENDIF
   ENDELSE

   ; Create a dictionary entry for the document header.
   entry = {DICT_STR,subject:sub,indx:infile_indx,lib:libfile_indx,$
            id:ndup,offset:pos,nline:num}
   IF (N_ELEMENTS(dict) EQ 0) THEN dict = [entry] ELSE dict = [dict,entry]
  ENDIF
 ENDWHILE

DONE: 
 ON_IOERROR, NULL
 FREE_LUN, in_file
END

;----------------------------------------------------------------------------
PRO mhh_gen_file,dict,txt_file,infiles,libfiles,outfile,verbose,title,strict
;
; Build a .HTML file with the constituent parts.
;
; entry:
;       dict - Array of dictionary entries. Each entry is a structure
;              with a subject name, scratch file offset, number of lines
;              of documentation text, etc.
;       infiles - String array containing the name(s) of .pro or .tlb files 
;              for which help is being generated.
;       libfiles - String array containing the name(s) of .pro files extracted
;              from any .tlb files in the infiles array. 
;	txt_file - Scratch file containing the documentation text.
;	outfile - NAME of final HELP file to be generated.
;	verbose - TRUE if the routine should output a descriptive message
;		when it finds the documentation header.
;	title - Scalar string containing the name to go at the top of the
;               HTML help page.
;       strict - If nonzero, the routine will adhere strictly to HTML format.
;                The document headers will be scanned for characters that are
;                reserved in HTML (<,>,&,"), which are then converted to the 
;                appropriate HTML syntax in the output file.
;
; exit:
;	outfile has been created.
;	txt_file has been closed via FREE_LUN.
;

 ; Append unique numbers to any duplicate subject names.
 dpos = WHERE(dict.id GT 0,ndup) 
 FOR i=0,ndup-1 DO BEGIN
  entry = dict(dpos(i))
  dict(dpos(i)).subject = entry.subject+'['+STRTRIM(STRING(entry.id),2)+']'
 ENDFOR

 ; Sort the subjects alphabetically.
 count = N_ELEMENTS(dict)
 indices = SORT(dict.subject)

 ; Open the final file.
 OPENW,final_file,outfile,/STREAM,/GET_LUN
 IF (verbose NE 0) THEN MESSAGE,/INFO,'Building '+outfile+'...'

 ; Print a comment indicating how the file was generated.
 PRINTF,final_file,'<!-- This file was generated by mk_html_help.pro -->'

 ; Header stuff.
 PRINTF,final_file,'<html>'
 PRINTF,final_file,' '

 ; Title.
 PRINTF,final_file,'<head>'
 PRINTF,final_file,'<TITLE>',title,'</TITLE>'
 PRINTF,final_file,'</head>'
 PRINTF,final_file,' '

 ; Title and intro info.
 PRINTF,final_file,'<body>'
 PRINTF,final_file,'<H1>',title,'</H1>'
 PRINTF,final_file,'<P>'
 PRINTF,final_file,'This page was created by the IDL library routine '
 PRINTF,final_file,'<CODE>mk_html_help</CODE>.  For more information on '
 PRINTF,final_file,'this routine, refer to the IDL Online Help Navigator '
 PRINTF,final_file,'or type: <P>'
 PRINTF,final_file,'<PRE>     ? mk_html_help</PRE><P>'
 PRINTF,final_file,'at the IDL command line prompt.<P>'
 PRINTF,final_file,'<STRONG>Last modified: </STRONG>',SYSTIME(),'.<P>'
 PRINTF,final_file,' '
 PRINTF,final_file,'<HR>'
 PRINTF,final_file,' '

 ; Index.
 PRINTF,final_file,'<A NAME="ROUTINELIST">'
 PRINTF,final_file,'<H1>List of Routines</H1></A>'
 PRINTF,final_file,'<UL>'
 FOR i=0,count-1 DO BEGIN
  entry = dict(indices(i))

  IF (entry.nline GT 0) THEN $
   PRINTF,final_file,'<LI><A HREF="#',entry.subject,'">',entry.subject,'</A>'
 ENDFOR
 PRINTF,final_file,'</UL><P>'
 PRINTF,final_file,' '

 PRINTF,final_file,'<HR>'
 PRINTF,final_file,' '

 ; Descriptions.
 PRINTF,final_file,'<H1>Routine Descriptions</H1>'
 ON_IOERROR,TXT_DONE
 FOR i=0,count-1 DO BEGIN
  entry = dict(indices(i))
  IF (entry.nline GT 0) THEN BEGIN
   PRINTF,final_file,'<A NAME="',entry.subject,'">'
   PRINTF,final_file,'<H2>',entry.subject,'</H2></A>'

   prev_i = i - 1
   IF (prev_i LT 0) THEN $
    dostep = 0 $ 
   ELSE BEGIN
    prev_ent = dict(indices(prev_i))
    dostep = prev_ent.nline EQ 0
   ENDELSE
   WHILE dostep DO BEGIN
    prev_i = prev_i - 1
    IF (prev_i LT 0) THEN $
     dostep = 0 $
    ELSE BEGIN
     prev_ent = dict(indices(prev_i))
     dostep = prev_ent.nline EQ 0
    ENDELSE
   ENDWHILE
   IF (prev_i GE 0) THEN $
    PRINTF,final_file,'<A HREF="#',prev_ent.subject,'">[Previous Routine]</A>'

   next_i = i + 1
   IF (next_i GE count) THEN $
    dostep = 0 $
   ELSE BEGIN
    next_ent = dict(indices(next_i))
    dostep = next_ent.nline EQ 0
   ENDELSE
   WHILE dostep DO BEGIN
    next_i = next_i + 1
    IF (next_i GE count) THEN $
     dostep = 0 $
    ELSE BEGIN
     next_ent = dict(indices(next_i))
     dostep = next_ent.nline EQ 0
    ENDELSE
   ENDWHILE
   IF (next_i LT count) THEN $
    PRINTF,final_file,'<A HREF="#',next_ent.subject,'">[Next Routine]</A>'

   PRINTF,final_file,'<A HREF="#ROUTINELIST">[List of Routines]</A>'
   PRINTF,final_file,'<PRE>'
   tmp = ''

   POINT_LUN,txt_file,entry.offset
   FOR j=1,entry.nline DO BEGIN
    READF,txt_file,tmp
    PRINTF,final_file,tmp
   ENDFOR
   PRINTF,final_file,'</PRE><P>'
   IF (entry.lib NE -1L) THEN BEGIN
    fname = libfiles(entry.lib)
    lname = infiles(entry.indx)
    IF (strict) THEN BEGIN
     mhh_strict,fname
     mhh_strict,lname
    ENDIF
    PRINTF,final_file,'<STRONG>(See '+fname+' in '+lname+')</STRONG><P>'
   ENDIF ELSE BEGIN
    fname = infiles(entry.indx)
    IF (strict) THEN mhh_strict,fname
    PRINTF,final_file,'<STRONG>(See '+fname+')</STRONG><P>'
   ENDELSE
   PRINTF,final_file,'<HR>'
   PRINTF,final_file,' '
  ENDIF
 ENDFOR
TXT_DONE:
 ON_IOERROR,NULL
 FREE_LUN,txt_file

 ; Footer.
 PRINTF,final_file,'</body>'
 PRINTF,final_file,'</html>'
 FREE_LUN,final_file
END

;----------------------------------------------------------------------------
PRO mk_html_help, sources, outfile, VERBOSE=verbose, TITLE=title, STRICT=strict

 IF (NOT KEYWORD_SET(verbose)) THEN verbose=0
 IF (NOT KEYWORD_SET(title)) THEN title="Extended IDL Help" 
 IF (NOT KEYWORD_SET(strict)) THEN strict=0

 infiles = ''
 istlb = 0b

 count = N_ELEMENTS(sources)
 IF (count EQ 0) THEN BEGIN
  MESSAGE,/INFO,'No source IDL directories found.'
  RETURN
 ENDIF

 ; Open a temporary file for the documentation text.
 OPENW, txt_file, FILEPATH('userhtml.txt', /TMP), /STREAM, /GET_LUN, /DELETE

 ; Loop on sources. 
 FOR i=0, count-1 DO BEGIN
  src = sources(i)

  ; Strip any version numbers from the source so we can check for the
  ; VMS .tlb or .pro extension.
  vpos = STRPOS(src,';')
  IF (vpos NE -1) THEN vsource = STRMID(src,0,vpos) ELSE vsource = src

   ; Test if the source is a VMS text library.
  IF (!VERSION.OS EQ 'vms') AND (STRLEN(vsource) GT 4) AND $
     (STRUPCASE(STRMID(vsource, STRLEN(vsource)-4,4)) EQ '.TLB') THEN BEGIN 
   infiles = [infiles,src]
   istlb = [istlb, 1b]
  ENDIF ELSE BEGIN
   ; Test if the file is a .PRO file.
   IF (STRUPCASE(STRMID(vsource, STRLEN(vsource)-4,4)) EQ '.PRO') THEN BEGIN 
    infiles = [infiles,src]
    istlb = [istlb, 0b]

   ; If not a VMS text library or .PRO file, it must be a directory name.
   ENDIF ELSE BEGIN
    CASE !VERSION.OS_FAMILY OF
     'Windows': tok = '\'
     'MacOS': tok = ':'
     'unix': tok = '/'
     'vms': tok = ''
    ENDCASE

    ; Get a list of all .pro files in the directory.
    flist = FINDFILE(src+tok+'*.pro',COUNT=npro)
    IF (npro GT 0) THEN BEGIN
     infiles = [infiles,flist]
     istlb = [istlb, REPLICATE(0b,npro)]
    ENDIF

    ; Get a list of all .tlb files in the directory.
    flist = FINDFILE(src+tok+'*.tlb',COUNT=ntlb)
    IF (ntlb GT 0) THEN BEGIN
     infiles = [infiles,flist]
     istlb = [istlb, REPLICATE(1b,ntlb)]
    ENDIF
   ENDELSE
  ENDELSE
 ENDFOR

 count = N_ELEMENTS(infiles)
 IF (count EQ 1) THEN BEGIN
  MESSAGE,/INFO,'No IDL files found.'
  RETURN
 ENDIF 
 infiles = infiles(1:*)
 istlb = istlb(1:*)
 count = count-1
 
 ; Loop on all files.
 FOR i=0,count-1 DO BEGIN
  src = infiles(i)

  IF (istlb(i)) THEN BEGIN
   ; If it is a text library, get a list of routines by spawning
   ; a LIB/LIST command. 
   SPAWN,'LIBRARY/TEXT/LIST ' + src,files
   lib_count = N_ELEMENTS(files)
   j=0
   WHILE ((j LT lib_count) AND (STRLEN(files(j)) NE 0)) DO j = j + 1
   lib_count = lib_count - j - 1
   IF (count GT 0) THEN files = files(j+1:*)
   ; We do a separate extract for each potential routine. This is
   ; pretty slow, but easy to implement. This routine is generally
   ; run once in a long while, so I think it's OK.
   lib_total = N_ELEMENTS(libfiles)
   IF (lib_total EQ 0) THEN libfiles = files ELSE libfiles = [libfiles, files]
   FOR j=0, lib_count-1 DO BEGIN
    name = FILEPATH('mkhtmlhelp.scr',/TMP)
    SPAWN,'LIBRARY/TEXT/EXTRACT='+files(j)+'/OUT='+name+' '+src
    mhh_grab_hdr,files(j),dict,i,lib_total+j,txt_file,verbose,strict
   ENDFOR
  ENDIF ELSE BEGIN
   name = infiles(i)
   mhh_grab_hdr,name,dict,i,-1L,txt_file,verbose,strict
  ENDELSE
 ENDFOR

 ; Generate the HTML file.
 mhh_gen_file,dict,txt_file,infiles,libfiles,outfile,verbose,title,strict
END

; $Id: mk_library_help.pro,v 1.5 1995/07/07 17:47:49 griz Exp $

;+
; NAME:
;	MK_LIBRARY_HELP
;
; PURPOSE:
;	Given a directory or a VMS text library containing IDL user library
;	procedures, this procedure generates a file in the IDL help format
;	that contains the documentation for those routines that contain
;	a DOC_LIBRARY style documentation template.  The output file is
;	compatible with the IDL "?" command.
;
;	A common problem encountered with the DOC_LIBRARY user library
;	procedure is that the user needs to know what topic to ask for
;	help on before anything is possible.  The XDL widget library
;	procedure is one solution to this "chicken and egg" problem.
;	The MK_LIBRARY_HELP procedure offers another solution.
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	MK_LIBRARY_HELP, Source, Outfile
;
; INPUTS:
;      SOURCE:	The directory or VMS text library containing the
;		.pro files for which help is desired.  If SOURCE is
;		a VMS text library, it must include the ".TLB" file
;		extension, as this is what MK_LIBRARY_HELP uses to
;		tell the difference.
;
;     OUTFILE:	The name of the output file which will be generated.
;		If you place this file in the help subdirectory of the
;		IDL distribution, and if it has a ".help" extension, then
;		the IDL ? command will find the file and offer it as one
;		of the availible help categories. Note that it uses the
;		name of the file as the name of the topic.
;
; KEYWORDS:
;     TITLE:	If present, a string which supplies the name that
;		should appear on the topic button for this file
;		in the online help. This title is only used on
;		systems that allow very short file names (i.e. MS DOS),
;		so it won't always have a visible effect. However,
;		it should be used for the broadest compatibility. If
;		a title is not specified, IDL on short name systems
;		will use a trucated copy of the file name.
;     VERBOSE:	Normally, MK_LIBRARY_HELP does its work silently.
;		Setting this keyword to a non-zero value causes the procedure
;		to issue informational messages that indicate what it
;		is currently doing.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A help file with the name given by the OUTFILE argument is
;	created.
;
; RESTRICTIONS:
;	If you put the resulting file into the "help" subdirectory of
;	the IDL distribution, it will be overwritten when you install a
;	new release of IDL.  To avoid this problem, keep a backup copy of
;	your created help files in another directory and move them into
;	the new distribution.
;
;	Since this routine copies the documentation block from the
;	functions and procedures, subsequent changes will not be
;	reflected in the help file unless you run MK_LIBRARY_HELP
;	again.
;
;	The following rules must be followed in formating the .pro
;	files which are searched.
;		(a) The first line of the documentation block contains
;		    only the characters ";+", starting in column 1.
;		(b) The last line of the documentation block contains
;		    only the characters ";-", starting in column 1.
;		(c) Every other line in the documentation block contains
;		    a ";" in column 1.
;
;	No reformatting of the documentation is done.
;
; MODIFICATION HISTORY:
;	17 April, 1991, Written by AB, RSI.
;	1 December 1992, Reorganized internally. No functionality change.
;	31 December 1992, Added the TITLE keyword as part of the effort
;		towards releasing the Microsoft Windows version of IDL.
;	20 January 1993,  Corrected for VMS, W. Landsman HSTX
;	17 March 1993, Corrected for MSDOS and VMS, AB.
;	13 January 1994, Added the VERSION attribute and modified format to
;		accomodate extended identifier names (the old format was
;		limited to 15 characters.
;       7 July 1995, Added support for MacOS, DD, RSI.
;-
;
;


pro mlh_grab_header, in_file, num, id_chars, subject, idx_file, $
	txt_file, verbose
;
; Searches in_file for all text between the ;+ and ;- comments, and
; updates the index and text files appropriately.
;
; entry:
;	in_file - LUN for .PRO file containing documentation header.
;	num - Named variable containing # of entries added to idx_file.
;	id_chars - Named variable containing number of characters used
;		by all identifier names in the table of contents.
;	subject - Name of subject represented by in_file
;	idx_file - Scratch file to which table of contents entries will
;		be written.
;	txt_file - Scratch file to which the documentation header will
;		be written.
;	verbose - TRUE if the routine should output a descriptive message
;		when it finds the documentation header.
;
; exit:
;	in_file - Closed via FREE_LUN
;	num - Incremented if a documentation header was found.
;	id_chars - Updated to reflect new entry added to table of contents.
;	idx_file, txt_file - Updated as necessary. Both are positioned at EOF.
;

  ; Under DOS, formatted output ends up with a carriage return linefeed
  ; pair at the end of every record. The resulting file would not be
  ; compatible with Unix. Therefore, we use unformatted output, and
  ; explicity add the linefeed, which has ASCII value 10.
  LF=10B

  ; Find the opening line
  tmp = ''
  found = 0
  while (not eof(in_file)) and (not found) do begin
    readf, in_file, tmp
    if (strmid(tmp, 0, 2) eq ';+') then found = 1
  endwhile

  if (found) then begin
    if (verbose ne 0) then message, /INFO, subject
    num = num + 1
    id_chars = id_chars + strlen(subject)
    point_lun, -txt_file, txt_pos
    writeu, idx_file, string(txt_pos, subject, format='(I0, ":", A)'), LF
    writeu, txt_file, ';+', LF
    txt_pos = txt_pos + 3
    found = 0
    while (not found) do begin
      readf, in_file, tmp
      if (strmid(tmp, 0, 2) eq ';-') then begin
        found = 1
      endif else begin
	len = strlen(tmp)
	if (len eq 0) then len = 1
	txt_pos = txt_pos + len
        writeu, txt_file, strmid(tmp, 1, 1000), LF
      endelse
    endwhile

    writeu, txt_file, ';-', LF
    txt_pos = txt_pos + 3
  endif

  FREE_LUN, in_file
end







pro MLH_GEN_FILE, num, id_chars, idx_file, txt_file, outfile, verbose, title
;
; Build a .HELP file from the consituent parts.
;
; entry:
;	num - # of subjects
;	id_chars - # of characters used by identifiers in table of contents
;		not counting any possible NULL termination.
;	idx_file - Scratch file containing the table of contents.
;	txt_file - Scratch file containing the documentation text.
;	outfile - NAME of final HELP file to be generated.
;	verbose - TRUE if the routine should output a descriptive message
;		when it finds the documentation header.
;	title - Scalar string. If non-null,  contains the optional %TITLE
;		name to go at the top of the file.
;
; exit:
;	outfile has been created.
;	idx_file and txt_file have been closed via FREE_LUN


  ; Rewind the scratch files.
  point_lun, idx_file, 0
  point_lun, txt_file, 0

  ; Open the final file.
  openw, final_file, outfile, /stream, /get_lun
  if (verbose ne 0) then message, /INFO, 'building ' + outfile

  ; Under DOS, formatted output ends up with a carriage return linefeed
  ; pair at the end of every record. The resulting file would not be
  ; compatible with Unix. Therefore, we use unformatted output, and
  ; explicity add the linefeed, which has ASCII value 10.
  LF=10B

  writeu, final_file, '%VERSION:2', LF
  if (title ne '') then writeu, final_file, '%TITLE:', STRUPCASE(title), LF

  writeu, final_file, string(num, format='(I0)'), LF	; The subject count
  writeu, final_file, string(id_chars, format='(I0)'), LF  ; # of subject chars

  tmp = ''
  ON_IOERROR, IDX_DONE
  while 1 do begin                              ; Breaks out via IOERROR
    readf, idx_file, tmp
    writeu, final_file, tmp, LF
  endwhile
IDX_DONE:
  free_lun, idx_file				; This deletes the index file

  tmp = ''
  ON_IOERROR, TXT_DONE
  while 1 do begin				; Breaks out via IOERROR
    readf, txt_file, tmp
    writeu, final_file, tmp, LF
  endwhile
TXT_DONE:
  ON_IOERROR, NULL
  free_lun, txt_file, final_file		; Deletes the text file


end







pro MK_LIBRARY_HELP, source, outfile, verbose=verbose, title=title

  if (not keyword_set(verbose)) then verbose = 0
  if (not keyword_set(title)) then title=''

  ; Open two temporary files, one for the index and one for the text.
  openw, idx_file, filepath('userlib.idx', /TMP), /stream, /get_lun, /delete
  openw, txt_file, filepath('userlib.txt', /TMP), /stream, /get_lun, /delete

  ; This is the number of files that actually contain a documentation block
  num = 0

  ; This is the number of characters used by all the identifiers in the
  ; table of contents, not counting any possible NULL termination.
  id_chars = 0

  if (verbose ne 0) then message, /INFO, 'searching ' + source

  ; Is it a VMS text library?
  vms_tlb = 0				; Assume not
  if (!version.os eq 'vms') then begin
    ; If this is VMS, decide if SOURCE is a directory or a text library.
    if ((strlen(SOURCE) gt 4) and $
        (strupcase(strmid(SOURCE, strlen(SOURCE)-4,4)) eq '.TLB')) then $
      vms_tlb = 1
  endif

  ; If it is a text library, get a list of routines by spawning
  ; a LIB/LIST command. Otherwise, just search for .pro files.
  if (vms_tlb) then begin
    spawn,'LIBRARY/TEXT/LIST ' + SOURCE, FILES
    count = n_elements(files)
    i = 0
    while ((i lt count) and (strlen(files(i)) ne 0)) do i = i + 1
    count = count - i - 1
    if (count gt 0) then files = files(i+1:*)
  endif else begin		  ; Search for .pro files
    case !version.os_family of
     'unix': tmp = '/'
     'vms': tmp = ''
     'Windows': tmp = '\'
     'MacOS': tmp = ':'
    endcase 
    files = findfile(source + tmp + '*.pro', count=count)
    if (!version.os eq 'vms') then begin
      if (count ne 0) then prefix_length = STRPOS(files(0), ']')+1
    endif else begin
      prefix_length = strlen(source) + 1
    endelse
  endelse

  for i = 0, count-1 do begin
    if (vms_tlb) then begin
      ; We do a separate extract for each potential routine. This is
      ; pretty slow, but easy to implement. This routine is generally
      ; run once in a long while, so I think it's OK
      subject = files(i)
      name = filepath('mklibhelp.scr', /tmp)
      spawn, 'LIBRARY/TEXT/EXTRACT='+subject+'/OUT='+name+' '+SOURCE
      openr, in_file, name, /get_lun, /delete
    endif else begin
      name = files(i)
      if (!version.os eq 'vms') then begin
        subject = STRMID(name, prefix_length, 1000)
        subject = STRMID(subject, 0, STRPOS(subject, '.'))
      endif else begin
        subject = strupcase(strmid(name, prefix_length, $
	  strlen(name) - prefix_length-4))
      endelse
      openr, in_file, name, /get_lun
    endelse

    ; Grab the header
    MLH_GRAB_HEADER, in_file, num, id_chars, subject, idx_file, $
		txt_file, verbose


  endfor

  ; Produce the final product
  MLH_GEN_FILE, num, id_chars, idx_file, txt_file, outfile, verbose, title

end
; $Id: modifyct.pro,v 1.2 1995/01/25 23:00:25 billo Exp $

PRO MODIFYCT, ITAB, NAME, R, G, B, FILE=file	;MODIFY COLOR TABLE IN FILE
;+
; NAME:
;	MODIFYCT 
;
; PURPOSE:
;	Update the distribution color table file "colors1.tbl" or the
;	user-supplied file with a new table.
;
; CATEGORY:
;	Z4 - Image processing, color table manipulation.
;
; CALLING SEQUENCE:
;	MODIFYCT, Itab, Name, R, G, B
;
; INPUTS:
;	Itab:	The table to be updated, numbered from 0 to 255.  If the
;		table entry is greater than the next available location
;		in the table, then the entry will be added to the table
;		in the available location rather than the index specified
;		by Itab.  On return, Itab will contain the index for the
;		location that was modified or extended.  The table 
;		can be loaded with the IDL command:  LOADCT, Itab.
;
;	Name:	A string up to 32 characters long that contains the name for 
;		the new color table.
;
;	R:	A 256-element vector that contains the values for the red
;		color gun.
;
;	G:	A 256-element vector that contains the values for the green
;		color gun.
;
;	B:	A 256-element vector that contains the values for the blue
;		color gun.
;
; KEYWORD PARAMETERS:
;	FILE:	If this keyword is set, the file by the given name is used
;		instead of the file colors1.tbl in the IDL directory.  This
;		allows multiple IDL users to have their own color table file.
;		The file specified must be a copy of the colors1.tbl file.
;		The file must exist.
;
; OUTPUTS:
;	Itab:	The index of the entry which was updated, 0 to 255.  This
;		may be different from the input value of Itab if the
;		input value was greater than the next available location
;		in the table.  If this was the case the entry was added to
;		the table in the next available location instead of leaving
;		a gap in the table.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The distribution file "colors.tbl1" or the user-supplied file is
;	modified with the new table.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	Aug, 1982, DMS, Written.
;	Unix version, 1987, DMS.
;	ACY, 9/92, Update for new color table structure, Add FILE keyword.
;		   Allow extending table.
;	WSO, 1/95, Updated for new directory structure
;	
;-
  ON_ERROR,2                    ;Return to caller if an error occurs
  IF (ITAB LT 0)OR(ITAB GT 255) THEN message, $
		'Color table number out of range.'
  
  IF (N_ELEMENTS(file) GT 0) THEN filename = file $
  ELSE filename = FILEPATH('colors1.tbl', subdir=['resource', 'colors'])

  GET_LUN,IUNIT		;GET A LOGICAL UNIT
  OPENU,IUNIT, filename, /BLOCK  ;OPEN FILE
  ntables = 0b
  readu, IUNIT, ntables

  if (ITAB LT ntables) then begin	; Update an existing record
     AA=ASSOC(IUNIT,BYTARR(32,ntables), ntables*768L+1)	;UPDATE NAME RECORD.
     a = aa(0)
     a(*,ITAB) = 32B			;blank out old name
     a(0:strlen(name)-1,ITAB) = byte(name)
     aa(0)=a				;Write names out

     AA=ASSOC(IUNIT,BYTARR(256),1)	;UPDATE VECTORS. SKIP PAST COUNT
     AA(ITAB*3)   = BYTE(R)		;PUT IN RED. GUARANTEE BYTE
     AA(ITAB*3+1) = BYTE(G)		;GREEN IN 2ND BLOCK
     AA(ITAB*3+2) = BYTE(B)		;BLUE IN 3RD BLOCK

  endif else begin			; Add a new record at the end of table
     ITAB = ntables
     ; Add new vectors.  First, read names, then insert vectors
     AA=ASSOC(IUNIT,BYTARR(32,ntables), ntables*768L+1) ;UPDATE NAME RECORD.
     a = aa(0)
     ; Skip past old vectors
     AA=ASSOC(IUNIT,BYTARR(256),ntables*768L+1)      ;UPDATE VECTORS
     AA(0) = BYTE(R)             ;PUT IN RED. GUARANTEE BYTE
     AA(1) = BYTE(G)             ;GREEN IN 2ND BLOCK
     AA(2) = BYTE(B)             ;BLUE IN 3RD BLOCK

     ; Skip past new vector to put in names
     AA=ASSOC(IUNIT,BYTARR(32,ntables+1), (ntables+1)*768L+1)
     ; Add new name to end
     temp=bytarr(32)+32B
     temp(0:strlen(name)-1)=byte(name)
     allnames=bytarr(32,ntables+1)
     allnames(*,0:ntables-1) = a
     allnames(*,ntables)=temp
     AA(0) = allnames		; write the names out
          
     ; Update count
     AA=ASSOC(IUNIT,BYTARR(1))
     AA(0) = [ntables+1B]
  endelse

  FREE_LUN,IUNIT
  RETURN
END
;$Id: moment.pro,v 1.4 1995/07/25 20:32:55 dave Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       MOMENT
;
; PURPOSE:
;       This function computes the mean, variance, skewness and kurtosis
;       of an n-element vector.  
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Moment(X)
;
; INPUTS:
;       X:      An n-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
;       MDEV:   Use this keyword to specify a named variable which returns
;               the mean absolute deviation of X.
;
;       SDEV:   Use this keyword to specify a named variable which returns
;               the standard deviation of X.
;
; EXAMPLE:
;       Define the n-element vector of sample data.
;         x = [65, 63, 67, 64, 68, 62, 70, 66, 68, 67, 69, 71, 66, 65, 70]
;       Compute the mean, variance, skewness and kurtosis.
;         result = moment(x)
;       The result should be the 4-element vector: 
;       [66.7333, 7.06667, -0.0942851, -1.18258]
;
; PROCEDURE:
;       MOMENT computes the first four "moments" about the mean of an 
;       n-element vector of sample data. The computational formulas 
;       are given in the Univariate Statistics section of the Mathematics
;       Guide.
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, August 1994
;-

function moment, x, mdev = mdev, sdev = sdev

  on_error, 2
  nx = n_elements(x)
  if nx le 1 then $
    message, 'Not defined for scalar inputs.' 
  
  mean = total(x) / nx
  resid = x - mean
  ;Mean absolute deviation (returned through the MDEV keyword).
  mdev = total(abs(resid)) / nx
  r2 = total(resid^2)  
  var1 = r2 / (nx-1.0)
  var2 = (r2 - (total(resid)^2)/nx)/(nx-1.0)
  var =  (var1 + var2)/2.0
  ;Standard deviation (returned through the SDEV keyword).
  sdev = sqrt(var)

  if var ne 0 then begin 
    skew = total(resid^3) / (nx * sdev ^ 3)
    kurt = total(resid^4) / (nx * sdev ^ 4) - 3.0
  endif else message, $
     'Skewness and Kurtosis not defined for a sample variance of zero.'
  return, [mean, var, skew, kurt]
end

; $Id: mp_basic.pro,v 1.6 1995/01/20 19:41:01 tonyh Exp $

;+
; NAME:
;	MP_BASIC
;
; PURPOSE:
;	Provide online documentation for IDL topics. The style
;	is a cross between Unix man pages and VMS online help.  The
;	help is organized in a two level hierarchy --- Level 1 is the
;	global subject, and Level 2 supplies help on subjects within
;	each global subject.  If !D.WINDOW is not -1, (window system in use)
;	the mouse is used to prompt for subjects, otherwise, the normal tty
;	interface is used.
;
;	THIS ROUTINE IS TO BE CALLED ONLY BY MAN_PROC.  Users can obtain
;	online help by using the "?" command.
;
; CATEGORY:
;	Help, documentation.
;
; CALLING SEQUENCE:
;	MP_BASIC [, Request]
;
; INPUTS:
;     REQUEST:	A scalar string containing the item on which help is desired.
;		This string can contain 1 or 2 (whitespace separated) words.
;		The first word is taken as the global topic and the second
;		as the topic within the scope of the first.  The procedure
;		prompts for missing words.
;
; OUTPUTS:
;	Help text is sent to the standard output.
;
; COMMON BLOCKS:
;	None.
;
; RESTRICTIONS:
;	The help text is derived from the LaTeX files used to produce
;	the reference manual.  However, it is not possible to produce
;	exactly the same output as found in the manual due to limitations
;	of text oriented terminals.  The text used is therefore considerably
;	abbreviated.  Always check the manual if the online help is
;	insufficient.
;
; MODIFICATION HISTORY:
;	3 November 1988, AB
;
;	January, 1989, AB
;	Added ambiguity resolution, ability to handle multiple levels,
;	and support for mouse.
;
;       SNG, December, 1990	Added support for MS-DOS.
;
;	3 January 1991, AB
;	Renamed from MAN_PROC to make room for the widget version.
;	
;       Bobby Candey, Atlantic Research         30 January 1991
;       Added looping in VMS version to extract multiple "]" from filenames
;
;       31 December 1992, AB    Modified to ignore the optional %TITLE
;                               line at the top of the file. There's no
;                               reason to handle it, since this routine is
;                               obsolete. The builtin online help system
;                               *does* handle it.
;
;	11 February 1993, SMR	Added support for the Mac Version
;	21 April 1993, AB, Added ability to use new !HELP_PATH system
;		variable to locate help files.
;	13 January 1994, AB	Added ability to understand new version
;				2 help files with extended identifier names.
;
;-
;

function MPB_SELTOPIC, SUBJECT, TOPIC_ARRAY, INITIAL
; Given a subject header and an array of topics, returns a string with
; the requested topic (which may or may not be in TOPIC_ARRAY).
; Initial is the index of the initial selection to be highlighed *if*
; a window system menu is used.
on_error,2                      ;Return to caller if an error occurs
target = ''
if((!d.name eq 'X') or (!d.name eq 'SUN')) then begin
    index = wmenu([SUBJECT, TOPIC_ARRAY], title=0, initial=initial)
    if (index ne -1) then target = TOPIC_ARRAY(index-1)
  endif else begin				; Use tty
    if (!VERSION.OS NE 'MacOS') then $
      openw, outunit, filepath(/TERMINAL), /MORE, /GET_LUN $
    else outunit = -1
    printf, outunit, format = '(/,A,":",/)', SUBJECT
    printf, outunit, TOPIC_ARRAY
    if (!VERSION.OS NE 'MacOS') then close, outunit
    outunit = 0
    print, format='(/,/)'
    read, 'Enter topic for which help is desired: ', target
  endelse

return, STRCOMPRESS(STRUPCASE(target),/REMOVE_ALL)    ; Up case & no blanks
end



function MPB_TM, KEY, TOPIC_ARRAY, FOUND, OUTUNIT
; Topic MAtch. Given a string, MPB_TM returns an array of indicies into
; TOPIC_ARRAY that match into FOUND. If there is an exact match
; only its index is returned, otherwise all elements with the same prefix
; match. The number of elements that matched is returned.
; OUTUNIT is the file unit to which output should be directed.
on_error,2                      ;Return to caller if an error occurs
l_topic_array = strupcase(topic_array)
found = [ where(STRTRIM(L_TOPIC_ARRAY) eq KEY, count) ] ; Match exact string
if (count le 0) then begin	; No exact match, try to match the prefix
  FOUND = [ where(strpos(L_TOPIC_ARRAY, KEY) eq 0, count) ]
  if ((count le 0) or (KEY eq '')) then begin		;Found it?
    count = 0
    printf,outunit, !MSG_PREFIX, 'Nothing matching topic "',KEY,'" found."'
    printf,outunit, !MSG_PREFIX, 'Enter "?" for list of available topics.'
  endif else begin
    if (count ne 1) then begin
      printf, outunit, format = "(A,'Ambiguous topic ""', A, '"" matches:')",$
	     !MSG_PREFIX, KEY
      printf, OUTUNIT, TOPIC_ARRAY(FOUND)
      endif
  endelse
endif
return, count
end



PRO MP_BASIC, REQUEST

  on_error,1                      ; Return to main level if error occurs
  outunit = (inunit = 0)
  lv1_topic = (lv2_topic = '')

  if (N_ELEMENTS(REQUEST)) then begin
    temp = size(request)
    if (temp(0) NE 0) then begin
      MSG = 'Argument must be scalar.'
      goto, fatal
      endif
    if (temp(1) NE 7) then begin
      MSG = 'Argument must be of type string.'
      goto, FATAL
      endif
    ; Parse into 1 or two strings
    lv1_topic = STRUPCASE(STRTRIM(STRCOMPRESS(REQUEST), 2))
    if (((blank_pos = STRPOS(lv1_topic, ' '))) ne -1) then begin
	lv2_topic = STRMID(lv1_topic, blank_pos+1, 10000L)
	lv1_topic = STRMID(lv1_topic, 0, blank_pos)
      endif
  endif


  ; lv1_files recieves all help files found through !HELP_PATH.
  lv1_dirs = EXPAND_PATH(!HELP_PATH, /ARRAY, COUNT=cnt)
  if (cnt eq 0) then begin
    MSG = 'No online help files found.'
    goto, fatal
  endif
  for i = 0, cnt-1 do begin
    tmp = STRLOWCASE(findfile(filepath('*.help', root_dir=lv1_dirs(i))))
    if (i eq 0) then lv1_files = TEMPORARY(tmp) $
    else lv1_files=[lv1_files, TEMPORARY(tmp)]
  endfor

  ; lv1_topics gets uppercase version of just the names.
  lv1_topics = STRUPCASE(lv1_files)
  if !version.os ne 'Win32' then begin
    tail = STRPOS(lv1_topics, '.HELP')
  endif else begin
    tail = STRPOS(lv1_topics, '.HEL')
  endelse
  n = n_elements(lv1_topics)
  for i = 0, n-1 do $
	lv1_topics(i) = strmid(lv1_topics(i), 0, tail(i))
  for i = 0, n-1 do begin	; Strip path part off lv1_topics
    case !version.os of
      'vms': begin
           j = STRPOS(lv1_topics(i), ']')
           while (j ne -1) do begin
             lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
             j = STRPOS(lv1_topics(i), ']')
           endwhile
      end
      'Win32': begin
        j = STRPOS(lv1_topics(i), '\')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), '\')
        endwhile
      end
      'MacOS': begin
        j = STRPOS(lv1_topics(i), ':')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), ':')
        endwhile
      end
      else:  begin      ; Unix otherwise
        j = STRPOS(lv1_topics(i), '/')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), '/')
        endwhile
      end
    endcase
  endfor

  ; Sort the topics into alphabetical order.
  tmp = sort(lv1_topics)
  lv1_files = lv1_files(tmp)
  lv1_topics = lv1_topics(tmp)

  initial = where(lv1_topics eq 'ROUTINES')
  if (lv1_topic eq '') then $
    lv1_topic = MPB_SELTOPIC('Help categories', lv1_topics, initial(0)+1)
  if (!VERSION.OS NE 'MacOS') then $
    openw, outunit, filepath(/TERMINAL), /MORE, /GET_LUN $
  else outunit = -1
  if (((count=MPB_TM(lv1_topic,lv1_topics,found,outunit))) eq 0) then $
    goto, done
  IF (!VERSION.OS NE 'MacOS') THEN free_lun, outunit
  outunit = 0
  lv2_subject = lv1_topics(found(0))		; Use the first element

  ; At this point, a global subject exists, process the specific subject
  lv2_topics = ''
  offset = 0L
  openr, inunit, lv1_files(found(0)), /GET_LUN
  outunit = 0;
  n = 0L
  tmp=''
  readf,inunit,tmp				; Read first line.
  ; If it's the version tag, parse it.
  version = 1L					; Assume old format
  if (strmid(tmp, 0, 9) eq '%VERSION:') then begin
    reads, tmp, version, format='(9X, I0)'
    readf,inunit,tmp				; Read next line.
  endif
  if (strmid(tmp, 0, 7) eq '%TITLE:') then readf, inunit, tmp   ; Skip title
  n = long(tmp)					;# of records
  if (version ne 1) then begin
    ; Version 2 format has the number of characters used by all the
    ; subtopics on the next line. We don't use it, but have to read it
    readf,inunit,tmp				; Read next line.
  endif
  lv2_topics = strarr(n)			;Make names
  readf,inunit,lv2_topics			;Read entire string to inunit
  if (version eq 1) then begin
    offsets = long(strmid(lv2_topics, 15, 30))	;Extract starting bytes
    lv2_topics = strmid(lv2_topics,0,15)		;Isolate names
  endif else begin
    offsets = lonarr(n)
    for i = 0, n-1 do begin
      tmp = lv2_topics(i)
      colon = strpos(tmp, ':') + 1		; Find delimiter
      offsets(i) = long(strmid(tmp, 0, colon))
      lv2_topics(i) = strmid(tmp, colon, 10000000)
    endfor
  endelse

  ; Determine the base of the help text
  tmp = fstat(inunit)
  text_base = tmp.cur_ptr

  ; If no topic is supplied, prompt for one
  if lv2_topic eq '' then $
    lv2_topic = MPB_SELTOPIC(STRUPCASE(lv2_subject), lv2_topics, 1)

  if (!VERSION.OS NE 'MacOS') THEN $
    openw, outunit, filepath(/TERMINAL), /MORE, /GET_LUN $
  else outunit = -1
  if (((count=MPB_TM(lv2_topic,lv2_topics,found,outunit))) eq 0) then $
    goto, done
  str = ''
  for i = 0, count-1 do begin
    index = found(i)
    if (count ne 1) then $
      printf, outunit, lv2_topics(index), $
	      format='("***************",/,A,/,"***************")'
      POINT_LUN, inunit, text_base + offsets(index)
      readf, inunit, str		; Skip the ";+"
      readf, inunit, str
      !err = 0
      while (str NE ";-") do begin
	printf, outunit, str, ' '
	if !err ne 0 then goto, DONE
	readf, inunit, str
	endwhile
      endfor

  goto, DONE
FATAL:		; The string MSG must be set
;  message, MSG, /RETURN
DONE:
  if (outunit ne 0) then FREE_LUN, outunit
  if (inunit ne 0) then FREE_LUN, inunit
end
; $Id: mp_widgets.pro,v 1.3 1995/01/20 19:41:01 tonyh Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	MP_WIDGETS
;
; PURPOSE:
;	Provide a graphical user interface to the online documentation.
;	The topic is selected by pressing a button at the top.
;	Subtopics a displayed in a scrolling list on the left side.  Pressing
;	a mouse button while pointing at a subtopic causes the information
;	on that topic to be displayed in the large text region on the right.
;
;	It is expected that this routine will only be called by MAN_PROC.
;
; CATEGORY:
;	Help, documentation, widgets.
;
; CALLING SEQUENCE:
;	MP_WIDGETS [, Request]
;
; INPUTS:
;     Request:	A scalar string containing the item on which help is desired.
;		This string can contain 1 or two (whitespace separated) words.
;		The first word is taken as the global topic and the second
;		as the topic within the scope of the first.
;
; OUTPUTS:
;	None.  A widget interface is used to allow reading the help text.
;
; COMMON BLOCKS:
;	MPW_COM: This common block is private to MP_WIDGETS, and
;		 should not be referenced by other modules.
;
; RESTRICTIONS:
;	The basic version of the help facility (MP_BASIC) can accept
;	ambiguous requests, and if a request maches more than a single
;	subtopic, they are all shown.  This version can also accept
;	ambiguous requests, but only the first subtopic matched is shown.
;	This feature is not as important as it was in MP_BASIC because the
;	widget interface allows multiple subjects to be viewed easily.
;
;	This routine uses a COMMON block to keep its internal state, so only
;	one copy of this routine can run at a time.
;
; MODIFICATION HISTORY:
;	AB, August, 1990
;	28 December 1990	Rewritten to take advantages in changes to
;				the widget facility, to use XMANAGER, and to
;				accept the REQUEST argument.
;	31 December 1992	Modified to ignore the optional %TITLE
;				line at the top of the file. There's no
;				reason to handle it, since this routine is
;				obsolete. The builtin online help system
;				*does* handle it.
;-




function mpw_set_lv1, topic_idx, lv2_topics
; Open a new level 1 help file. Close the old one if one exists.
; Update the common block to reflect the change. lv2_topics is the
; array of level 2 topics found in the file. Returns TRUE if the topic
; was changed, FALSE otherwise.

common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  if (topic_idx ne cur_lv1_topic_idx) then begin   ; Only if the topic changed.
    if (unit ne 0) then FREE_LUN, unit
    openr, unit, lv1_files(topic_idx), /get_lun
    cur_lv1_topic_idx = topic_idx
    n = 0L
    tmp = ''
    readf, unit, tmp
    ; If it's the version tag, parse it.
    version = 1L					; Assume old format
    if (strmid(tmp, 0, 9) eq '%VERSION:') then begin
      reads, tmp, version, format='(9X, I0)'
      readf,unit,tmp				; Read next line.
    endif
    if (strmid(tmp, 0, 7) eq '%TITLE:') then readf, unit, tmp	; Skip title
    n = long(tmp)				; # of records
    if (version ne 1) then begin
      ; Version 2 format has the number of characters used by all the
      ; subtopics on the next line. We don't use it, but have to read it
      readf,unit,tmp				; Read next line.
    endif
    lv2_topics = strarr(n)			;Make names
    readf, unit, lv2_topics			;Read entire string from unit
    if (version eq 1) then begin
      offsets = long(strmid(lv2_topics, 15, 30))	;Extract starting bytes
      lv2_topics = strmid(lv2_topics,0,15)		;Isolate names
    endif else begin
      offsets = lonarr(n)
      for i = 0, n-1 do begin
        tmp = lv2_topics(i)
        colon = strpos(tmp, ':') + 1		; Find delimiter
        offsets(i) = long(strmid(tmp, 0, colon))
        lv2_topics(i) = strmid(tmp, colon, 10000000)
      endfor
    endelse

    ; Determine the base of the help text
    tmp = fstat(unit)
    text_base = tmp.cur_ptr
    cur_lv2_idx=-1
    r = 1
  endif else r = 0

  return, r
end







pro mpw_update_display, lv2_topics
; Update the topic label and list elements to reflect the current state
; as determined by mpw_set_lv1. lv2_topics is the array of level 2 topics
; returned by mpw_set_lv1.

  common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  WIDGET_CONTROL, list, set_value=lv2_topics
  WIDGET_CONTROL,title,set_value='Current Topic: ' $
	+ lv1_topics(cur_lv1_topic_idx)
  WIDGET_CONTROL,text,set_value='', /NO_NEWLINE

end







pro mpw_set_lv2, index
; Given an index, display the text associated with it in the current
; help file.

  common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  if (cur_lv2_idx ne index) then begin
    str = ''
    POINT_LUN, unit, text_base + offsets(index)
    readf, unit, str                ; Skip the ";+"
    ; Remember this position
    start = fstat(unit)
    start = start.cur_ptr
    ; Find the end
    while (str NE ";-") do readf, unit, str
    ; How long is the selection?
    tmp = fstat(unit)
    len = tmp.cur_ptr - start - 3
    ; Read the text using binary I/O into a single byte array for efficiency
    str = bytarr(len)
    point_lun, unit, start
    readu, unit, str
    WIDGET_CONTROL, text, SET_VALUE=string(str), /NO_NEWLINE
    cur_lv2_idx = index
  endif

end







pro mpw_event, ev

common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  case (tag_names(ev, /STRUCTURE_NAME)) of
  "WIDGET_BUTTON": begin
	  WIDGET_CONTROL, get_uvalue=uv, ev.id
	  if (uv eq -2) then begin
	    WIDGET_CONTROL, /DESTROY, ev.top
	    if (unit ne 0) then FREE_LUN, unit
	    return
	  endif else begin
	    if (mpw_set_lv1(uv,lv2_topics)) then mpw_update_display,lv2_topics
	  endelse
	end
  "WIDGET_LIST": mpw_set_lv2, ev.index
  endcase


end







function MPW_TM, KEY, TOPIC_ARRAY
; Topic Matcher. Given KEY, this routine returns an index into TOPIC_ARRAY
; that matches KEY. If there is an exact match, that index is returned.
; otherwise the first element with the same prefix is returned.
; On error, MESSAGE is used to report the problem and terminate execution.

  found = where(STRTRIM(TOPIC_ARRAY) eq KEY, count) ; Match exact string
  if (count le 0) then begin	; No exact match, try to match the prefix
    FOUND = where(strpos(TOPIC_ARRAY, KEY) eq 0, count)
    if (count le 0) then begin
      message, /NONAME, 'Unknown topic: ' + KEY
    endif else begin
      if (count ne 1) then begin
	message, /INFO, /NONAME, 'Ambiguous topic "' + KEY $
		+ '" matches: ' + string(format='(i0, " ")', count) $
		+ 'items. ' + strcompress(topic_array(found(0)), /remove) $
		+ ' used.'
      endif
    endelse
  endif

  return, found(0)
end







pro MP_WIDGETS, request

  common mpw_com, cur_lv1_topic_idx, cur_lv2_idx, offsets, text_base, list, $
	title, text, unit, lv1_topics, lv1_files

  if (XREGISTERED('MP_WIDGETS')) then return	; Only one copy at a time

  on_error, 1		; On error, return to main level
  unit = 0		; No help file is open yet

  ; lv1_files recieves all help files found through !HELP_PATH.
  lv1_dirs = EXPAND_PATH(!HELP_PATH, /ARRAY, COUNT=cnt)
  if (cnt eq 0) then message, 'No online help files found.'
  for i = 0, cnt-1 do begin
    tmp = STRLOWCASE(findfile(filepath('*.help', root_dir=lv1_dirs(i))))
    if (i eq 0) then lv1_files = TEMPORARY(tmp) $
    else lv1_files=[lv1_files, TEMPORARY(tmp)]
  endfor

  ; lv1_topics gets uppercase version of just the names.
  lv1_topics = STRUPCASE(lv1_files)
  if !version.os ne 'Win32' then begin
    tail = STRPOS(lv1_topics, '.HELP')
  endif else begin
    tail = STRPOS(lv1_topics, '.HEL')
  endelse
  n = n_elements(lv1_topics)
  for i = 0, n-1 do $
	lv1_topics(i) = strmid(lv1_topics(i), 0, tail(i))
  for i = 0, n-1 do begin	; Strip path part off lv1_topics
    case !version.os of
      'vms': begin
           j = STRPOS(lv1_topics(i), ']')
           while (j ne -1) do begin
             lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
             j = STRPOS(lv1_topics(i), ']')
           endwhile
      end
      'Win32': begin
        j = STRPOS(lv1_topics(i), '\')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), '\')
        endwhile
      end
      'MacOS': begin
        j = STRPOS(lv1_topics(i), ':')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), ':')
        endwhile
      end
      else:  begin      ; Unix otherwise
        j = STRPOS(lv1_topics(i), '/')
        while (j ne -1) do begin
  	  lv1_topics(i) = strmid(lv1_topics(i), j+1, 32767)
          j = STRPOS(lv1_topics(i), '/')
        endwhile
      end
    endcase
  endfor

  ; Sort the topics into alphabetical order.
  tmp = sort(lv1_topics)
  lv1_files = lv1_files(tmp)
  lv1_topics = lv1_topics(tmp)


  ; Check the request (if any) for validity before any widgets are created.
  ; If it is empty, act as if it isn't present.
  REQ_PRESENT = N_ELEMENTS(REQUEST) ne 0
  if (REQ_PRESENT) then begin
    temp = size(request)
    if (temp(0) NE 0) then message, 'Argument must be scalar.'
    if (temp(1) NE 7) then message, 'Argument must be of type string.'
    if (STRLEN(STRCOMPRESS(REQUEST, /REMOVE_ALL)) eq 0) then REQ_PRESENT = 0
  endif

  ; Choose initial display using first option in this list that fits:
  ;  - Request on the command line.
  ;  - The topic used last time this routine was run.
  ;  - Topic is ROUTINES, subtopic is empty
  if (REQ_PRESENT) then begin
    ; Parse into 1 or two strings
    lv1_topic_idx = STRUPCASE(STRTRIM(STRCOMPRESS(REQUEST), 2))
    if (((blank_pos = STRPOS(lv1_topic_idx, ' '))) ne -1) then begin
      lv2_topic = STRMID(lv1_topic_idx, blank_pos+1, 10000L)
      lv1_topic_idx = STRMID(lv1_topic_idx, 0, blank_pos)
    endif else begin
      lv2_topic=''
    endelse
    ; Make sure its legitimate.
    lv1_topic_idx = MPW_TM(lv1_topic_idx, lv1_topics)
    cur_lv1_topic_idx = -1
    junk = mpw_set_lv1(lv1_topic_idx, lv2_topics)
    if (lv2_topic ne '') then lv2_index = MPW_TM(lv2_topic, lv2_topics) $
      else lv2_index = -1
  endif else begin			; No request is present
    if (n_elements(cur_lv1_topic_idx) eq 0) then begin	; Default to ROUTINES
      lv1_topic_idx=MPW_TM("ROUTINES", lv1_topics)	; No sub-topic
      lv2_index = -1
    endif else begin					; Use previous state
      lv1_topic_idx=cur_lv1_topic_idx
      lv2_index = cur_lv2_idx
    endelse
    cur_lv1_topic_idx = -1
    junk = mpw_set_lv1(lv1_topic_idx, lv2_topics)
  endelse
  cur_lv2_idx = -1				; Forget the old state

  ; The request (if any) is OK. Create and realize the widgets.
  base = WIDGET_BASE(title='Help', /COLUMN)
  cntl1 = WIDGET_BASE(base, /FRAME, /ROW, space=30)
  if (!version.os eq 'sunos') then tmp = 10 else tmp = 5
  cntl2 = WIDGET_BASE(base, column=tmp, /FRAME, /exclusive)
    pb_quit = WIDGET_BUTTON(value='Quit', cntl1, uvalue = -2)
    topic_but_ids = lonarr(n, /nozero)
    for i = 0, n-1 do $
      topic_but_ids(i) = WIDGET_BUTTON(value=lv1_topics(i), cntl2, $
				    uvalue = i, /NO_RELEASE)
  title=WIDGET_LABEL(cntl1, value='Current Topic:')
  bottom=WIDGET_BASE(base, /ROW)
  list = WIDGET_LIST(bottom,ysize=30,value = string(bytarr(20) + 45B),/frame)
  text = WIDGET_TEXT(bottom, /SCROLL, xsize = 80, ysize=45)

  WIDGET_CONTROL, base, /REALIZE

  mpw_update_display, lv2_topics

  ; Set the proper button
  if (cur_lv1_topic_idx ne -1) then $
    WIDGET_CONTROL, topic_but_ids(cur_lv1_topic_idx), /SET_BUTTON

  lv2_topics = 0		; Free the dynamic memory
  if (lv2_index ne -1) then mpw_set_lv2, lv2_index

  XMANAGER, 'MP_WIDGETS', base, event_handler='MPW_EVENT'
end
; $Id: multi.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro multi, n	;Multiple wrap of existing color tables
;+
; NAME:
;	MULTI
;
; PURPOSE:
;	Expand the current color table to wrap around N times.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	MULTI, N
;
; INPUTS:
;	N:	The number of times the color table will wrap.  This 
;		parameter does not need not be an integer.
;
; OUTPUTS:
;	No explicit outputs, color tables are loaded.
;
; COMMON BLOCKS:
;	COLORS, the IDL color table common block, contains current color 
;	tables, loaded by LOADCT, ADJCT, HLS, HSV, etc.
;
; SIDE EFFECTS:
;	Color tables are loaded.
;
; RESTRICTIONS:
;	One of the above procedures must have been called.
;
; PROCEDURE:
;	Tables are expanded by a factor of n.
;
; EXAMPLE:
;	Display an image, load color table 1, and make that color table
;	"wrap around" 3 times.  Enter:
;		TVSCL, DIST(256)	;A simple image.
;		LOADCT, 1		;Load color table 1.
;		MULTI, 3		;See how the new color table affects
;					;the image.
; 
; MODIFICATION HISTORY:
;	DMS, May, 1984.
;	Changed common, DMS, 4/87.
;-
common colors,r,g,b,cur_red,cur_green,cur_blue
on_error,2                      ;Return to caller if an error occurs
if n_params() eq 0 then n = 1	;Default = 1 wrap
m = n_elements(r)		;size of tables
if m le 0 then begin
		m = 256		;Default to 256.
		r=indgen(m)  & g = r  & b = r
		end
mm = (indgen(M)*n) mod m	;calc subscripts
cur_red = r(mm) & cur_green = g(mm) & cur_blue = b(mm)
tvlct,cur_red,cur_green,cur_blue ;load it
return
end




























; $Id: ncdf_exists.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;
; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	NCDF_EXISTS
;
; PURPOSE:
;	Test for the existence of the NetCDF library
;
; CATEGORY:
;	File Formats
;
; CALLING SEQUENCE:
;	Result = NCDF_EXISTS()
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	Returns TRUE (1) if the NetCDF data format library is supported
;	Returns FALSE(0) if it is not.
;
; COMMON BLOCKS:
;	NCDFTEST
;
; EXAMPLE:
;	IF ncdf_exists() EQ 0 THEN Fail,"Library not supported on this machine"
;
; MODIFICATION HISTORY
;	Written by:	Joshua Goldstein,  12/8/92
;
;-

PRO	ncdf_control, cid, VERBOSE=v
	common	ncdftest, has_ncdf
	has_ncdf	= 0
end

FUNCTION ncdf_exists
	common	ncdftest, has_ncdf
	has_ncdf	= 1
	ncdf_control,0,/verbose
	return, has_ncdf
END
;$Id: norm.pro,v 1.6 1994/11/29 18:44:16 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       NORM
;
; PURPOSE:
;       1) This function computes the Euclidean norm of a vector.
;          OR
;       2) This function computes the Infinity norm of an array.
;
; CATEGORY:
;       Complex Linear Algebra.
;
; CALLING SEQUENCE:
;       Result = NORM(A)
;
; INPUTS:
;       A:      An N-element real or complex vector.
;               An M by N real or complex array.
;
; KEYWORD PARAMETERS:
;       DOUBLE: If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
; EXAMPLE:
;       1) Define an N-element complex vector (a).
;            a = [complex(1, 0), complex(2,-2), complex(-3,1)]
;          Compute the Euclidean norm of (a).
;            result = norm(a)
;
;       2) Define an M by N complex array (a). 
;            a = [[complex(1, 0), complex(2,-2), complex(-3,1)], $
;                 [complex(1,-2), complex(2, 2), complex(1, 0)]]
;          Compute the Infinity norm of the complex array (a).
;            result = norm(a)
;
; PROCEDURE:
;       NORM.PRO computes the Euclidean norm of an N-element vector.
;       NORM.PRO computes the Infinity norm of an M by N array
;
; REFERENCE:
;       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
;       Erwin Kreyszig
;       ISBN 0-471-55380-8
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, April 1992
;       Modified:    GGS, RSI, February 1994
;                    Computes the Euclidean norm of an N-element vector.
;                    Accepts complex inputs. Added DOUBLE keyword.
;       Modified:    GGS, RSI, September 1994
;                    Added support for double-precision complex inputs.
;-

function NORM, a, double = double
  
  on_error, 2  ;Return to caller if error occurs.

  type = size(a) 

  if type(0) eq 1 then begin ;If vector, compute the Euclidean norm.
    if keyword_set(DOUBLE) ne 0 then begin 
      if type(2) ne 6 and type(2) ne 9 then a = double(a) $
      else a = dcomplex(a) 
    endif
    return, sqrt(total(abs(a)^2)) 
  endif else if type(0) eq 2 then begin ;If matrix, compute the Infinity norm.
    if keyword_set(DOUBLE) ne 0  then begin
      if type(3) ne 6 and type(3) ne 9 then a = double(a) $
      else a = dcomplex(a)
    endif
    return, max(total(abs(a),1))   ;Create the matrix of absolute values,
                                   ;add the elements of each row,
                                   ;and return the maximum.
  endif else message, $
    'Input must be an n-element vector or an M by N array.'

end
; $Id: oploterr.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO OPLOTERR, X, Y, ERR, PSYM
;
;+
; NAME:
;	OPLOTERR
;
; PURPOSE:
;	Overplot data points with accompanying error bars.
;
; CATEGORY:
;	Plotting, 2-dimensional.
;
; CALLING SEQUENCE:
;	OPLOTERR, [ X ,]  Y , Err  [, Psym ]
;
; INPUTS:
;	Y:	The array of Y values.
;
;	Err:	The array of error bar values.
;
; OPTIONAL INPUT PARAMETERS:
;	X:	An optional array of X values.  The procedure checks whether 
;		or not the third parameter passed is a vector to decide if X 
;		was passed.
;		
;		If X is not passed, then INDGEN(Y) is assumed for the X values.
;
;	PSYM:	The plotting symbol to use (default = +7).
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	Arrays cannot be of type string.  There must be enough points to
;	plot.
;
; PROCEDURE:
;	A plot of X versus Y with error bars drawn from Y - ERR to Y + ERR
;	is written to the output device over any plot already there.
;
; MODIFICATION HISTORY:
;	William Thompson	Applied Research Corporation
;	July, 1986		8201 Corporate Drive
;				Landover, MD  20785
;-
;
P_SYM = !PSYM		; Save the affected system parameters
LINETYPE = !LINETYPE
;
;  Interpret the input parameters.
;
ON_ERROR,2              ; Return to caller if an error occurs
NP = N_PARAMS(0)
IF NP LT 2 THEN $
  message, 'Must be called with 2-4 parameters: [ X ,]  Y , ERR  [, PSYM ]' $
 ELSE IF NP EQ 2 THEN BEGIN			;Only Y and ERR passed.
	!PSYM = 7
	YERR = Y
	YY = X
	XX = INDGEN(n_elements(x))
END ELSE IF NP GE 3 THEN BEGIN
	N = N_ELEMENTS(ERR)
	IF N EQ 1 THEN BEGIN			;X array not passed.
		!PSYM = ERR
		YERR = Y
		YY = X
		XX = INDGEN(Y)
	END ELSE BEGIN				;X array passed.
		IF NP EQ 3 THEN !PSYM = 7 $
			ELSE !PSYM = PSYM
		YERR = ERR
		YY = Y
		XX = X
	END
END
;
;  Plot data and the error bars.
;
N = N_ELEMENTS(XX) < N_ELEMENTS(YY) < N_ELEMENTS(YERR)
IF N LT 1 THEN message, 'No points to plot.' $
ELSE IF N EQ 1 THEN BEGIN		;Double XX and YY arrays to allow
	XX = [XX(0),XX(0)]		;	plotting of single point.
	YY = [YY(0),YY(0)]
	YERR = [YERR(0),YERR(0)]
END ELSE BEGIN
	XX = XX(0:N-1)
	YY = YY(0:N-1)
ENDELSE
OPLOT,XX,YY				;Plot data points.
!PSYM = 0
!LINETYPE = 0
FOR I = 0,N-1 DO BEGIN			;Plot error bars.
	XXX = [XX(I),XX(I)]
	YYY = [YY(I)-YERR(I),YY(I)+YERR(I)]
	OPLOT,XXX,YYY
END
;
!PSYM = P_SYM		; Return the orginal system parameter values.
!LINETYPE = LINETYPE
;
RETURN
END

;$Id: p_correlate.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       P_CORRELATE
;
; PURPOSE:
;       This function computes the partial correlation coefficient of a
;       dependent variable and one particular independent variable when
;       the effects of all other variables involved are removed.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE: 
;       Result = P_correlate(X, Y, C)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double that
;             specifies the independent variable data.
;       
;       Y:    An n-element vector of type integer, float or double that
;             specifies the dependent variable data.
;
;       C:    An array of type integer, float or double that specifies the 
;             independent variable data whose effects are to be removed. 
;             The columns of this two dimensional array correspond to the 
;             n-element vectors of independent variable data.
;
; EXAMPLES:
;       Define the data vectors.
;         x0 = [64, 71, 53, 67, 55, 58, 77, 57, 56, 51, 76, 68]
;         x1 = [57, 59, 49, 62, 51, 50, 55, 48, 52, 42, 61, 57]
;         x2 = [ 8, 10,  6, 11,  8,  7, 10,  9, 10,  6, 12,  9]
;
;       Compute the partial correlation of x0 and x1 with the effects of
;       x2 removed. The result should be 0.533469
;         result = p_correlate(x0, x1, reform(x2, 1, n_elements(x2)))
;
;       Compute the partial correlation of x0 and x2 with the effects of 
;       x1 removed. The result should be 0.334572
;         result = p_correlate(x0, x2, reform(x1, 1, n_elements(x1)))
;
;       Compute the partial correlation of x1 and x2 with the effects of 
;       x0 removed. The result should be 0.457907
;         result = p_correlate(x1, x2, reform(x0, 1, n_elements(x0)))
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function p_correlate, x, y, c

  on_error, 2  ;Return to caller if an error occurs.

  if n_elements(x) ne n_elements(y) then message, $
    'x and y must have the same number of elements.'

  sc = size(c)

  if sc(1) eq 1 then begin
    p = [correlate(x, y), correlate(x, c), correlate(y, c)]
    if (p(1) ne 1 and p(2) ne 1) then $
      return, (p(0) - p(1) * p(2))/sqrt((1 - p(1)^2) * (1 - p(2)^2)) $
      else return, 0
  endif else begin
    w = replicate(1.0, sc(2))  ;Vector of weights.
    cf = regress(c, y, w, yfit, a0, s, f, r, p0, /rel)
    cf = regress([c, transpose(x)], y, w, yfit, a0, s, f, r, p1, /rel)
    p0 = 1 - p0^2
    p1 = 1 - p1^2 
    if p0 eq 0 then $
      return, 0 $
      else return, sqrt((p0 - p1)/p0) 
  endelse

end

;
; $Id: pdmenu_alloc.pro,v 1.9 1995/01/20 19:41:01 tonyh Exp $
;
;  WidPdmenu
;   Widget Pull Down Menu class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  PDMENU_Icon
;       Return the pulldown menu toolbar icon
;
FUNCTION PDMENU_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 255b, 247b, 223b, 255b ], $
    [ 1b, 20b, 80b, 128b ], $
    [ 1b, 20b, 80b, 128b ], $
    [ 249b, 148b, 83b, 158b ], $
    [ 249b, 148b, 83b, 158b ], $
    [ 1b, 20b, 80b, 128b ], $
    [ 1b, 20b, 80b, 128b ], $
    [ 255b, 247b, 255b, 255b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 144b, 127b, 16b ], $
    [ 0b, 144b, 127b, 16b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 144b, 255b, 19b ], $
    [ 0b, 144b, 255b, 19b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 144b, 231b, 19b ], $
    [ 0b, 144b, 231b, 19b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 144b, 255b, 17b ], $
    [ 0b, 144b, 255b, 17b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 16b, 0b, 16b ], $
    [ 0b, 240b, 255b, 31b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END


;
;  PDMENU_Copy
;   Copy a pdmenu.
;   Method 1: Copies contents out out ptr and into copy, destroying ptr.
;   Method 2: Duplicates ptr including submenus
;
PRO PDMENU_Copy, Ptr, Copy

  COMMON WidEd_Comm

    IF KEYWORD_SET(Copy) THEN BEGIN     ; Copy is already allocated
        Ptr2Obj, Copy, Contents
        SubPtrs = Contents.Value.SubMenuPtr
        FOR I=1,N_ELEMENTS(SubPtrs)-1 DO BEGIN
            IF(SubPtrs(I) NE 0L) THEN PDMENU_Destroy, Copy, /LEAVE_DIALOGS
        ENDFOR

        Ptr2Obj, Ptr, Obj               ; Remove object from original pointer
        Obj2Ptr, Obj, Copy              ; Store in copy pointer
        WIDGET_CONTROL, Ptr, /DESTROY

    ENDIF ELSE BEGIN

        Ptr2Obj, Ptr, Obj, /COPY                ; Copy original ptr contents
        Copy    = WIDGET_BASE(GROUP=TopDlg)     ; Make a new pointer

        ;       Copy submenus

        SubPtrs = Obj.Value.SubMenuPtr
        FOR I=1,N_ELEMENTS(SubPtrs)-1 DO BEGIN
            IF SubPtrs(I) NE 0L THEN BEGIN
                ClearVar, NewChild
                PDMENU_Copy, SubPtrs(I), NewChild
                SubPtrs(I)      = NewChild
            ENDIF
        ENDFOR
        Obj.Value.SubMenuPtr    = SubPtrs

        Obj2Ptr, Obj, Copy              ; Store copy into new pointer
    ENDELSE
END


;
;  PDMENU_Destroy
;   Release resources for the given pdmenu
;
PRO PDMENU_Destroy, Ptr, LEAVE_DIALOGS=ClearDlg

    ClearDlg    = KEYWORD_SET(ClearDlg) ; Make keyword 0/1, never <UNDEFINED>
    Ptr2Obj, Ptr, Obj                   ; Get object

    IF N_ELEMENTS(Obj) EQ 0 THEN RETURN

    ; Reset Dialog Pointer to prevent destruction?
    IF ClearDlg THEN Obj.Dialog = 0L

    IF WIDGET_INFO(Obj.Dialog, /VALID) THEN $           ; Valid Dialog?
        WIDGET_CONTROL, Obj.Dialog, /DESTROY            ; Destroy it

    SubPtrs     = Obj.Value.SubMenuPtr                  ; Destroy submenus
    FOR I=1,N_ELEMENTS(SubPtrs)-1 DO BEGIN
        IF(SubPtrs(I) NE 0L) THEN $
            PDMENU_Destroy, SubPtrs(I), LEAVE_DIALOGS=ClearDlg
    ENDFOR

    WIDGET_CONTROL, Ptr, /DESTROY                       ; Destroy pointer

    ; Obj is local variable and is freed on return
END


;
;  PDMENU_MakeStrVal
;       Create a string array based on a menu's contents
;       appropriate for placement inside a menu list box.
;
;       Precede submenus with a '*' notation.
;
PRO PDMENU_MakeStrVal, Obj, Val
    Strs        = Obj.Value.Str
    Ptrs        = Obj.Value.SubMenuPtr
    Val         = STRARR(N_ELEMENTS(Strs))
    Val(0)      = "<Top Of List>"
    FOR I=1, N_ELEMENTS(Strs)-1 DO BEGIN
        IF Ptrs(I) NE 0L THEN Prefix = "* " ELSE Prefix = "  "
        Val(I)  = Prefix + Strs(I)
    ENDFOR
END


;
;  PDMENU_Event
;   Event handling routine for a pdmenu dialog.  Shares common code
;   (c.f. widbuild.pro)
;
PRO PDMENU_Event, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'NAME':     Obj.Name        = Event.Value
    'FONT':     Obj.Font        = Event.Value
    'UVALUE':   Obj.UValue      = Event.Value

    ;   User has selected an item in list.  The first item cannot
    ;   be deleted or used as a submenu (just a place holder so we
    ;   can add after it)
    'LIST':     BEGIN
        Binfo.Current   = Event.Index
        WIDGET_CONTROL, Binfo.Delete, SENSITIVE=(Event.Index NE 0)
        WIDGET_CONTROL, Binfo.SubMenu, SENSITIVE=(Event.Index NE 0)
        END

    'XFONT':    DoXFont, Obj, Binfo.Foci(1)

    'DELETE':   BEGIN

        ;       If the item being deleted is a submenu, there are
        ;       resources associated with it and those must be released
        DelItem = Obj.Value(Binfo.Current)
        IF DelItem.SubMenuPtr NE 0 THEN PDMENU_Destroy, DelItem.SubMenuPtr

        ;       Create a new value array

        Last    = N_ELEMENTS(Obj.Value)-1
        IF Binfo.Current EQ Last THEN BEGIN
                Vals    = Obj.Value(0:Last-1)
        ENDIF ELSE BEGIN
                Vals    = [ Obj.Value(0:Binfo.Current-1), $
                                Obj.Value(Binfo.Current+1:Last) ]
        ENDELSE


        ;       Redefine object to reflect new value.
        NewObj = {                      $
            Type:       Obj.Type,       $
            Parent:     Obj.Parent,     $
            Id:         Obj.Id,         $
            Dialog:     Obj.Dialog,     $
            Next:       Obj.Next,       $
            Name:       Obj.Name,       $
            Font:       Obj.Font,       $
            UValue:     Obj.UValue,     $
            Value:      Vals            $
        }

        ;       Update list box to reflect changes
        ;       Set list box selection to <Top of List>
        ;       Have to desensitize delete/Add as Submenu buttons

        PDMENU_MakeStrVal, NewObj, Strs
        WIDGET_CONTROL, Binfo.ListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ListId, SET_LIST_SELECT=0
        Binfo.Current   = 0
        WIDGET_CONTROL, Binfo.Delete, SENSITIVE=0
        WIDGET_CONTROL, Binfo.SubMenu, SENSITIVE=0
        Obj     = NewObj
        END

    'ADDID':    BEGIN
        ;       User has typed in the 'Button value:' field
        ;       Consider <CR> to be the same as the 'Add' button
        ;       Of course, don't add nil buttons

        WIDGET_CONTROL, Binfo.AddId, GET_VALUE=Val
        Sens    = (Val(0) NE '')
        WIDGET_CONTROL, Binfo.Add, SENSITIVE=Sens
        IF Sens AND Event.Update THEN GOTO, AddEquiv
        END

    'ADD':      BEGIN
        WIDGET_CONTROL, Binfo.AddId, GET_VALUE=Val
    AddEquiv:

        ;       If the user hasn't chosen where they want to add
        ;       the new value, add it to the end of the list

        IF Binfo.Current NE -1 THEN     N = Binfo.Current       $
        ELSE                            N = N_ELEMENTS(Obj.Value)-1

        Last    = N_ELEMENTS(Obj.Value)-1
        Vals    = Obj.Value
;        NewVal  = { WE_MENUITEM, Val(0), 0L }
        IF N EQ Last THEN BEGIN
             Vals       = [ Vals, NewVal ]
        ENDIF ELSE BEGIN
             Vals       = [ Vals(0:N), NewVal, Vals(N+1:*) ]
        ENDELSE

        ;       Redefine object to reflect addition

        NewObj = {                      $
            Type:       Obj.Type,       $
            Parent:     Obj.Parent,     $
            Id:         Obj.Id,         $
            Dialog:     Obj.Dialog,     $
            Next:       Obj.Next,       $
            Name:       Obj.Name,       $
            Font:       Obj.Font,       $
            UValue:     Obj.UValue,     $
            Value:      Vals            $
        }

        ;       Update list box to reflect change as well
        PDMENU_MakeStrVal, NewObj, Strs
        WIDGET_CONTROL, Binfo.ListId, SET_VALUE=Strs
        Obj             = NewObj
        Binfo.Current   = N+1

        ;       Set it to be the current selection
        WIDGET_CONTROL, Binfo.ListId, SET_LIST_SELECT=N+1
        WIDGET_CONTROL, Binfo.Delete, SENSITIVE=1
        WIDGET_CONTROL, Binfo.SubMenu, SENSITIVE=1

        ;       Clear the 'Button Value:' field after adding
        ;       a value.  Its easier for the user

        WIDGET_CONTROL, Binfo.AddId, SET_VALUE=''
        WIDGET_CONTROL, Binfo.Add, SENSITIVE=0
        END

    'SUBMENU':  BEGIN
        ;       Build a submenu dialog (and allocate submenu if
        ;       necessary).
        SUBMENU_Build, Binfo.ObjPtr, Obj, Binfo.Current

        ;       Update parent (us) list box to reflect possible change
        ;       of state.
        PDMENU_MakeStrVal, Obj, Strs
        WIDGET_CONTROL, Binfo.ListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ListId, SET_LIST_SELECT=Binfo.Current
        END

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  SUBMENU_Build
;   Create a dialog box a pdmenu submenu object.  If ptr is nil then
;   create the object as well.
;
;   The dialog and the object description contain unused fields.  They
;   are there so that we can use the PDMENU_Event and PDMENU_Alloc
;   routines on both menus and submenus.  Theres not many fields to begin
;   with and I feel the memory expense is justifyable
;
PRO SUBMENU_Build, ParPtr, ParObj, SubIdx

  COMMON WidEd_Comm

    ; Lookup pointer in parent menu item table.  We need to pull it
    ; out into a named variable for the alloc routine.
    ; If the pointer was nil, now we need to put it back into the list
    ; Otherwise, we did a little extra work

    Ptr = ParObj.Value(SubIdx).SubMenuPtr
    PDMENU_Alloc, ParPtr, Ptr
    ParObj.Value(SubIdx).SubMenuPtr     = Ptr

    MgrName = 'WE_PDMENU' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    ;  Use the name of the submenu for generating title

    Title   = 'SubMenu ' + ParObj.Value(SubIdx).Str

    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)

    Foci    = 0L

    Base1   = WIDGET_BASE(Base, /ROW, /FRAME)

    PDMENU_MakeStrVal, Obj, Val
    List    = WIDGET_LIST(Base1, /FRAME, YSIZE=8, VALUE=Val, UVALUE='LIST')
    Base2   = WIDGET_BASE(Base1, /FRAME, /COLUMN)
    SubMenu = WIDGET_BUTTON(Base2, VALUE='Edit as a SubMenu', UVALUE='SUBMENU')
    Delete  = WIDGET_BUTTON(Base2, VALUE='Delete', UVALUE='DELETE')
    Add     = WIDGET_BUTTON(Base2, VALUE='Add', UVALUE='ADD')
    AddFld  = Field(Base2, "Button Value:", "", 'ADDID', SIZE=20, /STRING)

    Dummy   = WIDGET_LABEL(Base, VALUE=" ")
    Done    = WIDGET_BUTTON(Base, VALUE='Done', UVALUE='DONE')

    DlgInfo     = {             $
        ListId:         List,   $
        SubMenu:        SubMenu,$
        Delete:         Delete, $
        Add:            Add,    $
        AddId:          AddFld, $
        Current:        -1,     $
        Foci:           Foci,   $
        ObjPtr:         Ptr     $
    }
    Obj.Dialog  = Base

    WIDGET_CONTROL, SubMenu, SENSITIVE=0
    WIDGET_CONTROL, Delete, SENSITIVE=0
    WIDGET_CONTROL, Add, SENSITIVE=0
    WIDGET_CONTROL, List, SET_LIST_SELECT=0
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='PDMENU_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  PDMENU_Build
;   Create a dialog box a pdmenu object.  If ptr is nil then
;   create the object as well.
;
PRO PDMENU_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    PDMENU_Alloc, ParPtr, Ptr               ; Allocate object if necessary
    MgrName = 'WE_PDMENU' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    Foci    = LONARR(3)

    ;   Event Related Info

    Base1   = WIDGET_BASE(Base, /ROW, /FRAME)

    PDMENU_MakeStrVal, Obj, Val
    List    = WIDGET_LIST(Base1, /FRAME, YSIZE=8, VALUE=Val, UVALUE='LIST')
    Base2   = WIDGET_BASE(Base1, /FRAME, /COLUMN)
    SubMenu = WIDGET_BUTTON(Base2, VALUE='Edit as a SubMenu', UVALUE='SUBMENU')
    Delete  = WIDGET_BUTTON(Base2, VALUE='Delete', UVALUE='DELETE')
    Add     = WIDGET_BUTTON(Base2, VALUE='Add', UVALUE='ADD')
    AddFld  = Field(Base2, "Button Value:", "", 'ADDID', SIZE=20, /STRING)


    Foci(0) = Field(Base, "Name:", Obj.Name, 'NAME', SIZE=50, /STRING)
    Base1   = WIDGET_BASE(Base,/ROW)
    Foci(1) = Field(Base1, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base1, VALUE="XFont", UVALUE="XFONT")
    Foci(2) = Field(Base, "User Value:", Obj.UValue, 'UVALUE', SIZE=30,/STRING)

    BuildOkCancel, Base, Obj

    DlgInfo     = {             $
        ListId:         List,   $
        SubMenu:        SubMenu,$
        Delete:         Delete, $
        Add:            Add,    $
        AddId:          AddFld, $
        Current:        -1,     $
        Foci:           Foci,   $
        ObjPtr:         Ptr     $
    }
    Obj.Dialog  = Base

    WIDGET_CONTROL, SubMenu, SENSITIVE=0
    WIDGET_CONTROL, Delete, SENSITIVE=0
    WIDGET_CONTROL, Add, SENSITIVE=0
    WIDGET_CONTROL, List, SET_LIST_SELECT=0
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='PDMENU_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


PRO PDMENU_MakeDesc, Obj, MenuDesc, Idx

    IF N_ELEMENTS(MenuDesc) EQ 0 THEN BEGIN
;        MenuDesc        = REPLICATE( { CW_PDMENU_S, 0, '' }, 1000 )
        Idx             = 0
    ENDIF

    N   = N_ELEMENTS(Obj.Value)
    IF N EQ 1 THEN BEGIN
        MenuDesc(Idx).Name      = '<Empty Menu>'
        MenuDesc(Idx).Flags     = 2
        Idx                     = Idx + 1
    ENDIF ELSE BEGIN
        FOR I=1,N-1 DO BEGIN
            MenuDesc(Idx).Name  = Obj.Value(I).Str
            Last                = Idx
            Idx                 = Idx + 1
            SubPtr              = Obj.Value(I).SubMenuPtr
            IF SubPtr NE 0L THEN BEGIN
                MenuDesc(Last).Flags    = 1
                Ptr2Obj, SubPtr, SubObj
                PDMENU_MakeDesc, SubObj, MenuDesc, Idx
                Obj2Ptr, SubObj, SubPtr
            ENDIF
        ENDFOR

        ; Set the 'final entry' bit in the last entry of each menu/submenu
        MenuDesc(Last).Flags    = MenuDesc(Last).Flags OR 2
    ENDELSE
END


;
;  PDMENU_Save
;   Save pdmenu information to a file.
;   This is a simple object to save.
;
PRO PDMENU_Save, Unit, Ptr

  COMMON WidEd_Comm

    ON_IOERROR, BadWrite
    Ptr2Obj, Ptr, Obj
    WRITEU, Unit, N_ELEMENTS(Obj.Value) ; Save sizeof(value)
    WRITEU, Unit, Obj                   ; Save basic information

    ;   Save any submenus
    SubPtrs     = Obj.Value.SubMenuPtr
    FOR I=1,N_ELEMENTS(SubPtrs)-1 DO BEGIN
        IF SubPtrs(I) NE 0L THEN BEGIN
            PDMENU_Save, Unit, SubPtrs(I)
        ENDIF
    ENDFOR

    Obj2Ptr, Obj, Ptr
    RETURN

  BadWrite:
    Dirty   = 2
END


;
;  PDMENU_Restore
;   Read in a pdmenu object from a file
;
PRO PDMENU_Restore, Unit, Parent, Ptr

    NItem       = 0
    READU, Unit, NItem
    PDMENU_Alloc, Parent, Ptr, N_ITEMS=NItem
    Ptr2Obj, Ptr, Obj
    READU, Unit, Obj

    SubPtrs     = Obj.Value.SubMenuPtr
    FOR I=1,N_ELEMENTS(SubPtrs)-1 DO BEGIN
        IF SubPtrs(I) NE 0L THEN BEGIN
            ClearVar, Child
            PDMENU_Restore, Unit, Ptr, Child
            SubPtrs(I)  = Child
        ENDIF
    ENDFOR
    Obj.Value.SubMenuPtr        = SubPtrs

    Obj2Ptr, Obj, Ptr
END


;
;  PDMENU_Generate
;   Create a pdmenu object for previewing
;
PRO PDMENU_Generate, Base, Ptr

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Build a command string

    PDMENU_MakeDesc, Obj, MenuDesc

    Cmd = 'Id = CW_PDMENU(Base, MenuDesc'
    SAddCmd, Cmd, Obj.Font, 'FONT'

    Obj2Ptr, Obj, Ptr

    ; Create pdmenu by executing the command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Pdmenu ' + VarName(Ptr)
    ENDIF
END


;
;  PDMENU_GenWid
;   Create IDL code for creating a PDMENU
;
PRO PDMENU_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)                ; Get variable name of object
    Ptr2Obj, Ptr, Obj                   ; Get object info

    DescName    = 'MenuDesc' + STRTRIM(Ptr,2)   ; Create value name

    PDMENU_MakeDesc, Obj, MenuDesc

    XPRINTF, Unit, '  ' + DescName + ' = [ $'

    ;   Now print out the contents of the description,
    ;   indenting to indicate what is a child of what
    ;   Note that if the final object is also a submenu
    ;   one need to keep track of that fact.

    ;   Its a little non-intuitive how the indentation stuff works
    ;   But basically, we keep track of the current indent level
    ;   and how it will effect things for the NEXT item

    MenuIdx     = 0     ; Current index in the Description array
    Level       = 1     ; Current indent level
    PreDec      = 0     ; Indent level(s) not yet acknowledged

    REPEAT BEGIN
        ;       Every item but the first one needs a comma and
        ;       a continuation character appended to the line above

        IF MenuIdx NE 0 THEN XPRINTF, Unit, ', $ ; ', MenuIdx-1

        ;       Indent 4 characters + 2 characters for every level
        ;       of indentation after the first

        FOR I=-1,LEVEL DO XPRINTF, Unit, FORMAT='(A)', "  ", /NO_EOL
        Flags = MenuDesc(MenuIdx).Flags
        XPRINTF, Unit, Flags, Qstring(MenuDesc(MenuIdx).Name), /NO_EOL, $
                FORMAT='("{ CW_PDMENU_S, ", I, ", ''",A,"'' }")'

        ;       See how the current object affects the level

        CASE Flags OF
        0:      ;
        1:      Level   = Level + 1
        2:      BEGIN
                Level   = Level - 1 - PreDec
                PreDec  = 0
                END
        3:      BEGIN
                Level   = Level + 1
                PreDec  = PreDec + 1
                END
        ENDCASE

        ;       Go on to the next object

        MenuIdx = MenuIdx + 1

        ;       We know we are done when the level goes to 0.
        ;       This happens after the last object has been written

    ENDREP UNTIL LEVEL EQ 0

    XPRINTF, Unit, FORMAT='(" $  ;",I)', MenuIdx-1

    PRINTF, Unit, FORMAT='(/"  ]"//)'   ; XPRINTF does wierd stuff

        ;       Lastly, write the code which calls the
        ;       pulldown menu creation function with the description
        ;       we just wrote.

    XPRINTF, Unit, FORMAT='("  ", A," = CW_PDMENU( ", A, ", ", A)', $
        Name, Parent, DescName, /NO_EOL
    XPRINTF, Unit, FORMAT='(A)', ", /RETURN_FULL_NAME", /NO_EOL
    SSaveCmd, Unit, Obj.Font, 'FONT'
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  SavePDCase
;       Generate a case statement for the given String.
;       If the Item is actually a submenu, then call
;       SavePDCase for each child.
;
;       Parent contains the concatenation of all of the previous
;       submenu names separated by periods. This is done to
;       match the event.value returned by the event procedure
;       when CW_PDMENU is called with the RETURN_FULL_NAME flag --
;       which we do.
;
PRO SavePDCase, Unit, Item, Parent


    IF Item.SubMenuPtr NE 0L THEN BEGIN
        NewParent       = Parent + Item.Str + '.'
        Ptr2Obj, Item.SubMenuPtr, Obj
        FOR I=1,N_ELEMENTS(Obj.Value)-1 DO BEGIN
            SavePDCase, Unit, Obj.Value(I), NewParent
        ENDFOR
        Obj2Ptr, Obj, Item.SubMenuPtr

    ENDIF ELSE BEGIN

        ;       Normal string. Build a statement of the form:
        ;       "<full-name>": BEGIN
        ;               PRINT, "Event for <full-name>"
        ;               END

        Name = Qstring(Parent + Item.Str)
        PRINTF, Unit, "  '" + Name + "': BEGIN"
        PRINTF, Unit, "    PRINT, 'Event for ", Name, "'"
        PRINTF, Unit, '    END'

    ENDELSE
END

;
;  PDMENU_MenuEv
;
;       Generate IDL code to handle a menu event
;
PRO PDMENU_MenuEv, Unit, OldUnit, Ptr

    Ptr2Obj, Ptr, Obj

    CASE Obj.Type OF

    'MAIN':     Goto, BaseType
    'DEP':      Goto, BaseType
    'BASE':     BEGIN
    BaseType:

        ;       If the user wants to provide an event handler, don't
        ;       do anything
        ;       Otherwise, look for pull down menus

        IF Obj.EventFunc EQ '' AND Obj.EventProc EQ '' THEN BEGIN
            DoFList2, Obj.children, 'PDMENU_MenuEv', Unit, OldUnit
        ENDIF

        END

    'PDMENU':   BEGIN

        ;       Found a pull down menu.  Create an event handler
        ;       routine for this menu.

        Obj2Ptr, Obj, Ptr
        Id      = VarId(Ptr)
        Ptr2Obj, Ptr, Obj

        IF FindMagic(Id, Unit, OldUnit) EQ 0 THEN BEGIN

            ; Write the routine header

            BeginMagic, Unit, Id

            PRINTF, Unit, FORMAT='(//"PRO ",A,"_Event, Event")', Id
            PRINTF, Unit, FORMAT='(//A//A/)',               $
                '  CASE Event.Value OF '

            FOR I=1,N_ELEMENTS(Obj.Value)-1 DO BEGIN
                SavePDCase, Unit, Obj.Value(I), ''
            ENDFOR

            ;       Write routine footer

            PRINTF, Unit, '  ENDCASE'
            PRINTF, Unit, 'END'

            EndMagic, Unit, Id

        ENDIF

        END
    ELSE:       ; Do nothing
    ENDCASE

    Obj2Ptr, Obj, Ptr
END


;
;  PDMENU_Alloc
;       Allocate a menu object.  Don't allocate if ptr is non-nil
;
;       If we are restoring an menu object it may have several
;       menu items already.  Allocate appropriately (N_ITEMS flag)
;
PRO PDMENU_Alloc, Parent, Ptr, N_ITEMS=NItem
  COMMON WidEd_Comm

    IF KEYWORD_SET(NItem) EQ 0 THEN NItem=1     ; Allocate 1 Item by dflt

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

;    Val = REPLICATE( { WE_MENUITEM, '', 0L }, NItem )

    ;   No WE_PDMENU structure type
    ;   Menus must be typeless so they can have dynamically alterable
    ;   definition (Value changes)

    Ptr = WIDGET_BASE(GROUP=TopDlg)                         ; Make a pointer
    Obj = {                     $
        Type:           'PDMENU', $
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; object name
        Font:           '',     $
        UValue:         '',     $
        Value:          Val     $
    }
    Obj2Ptr, Obj, Ptr
END
; $Id: pickfile.pro,v 1.11 1995/04/13 15:03:19 mattr Exp $
;
; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       PICKFILE
;
; PURPOSE:
;       This function allows the user to interactively pick a file.  A file
;       selection tool with a graphical user interface is created.  Files
;       can be selected from the current directory or other directories.
;
; CATEGORY:
;       Widgets.
;
; CALLING SEQUENCE:
;       Result = PICKFILE()
;
; KEYWORD PARAMETERS:
;
;       FILE:   A string value for setting the initial value of the
;               selection. Useful if there is a default file
;
;       GET_PATH: Set to a named variable. Returns the path at the
;               time of selection.
;
;       GROUP:  The widget ID of the widget that calls PICKFILE.  When this
;               ID is specified, a death of the caller results in the death of
;               the PICKFILE widget application.
;
;       READ:   Set this keyword to make the title of the PICKFILE window
;               "Select File to Read".
;
;       WRITE:  Set this keyword to make the title of the PICKFILE window
;               "Select File to Write".
;
;       PATH:   The initial path to select files from.  If this keyword is
;               not set, the current directory is used.
;
;       FILTER: A string value for filtering the files in the file list.  This
;               keyword is used to reduce the number of files to choose from.
;               The user can modify the filter unless the FIX_FILTER keyword
;               is set.  Example filter values might be "*.pro" or "*.dat".
;
;       FIX_FILTER: When this keyword is set, only files that satisfy the
;               filter can be selected.  The user has no ability to modify
;               the filter and the filter is not shown.
;
;       TITLE:  A scalar string to be used for the window title.  If it is
;               not specified, the default title is "Select File"
;
;       NOCONFIRM: Return immediately upon selection of a file.  The default
;               behavior is to display the selection and then return the
;               file when the user uses the "ok" button.
;
;       MUST_EXIST: When set, only files that actually exist can be selected.
;
; OUTPUTS:
;       PICKFILE returns a string that contains the name of the file selected.
;       If no file is selected, PICKFILE returns a null string.
;
; COMMON BLOCKS:
;       PICKER: COMMON block that maintains state for the widget.
;
; SIDE EFFECTS:
;       This function initiates the XMANAGER if it is not already running.
;
; RESTRICTIONS:
;       This routine is known to work on Suns (OPEN LOOK), MIPS, RS/6000,
;       DEC Ultrix, HP/700, VAX/VMS and SGI machines.
;
;       Only one instance of the PICKFILE widget can be running at one time.
;
;       PICKFILE does not recognize symbolic links to other files in UNIX.
;
; PROCEDURE:
;       Create and register the widget and then exit, returning the filename
;       that was picked.
;
; EXAMPLE:
;       Create a PICKFILE widget that lets users select only files with
;       the extensions 'pro' and 'dat'.  Use the 'Select File to Read' title
;       and store the name of the selected file in the variable F.  Enter:
;
;               F = PICKFILE(/READ, FILTER = '*.pro *.dat')
;
; MODIFICATION HISTORY:
;       Written by:     Steve Richards, April, 1991
;       July, 1991      Added a FILTER keyword to allow users
;                       to select files with a given extension or
;                       extensions.
;       August, 1991    Fixed bugs caused by differences between
;                       spawned ls commands on different machines.
;       September, 1991 Made Myfindfile so only one pass was
;                       necessary to find files and directories.
;       3/92 - ACY      Corrected initialization of dirsave, change spawn
;                       command to "ls -lL" and added case for links
;                       add NOCONFIRM keyword for auto exiting on selection
;       8/92 - SMR      Rewrote pickfile as a compound widget.
;       10/92 - SMR     Fixed a bug where extremely large file namess didn't
;                       show up properly in the file list or as return
;                       values.
;       12/92 - JWG     Add better machine dependency code
;       1/93 - JWG      Added FILE, GET_PATH keywords.
;       1/93 - TAC      Added Windows Common dialog pickfile code
;       2/93 - SMR      Fixed the documentation example for multiple extensions
;       1/94 - KDB      If directory had no execute permission on Unix
;                       platforms, CD fails and causes error. Added check
;                       for this. Increased spawn speed by using /sh for unix.
;                       Added -a switch to ls so that all files can be found
;                       on unix machines.
;       2/94 - KDB	Values passed to CD cannot end in a '\' on DOS
;			platforms. Program would crash if the PATH keyword
;			was supplied a value that ended with a "\". Added
;		        a check for this.
;	3/94 - BMH	Deleted the reference here to OS_PICKFILE for the
;			Unix platforms and created an IDL routine to
;			to call the Mac and Windows specific OS_PICKFILE
;			routines.  This solved the saving and restoring on
;	 		different platforms problem.
;	4/94 - KDB      The vms call to lib$findfile in valid_dir was
;		        commented out. This caused errors when path was
;			changed by user. Uncommented. In Valid_Dir, with
;			vms the type of directory specification was not
;		        checked (directory can be a path or a filename):
;			Fixed this. In dirlist section of event handler,
;		        a "[-]" would get trimmed to "" and cause error:
;			Fixed.
;	8/94 - ACY      Change the spawn command in getdirs to send error
;			output to /dev/null.
;	12/94 - DJE	Fix the FIX_FILTER option for the MacOS.
;-
;

FUNCTION valid_dir, dir
  WIDGET_CONTROL, /HOUR
  CASE !VERSION.OS OF

  'vms': BEGIN
            CD, current = here   ; get pwd

       ; VMS directories can be files, NAME.DIR, or paths DEVICE:[NAME.NAME].
       ; If the "[]" method is used, tack on a wildcard spec (*.*), otherwise
       ; the value of dir is a filename and it can remain the same.

            if(strpos(dir,']') gt -1)then dir = dir + "*.*"
            context = 0L
            resultant = STRING(BYTARR(256)+32B)

       ; See if either Name.dir file exists in the current directory or
       ; if a path specified see if there is any files in that dir.
       ; Use vms LIB$ routines via Call External

            result = CALL_EXTERNAL("LIBRTL", "LIB$FIND_FILE", dir, resultant,$
		 context, here, 0L, 0L, 0L, VALUE = [0, 0, 0, 0, 1, 1, 1])
            toss = CALL_EXTERNAL("LIBRTL", "LIB$FIND_FILE_END", context)

            RETURN, (result EQ 65537)
         END
  'Win32': BEGIN
            RETURN,1    ; Hook into common dialogs for windows
                        ; when this really works.
         END
  ELSE:  BEGIN
      ; Can't CD to a directory unless the user has execute permission.
      ; Use the unix command test to check this. Have to use sh5 on ultrix
      ; Test sets the shell status variable and echo prints it out. This is
      ; then captured by spawn and placed in result

   if(!version.os ne 'ultrix')then $
     spawn, ['test -d "'+dir +'" -a -x "'+dir+'" ; echo $?'], result, /sh $
   else $
     spawn, ['/bin/sh5 -c "test -d '''+dir+''' -a -x '''+dir+''' ";echo $?'], $
            result, /sh

        return, (not fix(result(0)) )  ;convert result to int and NOT it.

      END
  ENDCASE
END

;------------------------------------------------------------------------------
;       procedure GETDIR
;------------------------------------------------------------------------------
; This routine finds the files or directories at the current directory level.
; It must be called with either files or directories as a keyword.
;------------------------------------------------------------------------------

function getdirs

WIDGET_CONTROL, /HOUR

IF (!VERSION.OS EQ "vms") THEN BEGIN                    ;version is VMS who's
  retval = ['[-]']
  results = findfile("*.DIR")                           ;directories have an
  IF(KEYWORD_SET(results)) THEN BEGIN                   ;extension of ".dir"
    endpath = STRPOS(results(0), "]", 0) + 1
    results = strmid(results, endpath, 100)
    dirs = WHERE(STRPOS(results, ".DIR", 0) NE -1, found)
    IF (found GT 0) THEN BEGIN
      results = results(dirs)
      retval = [retval, results]
    ENDIF
  ENDIF
ENDIF ELSE IF !VERSION.OS EQ 'Win32' THEN BEGIN
  message,"Unsupported on this platform"
ENDIF ELSE BEGIN
  retval = ['../']
  ;added -a switch to get .* dirs
  ;change to /noshell, send errors to /dev/null
  SPAWN, ["/bin/sh", "-c", "ls -laL 2> /dev/null"], /NOSHELL, results
  numfound = N_ELEMENTS(results)
  IF(KEYWORD_SET(results)) THEN BEGIN                   ;extension of ".dir"
    firsts = STRUPCASE(STRMID(results, 0, 1))
    dirs = (where(firsts EQ "D", found))
    IF (found GT 0) THEN BEGIN
      results = results(dirs)
      spaceinds = WHERE(BYTE(results(0)) EQ 32)
      spaceindex = spaceinds(N_ELEMENTS(spaceinds)-1)
      retval = [retval, STRMID(results, spaceindex + 1, 100)]

    ; get rid of "." and ".." that ls -laL picks up
      retval = retval(WHERE( (retval ne '.')and(retval ne '..')) )

    ENDIF
  ENDIF
ENDELSE
RETURN, retval
END ; function getdirs

;------------------------------------------------------------------------------

FUNCTION getfiles, filter

WIDGET_CONTROL, /HOUR

IF (!VERSION.OS EQ "vms") THEN BEGIN
  results = findfile(filter)
  IF (KEYWORD_SET(results)) THEN BEGIN
    endpath = STRPOS(results(0), "]", 0) + 1
    results = strmid(results, endpath, 100)
    dirs = WHERE(STRPOS(results, ".DIR", 0) EQ -1, found)
    IF (found GT 0) THEN BEGIN
      results = results(dirs)
      return, results
    ENDIF
  ENDIF
ENDIF ELSE IF !VERSION.OS EQ 'Win32' THEN BEGIN
  message,"Unsupported on this platform"
ENDIF ELSE BEGIN
  SPAWN, ["/bin/sh", "-c", "ls -laL " + filter + $
          " 2> /dev/null"], results, /NOSHELL     ;added -a to get all files
  IF(KEYWORD_SET(results)) THEN BEGIN
    firsts = STRUPCASE(STRMID(results, 0, 1))
    fileinds = (WHERE(((firsts EQ "F") OR (firsts EQ "-") OR $
                       (firsts EQ "l")), found))
    IF (found GT 0) THEN BEGIN
      results = results(fileinds)
      FOR i = 0, N_ELEMENTS(results) - 1 DO BEGIN
        spaceinds = WHERE(BYTE(results(i)) EQ 32)
        spaceindex = spaceinds(N_ELEMENTS(spaceinds) - 1)
        results(i) = STRMID(results(i), spaceindex + 1, 100)
      ENDFOR
      RETURN, results
    ENDIF
  ENDIF
ENDELSE
RETURN, ""
END

;------------------------------------------------------------------------------
;       procedure Pickfile_ev
;------------------------------------------------------------------------------
; This procedure processes the events being sent by the XManager.
;------------------------------------------------------------------------------
PRO Pickfile_ev, event

COMMON newpicker, pathtxt, filttxt, dirlist, filelist, selecttxt, $
        ok, cancel, help, here, thefile, separator

WIDGET_CONTROL, filttxt, GET_VALUE = filt
filt = filt(0)

CASE event.id OF

  cancel: BEGIN
      thefile = ""
      WIDGET_CONTROL, event.top, /DESTROY
    END

  filttxt: BEGIN
      files = getfiles(filt)
      WIDGET_CONTROL, filelist, SET_VALUE = files
      WIDGET_CONTROL, filelist, SET_UVALUE = files
    END

  dirlist: BEGIN
      WIDGET_CONTROL, dirlist, GET_UVALUE = directories
      IF (event.index GT N_ELEMENTS(directories) - 1) THEN RETURN

   ;  Check an see if the directory is valid

      if(not valid_dir(directories(event.index)) ) then return

      IF (!version.os EQ "vms") THEN BEGIN
      ; Fixed logic error. If the users selects [-], the strpos/mid
      ; combo would return a null string. Added a check for [-],index=0

        if(event.index eq 0)then   $
           found = 3		   $ ; len of [-]
        else			   $
	   found = STRPOS(directories(event.index), ".", 0)

        CD, STRMID(directories(event.index), 0, found)
        CD, CURRENT = here   ;get pwd

      ENDIF ELSE IF !version.os EQ 'Win32' THEN BEGIN
        message,"Unsupported on this platform"
      ENDIF ELSE BEGIN
        CD, directories(event.index)
        CD, CURRENT = here
        here = here + separator
      ENDELSE
      WIDGET_CONTROL, pathtxt, SET_VALUE = here
      directories = getdirs()
      files = getfiles(filt)
      WIDGET_CONTROL, filelist, SET_VALUE = files
      WIDGET_CONTROL, filelist, SET_UVALUE = files
      WIDGET_CONTROL, dirlist, SET_VALUE = directories
      WIDGET_CONTROL, dirlist, SET_UVALUE = directories
    END

  pathtxt: BEGIN
      WIDGET_CONTROL, pathtxt, GET_VALUE = newpath
      newpath = newpath(0)
      len = STRLEN(newpath) - 1
      IF STRPOS(newpath, '/', len) NE -1 THEN $
        newpath = STRMID(newpath, 0, len)
      IF (valid_dir(newpath(0))) THEN BEGIN
        here = newpath(0) + separator
        CD, here
        directories = getdirs()
        files = getfiles(filt)
        WIDGET_CONTROL, filelist, SET_VALUE = files
        WIDGET_CONTROL, filelist, SET_UVALUE = files
        WIDGET_CONTROL, dirlist, SET_VALUE = directories
        WIDGET_CONTROL, dirlist, SET_UVALUE = directories
      ENDIF ELSE $
        WIDGET_CONTROL, pathtxt, SET_VALUE = here
    END

  filelist: BEGIN
      WIDGET_CONTROL, filelist, GET_UVALUE = files
      IF (KEYWORD_SET(files)) THEN BEGIN
        thefile = here + files(event.index)
        WIDGET_CONTROL, selecttxt, SET_VALUE =  thefile
        WIDGET_CONTROl, ok, GET_UVALUE = auto_exit
        IF (auto_exit) THEN GOTO, checkfile
      ENDIF
    END

  ok: GOTO, checkfile

  selecttxt: GOTO, checkfile

  help: XDISPLAYFILE, "", $
                GROUP = event.top, $
                TITLE = "File Selection Help", $
                WIDTH = 50, $
                HEIGHT = 12, $
                TEXT = ["    This file selection widget lets you pick a ", $
                        "file.  The files are shown on the right.  You can", $
                        "select a file by clicking on it with the mouse.", $
                        "Pressing the 'OK' button will accept the choice", $
                        "and the Cancel button will not.  To move into a ", $
                        "subdirectory, click on its name in the directory", $
                        "list on the left.  The path can also be modified", $
                        "to view files from a different directory.  The ", $
                        "full file name can also be typed in directly", $
                        "in the Selection area.  The list of files can be", $
                        "modified by typing in a filter."]

ENDCASE
RETURN

checkfile:
  WIDGET_CONTROL, selecttxt, GET_VALUE = temp
  WIDGET_CONTROL, cancel, GET_UVALUE = existflag
  IF existflag THEN BEGIN
    ON_IOERROR, print_error
    OPENR, unit, temp(0), /GET_LUN
    FREE_LUN, unit
  ENDIF
  thefile = temp(0)
  WIDGET_CONTROL, event.top, /DESTROY
  RETURN

  print_error:
    WIDGET_CONTROL, selecttxt, SET_VALUE = "!!! Invalid File Name !!!"
    thefile = ""

END ;============= end of Pickfile event handling routine task ================



;------------------------------------------------------------------------------
;       procedure Pickfile
;------------------------------------------------------------------------------
;  This is the actual routine that creates the widget and registers it with the
;  Xmanager.  It also determines the operating system and sets the specific
;  file designators for that operating system.
;------------------------------------------------------------------------------
FUNCTION Pickfile, GROUP = GROUP, PATH = PATH, READ = READ, WRITE = WRITE, $
                FILTER = FILTER, TITLE = TITLE, NOCONFIRM = NOCONFIRM, $
                MUST_EXIST = MUST_EXIST, FIX_FILTER = FIX_FILTER, $
                FILE=FILE, GET_PATH=GET_PATH

COMMON newpicker, pathtxt, filttxt, dirlist, filelist, selecttxt, $
        ok, cancel, help, here, thefile, separator

IF(XRegistered("Pickfile")) THEN RETURN, 0

thefile = ""
existflag = 0

CASE !VERSION.OS OF
'vms':          separator       = ''
; WINDOWS does NOT want a \ at the end of the directory
'Win32':      separator       = ''
'MacOS': separator = ""
ELSE:           separator       = '/'
ENDCASE

CD, CURRENT = dirsave

IF (N_ELEMENTS(PATH) EQ 0) THEN BEGIN
  PATH = dirsave + separator
  here = PATH
ENDIF ELSE BEGIN

  ;; When on a Dos platform the argument to CD cannot end in a '\' unless
  ;; it is a root directory of a drive (ie C:\). Because of this, check
  ;; If we must remove the last character of PATH. -KDB 2/4/94

  IF((!version.os eq 'Win32')and  $
       (Strpos(path,'\', Strlen(PATH)-1)ne -1))THEN  BEGIN
         IF(strlen(path) gt 3)THEN  $ ; Root dirs are 3 chars long.
             path = Strmid( path, 0, Strlen(path)-1)
  ENDIF

  IF(STRPOS(PATH, separator,STRLEN(PATH)- 1) EQ -1)AND(PATH NE separator)THEN $
    PATH = PATH + separator
  CD, PATH                                              ;if the user selected
  here = PATH                                           ;a path then use it
ENDELSE

IF (KEYWORD_SET(NOCONFIRM))     THEN auto_exit = 1      ELSE auto_exit = 0
IF (KEYWORD_SET(MUST_EXIST))    THEN existflag = 1      ELSE existflag = 0
IF (KEYWORD_SET(FIX_FILTER))    THEN mapfilter = 0      ELSE mapfilter = 1

IF (N_ELEMENTS(FILE) EQ 0)      THEN FILE = ""

IF (NOT (KEYWORD_SET(TITLE))) THEN $                    ;build up the title
  TITLE = "Please Select a File"                        ;based on the keywords

IF (KEYWORD_SET(READ)) THEN TITLE = TITLE + " for Reading" $
ELSE IF (KEYWORD_SET(WRITE)) THEN TITLE = TITLE + " for Writing"

CASE !VERSION.OS OF

'Win32':      BEGIN
        ; Windows common dialog pickfile
        ; currently does NOT support NOCONFIRM or FIX_FILTER

        ; default FILTER needs to be forced to *.* if none set
        IF (KEYWORD_SET(FILTER))        THEN filt = FILTER ELSE filt = "*.*"

        IF (N_ELEMENTS(GROUP) EQ 0)     THEN GROUP=0

        thefile = OS_PICKFILE( GROUP = GROUP, FILTER = filt, TITLE = TITLE, $
                     MUST_EXIST = existflag, FILE = FILE, GET_PATH = here)
        END

'MacOS':        BEGIN
        ; Mac Standard File dialog pickfile
        ; currently does NOT support FIX_FILTER

        ; default FILTER is set to "*" if none set
        IF (KEYWORD_SET(FILTER))        THEN filt = FILTER ELSE filt = "*"

        IF (N_ELEMENTS(GROUP) EQ 0)     THEN GROUP=0

        IF (KEYWORD_SET(WRITE)) THEN wr = 1 else wr = 0

        IF (KEYWORD_SET(PATH)) THEN pth = PATH else cd, current = pth

	IF (KEYWORD_SET(FIX_FILTER))    THEN mapfilter = 1      ELSE mapfilter = 0

        thefile = OS_PICKFILE( GROUP = GROUP, FILTER = filt, TITLE = TITLE, $
                MUST_EXIST = existflag, FILE = FILE, FIX_FILTER = mapfilter, $
                                GET_PATH = here, WRITE = wr, PATH = pth)

        END

ELSE:   BEGIN
        ; Widget pickfile for the rest of IDL

        IF (KEYWORD_SET(FILTER))        THEN filt = FILTER ELSE filt = ""

        directories = getdirs()
        files = getfiles(filt)

        version = WIDGET_INFO(/VERSION)
        IF (version.style EQ 'Motif') THEN osfrm = 0 ELSE osfrm = 1

        Pickfilebase =  WIDGET_BASE(TITLE = TITLE, /COLUMN)
        widebase =      WIDGET_BASE(Pickfilebase, /ROW)
        label =         WIDGET_LABEL(widebase, VALUE = "Path:")
        pathtxt =       WIDGET_TEXT(widebase, VAL = here, /EDIT, FR = osfrm, XS = 50)
        filtbase =      WIDGET_BASE(Pickfilebase, /ROW, MAP = mapfilter)
        filtlbl =       WIDGET_LABEL(filtbase, VALUE = "Filter:")
        filttxt =       WIDGET_TEXT(filtbase, VAL = filt, /EDIT, XS = 10, FR = osfrm)
        selections =    WIDGET_BASE(Pickfilebase, /ROW, SPACE = 30)
        dirs =  WIDGET_BASE(selections, /COLUMN, /FRAME)
        lbl =   WIDGET_LABEL(dirs, VALUE = "Subdirectories          ")
        dirlist =       WIDGET_LIST(dirs, VALUE = directories, YSIZE = 8, $
                        UVALUE = directories)
        fls =   WIDGET_BASE(selections, /COLUMN, /FRAME)
        lbl =   WIDGET_LABEL(fls, VALUE = "Files                   ")
        filelist =      WIDGET_LIST(fls, VALUE = files, YSIZE = 8, $
                        UVALUE = files)
        widebase =      WIDGET_BASE(Pickfilebase, /ROW)
        label =         WIDGET_LABEL(widebase, VALUE = "Selection:")
        selecttxt =     WIDGET_TEXT(widebase, VAL = FILE, XS = 42,      $
                        FRAME = osfrm, /EDIT)
        rowbase =       WIDGET_BASE(Pickfilebase, SPACE = 20, /ROW)
        ok =            WIDGET_BUTTON(rowbase, VALUE = "     Ok     ", $
                        UVALUE = auto_exit)
        cancel =        WIDGET_BUTTON(rowbase, VALUE = "   Cancel   ", $
                        UVALUE = existflag)
        help =  WIDGET_BUTTON(rowbase, VALUE = "    Help    ")

        WIDGET_CONTROL, Pickfilebase, /REALIZE

        XManager, "Pickfile", Pickfilebase, EVENT_HANDLER = "Pickfile_ev", $
                GROUP_LEADER = GROUP, /MODAL
        END
ENDCASE

CD, dirsave
filt = ""
GET_PATH=here
RETURN, thefile

END ;====================== end of Pickfile routine ===========================

;  $Id: plot_3dbox.pro,v 1.1 1994/06/27 14:55:56 kirk Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;	Plot_3dbox
;
; PURPOSE:
;	This procedure plots data in a 3-dimensional box, with options
;	to have the data displayed on the walls surrounding the plot area.
;
; CATEGORY:
;	Plotting, Three-dimensional
;
; CALLING SEQUENCE:
;	Plot_3dbox, X, Y, Z
; 
; INPUTS:
;	X:	A one dimensional array that contains the X coordinats
;
;	Y:	A one dimensional array that contains the Y coordinates
;
;	Z:	A one dimensional array that contains the Z coordinates
;
; OPTIONAL INPUTS:
;	None.
;	
; KEYWORD PARAMETERS:
;	COLOR:		The color for the Grid and Lines or the Color
;		 	for the box walls when the keyword SOLID_WALLS
;			is set.
;
;	BACKGROUND:	The background color of the plot or the color
;			of the Grid and Plot data when the SOLID_WALLS
;			keyword is set.
;
;	XY_PLANE:	Setting this keyword will cause the X and Y values
;			of the data to be plotted on the Z=0 axis plane.
;
;	XZ_PLANE:	Setting this keyword will cause the X and Z values
;			of the data to be plotted on the Y=Ymax axis plane.
;
;	YZ_PLANE:	Setting this keyword will cause the Y and Z values
;			of the data to be plotted on the X=Xmax axis plane.
;
;	SOLID_WALLS:	Setting this keyword causes the axis "walls" of 
;			the plot box to be filled with the value of COLOR.
;
;	PSYM:		The plotting symbol that the data is draw with.
;
;	GRIDSTYLE:	Set this keyword to the linestyle that will be 
;			used in drawing the gridlines.
;
;	TITLE:		Set this keyword to the Main plot title
;	
;	XTITLE:		Set this keyword to the X axis title.
;
;	YTITLE:		Set this keyword to the Y axis title.
;
;	ZTITLE:		Set this keyword to the Z axis title.
;
; 	SUBTITLE:	Set this keyword to the Sub-Title 
;
;	LINESTYLE:	The linestyle used to plot the data.
;
;	XYSTYLE:	The linesytle used to draw the plot in the XY plane.
;			If this keyword is not set, the value of LINESTYLE
;			is used.
;
;	XZSTYLE:	The linesytle used to draw the plot in the XZ plane.
;			If this keyword is not set, the value of LINESTYLE
;			is used.
;
;	YZSTYLE:	The linesytle used to draw the plot in the YZ plane.
;			If this keyword is not set, the value of LINESTYLE
;			is used.
;
;	Surface         All other keywords available to SURFACE are also
;	Keywords:	used by this procedure.
;
; OUTPUTS:
;	None.
;
; OPTIONAL OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Plotting on the current device is performed.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.  Unrecognized keywords are passed to the SURFACE
;	procedure.  
;
; EXAMPLE:
;       Create some data that can be passed to Plot_3dbox
;
;       x = Replicate(5., 10)
;       x1 = cos(findgen(36)*10.*!dtor)*2.+5.     
;       x=[x,x1,x]     
;       y = findgen(56)     
;       z = Replicate(5., 10)
;       z1 =sin(findgen(36)*10.*!dtor)*2.+5.     
;       z=[z,z1,z]     
;
;     ; Plot this data in a "plot box" 
;
;       Plot_3dbox, X, Y, Z, /XY_PLANE, /YZ_PLANE, /XZ_PLANE, $
;                 /SOLID_WALLS, GRIDSTYLE=1, XYSTYLE=3, XZSTYLE=4, $
;                 YZSTYLE=5, AZ=40, TITLE="Example Plot Box",      $
;                 Xtitle="X Coodinate", Ytitle="Y Coodinate",      $
;                 Ztitle="Z Coodinate", SubTitle="Sub Title",      $
;                 /YSTYLE, ZRANGE=[0,10], XRANGE=[0,10],Charsize=1.6
;
;     ; Then to plot symbols on the locations of the above plot
;
;       plots, X, Y, Z, /T3D, PSYM=4, COLOR=!p.background
;
; MODIFICATION HISTORY:
;       6/94   KDB, RSI   - Initial Coding and Testing
;
;-

PRO Plot_3dbox, X, Y, Z, COLOR=COLOR, BACKGROUND=BACKGROUND,        $  
                    XY_PLANE=XY_PLANE, YZ_PLANE=YZ_PLANE,        $  
                    XZ_PLANE=XZ_PLANE, SOLID_WALLS=SOLID_WALLS,  $  
                    PSYM=PSYM, GRIDSTYLE=GRIDSTYLE, TITLE=TITLE, $
		    XTITLE=XTITLE, YTITLE=YTITLE, ZTITLE=ZTITLE, $
		    SUBTITLE=SUBTITLE, LINESTYLE=LINESTYLE,      $
                    XYSTYLE=XYSTYLE, YZSTYLE=YZSTYLE, XZSTYLE=XZSTYLE, $
                    _EXTRA=e       

;  Set up simple error handling
       
   On_ERROR, 2

;  Lets make sure that all arrays are the same size     
       
   Xcnt = N_Elements(X)      
   Ycnt = N_Elements(Y)     
   Zcnt = N_Elements(Z)     
     
   if (Xcnt ne Ycnt) or (Xcnt ne Zcnt) then $
          Message, "X, Y and Z arrays must have same number of elements "      
     
;  Check the values of the keywords  
     
   if(N_Elements(PSYM)  eq 0)then      PSYM = 0  
   if(N_Elements(COLOR) eq 0)then      COLOR = !P.COLOR  
   if(N_Elements(BACKGROUND) eq 0)then BACKGROUND = !P.BACKGROUND  
   if(N_Elements(GRIDSTYLE) eq 0)then  GRIDSTYLE = 1  
   if(N_Elements(LINESTYLE) eq 0)then  LINESTYLE = 0  
   if(N_Elements(XYSTYLE) eq 0)then    XYSTYLE = LINESTYLE  
   if(N_Elements(XZSTYLE) eq 0)then    XZSTYLE = LINESTYLE
   if(N_Elements(YZSTYLE) eq 0)then    YZSTYLE = LINESTYLE

   if(not KeyWord_Set(TITLE))then      TITLE=''
   if(not KeyWord_Set(SUBTITLE))then   SUBTITLE=''
   if(not KeyWord_Set(XTITLE))then     XTITLE=''
   if(not KeyWord_Set(YTITLE))then     YTITLE=''
   if(not KeyWord_Set(ZTITLE))then     ZTITLE=''
   if(not KeyWord_Set(ZRANGE))then     ZRANGE=[Min(Z, MAX=zmax), zmax]

;  Use SURFACE to set up the coordinates system, handle titles ect...     
     
   Surface, FltArr(Xcnt,Xcnt), X, Y, /NODATA, /SAVE, TICKLEN=1,        $ 
      COLOR=COLOR, XGRIDSTYLE=GRIDSTYLE, YGRIDSTYLE=GRIDSTYLE,         $ 
      ZGRIDSTYLE=GRIDSTYLE, BACKGROUND=BACKGROUND, XTICK_GET=xt,       $ 
      YTICK_GET=yt, ZTICK_GET=zt,ZRANGE=ZRANGE, SUBTITLE=SUBTITLE,     $
      TITLE=TITLE, YTITLE=YTITLE, ZTITLE=ZTITLE, XTITLE=XTITLE, _EXTRA=e    

   name = replicate(' ' ,30)   ; Make up null tick names  
     
;  See if the user wants to have "Solid" box walls  
  
   if(KeyWord_Set(SOLID_WALLS))then BEGIN  
  
   ;  Using the values of Crange, fill in the box walls with the value  
   ;  of color  
  
      PolyFill, [!X.Crange(0), !X.Crange, !X.Crange(1)],  $;bottom  
                [!Y.Crange, !Y.Crange(1), !Y.Crange(0)],  $  
                Replicate(!Z.Crange(0), 4), /T3D, COLOR=COLOR  
      PolyFill, [!X.Crange(0), !X.Crange, !X.Crange(1)],  $ ; Back  
                Replicate(!Y.Crange(1),4),                $  
                [!Z.Crange, !Z.Crange(1), !Z.Crange(0)],  $  
                /T3D, COLOR=COLOR  
      PolyFill, Replicate(!X.Crange(1),4), /T3D, COLOR=COLOR, $ ;side  
                [!Y.Crange, !Y.Crange(1), !Y.Crange(0)],  $  
                [!Z.Crange(0), !Z.Crange, !Z.Crange(1)]  

   ;  Now Replot the surface data  
  
      COLOR=BACKGROUND  ; reverse colors 

      Surface, FltArr(Xcnt,Xcnt), X, Y, /NODATA, /SAVE, TICKLEN=1,       $ 
              /NOERASE, COLOR=COLOR, XTICKNAME=name, YTICKNAME=name,     $  
              ZTICKNAME=name, XGRIDSTYLE=GRIDSTYLE, YGRIDSTYLE=GRIDSTYLE,$  
              ZGRIDSTYLE=GRIDSTYLE, ZRANGE=ZRANGE, _EXTRA=e     

   ENDif  ;if solid walls set.  
   
;  Now complete the drawing of the axis box     
     
   Axis, !X.Crange(1), !Y.Crange(1), !Z.Crange(1), /YAXIS, /T3D,    $ 
         YTICKNAME = name, COLOR=COLOR, YTICKLEN=0     
   Axis, !X.Crange(1), !Y.Crange(0), !Z.Crange(0), ZAXIS=-1, /T3D,  $ 
         ZTICKNAME = name, COLOR=COLOR, ZTICKLEN=0     
   Axis, !X.Crange(0), !Y.Crange(1), !Z.Crange(0), /XAXIS, /T3D,    $ 
         XTICKNAME = name, COLOR=COLOR, XTICKLEN=0     
   Axis, !X.Crange(0), !Y.Crange(1), !Z.Crange(1), /XAXIS, /T3D,    $  
         XTICKNAME = name, COLOR=COLOR, XTICKLEN=0     
   Axis, !X.Crange(1), !Y.Crange(1), !Z.Crange(0), ZAXIS=-1, /T3D,  $ 
         ZTICKNAME = name, COLOR=COLOR, ZTICKLEN=0     
   Axis, !X.Crange(1), !Y.Crange(0), !Z.Crange(1), YAXIS=-1, /T3D,  $ 
         YTICKNAME = name, COLOR=COLOR, YTICKLEN=0     
   Axis, !X.Crange(1), !Y.Crange(0), !Z.Crange(0), /YAXIS, /T3D,    $ 
         YTICKNAME = name, COLOR=COLOR, YTICKLEN=0     

; now plot the data     
     
  Plots, X, Y, Z, /T3D , PSYM=PSYM, COLOR=COLOR ,LINESTYLE=LINESTYLE

; And now plot the data along the walls of the box if requested

  if(KeyWord_Set(XY_PLANE))then $     
      Plots, X, Y, Replicate(!Z.Crange(0), Zcnt), /T3D, COLOR=COLOR, $
               LINESTYLE=XYSTYLE
  if(KeyWord_Set(YZ_PLANE))then $     
      Plots, Replicate(!X.Crange(1), Xcnt), Y, Z, /T3D, COLOR=COLOR, $
               LINESTYLE=YZSTYLE
  if(KeyWord_Set(XZ_PLANE))then $     
      Plots, X, Replicate(!Y.Crange(1), Ycnt), Z, /T3D, COLOR=COLOR, $
               LINESTYLE=XZSTYLE

; now draw the grid lines on the plot that were not drawn by surface     
     
  for i=0, N_Elements(yt)-1 do $     
        Plots, [!X.Crange(1),!X.Crange(1)], [yt(i),yt(i)], !Z.Crange, /T3D, $  
               LINESTYLE=GRIDSTYLE, COLOR=COLOR  
  for i=0, N_Elements(zt)-1 do $     
        Plots, [!X.Crange(1),!X.Crange(1)], !Y.Crange, [zt(i),zt(i)], /T3D, $  
               LINESTYLE=GRIDSTYLE, COLOR=COLOR  
  for i=0, N_Elements(xt)-1 do $     
        Plots, [xt(i),xt(i)], [!Y.Crange(1),!Y.Crange(1)], !Z.Crange, /T3D, $  
               LINESTYLE=gridstyle, COLOR=COLOR  

END


; $Id: ploterr.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO PLOTERR,X,Y,ERR, psym = PSYM, type = TYPE
;
;+
; NAME:
;	PLOTERR
;
; PURPOSE:
;	Plot data points with accompanying error bars.
;	(See also OPLOTERR.)	
;
; CATEGORY:
;	Plotting, two-dimensional.
;
; CALLING SEQUENCE:
;	PLOTERR, [ X ,]  Y , Err [, PSYM = Psym] [, TYPE = Type]
;
; INPUTS:
;	X:	The array of abcissae.
;
;	Y:	The array of Y values.
;
;	Err:	The array of error-bar values.
;
; OPTIONAL KEYWORD PARAMETERS:
;	PSYM:	The plotting symbol to use.  The default is +7.
;
;	ITYPE:	The type of plot to be produced.  The possible types are:
;			ITYPE = 0 :	X Linear - Y Linear (default)
;			ITYPE = 1 :	X Linear - Y Log
;			ITYPE = 2 :	X Log    - Y Linear
;			ITYPE = 3 :	X Log    - Y Log
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	Arrays cannot be of type string.  There must be enough points to
;	plot.
;
; PROCEDURE:
;	A plot of X versus Y with error bars drawn from Y - ERR to Y + ERR
;	is written to the output device.
;
; MODIFICATION HISTORY:
;	William Thompson	Applied Research Corporation
;	July, 1986		8201 Corporate Drive
;				Landover, MD  20785
;
;	DMS, April, 1989	Modified for Unix.
;-
;
;P_SYM = !PSYM		; Save the affected system parameters
;Y_MIN = !YMIN
;Y_MAX = !YMAX
;BANG_C = !C
;LINETYPE = !LINETYPE
;
;  Interpret the input parameters.
;
if n_elements(type) eq 0 then type = 0
if n_elements(psym) eq 0 then psym = 7

ON_ERROR,2
NP = N_PARAMS(0)
IF NP LT 2 THEN BEGIN
	message,'Must be called with 2-5 parameters: [X,] Y, ERR [,PSYM [,ITYPE]]'
	RETURN
ENDIF ELSE IF NP EQ 2 THEN BEGIN	;Only Y and ERR passed.
	YERR = ABS(Y)
	YY = X
	XX = INDGEN(N_ELEMENTS(YY))
ENDIF ELSE BEGIN
	YERR = ABS(ERR)
	YY = Y
	XX = X
ENDELSE
;
N = N_ELEMENTS(XX) < N_ELEMENTS(YY) < N_ELEMENTS(YERR)
IF N LT 2 THEN message, 'Not enough points to plot.'

XX = XX(0:N-1)
YY = YY(0:N-1)
YERR = YERR(0:N-1)
YLO = yy - yerr
YHI = yy + yerr
;	Set yrange if not already set
if !y.range(0) eq !y.range(1) then $	;yrange specified?
    yrange = [ min(ylo), max(yhi) ] $
 else yrange = !y.range
;
plot,xx,yy,xtype = type/2, ytype = type and 1, yrange = yrange, psym=psym
;
;  Plot the error bars.
;
FOR I = 0,N-1 DO plots,[xx(i),xx(i)], [ylo(i), yhi(i)]
RETURN
END

; $Id: plot_field.pro,v 1.3 1993/10/08 15:53:31 doug Exp $

function mybi,a,x,y	;Bilinear interpolation
sizea=size(a)
nx=sizea(1)
i=long(x)+nx*long(y)
q=y-long(y)
p=x-long(x)
aint=(1.0-p)*(1.0-q)*a(i)+p*(1.0-q)*a(i+nx)+q*(1.0-p)*a(i+1)+p*q*a(i+nx+1)
return,aint
end



PRO ARRHEAD,X		;Add an arrowhead to a vector
THETA=ATAN(1.0)/4.0
TANT = TAN(THETA)
NP=3.0
SCAL=6.

SX=SIZE(X)
N=SX(2)


BIGL=SQRT((X(*,N-4,0)-X(*,N-5,0))^2+(X(*,N-4,1)-X(*,N-5,1))^2)
wbigl=where(BIGL ne 0.0)
wnbigl=where(bigl eq 0.0)
LL  = SCAL*TANT*BIGL(wbigl)/NP

DX = LL*(X(wbigl,N-4,1)-X(wbigl,N-5,1))/BIGL(wbigl)
DY = LL*(X(wbigl,N-4,0)-X(wbigl,N-5,0))/BIGL(wbigl)

XM = X(wbigl,N-4,0)-(SCAL-1)*(X(wbigl,N-4,0)-X(wbigl,N-5,0))/NP
YM = X(wbigl,N-4,1)-(SCAL-1)*(X(wbigl,N-4,1)-X(wbigl,N-5,1))/NP

X(wbigl,N-3,0) = XM-DX
X(wbigl,N-2,0) = X(wbigl,N-4,0)
X(wbigl,N-1,0) = XM+DX

X(wbigl,N-3,1) = YM+DY
X(wbigl,N-2,1) = X(wbigl,N-4,1)
X(wbigl,N-1,1) = YM-DY

if n_elements(wnbigl) gt 1 then begin
X(wnbigl,N-3,0) = x(wnbigl,n-4,0)
X(wnbigl,N-2,0) = X(wnbigl,n-4,0)
X(wnbigl,N-1,0) = X(wnbigl,n-4,0)

X(wnbigl,N-3,1) = X(wnbigl,N-4,1)
X(wnbigl,N-2,1) = X(wnbigl,N-4,1)
X(wnbigl,N-1,1) = X(wnbigl,N-4,1)
end
return
END



function arrows,u,v,n,length,xmax,lmax
su=size(u)
nx=su(1)
ny=su(2)
if n_params(0) lt 6 then lmax=sqrt(max(u^2+v^2))
if n_params(0) lt 5 then xmax=1.0
lth=0.1*length/lmax
xt=randomu(seed,n)
yt=randomu(seed,n)
x=fltarr(n,13,2)
x(0,0,0)=xt(*)
x(0,0,1)=yt(*)
for i=1,9 do begin
 xt(0)=(nx-1)*x(*,i-1,0)
 yt(0)=(ny-1)*x(*,i-1,1)
 ut=mybi(u,xt,yt)
 vt=mybi(v,xt,yt)
 x(0,i,0)=x(*,i-1,0)+ut*lth
 x(0,i,1)=x(*,i-1,1)+vt*lth
end
ARRHEAD,X
return,x<1.0>0.0
end




PRO Plot_field,U,V,N=N,LENGTH=length,ASPECT=aspect, title= title
;+
; NAME:
;	PLOT_FIELD
;
; PURPOSE:
;	This procedure plots a 2-dimensional field.
;
; CATEGORY:
;	Plotting, two-dimensional.
;
; CALLING SEQUENCE:
;	PLOT_FIELD, U, V
;
; INPUTS:
;	U:	The 2-dimensional array giving the field vector at each
;		point in the U(X) direction.
;
;	V:	The 2-dimensional array giving the field vector at each
;		point in the V(Y) direction.
;
; KEYWORD PARAMETERS:
;	N:	The number of arrows to draw. The default is 200.
;
;	LENGTH:	The length of the longest field vector expressed as a fraction
;		of the plotting area. The default is 0.1.
;
;	ASPECT:	The aspect ratio of the plot (i.e., the ratio of the X size 
;		to Y size). The default is 1.0.
;
;	TITLE:	The title of plot. The default is "Velocity Field".
;
; OUTPUTS:
;	No explicit outputs.
;
; SIDE EFFECTS:
;	A new plot is drawn to the current output device.
;
; PROCEDURE:
;	N random points are picked, and from each point a path is traced
;	along the field. The length of the path is proportional to "LENGTH" 
;	and the field vector magnitude.
;
; EXAMPLE:
;	X = FINDGEN(20, 20)		; Create array X
;	Y = FINDGEN(20, 20)*3		; Create array Y
;	PLOT_FIELD, X, Y		; Create plot
;	
; MODIFICATION HISTORY:
;	Jan., 1988	Neal Hurlburt, University of Colorado.
;-


if n_elements(n) le 0 then n=200
if n_elements(length) le 0 then length=.1
if n_elements(aspect) le 0 then aspect=1.0
if n_elements(title) le 0 then title = 'Velocity Field'

X=ARROWS(U,V,N,LENGTH)
IF ASPECT GT 1. THEN position=[0.20,(0.5-0.30/ASPECT),0.90,(0.5+0.40/ASPECT)]$
 else position=[(0.5-0.30*ASPECT),0.20,(0.5+0.40*ASPECT),0.90]
plot,[0,1,1,0,0],[0,0,1,1,0],title=title,/nodata, pos = position
FOR I=0,N-1 DO OPLOT,X(I,*,0),X(I,*,1)
RETURN
end

; $Id: pnt_line.pro,v 1.2 1993/10/05 21:35:57 doug Exp $

; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
Function Pnt_Line, p0, l0, l1, pl, INTERVAL = interval
;+
; NAME:
;	PNT_LINE
;
; PURPOSE:
;	This function returns the perpendicular distance between the
;	point P0 and the line between points L0 and L1.
;
; CATEGORY:
;	Geometry.
;
; CALLING SEQUENCE:
;	Result = PNT_LINE(P0, L0, L1 [, Pl])
;
; INPUTS:
;	P0: The location of the point. P0 may have 2 to N elements,
;    	    for N dimensions.
;	L0: One end-point of the line. L0 must have same number of
;	    elements as P0.
;	L1: The other end-point of the line. L1 must have the same
;	    number of elements as LO.
;
; KEYWORD PARAMETERS:
;	INTERVAL: If set, and if the point on the line between L0
;		  and L1 that is closest to PO is not within the
;		  interval (L0, L1), causes the function to return
;		  the distance from P0 to the closer of the two
;		  endpoints L0 and L1.
;
; OUTPUTS:
;	This function returns the distance from point P0 to the line
;	between L0 and L1, unless the closest point on the line is
;	not in the interval (L0, L1) and the keyword INTERVAL is set.
;	In this case, the function returns the distance between P0
;	and the closer of the two end-points.
;
; OPTIONAL OUTPUTS:
;	Pl: The point on the line between L0 and L1 that is closest to P0.
;	    Pl is not necessarily in the interval (L0, L1).
;
; RESTRICTIONS:
;	This function is limited by the machine accuracy of single
;	precision floating point.
;
; PROCEDURE:
;	Solve equations of perpendicular, etc.
;
; EXAMPLE:
;	To print the distance between the point (2,3) and the line
;	from (-3,3) to (5,12), and also the location of the point on
;	the line closest to (2,3), enter the following command:
;
;	  PRINT, PNT_LINE([2,3], [-3,3], [5,12], Pl), Pl
;
; MODIFICATION HISTORY:
; 	DMS, RSI, Jan, 1993.	Written.
;-


lv = float(l1 - l0)
l = sqrt(total(lv*lv))
if l eq 0 then begin	;Line is a point
	pl = p0
	return, sqrt(total((l0-float(p0))^2))
	endif
lv = lv / l			;Normal to line
t = - (-total(lv * p0) + total(l0 * lv))/(total(lv * lv))
pl = t * lv + l0		;Closest point on line
out = (t lt 0) or (t gt l)	;Within interval?

if keyword_set(interval) and out then begin  ;Outside interval?
    d1 = sqrt(total((p0-l1)^2))
    d2 = sqrt(total((p0-l0)^2))
    return, d1 < d2
endif else return, sqrt(total((p0 - pl)^2))

end

; $Id: polar_contour.pro,v 1.1 1995/02/03 17:00:52 dave Exp $
PRO Polar_Contour, z, theta, r, SHOW_TRIANGULATION=show, _Extra = e
;
; Copyright (c) 1995, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	POLAR_CONTOUR
;
; PURPOSE:
;	Produce a contour plot from data in polar coordinates.
;	Data may be in a regular or scattered grid.
; CATEGORY:
;	Graphics.
;
; CALLING SEQUENCE:
;	POLAR_CONTOUR, Z, Theta, R
; INPUTS:
;	Z = data values.  If regulary gridded, Z must have dimensions of 
;		(NTheta, NR).
;	Theta = values of theta in radians.  For the regular grid, Theta
;		must have the same number of elements as the first dimension
;		of Z.  For the scattered grid, Theta must have the same number
;		of elements as Z.
;	R = values of radius.  For the regular grid, R
;		must have the same number of elements as the second dimension
;		of Z.  For the scattered grid, R must have the same number
;		of elements as Z.
; KEYWORD PARAMETERS:
;	Any of the keywords accepted by CONTOUR may be specified.
;	In addition to:
;	SHOW_TRIANGULATION = color.  If set, the triangulation connecting
;		the data points is overplotted in the designated color.
; OUTPUTS:
;	A contour plot is produced.
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:
;	Plot is produced on the current graphics output device.
; RESTRICTIONS:
;	None.
; PROCEDURE:
;	The cartesian coordinates of each point are calculated.
;	TRIANGULATE is called to grid the data into triangles.
;	CONTOUR is called to produce the contours from the triangles.
; EXAMPLE:
;		Example with regular grid:
;	nr = 12		;# of radii
;	nt = 18		;# of thetas
;	r = findgen(nr) / (nr-1)   ;Form r and Theta vectors
;	theta = 2 * !pi * findgen(nt) / (nt-1)
;	z = cos(theta*3) # (r-.5)^2   ;Fake function value
;	tek_color
;		Create filled contours:
;	Polar_Contour, z, theta, r, /fill, c_color=[2,3,4,5]
;
;		Example with random (scattered) grid:
;	n = 200
;	r = randomu(seed, n)		;N random r's and Theta's
;	theta = 2*!pi * randomu(seed, n)
;	x = cos(theta) * r		;Make a function to plot
;	y = sin(theta) * r
;	z = x^2 - 2*y
;	Polar_Contour, z, theta, r, Nlevels=10, xrange=[0,1], yrange=[0,1]
;
; MODIFICATION HISTORY:
; 	Written by:	Your name here, Date.
;	January, 1995.	DMS, RSI.
;-

on_error, 2		;Return to caller...
s = size(z)
nz = n_elements(z)

if (s(0) eq 2) and (n_elements(theta) eq s(1)) and $   ;Regular grid case?
   (n_elements(r) eq s(2)) then begin
  tt = theta # replicate(1,n_elements(r))
  rr = replicate(1,n_elements(theta)) # r
  x = rr * cos(tt)
  y = rr * sin(tt)
endif else begin		;Irregular grid
  if n_elements(r) ne nz then message, $
	'R array has wrong number of elements'
  if n_elements(theta) ne nz then message, $
	'Theta array has wrong number of elements'
  x = r * cos(theta)
  y = r * sin(theta)
endelse

triangulate, x, y, tr
contour, z, x, y, TRIANGULATION=tr, _EXTRA=e

if n_elements(show) eq 1 then begin	;Show the triangulation?
    oplot, x, y, /psym, color=show
    for i=0, n_elements(tr)/3-1 do begin
      t = [tr(*,i), tr(0,i)]
      plots, x(t), y(t), color=show
      endfor
    endif
end

; $Id: polar_surface.pro,v 1.2 1993/10/05 21:57:01 doug Exp $

function polar_surface, z, r, theta, GRID = grid, SPACING = sp, $
	BOUNDS = bounds, QUINTIC = quintic, MISSING = missing
;+
; NAME:
;	POLAR_SURFACE
;
; PURPOSE:
;	This function interpolates a surface from polar coordinates
;	(R, Theta, Z) to rectangular coordinates (X, Y, Z).
;
; CATEGORY:
;	Gridding.
;
; CALLING SEQUENCE:
;	Result = POLAR_SURFACE(Z, R, Theta)
;
; INPUTS:
;	Z:	 An array containing the surface value at each point.
;		 If the data are regularly gridded (GRID=1) in R and 
;		 Theta, Z is a two dimensional array, where Z(i,j) has a
;		 radius of R(i) and an azimuth of Theta(j).  If GRID is
;		 not set, R(i) and Theta(i) contain the radius and azimuth
;		 of each Z(i).
;	R:	 The radius. If GRID is set, Z(i,j) has a radius of R(i).
;		 If GRID is not set, R must have the same number of elements
;		 as Z, and contains the radius of each point.
;	Theta:   The azimuth, in radians. If GRID is set, Z(i,j) has an
;		 azimuth of Theta(j). If GRID is not set, Theta must
;		 have the same number of elements as Z, and contains
;		 the azimuth of each point.
;
; KEYWORD PARAMETERS:
;	GRID:    Set GRID to indicate that Z is regularly gridded in R
;		 and Theta.
;	SPACING: A two element vector containing the desired grid spacing
;		 of the resulting array in X and Y.  If omitted, the grid
;		 will be approximately 51 by 51.
;	BOUNDS:  A four element vector, [X0, Y0, X1, Y1], containing the
;		 limits of the XY grid of the resulting array.  If omitted,
;		 the extent of input data sets the limits of the grid.
;	QUINTIC: If set, the function uses quintic interpolation, which is
;		 slower but smoother than the default linear interpolation.
;	MISSING: A value to use for areas within the grid but not within
;		 the convex hull of the data points. The default is 0.0.
;
; OUTPUTS:
;	This function returns a two-dimensional array of the same type as Z.
;
; PROCEDURE:
;	First, each data point is transformed to (X, Y, Z). Then
;	the TRIANGULATE and TRIGRID procedures are used to interpolate
;	the surface over the rectangular grid.
;
; EXAMPLE:
;	r = findgen(50) / 50.		  		;Radius
;	theta = findgen(50) * (2 * !pi / 50.) 		;Theta
;	z = r # sin(theta)		;Make a function (tilted circle)
;	SURFACE, POLAR_SURFACE(z, r, theta, /GRID) 	 ;Show it
;
; MODIFICATION HISTORY:
;	DMS 	Sept, 1992	Written
;-


IF keyword_set(grid) THEN BEGIN		;Regulary gridded?
	s = size(z)
	if s(0) ne 2 then message, "Z must be 2d if GRID is set"
	if n_elements(r) ne s(1) then $
		message, "R has wrong number of elements"
	if n_elements(theta) ne s(2) then $
		message, "Theta has wrong number of elements"
	x = r # cos(theta)
	y = r # sin(theta)
ENDIF ELSE BEGIN
	if (n_elements(r) ne n_elements(z)) or $
		(n_elements(theta) ne n_elements(z)) then $
		message, "R and Theta must have as many elements as Z"
	x = r * cos(theta)
	y = r * sin(theta)
ENDELSE

TRIANGULATE, x, y, tr		;Triangulate it
if n_elements(bounds) lt 4 then $
	bounds = [ min(x, max=x1), min(y, max=y1), x1, y1]
if n_elements(sp) lt 2 then $
	sp = [ bounds(2) - bounds(0), bounds(3) - bounds(1)] / 50.
if n_elements(missing) le 0 then missing = 0

RETURN, TRIGRID(x, y, z, tr, sp, bounds, QUINTIC = KEYWORD_SET(quintic), $
	MISSING = missing)
END

; $Id: poly_area.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function Poly_area,x,y
;+
; NAME:
;	POLY_AREA
;
; PURPOSE:
;	Return the area of a polygon given the coordinates
;	of its vertices.
;
; CATEGORY:
;	Analytical Geometry
;
; CALLING SEQUENCE:
;	Result = POLY_AREA(X, Y)
;
; INPUTS:
;	It is assumed that the polygon has N vertices with N sides
;	and the edges connect the vertices in the order:
;
;	[(x1,y1), (x2,y2), ..., (xn,yn), (x1,y1)].
;
;	i.e. the last vertex is	connected to the first vertex.
;
;	X:	An N-element vector of X coordinate locations for the vertices.
;
;	Y:	An N-element vector of Y coordinate locations for the vertices.
;
; OUTPUTS:
;	POLY_AREA returns the area of the polygon.  This value is always 
;	positive.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	The area is computed as:
;		Area = 	1/2 * [ x1y2 + x2y3 + x3y4 +...+x(n-1)yn + xny1 
;			- y1x2 - y2x3 -...-y(n-1)xn - ynx1)
;
; MODIFICATION HISTORY:
;	DMS, July, 1984.
;-
on_error,2                      ;Return to caller if an error occurs
n = n_elements(x)
if (n le 2) then message, 'Not enough vertices'
if n ne n_elements(y) then message,'X and Y arrays must have same size'

xx=float(x)		;Be sure its floating
return,abs(total(xx*shift(y,-1) - y*shift(xx,-1))/2.) ;This is it.
end

; $Id: poly_fit.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION POLY_FIT,X,Y,NDEGREE,YFIT,YBAND,SIGMA,A
;+
; NAME:
;	POLY_FIT
;
; PURPOSE:
;	Perform a least-square polynomial fit with optional error estimates.
;
;	This routine uses matrix inversion.  A newer version of this routine,
;	SVDFIT, uses Singular Value Decomposition.  The SVD technique is more
;	flexible, but slower.
;
;	Another version of this routine, POLYFITW, performs a weighted
;	least square fit.
;
; CATEGORY:
;	Curve fitting.
;
; CALLING SEQUENCE:
;	Result = POLY_FIT(X, Y, NDegree [,Yfit, Yband, Sigma, A] )
;
; INPUTS:
;	X:	The independent variable vector.
;
;	Y:	The dependent variable vector, should be same length as x.
;
;     NDegree:	The degree of the polynomial to fit.
;
; OUTPUTS:
;	POLY_FIT returns a vector of coefficients with a length of NDegree+1.
;
; OPTIONAL OUTPUT PARAMETERS:
;	Yfit:	The vector of calculated Y's.  These values have an error 
;		of + or - Yband.
;
;	Yband:	Error estimate for each point = 1 sigma
;
;	Sigma:	The standard deviation in Y units.
;
;	A:	Correlation matrix of the coefficients.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; MODIFICATION HISTORY:
;	Written by: George Lawrence, LASP, University of Colorado,
;		December, 1981.
;
;	Adapted to VAX IDL by: David Stern, Jan, 1982.
;
;-
	ON_ERROR,2		;RETURN TO CALLER IF ERROR
	XX = X*1.		;BE SURE X IS FLOATING OR DOUBLE
	N = N_ELEMENTS(X) 	;SIZE
	IF N NE N_ELEMENTS(Y) THEN $
	  message,'X and Y must have same # of elements'
;
	M = NDEGREE + 1			;# OF ELEMENTS IN COEFF VEC.
;
	A = DBLARR(M,M)		;COEFF MATRIX
	B = DBLARR(M)		;WILL CONTAIN SUM Y * X^J
	Z = DBLARR(N)+1.
;
	A(0,0) = N
	B(0) = TOTAL(Y)
;
	FOR P = 1,2*NDEGREE DO BEGIN ;POWER LOOP.
		Z=Z*XX			;Z IS NOW X^P
		IF P LT M THEN B(P) = TOTAL(Y*Z) ;B IS SUM Y*XX^J
		SUM = TOTAL(Z)
		FOR J= 0 > (P-NDEGREE), NDEGREE < P DO A(J,P-J) = SUM
	  END			;END OF P LOOP.
;
	A = INVERT(A)		;INVERT MATRIX.
;
;			IF A IS MULTIPLIED BY SIGMA SQUARED, IT IS THE
;			CORRELATION MATRIX.
;
	C = float(b) # a	;Get coefficients

;
	IF (N_PARAMS(0) LE 3) THEN RETURN,C	;EXIT IF NO ERROR ESTIMATES.
;
	YFIT = FLTARR(N)+C(0)	;INIT YFIT
	FOR K = 1,NDEGREE DO YFIT = YFIT + C(K)*(XX^K) ;FORM YFIT.
;
	IF (N_PARAMS(0) LE 4) THEN RETURN,C	;EXIT IF NO ERROR ESTIMATES.
;
	IF N GT M THEN $
		SIGMA = TOTAL((YFIT-Y) ^ 2) / (N-M) $	;COMPUTE SIGMA
	   ELSE	SIGMA = 0.
;
	A=A* SIGMA		;GET CORREL MATRIX
;
	SIGMA = SQRT(SIGMA)
	YBAND = FLTARR(N)+ A(0,0)	;SQUARED ERROR ESTIMATES
;
	FOR P = 1,2*NDEGREE DO BEGIN
	  Z = XX ^ P
	  SUM = 0.
	  FOR J=0 > (P - NDEGREE), NDEGREE < P DO SUM = SUM + A(J,P-J)
	  YBAND = YBAND + SUM * Z ;ADD IN ERRORS.
	END		;END OF P LOOP
	YBAND = SQRT(ABS(YBAND))	;ERROR ESTIMATES
	RETURN,C
END
; $Id: polyfitw.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION POLYFITW,X,Y,W,NDEGREE,YFIT,YBAND,SIGMA,A
;+
; NAME:
;	POLYFITW
;
; PURPOSE:
;	Perform a least-square polynomial fit with optional error estimates.
;
; CATEGORY:
;	Curve fitting.
;
; CALLING SEQUENCE:
;	Result = POLYFITW(X, Y, W, NDegree [, Yfit, Yband, Sigma, A])
;
; INPUTS:
;	    X:	The independent variable vector.
;
;	    Y:	The dependent variable vector.  This vector should be the same 
;		length as X.
;
;	    W:	The vector of weights.  This vector should be same length as 
;		X and Y.
;
;     NDegree:	The degree of polynomial to fit.
;
; OUTPUTS:
;	POLYFITW returns a vector of coefficients of length NDegree+1.
;
; OPTIONAL OUTPUT PARAMETERS:
;	 Yfit:	The vector of calculated Y's.  Has an error of + or - Yband.
;
;	Yband:	Error estimate for each point = 1 sigma.
;
;	Sigma:	The standard deviation in Y units.
;
;	    A:	Correlation matrix of the coefficients.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; MODIFICATION HISTORY:
;	Written by: 	George Lawrence, LASP, University of Colorado,
;			December, 1981.
;
;	Adapted to VAX IDL by: David Stern, Jan, 1982.
;
;	Weights added, April, 1987,  G. Lawrence
;
;-
ON_ERROR,2                      ;RETURN TO CALLER IF AN ERROR OCCURS
N = N_ELEMENTS(X) < N_ELEMENTS(Y) ; SIZE = SMALLER OF X,Y
M = NDEGREE + 1	; # OF ELEMENTS IN COEFF VEC
;
A = DBLARR(M,M) ; LEAST SQUARE MATRIX, WEIGHTED MATRIX
B = DBLARR(M)	; WILL CONTAIN SUM W*Y*X^J
Z = DBLARR(N) + 1.	; BASIS VECTOR FOR CONSTANT TERM
;
A(0,0) = TOTAL(W)
B(0) = TOTAL(W*Y)
;
FOR P = 1,2*NDEGREE DO BEGIN	; POWER LOOP
Z=Z*X	; Z IS NOW X^P
IF P LT M THEN B(P) = TOTAL(W*Y*Z)	; B IS SUM W*Y*X^J
SUM = TOTAL(W*Z)
FOR J = 0 > (P-NDEGREE), NDEGREE < P DO A(J,P-J) = SUM
	END ; END OF P LOOP, CONSTRUCTION OF A AND B
;
A = INVERT(A)
;
C = FLOAT(B # A)
;
IF ( N_PARAMS(0) LE 3) THEN RETURN,C	; EXIT IF NO ERROR ESTIMATES
;
; COMPUTE OPTIONAL OUTPUT PARAMETERS.
;
YFIT = FLTARR(N)+C(0)	; ONE-SIGMA ERROR ESTIMATES, INIT
FOR K = 1, NDEGREE DO YFIT = YFIT + C(K)*(X^K)	; SUM BASIS VECTORS
;
VAR = TOTAL((YFIT-Y)^2 )/(N-M)	; VARIANCE ESTIMATE, UNBIASED
;
;
SIGMA=SQRT(VAR)
YBAND = FLTARR(N) + A(0,0)
Z=FLTARR(N)+1.
FOR P=1,2*NDEGREE DO BEGIN	; COMPUTE CORRELATED ERROR ESTIMATES ON Y
	Z = Z*X		; Z IS NOW X^P
	SUM = 0.
	FOR J=0 > (P - NDEGREE), NDEGREE  < P DO SUM = SUM + A(J,P-J)
	YBAND = YBAND + SUM * Z	; ADD IN ALL THE ERROR SOURCES
ENDFOR	; END OF P LOOP
	YBAND = YBAND*VAR
	YBAND = SQRT( YBAND )
RETURN,C
END



; $Id: poly.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION POLY,X,C
;+
; NAME:
;	POLY
;
; PURPOSE:
;	Evaluate a polynomial function of a variable.
;
; CATEGORY:
;	C1 - Operations on polynomials.
;
; CALLING SEQUENCE:
;	Result = POLY(X,C)
;
; INPUTS:
;	X:	The variable.  This value can be a scalar, vector or array.
;
;	C:	The vector of polynomial coefficients.  The degree of 
;		of the polynomial is N_ELEMENTS(C) - 1.
;
; OUTPUTS:
;	POLY returns a result equal to:
;		 C(0) + c(1) * X + c(2)*x^2 + ...
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	DMS, Written, January, 1983.
;-

on_error,2		;Return to caller if an error occurs
N = N_ELEMENTS(C)-1	;Find degree of polynomial
Y = c(n)
for i=n-1,0,-1 do y = y * x + c(i)
return,y
end

; $Id: polywarp.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro POLYWARP, XI, YI, XO, YO, DEGREE, KX, KY
;+
; NAME:
;	POLYWARP
;
; PURPOSE:
;	Perform polynomial spatial warping.
;
;	Using least squares estimation, determine the coefficients Kx(i,j) 
;	and Ky(i,j) of the polynomial functions:
;		Xi = sum over i and j of:  Kx(i,j) * Xo^j * Yo^i
;		Yi = sum over i and j of:  Ky(i,j) * Xo^j * Yo^i
;
;	Kx and Ky can be used as inputs P and Q to the built-in function
;	POLY_2D.
;	
; CATEGORY:
;	Image processing.
;
; CALLING SEQUENCE:
;	POLYWARP, Xi, Yi, Xo, Yo, Degree, Kx, Ky
;
; INPUTS:
;	Xi, Yi:	The vectors of x,y coordinates to be fit as a function 
;		of Xo and Yo.
;
;	Xo, Yo:	The vectors of x,y independent coordinates.  These vectors 
;		must have the same number of elements as Xi and Yi.
;
;	Degree:	The degree of the fit.  The number of coordinate pairs must be
;		greater than or equal to (Degree+1)^2.
;
; OUTPUTS:
;	Kx:	The array of coefficients for Xi as a function of (xo,yo).  
;		This parameter is returned as a (Degree+1) by (Degree+1) 
;		element array.
;
;	Ky:	The array of coefficients for yi.  This parameter is returned
;		as a (Degree+1) by (Degree+1) element array.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	See:	Computer Image Processing and Recognition, Ernest L. Hall,
;		Academic Press, 1979, Pages 186-188.
;
;	Xi and Yi are expressed as polynomials of Xo, Yo:
;		Xi = Kx(i,j) * Xo^j * Yo^i   Summed for i,j = 0 to degree.
;	And
;		Yi = Ky(i,j) * Xo^j * Yo^i.
;
;	This coordinate transformation may be then used to
;	map from Xo, Yo coordinates into Xi, Yi coordinates.
;
; EXAMPLE:
;	The following example shows how to display an image and warp it
;	using the POLYWARP and POLY_2D routines.
;
;	Create and display the original image by entering:
;
;		A = BYTSCL(SIN(DIST(250)))
;		TVSCL, A
;
;	Now set up the Xi's and Yi's.  Enter:
;
;		XI = [24, 35, 102, 92]
;		YI = [81, 24, 25, 92]
;
;	Enter the Xo's and Yo's:
;
;		XO = [61, 62, 143, 133]
;		YO = [89, 34, 38, 105]
;
;	Run POLYWARP to obtain a Kx and Ky:
;
;		POLYWARP, XI, YI, XO, YO, 1, KX, KY
;
;	Create a warped image based on Kx and Ky with POLY_2D:
;
;		B = POLY_2D(A, KX, KY)
;
;	Display the new image:
;
;		TV, B
;
; MODIFICATION HISTORY:
;	DMS, RSI, Dec, 1983.
;-
;
on_error,2                      ;Return to caller if an error occurs
m = n_elements(xi)		;# of points..
if (m ne n_elements(yi)) or (n_elements(xo) ne n_elements(yo)) $
	or (m ne n_elements(xo)) then begin
		message,'Inconsistent number of elements.'
		endif
;
n = degree		;use halls notation
n2=(n+1)^2
if n2 gt m then message, '# of points must be ge (degree+1)^2.'
;
x = dblarr(2,m)		;x array
u = x
x = double([transpose(xi(*)),transpose(yi(*))])
u = double([transpose(xo(*)),transpose(yo(*))])
;
ut = dblarr(n2,m)	;transpose of U
u2i = dblarr(n+1)	;[1,u2i,u2i^2,...]
for i=0L,m-1 do begin
	u2i(0)=1.	;init u2i
	zz = u(1,i)
	for j=1,n do u2i(j)=u2i(j-1)*zz
	ut(0,i)= u2i	;evaluate 0 th power separately
	for j=1,n do ut(j*(n+1),i)=u2i*u(0,i)^j ;fill ut=u0i^j * U2i
	endfor
;
uu = transpose(ut)	;big u
kk = invert(ut#uu)#ut	;solve equation
kx = fltarr(n+1,n+1) + float(kk # transpose(x(0,*)))	;g1, make 2d square
ky = fltarr(n+1,n+1) + float(kk # transpose(x(1,*)))	;g2
return
end
; $Id: popd.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;+
; NAME:
;	POPD
;
; PURPOSE:
;	Change the current working directory to the directory
;	saved on the top of the directory stack maintained
;	by the PUSHD and POPD User Library procedures. This top entry
;	is then removed.
;
; CALLING SEQUENCE:
;	POPD
;
; SIDE EFFECTS:
;	The top entry of the directory stack is removed.
;
; RESTRICTIONS:
;	Popping a directory from an empty stack causes a warning
;	message to be printed.  The current directory is not changed
;	in this case.
;
; COMMON BLOCKS:
;	DIR_STACK:  Contains the stack.
;
; MODIFICATION HISTORY:
;	17, July, 1989, Written by AB, RSI.
;-
;
;
pro popd

COMMON DIR_STACK, DEPTH, STACK
on_error, 2		; Return to caller on error
if (n_elements(DEPTH) eq 0) then depth = 0
if (DEPTH eq 0) then message, 'Directory stack is empty.'
cd, stack(0)
DEPTH = DEPTH - 1
if (DEPTH eq 0) then STACK = 0 else STACK = STACK(1:*)
end
;$Id: primes.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       PRIMES
;
; PURPOSE:
;       This function computes the first K prime numbers. The result is a 
;       K-element vector of type long integer.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Primes(K)
;
; INPUTS:
;       K:    A scalar of type integer or long integer that specifies the 
;             number of primes to be computed.
;
; EXAMPLE:
;       Compute the first 25 prime numbers.
;         result = primes(25)
;
;       The result should be:
;         [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, $
;          53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, November 1994
;-

function primes, k

  ;Compute the first k prime numbers.

  prm = lonarr(k)

  prm(0) = 2L
  n = 3L
  count = 1L
  prm(count) = 3L

  case2: count = count + 1L

  while(count lt k) do begin
    case1:
    n = n + 2L

    for ip = 1L, count do begin
      q = n / prm(ip)
      r = n mod prm(ip)
      if r eq 0 then goto, case1  ;n is not prime.

      if q le prm(ip) then begin  ;n is prime.
        prm(count) = n
        goto, case2               ;compute next prime.
      endif

    endfor 

  endwhile

  return, prm
  prm = 0

end
; $Id: printd.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;+
; NAME:
;	PRINTD
;
; PURPOSE:
;	Display the contents of the directory stack maintained by the
;	PUSHD and POPD User Library procedures.
;
; CALLING SEQUENCE:
;	PRINTD
;
; OUTPUTS:
;	PRINTD lists the contents of the directory stack on the default
;	output device.
;
; COMMON BLOCKS:
;	DIR_STACK:  Contains the stack.
;
; MODIFICATION HISTORY:
;	17, July, 1989, Written by AB, RSI.
;-
;
;
pro printd

COMMON DIR_STACK, DEPTH, STACK

on_error,2                      ;Return to caller if an error occurs
if (n_elements(DEPTH) eq 0) then depth = 0

CD, CURRENT=current
print, 'Current Directory: ', current

if (DEPTH eq 0) then begin
  message, 'Directory stack is empty.'
endif else begin
  print, 'Directory Stack Contents:'
  for i = 0, DEPTH-1 do print,format='(I3,") ", A)', I, STACK(I)
endelse

end
; $Id: profile.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function profile, image, xx, yy, xstart = x0, ystart = y0, nomark = nomark
;+
; NAME:
;	PROFILE
;
; PURPOSE:
;	Extract a profile from an image.
;
; CATEGORY:
;	Image processing.
;
; CALLING SEQUENCE:
;	Result = PROFILE(Image, XX, YY)
;
; INPUTS:
;	Image:	The data array representing the image.  This array can be
;		of any type except complex.
;
; KEYWORD PARAMETERS:
;      XSTART:	The starting X location of the lower-left corner of Image.
;		If this keyword is not specified, 0 is assumed.
;
;      YSTART:	The starting Y location of the lower-left corner of Image.
;		If this keyword is not specified, 0 is assumed.
;
;     NONMARK:	Set this keyword to inhibit marking the image with the 
;		profile line.
;
; OUTPUTS:
;	PROFILE returns a floating-point vector containing the values of
;	the image along the profile line marked by the user.
;
; OPTIONAL OUTPUTS:
;	XX:	After picking the end points, XX contains the X coordinates
;		of the points along the selected profile.
;
;	YY:	After picking the end points, YY contains the Y coordinates
;		of the points along the selected profile.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Cursor on image display is enabled.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Allow the operator to mark two points on the
;	image display with the joystick.  Extract and
;	return the points along the line.  Optionally
;	return the X and Y values of each extracted point.
;
; EXAMPLE:
;	Display an image, select a profile and plot that profile in a new
;	window.  Create and display an image by entering:
;
;		A = BYTSCL(DIST(256))
;		TV, A
;
;	Extract a profile from the image.  Enter the following command and
;	mark two points on the image with the mouse:
;
;		R = PROFILE(A)
;
;	Create a new plotting window and plot the profile by entering:
;
;		WINDOW, /FREE
;		PLOT, R
;
;	An interactive version of this routine is available with the User
;	Library procedure PROFILES.
;
; MODIFICATION HISTORY:
;	Written, DMS, November, 1982.
;	Modified for Sun, march, 1988.
;	December 1991, KRC  Made PROFILES return XX and YY.
;-
on_error,2                      ;Return to caller if an error occurs
s=size(image)
sx = s(1) & sy=s(2)
if n_elements(x0) le 0 then x0 = 0
if n_elements(y0) le 0 then y0 = 0
try: print,'Mark the two end points of the profile.'
Pnt1:
	tvrdc,xx,yy,1,/dev	;Get first point
	y = yy - y0
	x = xx - x0
	if !order ne 0 then y = sy - 1 - y ;Invert?
	if (x lt 0) or (x ge sx) or (y lt 0) or (y ge sy) then begin
		message, 'Point outside image', /CONTINUE
		goto, pnt1
		endif
	print,'From: (',x,',',y,')'
pnt2:
	wait,.5			;for fast displays
	tvrdc,xx1,yy1,/dev	;2nd point.
	y1 = yy1 - y0
	x1 = xx1 - x0
	if !order ne 0 then y1 = sy - 1 - y1 ;Invert?
	if (x1 lt 0) or (x1 ge sx) or (y1 lt 0) or (y1 ge sy) then begin
		message, 'Point outside image.', /CONTINUE
		goto, pnt2
		endif
	print,'To (',x1,',',y1,')'
	if not keyword_set(nomark) then $
		plots,[xx,xx1],[yy,yy1],/dev,/noclip ;Draw the line
;
dx = float(x1-x)		;delta x
dy = float(y1-y)
n = abs(dx) > abs(dy)
if n eq 0 then message, 'Zero length line.'
;
r = fltarr(n+1)
;
if abs(dx) gt abs(dy) then begin
	if x1 ge x then s=1 else s=-1
	sy = (y1-y)/abs(dx)
   endif else begin
	if y1 ge y then sy=1 else sy=-1
	s = (x1-x)/abs(dy)
   endelse
;
xx = indgen(n+1l)*s+x		;X values, make into longwords.
yy = indgen(n+1l)*sy+y		;Y values
return,image(long(yy)*sx + xx)
end
; $Id: profiles.pro,v 1.2 1994/06/08 22:37:00 dan Exp $

pro profiles, image, sx = sx, sy = sy, wsize = wsize, order = order
;+
; NAME:
;	PROFILES
;
; PURPOSE:
;	Interactively draw row or column profiles of an image in a separate
;	window.
;
; CATEGORY:
;	Image analysis.
;
; CALLING SEQUENCE:
;	PROFILES, Image [, SX = sx, SY = sy]
;
; INPUTS:
;	Image:	The variable that represents the image displayed in current 
;		window.  This data need not be scaled into bytes.
;		The profile graphs are made from this array.
;
; KEYWORD PARAMETERS:
;	SX:	Starting X position of the image in the window.  If this 
;		keyword is omitted, 0 is assumed.
;
;	SY:	Starting Y position of the image in the window.  If this
;		keyword is omitted, 0 is assumed.
;
;	WSIZE:	The size of the PROFILES window as a fraction or multiple 
;		of 640 by 512.
;
;	ORDER:	Set this keyword param to 1 for images written top down or
;		0 for bottom up.  Default is the current value of !ORDER.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A new window is created and used for the profiles.  When done,
;	the new window is deleted.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	A new window is created and the mouse location in the original
;	window is used to plot profiles in the new window.  Pressing the
;	left mouse button toggles between row and column profiles.
;	The right mouse button exits.
;
; EXAMPLE:
;	Create and display an image and use the PROFILES routine on it.
;	Create and display the image by entering:
;
;		A = BYTSCL(DIST(256))
;		TV, A
;
;	Run the PROFILES routine by entering:
;
;		PROFILES, A
;
;	The PROFILES window should appear.  Move the cursor over the original
;	image to see the profile at the cursor position.  Press the left mouse
;	button to toggle between row and column profiles.  Press the right
;	mouse button (with the cursor over the original image) to exit the
;	routine.
;
; MODIFICATION HISTORY:
;	DMS, Nov, 1988.
;-
on_error,2                              ;Return to caller if an error occurs
if n_elements(sx) eq 0 then sx = 0	;Default start of image
if n_elements(sy) eq 0 then sy = 0
if n_elements(wsize) eq 0 then wsize = .75
s = size(image)
maxv = max(image) 			;Get extrema
minv = min(image)
orig_w = !d.window
nx = s(1)				;Cols in image
ny = s(2)				;Rows in image
IF (!Version.Os NE 'MacOS') THEN tvcrs,sx+nx/2,sy+ny/2,/dev ELSE tvcrs,1
tickl = 0.1				;Cross length
print,'Left mouse button to toggle between rows and columns.'
print,'Right mouse button to Exit.'
window,/free ,xs=wsize*640, ys=wsize*512,title='Profiles' ;Make new window
new_w = !d.window
old_mode = -1				;Mode = 0 for rows, 1 for cols
old_font = !p.font			;Use hdw font
!p.font = 0
mode = 0
if n_elements(order) eq 0 then order = !order	;Image order

while 1 do begin
	wset,orig_w		;Image window
	cursor,x,y,2,/dev	;Read position

	if !err eq 1 then begin
		mode = 1-mode	;Toggle mode
		repeat cursor,x,y,0,/dev until !err eq 0
		endif

	x = x - sx		;Remove bias
	y = y - sy
	wset,new_w		;Graph window

	if !err eq 4 then begin		;Quit
		wset,orig_w
		IF (!Version.Os NE 'MacOS') THEN $
			tvcrs,nx/2,ny/2,/dev	;curs to old window
		tvcrs,0				;Invisible
		wdelete, new_w
		!p.font = old_font
		return
		endif
	if mode ne old_mode then begin
		old_mode = mode
		first = 1
		if mode then begin	;Columns?
			plot,[minv,maxv],[0,ny-1],/nodat,title='Column Profile'
			vecy = findgen(ny)
			crossx = [-tickl, tickl]*(maxv-minv)
			crossy = [-tickl, tickl]*ny
		end else begin
			plot,[0,nx-1],[minv,maxv],/nodata,title='Row Profile'
			vecx = findgen(nx)
			crossx = [-tickl, tickl]*nx
			crossy = [-tickl, tickl]*(maxv-minv)
		endelse
	endif

	if (x lt nx) and (y lt ny) and $
		(x ge 0) and (y ge 0) then begin	;Draw it
		
		if order then y = (ny-1)-y	;Invert y?
		if first eq 0 then begin	;Erase?
			plots, vecx, vecy, col=0	;Erase graph
			plots, old_x, old_y, col=0	;Erase cross
			plots, old_x1, old_y1, col=0
			xyouts,.1,0,/norm,value,col=0	;Erase text
			empty
		  endif else first = 0
;;;;		value = string([x,y],format="('(',i4,',',i4,')')")
;;;;		value = strtrim(x,2) + string(y)
		value = strmid(x,8,4)+strmid(y,8,4)
		ixy = image(x,y)		;Data value
		if mode then begin		;Columns?
			vecx = image(x,*)	;get column
			old_x = crossx + ixy
			old_y = [y,y]
			old_x1 = [ixy, ixy]
			old_y1 = crossy + y
		  endif else begin
			vecy = image(*,y)	;get row
			old_x = [ x,x]
			old_y = crossy + ixy
			old_x1 = crossx + x
			old_y1 = [ixy,ixy]
		  endelse
		xyouts,.1,0,/norm,value	;Text of locn
		plots,vecx,vecy		;Graph
		plots,old_x, old_y	;Cross
		plots,old_x1, old_y1
		endif
endwhile
end
; $Id: project_vol.pro,v 1.4 1994/11/18 22:03:25 dan Exp $

; Copyright (c) 1992-1993, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	PROJECT_VOL
;
; PURPOSE:
;       This function returns a two dimensional image that is the
;       projection of a 3-D volume of data onto a plane (similar to an
;       X-ray). The returned image is a translucent rendering of the
;       volume (the highest data values within the volume show up as the
;       brightest regions in the returned image). Depth queing and
;       opacity may be used to affect the image. The volume is
;       projected using a 4x4 matrix, so any type of projection may
;       be used including perspective. Typically the system viewing
;       matrix (!P.T) is used as the 4x4 matrix.
;
;	Also, see the intrinsic procedure VOXEL_PROJ which performs many
;	of the same functions as this routine.   VOXEL_PROJ provides the
;       RGBO rendering method.   VOXEL_PROJ is faster, but it does not
;       allow for perspective projections.
;
;       PROJECT_VOL can combine the contents of the Z-buffer with the
;       projection when the Z_BUFFER keyword is set.   PROJECT_VOL will not,
;       however, modify the contents of the Z-buffer.
;
; CATEGORY:
;	Volume Rendering.
;
; CALLING SEQUENCE:
;       Image = PROJECT_VOL(Vol, X_sample, Y_sample, Z_sample)
;
; INPUTS:
;       Vol:        The three dimensional volume of data to project.
;                   Data type : Any 3-D array except string or structure.
;       X_sample:   The number of rays to project along the X dimension
;                   of the image. (The returned image will have the
;                   dimensions X_sample by Y_sample).
;                   Data type : Long.
;       Y_sample:   The number of rays to project along the Y dimension
;                   of the image.
;                   Data type : Long.
;       Z_sample:   The number of samples to take along each ray.
;                   Higher values for X_sample, Y_sample, and Z_sample
;                   increase the image resolution as well as execution time.
;                   Data type : Long.
;
; KEYWORD PARAMETERS:
;       AVG_INTENSITY:
;                   If set, then the average intensity method of projection
;                   is used.   The default is a maximum intensity projection.
;                   This keyword only has effect when NOT using the Z-buffer.
;       CUBIC:      If set, then the cubic method of interpolation is used.
;                   The default is a bilinear interpolation.
;       DEPTH_Q:    Set this keyword to indicate that the image should be
;                   created using depth queing. The depth queing should
;                   be a single floating point value (between 0.0 and 1.0).
;                   This value specifies the brightness of the farthest
;                   regions of the volume relative to the closest regions
;                   of the volume. A value of 0.0 will cause the back
;                   side of the volume to be completely blacked out,
;                   while a value of 1.0 indicates that the back side
;                   will show up just as bright as the front side.
;                   The default is 1.0 (indicating no depth queing).
;                   Data type : Float.
;       OPAQUE:     A 3-D array with the same size and dimensions as Vol.
;                   This array specifies the opacity of each cell in the
;                   volume. Opaque values of 0 allow all light to
;                   pass through. Opaque values are cumulative.
;                   For example, if a ray eminates from a data value of 50,
;                   and then passes through 10 opaque cells (each with a
;                   data value of 0 and an opacity value of 5) then that
;                   ray would be completely blocked out (the cell with the
;                   data value of 50 would be invisible on the returned
;                   image).   The default is no opacity.
;                   Data type : Any 3-D array except string or structure
;                               (usually the same type as Vol).
;       TRANS:      A 4x4 floating point array to use as the
;                   transformation matrix when projecting the volume.
;                   The default is to use the system viewing matrix (!P.T).
;                   Data type : Fltarr(4, 4).
;       XSIZE:      The X size of the image to return.   Congrid is used to
;                   resize the final image to be XSIZE by YSIZE.   The default
;                   is the X size of the current window (or the X size of the
;                   Z-buffer).   If there is no current window then the
;                   default is X_sample.
;                   Data type: Int or Long.
;       YSIZE:      The Y size of the image to return.   Congrid is used to
;                   resize the final image to be XSIZE by YSIZE.   The default
;                   is the Y size of the current window (or the Y size of the
;                   Z-buffer).   If there is no current window then the
;                   default is Y_sample.
;                   Data type: Int or Long.
;       Z_BUFFER:   If set, then the projection is combined with the contents
;                   of the Z-buffer.   The default is to not use the Z-buffer
;                   contents.
;
; OUTPUTS:
;       This function returns the projected volume as a two dimensional
;       array with the same data type as Vol. The dimensions of the
;       returned array are XSIZE by YSIZE.
;
; EXAMPLE:
;       Use "T3D" to set up a viewing projection and render a volume of
;       data using "PROJECT_VOL" :
;
;       ; Create some data.
;          vol = RANDOMU(s, 40, 40, 40)
;          FOR i=0, 10 DO vol = SMOOTH(vol, 3)
;          vol = BYTSCL(vol(3:37, 3:37, 3:37))
;          opaque = RANDOMU(s, 40, 40, 40)
;          FOR i=0, 10 DO opaque = SMOOTH(opaque, 3)
;          opaque = BYTSCL(opaque(3:37, 3:37, 3:37), TOP=25B)
;
;       ; Set up the view.
;          xmin = 0 & ymin = 0 & zmin = 0
;          xmax = 34 & ymax = 34 & zmax = 34
;          !X.S = [-xmin, 1.0] / (xmax - xmin)
;          !Y.S = [-ymin, 1.0] / (ymax - ymin)
;          !Z.S = [-zmin, 1.0] / (zmax - zmin)
;          T3D, /RESET
;          T3D, TRANSLATE=[-0.5, -0.5, -0.5]
;          T3D, SCALE=[0.7, 0.7, 0.7]
;          T3D, ROTATE=[30, -30, 60]
;          T3D, TRANSLATE=[0.5, 0.5, 0.5]
;          window, 0, xsize=512, ysize=512
;
;       ; Generate and display the image.
;          img = PROJECT_VOL(vol, 64, 64, 64, DEPTH_Q=0.7, $
;                OPAQUE=opaque, TRANS=(!P.T))
;          TVSCL, img
;
; MODIFICATION HISTORY:
; 	Written by:	Daniel Carr. Tue Sep  1 17:52:06 MDT 1992
;
;       Modified to increase speed.   Also modified
;       to use current data->normal coordinate conversion.   Added
;       CUBIC, AVG_INTENSITY, XSIZE, YSIZE, and Z_BUFFER keywords.
;                       Daniel Carr. Tue Nov 15 16:03:15 MST 1994
;-

FUNCTION Project_Vol, vol, x_sample, y_sample, z_sample, $
         Depth_q=depth_q, Opaque=opaque, Trans=trans, Cubic=cubic, $
         Xsize=xsize, Ysize=ysize, Avg_Intensity=avg_intensity, $
         Z_Buffer=z_buffer

; *** Test inputs.

size_vol = Size(vol)
vol_type = size_vol(size_vol(0)+1)

x_sample = Long(x_sample(0))
y_sample = Long(y_sample(0))
xy_sample = x_sample * y_sample
z_sample = Long(z_sample(0))
zf_sample = Float(z_sample)
zf_sample_m1 = zf_sample - 1.0
z_sample_m1 = z_sample - 1L
z_max = Float(z_sample - 1L)

IF (n_elements(xsize) LE 0L) THEN BEGIN
   IF (!D.Window GE 0L) THEN xsize = !D.X_Size ELSE xsize = x_sample
ENDIF

IF (n_elements(ysize) LE 0L) THEN BEGIN
   IF (!D.Window GE 0L) THEN ysize = !D.Y_Size ELSE ysize = y_sample
ENDIF

IF (N_ELEMENTS(depth_q) GT 0) THEN depth_q = (Float(depth_q(0)) > 0.0) < 1.0 $
ELSE depth_q = 1.0
depth_q = 1.0 - depth_q

block_out = 0B
IF (N_Elements(opaque) GT 0L) THEN BEGIN
   IF (N_Elements(opaque) EQ N_Elements(vol)) THEN BEGIN
      opaque = Reform(opaque, size_vol(1), size_vol(2), size_vol(3))
      block_out = 1B
   ENDIF ELSE BEGIN
      Print, 'Opaque array must be the same size as volume array.'
      RETURN, Bytarr(xsize, ysize)
   ENDELSE
ENDIF

IF (N_Elements(trans) GT 0) THEN BEGIN
   IF (N_Elements(trans) NE 16) THEN BEGIN
      Print, 'Incorrect number of elements in Trans.'
      RETURN, Bytarr(xsize, ysize)
   ENDIF ELSE BEGIN
      trans = Float(Reform(trans, 4, 4))
   ENDELSE
ENDIF ELSE BEGIN
   trans = !P.T
ENDELSE
trans = Invert(trans, status)
IF (status NE 0) THEN BEGIN
   Print, 'Unable to invert transformation matrix.'
   RETURN, Bytarr(xsize, ysize)
ENDIF

; *** Set up the required variables.

x_ind = (((Float(size_vol(1)) * Findgen(x_sample) / Float(x_sample - 1L)) * $
   !X.S(1)) + !X.S(0)) # Replicate(1.0, y_sample)
y_ind = Replicate(1.0, x_sample) # $
        (((Float(size_vol(2)) * Findgen(y_sample) / Float(y_sample - 1L)) * $
   !Y.S(1)) + !Y.S(0))

max_vol = Float(Max(vol))

IF Keyword_Set(z_buffer) THEN BEGIN ; *** Use Z-Buffer info.
   save_win = !D.Window
   save_name = !D.Name
   Set_Plot, 'Z'
   img = Congrid(Tvrd(), x_sample, y_sample, /Interp, /Minus_One)
   min_img = 0B
   depth_fac = 0B
   depth = Congrid(Tvrd(Channel=1, /Words), x_sample, y_sample, $
      /Interp, /Minus_one)
   xsize = !D.X_size
   ysize = !D.Y_size
   Set_Plot, save_name
   IF (save_win GE 0L) THEN Wset, save_win

   ; *** Do the projection.

   FOR k=0L, z_sample_m1 DO BEGIN
      kf = Float(k)
      z_pos = (kf * !Z.S(1)) + !Z.S(0)

      index = [[x_ind(*)], [y_ind(*)], $
         [replicate(z_pos, xy_sample)], [replicate(1.0, xy_sample)]] # trans

      indx = Float(size_vol(1)) * index(*, 0) / index(*, 3)
      indy = Float(size_vol(2)) * index(*, 1) / index(*, 3)
      indz = Float(size_vol(3)) * index(*, 2) / index(*, 3)

      z_pos = 2.0 * ((((z_pos - 0.5) > (-0.5)) < 0.5) * 32765.0)
      z_ind = Where(z_pos GT depth, count)

      IF (count EQ (xsize * ysize)) THEN BEGIN ; *** Nothing in the way.
         IF (block_out) THEN $
            img = img - $
               (Interpolate(opaque, indx, indy, indz, Missing=min_img, $
                            cubic=Keyword_Set(cubic)) < img)

         depth_fac(0) = ((1.0 - (kf / z_max)) * depth_q * max_vol)
         img = img > ((Interpolate(vol, indx, indy, indz, Missing=min_img, $
                                   cubic=Keyword_Set(cubic)) > $
            depth_fac(0)) - depth_fac(0))
      ENDIF ELSE BEGIN ; *** Something in the way.
         IF (count GE 1L) THEN BEGIN ; *** Something new in front.
            IF (block_out) THEN BEGIN
               temp_img = $
                  Interpolate(opaque, indx, indy, indz, Missing=min_img, $
                              cubic=Keyword_Set(cubic)) < img
               img(z_ind) = img(z_ind) - temp_img(z_ind)
            ENDIF

            depth_fac(0) = ((1.0 - (kf / z_max)) * depth_q * max_vol)
            temp_img = $
               (Interpolate(vol, indx, indy, indz, Missing=min_img, $
                            cubic=Keyword_Set(cubic)) > $
               depth_fac(0)) - depth_fac(0)
            img(z_ind) = img(z_ind) > temp_img(z_ind)
         ENDIF ; *** Nothing new in front.
      ENDELSE
   ENDFOR
ENDIF ELSE BEGIN ; *** Don't use Z-Buffer.
   IF Keyword_Set(avg_intensity) THEN img = Fltarr(x_sample, y_sample) $
   ELSE BEGIN
      CASE vol_type OF
         2: img = Intarr(x_sample, y_sample)
         3: img = Lonarr(x_sample, y_sample)
         4: img = Dblarr(x_sample, y_sample)
         5: img = Fltarr(x_sample, y_sample)
         6: img = Complexarr(x_sample, y_sample)
      ELSE: img = Bytarr(x_sample, y_sample)
      ENDCASE
   ENDELSE

   min_img = img(0)
   depth_fac = img(0)

   ; *** Do the projection.

   FOR k=0L, z_sample_m1 DO BEGIN
      kf = Float(k)
      z_pos = (kf * !Z.S(1)) + !Z.S(0)

      index = [[x_ind(*)], [y_ind(*)], $
         [replicate(z_pos, xy_sample)], [replicate(1.0, xy_sample)]] # trans

      indx = Float(size_vol(1)) * index(*, 0) / index(*, 3)
      indy = Float(size_vol(2)) * index(*, 1) / index(*, 3)
      indz = Float(size_vol(3)) * index(*, 2) / index(*, 3)

      IF (block_out) THEN $
         img = img - $
         (Interpolate(opaque, indx, indy, indz, Missing=min_img, $
                      cubic=Keyword_Set(cubic)) < img)

      depth_fac(0) = ((1.0 - (kf / z_max)) * depth_q * max_vol)
      IF Keyword_Set(avg_intensity) THEN $
         img = img + (((Interpolate(vol, indx, indy, indz, Missing=min_img, $
                        cubic=Keyword_Set(cubic)) > $
            depth_fac(0)) - depth_fac(0)) / zf_sample) $
      ELSE $
         img = img > ((Interpolate(vol, indx, indy, indz, Missing=min_img, $
                       cubic=Keyword_Set(cubic)) > $
            depth_fac(0)) - depth_fac(0))
   ENDFOR
   IF Keyword_Set(avg_intensity) THEN BEGIN
      CASE vol_type OF
         2: img = Fix(img)
         3: img = Long(img)
         4: img = Double(img)
         5: img = Float(img)
         6: img = Complex(img)
      ELSE: img = Byte(img)
      ENDCASE
   ENDIF
ENDELSE

IF ((xsize NE x_sample) OR (ysize NE y_sample)) THEN $
  img = Congrid(img, xsize, ysize, /Interp, /Minus_One)

RETURN, img
END
; $Id: psafm.pro,v 1.2 1993/10/18 16:21:56 doug Exp $

;+
; NAME:
;	PSAFM
;
; PURPOSE:
;	Given an Abobe Font metric file, this procedure generates an AFM
;	file in the format that IDL likes. This new file differs from the
;	original in the following ways:
;
;		[] Information not used by IDL is removed.
;		[] AFM files with the AdobeStandardEncoding are
;		   supplemented with an ISOLatin1Encoding.
;
; CATEGORY:
;	Misc., PostScript, Fonts
;
; CALLING SEQUENCE:
;	PSAFM, input_filename, output_filename
;
; INPUTS:
;	Input_Filename:	 Name of existing AFM file from Adobe.
;	Output_FIlename: Name of new AFM file to be created.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Generates an output file.
;
; MODIFICATION HISTORY:
;	8 January 1993, Written by AB, RSI.
;-
;
;

function PSAFM_ISOMAP
; Generate a table mapping character index to font name. Unmapped indices are
; represented by a null string.

  iso_map = strarr(256)

  ; These assignments were taken from the "PostScript Language Reference
  ; Manual" Second edition, Section E.5, "Standard Roman Character Set".
  ; To make trouble shooting easier, the assignments are in the same order as
  ; the book. Comparing the results of these assignments to the table in
  ; Section 7, "ISOLatin1Encoding Vector" reveals a few missing characters.
  ; These were derived by comparing the graphic in the twop sections. These
  ; extra assignments are at the end.
  iso_map('101'o) = 'A'
  iso_map('306'o) = 'AE'
  iso_map('301'o) = 'Aacute'
  iso_map('302'o) = 'Acircumflex'
  iso_map('304'o) = 'Adieresis'
  iso_map('300'o) = 'Agrave'
  iso_map('305'o) = 'Aring'
  iso_map('303'o) = 'Atilde'
  iso_map('102'o) = 'B'
  iso_map('103'o) = 'C'
  iso_map('307'o) = 'Ccedilla'
  iso_map('104'o) = 'D'
  iso_map('105'o) = 'E'
  iso_map('311'o) = 'Eacute'
  iso_map('312'o) = 'Ecircumflex'
  iso_map('313'o) = 'Edieresis'
  iso_map('310'o) = 'Egrave'
  iso_map('320'o) = 'Eth'
  iso_map('106'o) = 'F'
  iso_map('107'o) = 'G'
  iso_map('110'o) = 'H'
  iso_map('111'o) = 'I'
  iso_map('315'o) = 'Iacute'
  iso_map('316'o) = 'Icircumflex'
  iso_map('317'o) = 'Idieresis'
  iso_map('314'o) = 'Igrave'
  iso_map('112'o) = 'J'
  iso_map('113'o) = 'K'
  iso_map('114'o) = 'L'
  iso_map('115'o) = 'M'
  iso_map('116'o) = 'N'
  iso_map('321'o) = 'Ntilde'
  iso_map('117'o) = 'O'
  iso_map('323'o) = 'Oacute'
  iso_map('324'o) = 'Ocircumflex'
  iso_map('326'o) = 'Odieresis'
  iso_map('322'o) = 'Ograve'
  iso_map('330'o) = 'Oslash'
  iso_map('325'o) = 'Otilde'
  iso_map('120'o) = 'P'
  iso_map('121'o) = 'Q'
  iso_map('122'o) = 'R'
  iso_map('123'o) = 'S'
  iso_map('124'o) = 'T'
  iso_map('336'o) = 'Thorn'
  iso_map('125'o) = 'U'
  iso_map('332'o) = 'Uacute'
  iso_map('333'o) = 'Ucircumflex'
  iso_map('334'o) = 'Udieresis'
  iso_map('331'o) = 'Ugrave'
  iso_map('126'o) = 'V'
  iso_map('127'o) = 'W'
  iso_map('130'o) = 'X'
  iso_map('131'o) = 'Y'
  iso_map('335'o) = 'Yacute'
  iso_map('132'o) = 'Z'
  iso_map('141'o) = 'a'
  iso_map('341'o) = 'aacute'
  iso_map('342'o) = 'acircumflex'
  iso_map('222'o) = 'acute'
  iso_map('264'o) = 'acute'
  iso_map('344'o) = 'adieresis'
  iso_map('346'o) = 'ae'
  iso_map('340'o) = 'agrave'
  iso_map('46'o) = 'ampersand'
  iso_map('345'o) = 'aring'
  iso_map('136'o) = 'asciicircum'
  iso_map('176'o) = 'asciitilde'
  iso_map('52'o) = 'asterisk'
  iso_map('100'o) = 'at'
  iso_map('343'o) = 'atilde'
  iso_map('142'o) = 'b'
  iso_map('134'o) = 'backslash'
  iso_map('174'o) = 'bar'
  iso_map('173'o) = 'braceleft'
  iso_map('175'o) = 'braceright'
  iso_map('133'o) = 'bracketleft'
  iso_map('135'o) = 'bracketright'
  iso_map('226'o) = 'breve'
  iso_map('246'o) = 'brokenbar'
  iso_map('143'o) = 'c'
  iso_map('237'o) = 'caron'
  iso_map('347'o) = 'ccedilla'
  iso_map('270'o) = 'cedilla'
  iso_map('242'o) = 'cent'
  iso_map('223'o) = 'circumflex'
  iso_map('72'o) = 'colon'
  iso_map('54'o) = 'comma'
  iso_map('251'o) = 'copyright'
  iso_map('244'o) = 'currency'
  iso_map('144'o) = 'd'
  iso_map('260'o) = 'degree'
  iso_map('250'o) = 'dieresis'
  iso_map('367'o) = 'divide'
  iso_map('44'o) = 'dollar'
  iso_map('227'o) = 'dotaccent'
  iso_map('220'o) = 'dotlessi'
  iso_map('145'o) = 'e'
  iso_map('351'o) = 'eacute'
  iso_map('352'o) = 'ecircumflex'
  iso_map('353'o) = 'edieresis'
  iso_map('350'o) = 'egrave'
  iso_map('70'o) = 'eight'
  iso_map('75'o) = 'equal'
  iso_map('360'o) = 'eth'
  iso_map('41'o) = 'exclam'
  iso_map('241'o) = 'exclamdown'
  iso_map('146'o) = 'f'
  iso_map('65'o) = 'five'
  iso_map('64'o) = 'four'
  iso_map('147'o) = 'g'
  iso_map('337'o) = 'germandbls'
  iso_map('221'o) = 'grave'
  iso_map('76'o) = 'greater'
  iso_map('253'o) = 'guillemotleft'
  iso_map('273'o) = 'guillemotright'
  iso_map('150'o) = 'h'
  iso_map('235'o) = 'hungarumlaut'
  iso_map('255'o) = 'hyphen'
  iso_map('151'o) = 'i'
  iso_map('355'o) = 'iacute'
  iso_map('356'o) = 'icircumflex'
  iso_map('357'o) = 'idieresis'
  iso_map('354'o) = 'igrave'
  iso_map('152'o) = 'j'
  iso_map('153'o) = 'k'
  iso_map('154'o) = 'l'
  iso_map('74'o) = 'less'
  iso_map('254'o) = 'logicalnot'
  iso_map('155'o) = 'm'
  iso_map('257'o) = 'macron'
  iso_map('55'o) = 'minus'
  iso_map('265'o) = 'mu'
  iso_map('327'o) = 'multiply'
  iso_map('156'o) = 'n'
  iso_map('71'o) = 'nine'
  iso_map('361'o) = 'ntilde'
  iso_map('43'o) = 'numbersign'
  iso_map('157'o) = 'o'
  iso_map('363'o) = 'oacute'
  iso_map('364'o) = 'ocircumflex'
  iso_map('366'o) = 'odieresis'
  iso_map('236'o) = 'ogonek'
  iso_map('362'o) = 'ograve'
  iso_map('61'o) = 'one'
  iso_map('275'o) = 'onehalf'
  iso_map('274'o) = 'onequarter'
  iso_map('271'o) = 'onesuperior'
  iso_map('252'o) = 'ordfeminine'
  iso_map('272'o) = 'ordmasculine'
  iso_map('370'o) = 'oslash'
  iso_map('365'o) = 'otilde'
  iso_map('160'o) = 'p'
  iso_map('266'o) = 'paragraph'
  iso_map('50'o) = 'parenleft'
  iso_map('51'o) = 'parenright'
  iso_map('45'o) = 'percent'
  iso_map('56'o) = 'period'
  iso_map('267'o) = 'periodcentered'
  iso_map('53'o) = 'plus'
  iso_map('261'o) = 'plusminus'
  iso_map('161'o) = 'q'
  iso_map('77'o) = 'question'
  iso_map('277'o) = 'questiondown'
  iso_map('42'o) = 'quotedbl'
  iso_map('140'o) = 'quoteleft'
  iso_map('47'o) = 'quoteright'
  iso_map('162'o) = 'r'
  iso_map('256'o) = 'registered'
  iso_map('232'o) = 'ring'
  iso_map('163'o) = 's'
  iso_map('247'o) = 'section'
  iso_map('73'o) = 'semicolon'
  iso_map('67'o) = 'seven'
  iso_map('66'o) = 'six'
  iso_map('57'o) = 'slash'
  iso_map('40'o) = 'space'
  iso_map('243'o) = 'sterling'
  iso_map('164'o) = 't'
  iso_map('376'o) = 'thorn'
  iso_map('63'o) = 'three'
  iso_map('276'o) = 'threequarters'
  iso_map('263'o) = 'threesuperior'
  iso_map('224'o) = 'tilde'
  iso_map('62'o) = 'two'
  iso_map('262'o) = 'twosuperior'
  iso_map('165'o) = 'u'
  iso_map('372'o) = 'uacute'
  iso_map('373'o) = 'ucircumflex'
  iso_map('374'o) = 'udieresis'
  iso_map('371'o) = 'ugrave'
  iso_map('137'o) = 'underscore'
  iso_map('166'o) = 'v'
  iso_map('167'o) = 'w'
  iso_map('170'o) = 'x'
  iso_map('171'o) = 'y'
  iso_map('375'o) = 'yacute'
  iso_map('377'o) = 'ydieresis'
  iso_map('245'o) = 'yen'
  iso_map('172'o) = 'z'
  iso_map('60'o) = 'zero'

  ; Extra assignments from Section 7.
  iso_map('225'o) = 'macron'
  iso_map('230'o) = 'dieresis'
  iso_map('233'o) = 'cedilla'
  iso_map('240'o) = 'space'

  return, iso_map
end







PRO PSAFM, input_file, output_file
;  on_error, 2		; Return to caller if an error occurs
  do_iso_encoding = 0
  iso_map = PSAFM_ISOMAP()
  iso_lines = strarr(256)
  message,/INFO,'Processing ' + input_file


  openr, in, input_file, /GET_LUN
  openw, out, output_file, /GET_LUN

  printf,out,'Comment This file was generated by PSAFM.PRO for use by IDL'
  printf,out,'Comment on ', systime(0), '. It may not work properly with'
  printf,out,'Comment other software because it does not contain the complete'
  printf,out,'Comment contents of the original file and some features are different.'
  printf, out, 'Comment'

  line = ''
  while not eof(in) do begin
    readf, in, line
    token = strcompress(line)
    i = strpos(line, ' ')
    if (i ne -1) then token = strmid(token, 0, i)
    case token of
	'Comment': do_verbatim = ((strpos(line, 'Copyright') ne -1) $
		                  or (strpos(line, 'Creation') ne -1))
	'EncodingScheme': begin
		do_verbatim = 1
		if (strpos(line,'AdobeStandardEncoding') ne -1) then $
		    do_iso_encoding = 1
		end
	'FontName': do_verbatim =1
	'FullName': do_verbatim =1
        'StartCharMetrics': do_verbatim =1
	'EndCharMetrics': do_verbatim =1
	'StartFontMetrics': do_verbatim = 1
	'C': begin
	    do_verbatim = long(strmid(line, 2, 10000)) ne -1
	    ; Get name and match against ISO mapping.
	    i = strpos(line, '; N ')
	    if (i ne -1) then begin
	      name = strmid(line, i+4, 1000)
	      i = strpos(name, ' ;')
	      if (i ne -1) then name = strmid(name, 0, i)
	      tmp = where(iso_map eq name, i)
	      for count=0,i-1 do begin
		iso_lines(tmp(count)) = $
		  string(tmp(count),strmid(line, strpos(line, ';'), 1000), $
			format='("C ", I0, X, A)')
	      endfor
	    endif
	    end
        else: do_verbatim = 0
    endcase
    if (do_verbatim) then printf, out, line
  endwhile

  if (do_iso_encoding) then begin
    printf, out, 'Comment'
    printf, out, 'Comment A real Adobe AFM file wouldn''t have a second'
    printf, out, 'Comment encoding here. However, having this reduces the'
    printf, out, 'Comment runtime load when switching fonts.'
    printf, out, 'Comment'
    printf, out, 'EncodingScheme ISOLatin1Encoding'
    printf, out, 'StartCharMetrics'
    for i = 0, 255 do begin
	if (iso_lines(i) ne '') then begin
	    printf, out, iso_lines(i)
	endif else if (iso_map(i) ne '') then begin
	    print,format='("    Unmapped ISO character: ", A, "(",O0,")")', $
		iso_map(i), i
	endif
    endfor
    printf, out, 'EndCharMetrics'
  endif

  printf, out, 'EndFontMetrics'

  FREE_LUN, in, out
end
; $Id: pseudo.pro,v 1.3 1994/10/27 18:32:20 mattr Exp $

PRO	PSEUDO,LITLO,LITHI,SATLO,SATHI,HUE,LOOPS,COLR
;+
; NAME:
;	PSEUDO
;
; PURPOSE:
;	Generate a pseudo-color table based on the LHB,
;	(lightness, hue, and brightness) system and load it.
;
; CATEGORY:
;	Z4 - Image processing, color table manipulation.
;
; CALLING SEQUENCE:
;	PSEUDO, Litlo, Lithi, Satlo, Sathi, Hue, Loops [, Colr]
;
; INPUTS:
;	Litlo:	Starting lightness, from 0 to 100%.
;
;	Lithi:	Ending lightness, from 0 to 100%.
;
;	Satlo:	Starting saturation, from 0 to 100%.
;
;	Sathi:	Ending saturation, from 0 to 100%.
;
;	Hue:	Starting hue, in degrees, from 0 to 360.
;
;	Loops:	The number of loops of hue to make in the color helix.
;		This value can range from 0 to around 3 to 5 and it need
;		not be an integer.
;
; OUTPUTS:
;	No required outputs.
;
; OPTIONAL OUTPUT PARAMETERS:
;	Colr:	A (256,3) integer array containing the red, green, and 
;		blue color values that were loaded into the color lookup 
;		tables.  Red = COLR(*,0), Green = COLR(*,1), Blue = COLR(*,1).
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Color tables are loaded.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	This procedure generates a pseudo-color table and loads the red,
;	green, and blue LUTS with the table.  The pseudo-color mapping 
;	used is generated by first translating from the LHB (lightness, 
;	hue, and brightness) coordinate system to the LAB coordinate 
;	system, finding N colors spread out along a helix that spans
;	this LAB space (supposedly a near maximal entropy mapping for 
;	the eye, given a particular N) and remapping back into the RGB
;	space (red, green, and blue color space).  Thus, given N desired 
;	colors, the output will be N discrete values loaded into the
;	red LUTs, N discrete values loaded into the blue LUTs, and N
;	discrete values loaded into the green LUTs. 
;   
; MODIFICATION HISTORY:
;	Adapted from the IIS primitive DPSEU. DMS, Nov, 1982.
;	Changed common, DMS, Apr, 1987.
;       MWR:  9/13/94 - The cur_* variables in common block need to be non-zero
;                       for use with other routines (e.g. XPALETTE).
;       MWR: 10/27/94 - Changed common block variable names to comply with
;                       naming convention used by other IDL routines.
;-   
        COMMON colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
	ON_ERROR,2                      ;Return to caller if an error occurs
	GAMINV=1./2.			;Gamma correction, was 1/2.7
	DTOR = .017452393		;Degs to radians
;
;		conversion matrix from x-y-z to r-g-b color coordinates
	CVT = [[2.58,-1.09,.125],[-1.15,2.04,-.295],[-.422,.058,1.17]]
;
	ZSTEP = FINDGEN(256)		;From 0 to 255.
	X = ZSTEP/(255./2.) - 1.	;From -1 to +1
	S = (SATHI-SATLO) * ( 1. -X*X) + SATLO	;Saturation
	H = (HUE + ZSTEP*(LOOPS*360./256.))*DTOR ;Hue in radians
;			Into Lab coords from Lsh.
	A = S*COS(H)
	B = S * SIN(H)
	L = (LITHI-LITLO)/255. * ZSTEP + LITLO	;Liteness
;		Cvt from LAB to XYZ coordinates.
	T = (L + 16.)/116.
	X = (A/500. + T) ^ 3		;Into X-Y-Z space from L-a-b
	Y = T^3
	Z = (T - B/200.) ^ 3
;		Cvt from XYZ to RGB.
	COLR = FIX(([[X],[Y],[Z]] # CVT > 0. < 1.) ^ GAMINV * 255.)
;               Save the colors in the common block
	r_orig = colr(*,0) & g_orig = colr(*,1) & b_orig=colr(*,2)
        r_curr = r_orig & g_curr = g_orig & b_curr = b_orig
	tvlct,r_orig,g_orig,b_orig
	RETURN
END

; $Id: ps_show_fonts.pro,v 1.3 1993/10/18 16:16:26 doug Exp $

;+
; NAME:
;	PS_SHOW_FONTS
;
; PURPOSE:
;	This procedure displays all the PostScript fonts that IDL knows
;	about, with both the StandardAdobe and ISOLatin1 encodings. Each
;	display takes a separate page, and each character in each font
;	is shown with its character index.
;
; CATEGORY:
;	Misc., PostScript, Fonts.
;
; CALLING SEQUENCE:
;	PS_SHOW_FONTS
;
; INPUTS:
;	None.
;
; KEYWORDS:
;	NOLATIN: If set, do NOT output ISOLatin1 encodings.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A PostScript file is produced, one page per font/mapping combination.
;
; RESTRICTIONS:
;	The output file contains almost 70 pages of output. A PostScript
;	previewer is recommended rather than sending it to a printer.
;
; MODIFICATION HISTORY:
;	12 January 1993, AB, RSI.
;	12 October 1993, Rob Montgomery, NCAR - added 'nolatin' keyword.
;-

PRO PS_SHOFONT, font_kw
; Display the font selected by applying font_kw to the DEVICE
; procedure.

  on_error, 2		; Return to caller if an error occurs

  message,/info,font_kw

  DEVICE,ysize=9, yoffset=1, xsize=7, xoffset=.75, /inch, /COURIER
  xyouts, !d.x_size/2, !d.y_size+1000, align=.5, /dev, font_kw, font=0

  ; Lay the characters and indices out in separate passes to minimize
  ; font switching.

  junk = execute('DEVICE,'+font_kw)
  row = 25
  col = 0
  xstep = 1./10.
  ystep = 1./26.0
  for ch = 1, 255 do begin
    s = string(byte(ch))
    if (s eq '!') then s = '!!'
    xyouts, .075 + col * xstep, row*ystep, /norm, font=0, charsize=2.0, s
    if (col eq 9) then begin
      col = 0
      row = row - 1
    endif else col = col + 1
  endfor

  row = 25
  col = 0
  xstep = 1./10.
  ystep = 1./26.0
  yoff=ystep * .1
  for ch = 1, 255 do begin
    xyouts, .12 + col * xstep, row*ystep-yoff, /norm, font=0, charsize=.5, $
	string(ch,format='(I0)')
    if (col eq 9) then begin
      col = 0
      row = row - 1
    endif else col = col + 1
  endfor

  erase
END







pro ps_show_fonts, nolatin=nolatin
;	Display all of the fonts with and without ISO encodings.

  on_error, 2		; Return to caller if an error occurs
  olddev = !d.name
  set_plot,'ps'

  for i = 0, (1 - keyword_set(nolatin)) do begin

    lat = ',ISOLATIN1=' + strcompress(string(i), /remove_all)

    ps_shofont, '/COURIER'				+ lat
    ps_shofont, '/COURIER,/BOLD'			+ lat
    ps_shofont, '/COURIER,/OBLIQUE'			+ lat
    ps_shofont, '/COURIER,/BOLD,/OBLIQUE'		+ lat
    ps_shofont, '/HELVETICA'				+ lat
    ps_shofont, '/HELVETICA,/BOLD'			+ lat
    ps_shofont, '/HELVETICA,/OBLIQU'			+ lat
    ps_shofont, '/HELVETICA,/BOLD,/OBLIQU'		+ lat
    ps_shofont, '/HELVETICA,/NARROW'			+ lat
    ps_shofont, '/HELVETICA,/NARROW,/BOLD'		+ lat
    ps_shofont, '/HELVETICA,/NARROW,/OBLIQUE'		+ lat
    ps_shofont, '/HELVETICA,/NARROW,/BOLD,/OBLIQUE'	+ lat
    ps_shofont, '/AVANTGARDE,/BOOK'			+ lat
    ps_shofont, '/AVANTGARDE,/BOOK,/OBLIQUE'		+ lat
    ps_shofont, '/AVANTGARDE,/DEMI'			+ lat
    ps_shofont, '/AVANTGARDE,/DEMI,/OBLIQUE'		+ lat
    ps_shofont, '/BKMAN,/DEMI'				+ lat
    ps_shofont, '/BKMAN,/DEMI,/ITALIC'			+ lat
    ps_shofont, '/BKMAN,/LIGHT'				+ lat
    ps_shofont, '/BKMAN,/LIGHT,/ITALIC'			+ lat
    ps_shofont, '/ZAPFCHANCERY,/MEDIUM,/ITALIC'		+ lat
    ps_shofont, '/SCHOOLBOOK'				+ lat
    ps_shofont, '/SCHOOLBOOK,/BOLD'			+ lat
    ps_shofont, '/SCHOOLBOOK,/ITALIC'			+ lat
    ps_shofont, '/SCHOOLBOOK,/BOLD,/ITALIC'		+ lat
    ps_shofont, '/PALATINO'				+ lat
    ps_shofont, '/PALATINO,/BOLD'			+ lat
    ps_shofont, '/PALATINO,/ITALIC'			+ lat
    ps_shofont, '/PALATINO,/BOLD,/ITALIC'		+ lat
    ps_shofont, '/TIMES'				+ lat
    ps_shofont, '/TIMES,/BOLD'				+ lat
    ps_shofont, '/TIMES,/ITALIC'			+ lat
    ps_shofont, '/TIMES,/BOLD,/ITALIC'			+ lat
  endfor

  ps_shofont,'/SYMBOL'
  ps_shofont,'/ZAPFDINGBATS'
  
  DEVICE,/CLOSE
  set_plot,olddev
end
; $Id: pushd.pro,v 1.2 1994/01/03 22:26:00 doug Exp $

;+
; NAME:
;	PUSHD
;
; PURPOSE:
;	Push a directory onto the top of the directory stack maintained
;	by the PUSHD and POPD User Library procedures.
;
; CALLING SEQUENCE:
;	PUSHD, Dir
;
; INPUTS:
;	Dir:	The directory to change to. The current directory will
;		be pushed to the top of the directory stack.
;
; SIDE EFFECTS:
;	The current directory is pushed onto the directory stack.
;	It will be the next directory used by POPD.
;
; COMMON BLOCKS:
;	DIR_STACK:  Contains the stack.
;
; MODIFICATION HISTORY:
;	17, July, 1989, Written by AB, RSI.
;-
;
;
pro pushd,dir

COMMON DIR_STACK, DEPTH, STACK
on_error, 2		; Return to caller on error

if (n_elements(DEPTH) eq 0) then depth = 0
CD, dir, CURRENT=cwd

if (DEPTH eq 0) then STACK = [CWD] else STACK = [CWD, STACK]
DEPTH = DEPTH + 1
end
;$Id: ranks.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       RANKS
;
; PURPOSE:
;       This function computes the magnitude-based ranks of a sample 
;       population X. Elements of identical magnitude "ties" are ranked 
;       according to the mean of the ranks that would otherwise be assigned.
;       The result is a vector of ranks equal in length to X.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = Ranks(X)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;             The elements of this vector must be in ascending order
;             based on their magnitude.
;
; EXAMPLE:
;       Define an n-element sample population.
;         x = [-0.8, 0.1, -2.3, -0.6, 0.2, 1.1, -0.3, 0.6, -0.2, 1.1, -0.7, $
;              -0.2, 0.6, 0.4, -0.1, 1.1, -0.3, 0.3, -1.3, 1.1]
;
;       Allocate a two-column, n-row array to store the results.
;         array = fltarr(2, n_elements(x))
;
;       Sort the sample population and store in the 0th column of ARRAY.
;         array(0, *) = x(sort(x))
;
;       Compute the ranks of the sorted sample population and store in the 
;       1st column of ARRAY.
;         array(1, *) = ranks(x(sort(x)))
;
;       Display the sorted sample population and corresponding ranks with a 
;       two-decimal format.
;         print, array, format = '(2(5x, f5.2))'
;       
;       The result should be:
;         -2.30      1.00
;         -1.30      2.00
;         -0.80      3.00
;         -0.70      4.00
;         -0.60      5.00
;         -0.30      6.50
;         -0.30      6.50
;         -0.20      8.50
;         -0.20      8.50
;         -0.10     10.00
;          0.10     11.00
;          0.20     12.00
;          0.30     13.00
;          0.40     14.00
;          0.60     15.50
;          0.60     15.50
;          1.10     18.50
;          1.10     18.50
;          1.10     18.50
;          1.10     18.50
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, November 1994
;-

function ranks, x

  on_error, 2

  nx = n_elements(x)
  r_vec = [0.0, x] 
  k = 1L
  while(k lt nx) do begin
    if(r_vec(k+1) ne r_vec(k)) then begin
      r_vec(k) = k
      k = k+1
    endif else begin
      for kt = k+1, nx do $
        if (r_vec(kt) ne r_vec(k)) then goto, midrank
      kt = nx + 1
      midrank:
      rank = 0.5 * (k + kt - 1)
      for ki = k, kt-1 do $
        r_vec(ki) = rank
      t = kt - k
      k = kt
    endelse
  endwhile
  if(k eq nx) then r_vec(nx) = nx

  return, r_vec(1:*)

end
;$Id: r_correlate.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       R_CORRELATE
;
; PURPOSE:
;       This function computes Spearman's (rho) or Kendalls's (tau) rank 
;       correlation of two n-element vectors. The result is a two-element 
;       vector containing the rank correlation coefficient and the two-sided 
;       significance level of its deviation from zero.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = R_correlate(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An n-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
; KENDALL:    If set to a nonzero value, Kendalls's (tau) rank correlation
;             is computed. By default, Spearman's (rho) rank correlation is
;             computed.
;
;       D:    Use this keyword to specify a named variable which returns the 
;             sum-squared difference of ranks. If the KENDALL keyword is set
;             to a nonzero value, this parameter is returned as zero.
;
;      ZD:    Use this keyword to specify a named variable which returns the 
;             number of standard deviations by which D deviates from its null-
;             hypothesis expected value. If the KENDALL keyword is set to a
;             nonzero value, this parameter is returned as zero.
;
;   PROBD:    Use this keyword to specify a named variable which returns the 
;             two-sided significance level of ZD. If the KENDALL keyword is 
;             set to a nonzero value, this parameter is returned as zero.
;
; EXAMPLE
;       Define two n-element vectors of tabulated data.
;         x = [257, 208, 296, 324, 240, 246, 267, 311, 324, 323, 263, 305, $
;              270, 260, 251, 275, 288, 242, 304, 267]
;         y = [201, 56, 185, 221, 165, 161, 182, 239, 278, 243, 197, 271, $
;              214, 216, 175, 192, 208, 150, 281, 196]
;
;       Compute Spearman's (rho) rank correlation of x and y.
;         result = r_correlate(x, y, d = d, zd = zd, probd = probd)
;       The result should be the two-element vector:
;         [0.835967, 4.42899e-06]
;       The keyword parameters should be returned as:
;         d = 218.000, zd = -3.64390, probd = 0.000268542      
;
;       Compute Kendalls's (tau) rank correlation of x and y.
;         result = r_correlate(x, y, /kendall)
;       The result should be the two-element vector:
;         [0.624347  0.000118732]
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, Aug 1994
;                    R_CORRELATE is based on the routines spear.c and kendl1.c
;                    described in section 14.6 of Numerical Recipes, The Art 
;                    of Scientific Computing (Second Edition), and is used by 
;                    permission.
;-

function betacf, a, b, x
  on_error, 2
  eps   = 3.0e-7
  fpmin = 1.0e-30
  maxit = 100
  qab = a + b
  qap = a + 1.0
  qam = a - 1.0
    c = 1.0
    d = 1.0 - qab * x / qap
  if(abs(d) lt fpmin) then d = fpmin
  d = 1.0 / d
  h = d
  for m = 1, maxit do begin
    m2 = 2 * m
    aa = m * (b - m) * x / ((qam + m2) * (a + m2))
     d = 1.0 + aa*d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     h = h * d * c
     aa = -(a + m) *(qab + m) * x/((a + m2) * (qap + m2))
     d = 1.0 + aa * d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     del = d * c
     h = h * del
     if(abs(del - 1.0) lt eps) then return, h
  endfor
  message, 'Failed to converge within given parameters.'
end

function gammln, xx
  coff = [76.18009172947146d0,   -86.50532032941677d0,  $
          24.01409824083091d0,    -1.231739572450155d0, $
           0.1208650973866179d-2, -0.5395239384953d-5]
  stp = 2.5066282746310005d0
  x = xx
  y = x
  tmp = x + 5.5d0
  tmp = (x + 0.5d0) * alog(tmp) - tmp
  ser = 1.000000000190015d0
  for j = 0, n_elements(coff)-1 do begin
    y = y + 1.d0
    ser = ser + coff(j) / y
  endfor
  return, tmp + alog(stp * ser / x)
end

function ibeta, a, b, x
  on_error, 2
  if (x lt 0 or x gt 1) then message, $
    'x must be in the interval [0, 1].'
  if (x eq 0  or x eq 1) then bt = 0.0 $
  else $
    bt = exp(gammln(a + b) - gammln(a) - gammln(b) + $
             a * alog(x) + b * alog(1.0 - x))
  if(x lt (a + 1.0)/(a + b + 2.0)) then return, $
    bt * betacf(a, b, x) / a $
  else return, 1.0 - bt * betacf(b, a, 1.0-x) / b
end

pro crank, w, s
  n = n_elements(w)
  w = [0.0, w]  ;operate on elements w(1), ... , w(n) of the
                ;n+1 element float array, w.
  s = 0.0
  j = 1
  while(j lt n) do begin
    if(w(j+1) ne w(j)) then begin
      w(j) = j
      j = j+1
    endif else begin
      for jt = j+1, n do begin
        if (w(jt) ne w(j)) then goto, case2
      endfor
      jt = n + 1
      case2:
      rank = 0.5 * (j + jt - 1)
      for ji = j, jt-1 do $
        w(ji) = rank
      t = jt - j
      s = s + t^3 - t
      j = jt
    endelse
  endwhile
  if(j eq n) then w(n) = n
  w = w(1:*)
end

function erfcc, x
  z = abs(x)
  t = 1.0 / (1.0 + 0.5 * z)
  erfc = t*exp(-z*z-1.26551223+t*(1.00002368+t*(.37409196+t* $
         (.09678418+t*(-.18628806+t*(.27886807+t*(-1.13520398+t* $
         (1.48851587+t*(-.82215223+t*.17087277)))))))))
  if x lt 0 then return, 2.0 - erfc $
  else return, erfc
end

function r_correlate, x, y, kendall = kendall, d = d, zd = zd, probd = probd

  on_error, 2
  nx = n_elements(x)
  if nx le 1 or n_elements(y) le 1 then $
    message, 'x and y must be n-element vectors.'
  if nx ne n_elements(y) then $
    message, 'x and y must be vectors of equal length.'

  if keyword_set(kendall) eq 0 then begin ;Spearman's (rho)
    type = size(x)
    wrkx = x
    wrky = y
    ixy  = sort(wrkx) ;Indexes of "wrkx" in ascending order. 
    wrkx = wrkx(ixy)  ;Rearrangement of "wrkx" according to ixy.
    wrky = wrky(ixy)  ;Rearrangement of "wrky" according to ixy.
    crank, wrkx, sf   ;Replace elements of "wrkx" by their rank.
    ixy  = sort(wrky) ;Indexes of "wrky" in ascending order.
    wrkx = wrkx(ixy)  ;Rearrangement of "wrkx" according to ixy.
    wrky = wrky(ixy)  ;Rearrangement of "wrky" according to ixy.
    crank, wrky, sg   ;Replace elements of "wrky" by their rank.
    d = total((wrkx-wrky)^2)
    ;Free intermediate variables.
    wrkx = 0
    wrky = 0
    ixy = 0
    en = nx
    en3n = en^3 - en
    aved = en3n/6.0 - (sf + sg)/12.0
    fac = (1.0 - sf/en3n) * (1.0 - sg/en3n)
    vard = ((en - 1.0) * en^2 * (en + 1.0)^2 / 36.0) * fac
    zd = (d - aved) / sqrt(vard)
    probd = erfcc(abs(zd)/1.4142136)
    rs = (1.0 - (6.0/en3n) * (d+(sf+sg)/12.0))/sqrt(fac)
    fac = (1.0 + rs) * (1.0 - rs)
    if (fac gt 0.0) then begin
      t = rs * sqrt((en - 2.0)/fac)
      df = en - 2
      probrs = ibeta(0.5*df, 0.5, df/(df+t^2))
    endif else probrs = 0.0
    ;Return a vector of rank-correlation parameters.
    if type(2) eq 5 then begin 
      d = d+0d & zd = zd+0d & probd = probd+0d
      return, [rs, probrs]
    endif else begin
      d = float(d) & zd = float(zd) & probd = float(probd)
      return, float([rs, probrs])
    endelse
  endif else begin ;Kendall's (tau)
    nnx = 0.0
    nny = 0.0
    is  = 0.0
    ;There seems to be no efficient method of avoiding this nested 
    ;FOR loop structure. An alternate method is possible, but requires 
    ;about (1/2 * nx^2) storage and one FOR loop.
    for j = 0, nx-2 do begin
      for k = j+1, nx-1 do begin
        dx = x(j) - x(k)
        dy = y(j) - y(k)
        aa = dx * dy
        if aa ne 0 then begin
          nnx = nnx + 1
          nny = nny + 1
          if aa gt 0 then is = is + 1 $
            else is = is - 1
        endif else begin
          if dx ne 0 then nnx = nnx + 1 $
          else if dy ne 0 then nny = nny + 1
        endelse
      endfor
    endfor
    d = 0 & zd = 0 & probd = 0 ;Keyword parameters of Spearman's (rho).
    tau = is / sqrt(nnx * nny)
    var = (4.0 * nx + 10.0) / (9.0 * nx * (nx-1.0))
      z = tau / sqrt(var)
    prob = erfcc(abs(z) / 1.4142136)
    ;prob = 1 - errorf(abs(z) / 1.4142136) ;IDL's error function
    return, [tau, prob]
  endelse

end





; $Id: rdpix.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Pro Rdpix, Image,X0, Y0	;Read the value of the pixel under the cursor
			;Display x,y and the pixel value under the cursor
;+
; NAME:
;	RDPIX
;
; PURPOSE:
;	Interactively display the X position, Y position, and pixel value 
;	of the cursor.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	RDPIX, Image [, X0, Y0]
;
; INPUTS:
;	Image:	The array that represents the image being displayed.  This 
;		array may be of any type.  Rather reading pixel values from 
;		the display, they are taken from this parameter, avoiding 
;		scaling difficulties.
;
; OPTIONAL INPUT PARAMETERS:
;	X0, Y0:	The location of the lower-left corner of the image area on
;		screen.  If these parameters are not supplied, they are
;		assumed to be zero.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The X, Y, and value of the pixel under the cursor are continuously 
;	displayed.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Instructions are printed and the pixel values are printed as the 
;	cursor is moved over the image.
;
;	Press the left or center mouse button to create a new line of output,
;	saving the previous line.
;
;	Press the right mouse button to exit the procedure.
;
; MODIFICATION HISTORY:
;	DMS, Dec, 1987.
;	Rob Montgomery (rob@hao.ucar.edu), 9/21/92;
;		Correct indices for case of !order = 1
;
;-

on_error,2              ;Return to caller if an error occurs
print,'Press left or center mouse button for new output line.'
print,'... right mouse button to exit.'
s = size(image)
if s(0) ne 2 then message, 'Image parameter not 2d.'
s(1) = s(1)-1		;To n-1
s(2) = s(2)-1
!err=0
if n_elements(x0) le 0 then x0 = 0
if n_elements(y0) le 0 then y0 = 0
if s(s(0)+1) ge 4 then form = 'F' else form = 'I'
cr = string(15b)	;this codes a newline
form="($,'x=',i4,', y=',i4,', value=',"+form+",a)"
while !err ne 4 do begin
	tvrdc,x,y,2,/dev
	if (!err and 3) ne 0 then begin	;New line?
	   print,form="($,a)",string(12b)
	   while (!err ne 0) do begin wait,.1 & tvrdc,x,y,0,/dev & end
	  endif

	x = x-x0 & y = y - y0
	if (x le s(1)) and (y le s(2)) and (x ge 0) and (y ge 0) then begin
	   if (!order eq 1) then yy = s(2) - y else yy = y
	   print,form = form, x,y,Image(x,yy),cr
	endif
endwhile
print,form="(/)"
end
; $Id: read_bmp.pro,v 1.4 1994/10/10 15:38:44 dave Exp $

FUNCTION READ_BMP, File, Red, Green, Blue, Ihdr
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	READ_BMP
;
; PURPOSE:
; 	This function reads a Microsoft Windows Version 3 device
;	independent bitmap file (.BMP).
;
; CATEGORY:
;   	Input/Output
;
; CALLING SEQUENCE:
;   	Result = READ_BMP(File [, R, G, B [, IHDR]])
;
; INPUTS:
; 	File: The full path name of the bitmap file to read.
;
; OUTPUTS:
;	This function returns a byte array containing the image
;	from the bitmap file. In the case of 4-bit or 8-bit images,
;	the dimensions of the resulting array are (biWidth, biHeight);
;	for 24-bit images the dimensions are (3, biWidth, biHeight).
;	Dimensions are taken from the BITMAPINFOHEADER of the file.
;	NOTE: for 24 bit images, color interleaving is blue, green, red;
;	i.e. result(0,i,j) = blue, result(1,i,j) = green, etc.
;
; OPTIONAL OUTPUTS:
;   	R, G, B:  Color tables from the file. There 16 elements each for
;		  4 bit images, 256 elements each for 8 bit images. Not
;		  defined or used for 24 bit images.
;  	Ihdr:	  A structure containing BITMAPINFOHEADER from file.
;		  Tag names are as defined in the MS Windows Programmer's
;		  Reference Manual, Chapter 7.
;
; SIDE EFFECTS:
;   	IO is performed.
;
; RESTRICTIONS:
;   	DOES NOT HANDLE: 1 bit deep images, or compressed images.
;   	Is not fast for 4 bit images. Works best on images where the
;   	number of bytes in each scan-line is evenly divisible by 4.
;
; PROCEDURE:
;   	Straightforward. Will work on both big endian and little endian
;	machines.
;
; EXAMPLE:
;   	TV, READ_BMP('c:\windows\party.bmp', r, g, b) 	;Read & display image
;   	TVLCT, r, g, b              			;Load it's colors
;
; MODIFICATION HISTORY:
;   DMS, RSI.   March 1993.   	Original version.
;   DMS, RSI.   May, 1993.	Now works on all machines...
;-

on_ioerror, bad
on_error, 2         ;Return on error

openr, unit, file, /GET_LUN, /BLOCK
fhdr = { BITMAPFILEHEADER, $
    bftype: bytarr(2), $        ;A two char string
    bfsize: 0L, $
    bfreserved1: 0, $
    bfreserved2: 0, $
    bfoffbits: 0L $
  }
readu, unit, fhdr           ;Read the bitmapfileheader
if string(fhdr.bftype) ne "BM" then $
    message, 'File '+file+' is not in bitmap file format'

ihdr = { BITMAPINFOHEADER, $
    bisize: 0L, $
    biwidth: 0L, $
    biheight: 0L, $
    biplanes: 0, $
    bibitcount: 0, $
    bicompression: 0L, $
    bisizeimage: 0L, $
    bixpelspermeter: 0L, $
    biypelspermeter: 0L, $
    biclrused: 0L, $
    biclrimportant: 0L $
  }

readu, unit, ihdr

if (byte(1,0,2))(0) eq 0b then begin	;Big endian machine?
    fhdr = swap_endian(fhdr)		;Yes, swap it
    ihdr = swap_endian(ihdr)
    endif

if ihdr.bibitcount eq 1 then $
     message, 'Can''t handle monochrome images'
if ihdr.bicompression ne 0 then $
    message, 'Can''t handle compressed images'

if ihdr.bibitcount ne 24 then begin ;Pseudo color?
    colors = bytarr(4, 2^ihdr.bibitcount)
    readu, unit, colors             ;Read colors
    red = reform(colors(2, *))        ;Decommutate colors
    green = reform(colors(1, *))
    blue = reform(colors(0, *))
    endif

nx = ihdr.biwidth
ny = ihdr.biheight

point_lun, unit, fhdr.bfoffbits     ;Point to data...

if ihdr.bibitcount eq 4 then begin  ;4 bits/pixel?
    a = bytarr(nx, ny, /nozero)
    buff = bytarr(nx/2, /nozero)   ;Line buffer
    even = lindgen(nx/2) * 2
    odd = even + 1
    if nx and 1 then pad = 0B       ;interbyte padding
    i = (n_elements(buff) + n_elements(pad)) and 3  ;bytes we have
    if i ne 0 then pad = bytarr(4-i+n_elements(pad))
    for i=0, ny-1 do begin
        if n_elements(pad) ne 0 then readu, unit, buff, pad $
        else readu, unit, buff
        a(even, i) = ishft(buff, -4)
        a(odd, i) = buff and 15b
        if nx and 1 then a(nx-1, i) = ishft(pad(0), -4) ;Last odd byte?
        endfor
endif else if ihdr.bibitcount eq 8 then begin          ;8 bits/pixel?
    a = bytarr(nx, ny, /nozero)
    if (nx and 3) eq 0 then readu, unit, a $          ;Slam dunk it
    else begin                      ;Must read line by line...
       pad = bytarr(4 - (nx and 3))
       buff = bytarr(nx, /nozero)
       for i=0, ny-1 do begin       ;Each line
           readu, unit, buff, pad
           a(0,i) = buff
           endfor
    endelse
endif else begin                    ;24 bits / pixel....
    a = bytarr(3, nx, ny, /nozero)
    if ((3 * nx) and 3) eq 0 then readu, unit, a $  ;Again, dunk it.
    else begin
        pad = bytarr(4 - ((3 * nx) and 3))
        buff = bytarr(3, nx, /nozero)
        for i=0, ny-1 do begin
            readu, unit, buff, pad
            a(0,0, i) = buff            ;Insert line
            endfor
    endelse
endelse

free_lun, unit
return, a

bad:  if n_elements(unit) gt 0 then free_lun, unit
Message, 'Can''t open (or read)' + file
return, 0
end

; $Id: read_gif.pro,v 1.3 1995/01/11 21:03:02 dave Exp $

;
;  GifReadByte
;	Read a single byte out of the given file
;
FUNCTION GifReadByte, unit
	ch	= 0b
	READU, unit, ch
	RETURN, ch
END

PRO READ_GIF, FILE, IMAGE, R, G, B
;
;+
; NAME:
;	READ_GIF
;
; PURPOSE:
;	Read the contents of a GIF format image file and return the image
;	and color table vectors (if present) in the form of IDL variables.
;
; CATEGORY:
;	Input/Output.
;
; CALLING SEQUENCE:
;	READ_GIF, File, Image [, R, G, B]
;
; INPUTS:
;	File:	Scalar string giving the name of the rasterfile to read
;
; OUTPUTS:
;	Image:	The 2D byte array to contain the image.
;
;
; OPTIONAL OUTPUT PARAMETERS:
;     R, G, B:	The variables to contain the Red, Green, and Blue color vectors
;		if the rasterfile containes colormaps.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	This routine only reads in the first image in a file (the format
;	allows many). Local colormaps are not supported.
;	Only 8 bit images are supported.
;
; EXAMPLE:
;	To open and read the GIF image file named "foo.gif" in the current
;	directory, store the image in the variable IMAGE1, and store the color
;	vectors in the variables R, G, and B, enter:
;
;		READ_GIF, "foo.gif", IMAGE1, R, G, B
;
;	To load the new color table and display the image, enter:
;
;		TVLCT, R, G, B
;		TV, IMAGE1
; 
; MODIFICATION HISTORY:
;	Written June 1992, JWG
;	Added GIF89a and interlaced format, Jan, 1995, DMS.
;	
;-
; Copyright (c) 1992, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;

;	Define GIF header (and screen descriptor)

on_error, 2		;Return to caller on errors
h	= { 	magic:bytarr(6),				$
		width_lo:0b, width_hi:0b,			$
		height_lo:0b, height_hi:0b,			$
		screen_info:0b, background:0b, reserved:0b }

OPENR, unit, file, /GET_LUN, /BLOCK, ERROR=i
if i ne 0 then message, 'Error occured opening file: '+file

READU, unit, h		;Read gif header

;	Check Magic in header: GIF87a or GIF89a.
gif	= STRING(h.magic(0:2))
vers = STRING(h.magic(3:5))

IF gif NE 'GIF' OR (vers ne '87a' and vers ne '89a') THEN BEGIN
	MESSAGE, 'File ' + file + ' is not a GIF file'
	FREE_LUN, unit		
	RETURN
ENDIF

; Allocate an array to hold the image in

width	= h.width_hi * 256 + h.width_lo
height	= h.height_hi * 256 + h.height_lo
image	= BYTARR(width, height, /NOZERO)

;	Find out how big the color map is

bits_per_pixel	= (h.screen_info AND 'F'X) + 1
color_map_size	= 2 ^ bits_per_pixel

;	Read in the colormap (optional)

IF (h.screen_info AND '80'X) NE 0 THEN BEGIN
	map	= BYTARR(3,color_map_size, /NOZERO)
	READU, unit, map
	map	= transpose(map)
	r	= map(*,0)
	g	= map(*,1)
	b	= map(*,2)
	ENDIF


;	Image header declaration

ihdr	= { 	left:0, top:0,			$	; we read this but
		iwidth:0, iheight:0,		$	; mostly we ignore
		image_info:0b }				; its content

;	Read the image description

while 1 do begin			;Read till we get a terminator
  cmd = GifReadByte(unit)		;Loop thru commands in file.
  CASE STRING(cmd) OF

';':	BEGIN				; GIF terminator (0x3b)
	FREE_LUN, unit		
	END

',':	BEGIN				; Image description (0x2c)
	READU,unit,ihdr

	; Check for file formats we don't support
	; We don't support local colormaps

	if (ihdr.image_info AND '80'X) NE 0 THEN begin  ;Local color map
	   lcolor_map_size = 2^((ihdr.image_info and 7) + 1)
	   junk = bytarr(3, lcolor_map_size, /NOZERO)
	   readu, unit, junk
	   message,'Local colormaps ignored', /CONTINUE
	   endif

	;	Now call special GIF-LZW routine hidden within IDL
	;	to do the ugly serial bit stream decoding

	DECODE_GIF,unit,image		; magic
	FREE_LUN, unit			; done

	;	Reorder rows in an interlaced image

	if (ihdr.image_info AND '40'X) NE 0 THEN BEGIN
	    l = lindgen(height)	;Row indices...
		;Giff interlace ordering
	    p = [l(where(l mod 8 eq 0)), l(where(l mod 8 eq 4)), $
		 l(where(l mod 4 eq 2)), l(where(l and 1))]
	    image2 = bytarr(width, height, /NOZERO)
	    h1 = height-1
	    for i=0, h1 do image2(0, h1-p(i)) = image(*,h1-i)
	    image = temporary(image2)
	ENDIF

	RETURN
	END

'!':	BEGIN				;Gif Extention block (ignored) (0x21)
	label = GifReadByte(unit)	;toss extension block label
	repeat begin			;read and ignore blkss
	  blk_size = GifReadByte(unit)	;block size
	  if blk_size ne 0 then begin
		junk = BYTARR(blk_size, /NOZERO)
		READU, unit, junk
		endif
	endrep until blk_size eq 0
	ENDCASE

ELSE:	message,'Unknown GIF keyword in ' + file
ENDCASE
endwhile

END
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	READ_INTERFILE
;
; PURPOSE:
;	Simplistic Interfile (v3.3) reader. Can only read a series
;	of images containing byte,int,long,float or double data where
;	all images have the same height and with.  Result is returned
;	in a 3-D array.
;
; CATEGORY:
;	Input/Output.
;
; CALLING SEQUENCE:
;	READ_INTERFILE, File, Data
;
; INPUTS:
;	File:	Scalar string containing the name of the Interfile
;		to read.  Note: if the Interfile has a header file and
;		a data file, this should be the name of the header
;		file (also called the administrative file).
;	
; OUTPUTS:
;	Data: A 3-D array of data as read from the file.  Assumed to be
;	a series of 2-D images.
;
; RESTRICTIONS:
;	This is a simplistic reader.  It does not get additional
;	keyword information above and beyond what is needed to read
;	in the image data.  If any problems occur reading the file,
;	READ_INTERFILE prints a message and stops.
;
;	If the data is stored in on a bigendian machine and read on
;	a littleendian machine (or vice versa) the order of bytes in
;	each pixel element may be reversed, requiring a call to
;	BYTEORDER
;
; PROCEDURE:
;	Generates keyword table and initializes it on the fly.
;	Read in administrative data.
;	Read in binary data.
;	Clean up keyword processing information.
;
; EXAMPLE:
;	READ_INTERFILE, '0_11.hdr', X
;
; MODIFICATION HISTORY:
; 	Written by:	J. Goldstein, Oct 1993
;
;	12/22/93 JWG,TH		Bug fixes. Added byte swapping for short data
;-

;
;  GetPath
;
FUNCTION GetPath, File, PATH=DoPath, FILE=DoFile

    Idx	= WHERE(!Version.OS EQ [ "vms", "Win32", "MacOS" ])
    Idx	= Idx(0) + 1
		;   Unix, VMS, WIN, MAC
    First	= ([ '/', ']', '\', ':'])(Idx)
    Second	= ([ '',  ':', ':', ''])(Idx)

    FileStart	= RSTRPOS(File, First)+1
    IF FileStart EQ 0 AND Second NE '' THEN $
	FileStart = RSTRPOS(File,Second)+1

    IF KEYWORD_SET(DoFile) THEN $
	RETURN, STRMID(File, FileStart, 1000)
    RETURN, STRMID(File,0,FileStart)
END

;
;  Inter_MakeInfo
;	Create keyword table entries.  Create hetergenous data by
;	EXECUTE'ing initialization strings and storing the results
;	in unrealized base widget UVALUE's.  This may seem confusing.
;	It probably is.
;
PRO Inter_MakeInfo, Info, Filename

    ;	NB. Add hash entry for faster lookup if list gets large.
    ;	E.g. FOR I=0,Info_Size-1 DO Info(i).Hash = TOTAL(BYTE(Info(i).Name))

    Entry = { IFSYM,	$
	Keyword:	"",	$
	Value:		0L,	$	; Use UVALUE to hold current value
	Default:	"",	$	; EXECUTE this to create initial value
	Handler:	"",	$	; Generic keyword processor
	Choices:	0L,	$	; If limited set of choices, these
	ChoiceInit:	"",	$	; are them
	IsArray:	0,	$	; keyword requires indexing?
	Proc:		""	$	; Special per keyword processing
    }

    ;	These are the currently supported keywords.

    DefaultDataFile	= GetPath(Filename, /FILE)

;    Info	= [ $
;	{ IFSYM, "data starting block",  0L, '0L', "INT", 0L, "", 0, "" }, $
;	{ IFSYM, "data offset in bytes", 0L, '0L', "INT", 0L, "", 0, "" }, $
;	{ IFSYM, "data compression", 0L, $
;		"'none'", "STR", 0L, "'none'", 0, "" }, $
;	{ IFSYM, "data encode", 0L, $
;		"'none'", "STR", 0L, "'none'", 0, "" }, $
;	{ IFSYM, "imagedata byte order", 0L, $
;		"'bigendian'", "STR", 0L, $
;		"[ 'bigendian','littleendian' ]", 0, "" }, $
;	{ IFSYM, "matrix size", 0L, $
;		'[0L,0L]', "INT", 0L, "", 1, "Inter_Fixed" }, $
;	{ IFSYM, "name of data file", 0L, $
;		"'"+DefaultDataFile+"'", "STR", 0L, "", 0, "" }, $
;	{ IFSYM, "number format", 0L, $
;		"'unsigned integer'", "STR", 0L, $
;		"[ 'signed integer','unsigned integer'," + $
;		  "'long float', 'short float','bit' ]", 0, "" }, $
;	{ IFSYM, "number of bytes per pixel", 0L, '0L',"INT",0L, "", 0, "" }, $
;	{ IFSYM, "total number of images", 0L, '0L', "INT", 0L, "", 0, "" } $
;    ]

    ;	Run through keywords and create initial values
    ;	and choice values if keyword has a limited set of choices

    FOR I=0,N_ELEMENTS(Info)-1 DO BEGIN

	;	Create value

	Info(I).Value	= WIDGET_BASE()
	Value		= 0
	Result		= EXECUTE("Value = " + Info(I).Default)
	IF Result NE 1 THEN MESSAGE, "Cannot initialize Info structure"
	WIDGET_CONTROL, Info(I).Value, SET_UVALUE=Value

	;	Create choices if they exist

	IF Info(I).ChoiceInit NE "" THEN BEGIN
	    Info(I).Choices	= WIDGET_BASE()
	    Value		= 0
	    Result		= EXECUTE("Value = " + Info(I).ChoiceInit)
	    IF Result NE 1 THEN MESSAGE, "Cannot initialize Info structure"
	    WIDGET_CONTROL, Info(I).Choices, SET_UVALUE=Value
	ENDIF

    ENDFOR
END

;
;  Inter_INT
;	General integer keyword processing routine
;
PRO Inter_INT, KwdInfo, Value, Arr

    Value	= LONG(Value)

    ;	limited # of chioces?  See if user has chosen a valid chioce

    IF KwdInfo.Choices NE 0 THEN BEGIN
	WIDGET_CONTROL, KwdInfo.Choices, GET_UVALUE=Choices
	Dummy	= WHERE(Value EQ Choices, Count)
	IF Count NE 1 THEN $
	    MESSAGE, 'Illegal choice of values for ' + KwdInfo.Keyword
    ENDIF

    IF KwdInfo.Proc THEN BEGIN	;	Special keyword routine?

	CALL_PROCEDURE, KwdInfo.Proc, KwdInfo, Value, Arr

    ENDIF ELSE BEGIN		;	General processing
	IF KwdInfo.IsArray THEN BEGIN
	    WIDGET_CONTROL, KwdInfo.Value, GET_UVALUE=Vals
	    Vals(Arr-1)	= Value
	ENDIF ELSE BEGIN
	    Vals	= Value
	ENDELSE

        WIDGET_CONTROL, KwdInfo.Value, SET_UVALUE=Vals
    ENDELSE
END


;
;  Inter_STR
;	General string keyword processing routine
;
PRO Inter_STR, KwdInfo, Value, Arr

    ;	Hack. I've seen people use Keyword:=
    ;	Perhaps I should just add '' to the list of valid values.
    IF Value EQ '' THEN VALUE = 'none'

    IF KwdInfo.Choices NE 0 THEN BEGIN
	WIDGET_CONTROL, KwdInfo.Choices, GET_UVALUE=Choices
	Value	= STRLOWCASE(Value)
	Dummy	= WHERE(Value EQ Choices, Count)
	IF Count NE 1 THEN $
	    MESSAGE, 'Illegal choice of values for ' + KwdInfo.Keyword
    ENDIF

    IF KwdInfo.Proc THEN BEGIN

	CALL_PROCEDURE, KwdInfo.Proc, KwdInfo, Value, Arr

    ENDIF ELSE BEGIN
	IF KwdInfo.IsArray THEN BEGIN
	    WIDGET_CONTROL, KwdInfo.Value, GET_UVALUE=Vals
	    Vals(Arr-1)	= Value
	ENDIF ELSE BEGIN
	    Vals		= Value
	ENDELSE

        WIDGET_CONTROL, KwdInfo.Value, SET_UVALUE=Vals
    ENDELSE
END


;
;  Inter_Fixed
;	Routine to tell user that this is a simple reader.
;	If the size of a keyword element has been changed
;	and it wasn't 0 before, tell user we give up.
;
;	This is for :matrix size: because we don't handle images
;	of different sizes.
;
PRO Inter_Fixed, KwdInfo, Value, Arr

    WIDGET_CONTROL, KwdInfo.Value, GET_UVALUE=Vals
    IF KwdInfo.IsArray THEN Val = Vals(Arr-1) $
    ELSE Val = Vals

    IF Val EQ 0 THEN BEGIN

	IF KwdInfo.IsArray THEN Vals(Arr-1) = Value $
	ELSE Vals = Value
	WIDGET_CONTROL, KwdInfo.Value, SET_UVALUE=Vals

    ENDIF ELSE IF Value NE Val THEN BEGIN

	MESSAGE, "Support of Interfiles where " + KwdInfo.Keyword + $
		" changes is not currently supported"

    ENDIF
END


;
;  Inter_ReadHdr
;	Wade through administrative data looking for the keywords
;	we understand.  Quietly ignore any keywords not in the Info
;	list. This should provide enough information to either
;	read the data or realize we can't read the data.
;
;	N.B. STRMID(Str,Start, 255) will return the remainder of a
;	string as long as that string is less than 255 characters long --
;	which the Interfile 3.3 spec guarantees
;
PRO Inter_ReadHdr, Unit, Info

    ;	Parse lines until
    Line	= ""
    WHILE NOT EOF(Unit) DO BEGIN
	READF, Unit, Line			; Read in line of text

	;	Remove leading/trailing whitespace (blech)
	BLine		= BYTE(Line)
	Idx		= WHERE(Bline EQ 13b OR Bline EQ 10b, Count)
	IF Count GT 0 THEN Bline(Idx) = 32b
	Line		= STRTRIM(BLine,2)

	IF Line EQ '' THEN GOTO, Continue	; ignore blank lines

	FirstChar	= STRMID(Line,0,1)	; ';' is comment character
	IF FirstChar EQ ";" THEN GOTO, Continue

	;	Find full Keyword
	KeyStart	= FirstChar EQ "!"
	KeyEnd		= STRPOS(Line, ":=")
	Kwd		= STRMID(Line, KeyStart,KeyEnd-KeyStart)

	;	Look for array index
	ArrStart	= STRPOS(Kwd, "[")
	IF ArrStart NE -1 THEN BEGIN
		Arr	= FIX( STRMID(Kwd,ArrStart+1, 255))
		Kwd	= STRMID(Kwd, 0, ArrStart)
	ENDIF ELSE BEGIN
		Arr	= 0
	ENDELSE

	Kwd		= STRLOWCASE(STRTRIM(Kwd,2))

	;	Look for value
	Value		= STRMID(Line,KeyEnd+2,255)
	ValEnd		= STRPOS(Value, ";")
	IF ValEnd NE -1 THEN Value = STRMID(Value,0,ValEnd-1)
	Value		= STRTRIM(Value,2)

	;	We now have keyword, array index and value

	;	Special case for the 'End of Interfile' keyword
	;	It does not set a value like the other keywords.
	IF Kwd EQ "end of interfile" THEN RETURN

	Idx	= WHERE(Kwd EQ Info.Keyword, Count)
	IF Count EQ 0 THEN GOTO, Continue
	KwdInfo	= Info(Idx)

	;	Either we have an array with no subscripting which requires
	;	it or we have an array with a subscript that can't have one

	IF (Arr NE 0) XOR (KwdInfo.IsArray NE 0) THEN BEGIN
	    IF Arr NE 0 THEN $
		MESSAGE, 'Keyword :'+KwdInfo.Keyword +': cannot have subscript'
	    MESSAGE, 'Keyword :' + KwdInfo.Keyword + ': must have subscript'
	ENDIF

	CALL_PROCEDURE, "Inter_" + KwdInfo.Handler, $
		KwdInfo, Value, Arr
    Continue:
    ENDWHILE
END

;
;  GetIFSYM
;	Thin UI to cover keyword finding mechanism.
;	If hash is implemented it goes here
;
FUNCTION GetIFSYM, Name, Info, INDEX=Idx

	; Hash	= FIX(TOTAL(BYTE(Name)))
	; Idxs	= WHERE(Info.Hash EQ Hash, Count)
	; IF Count eq 0 then <Error>
	; Idx	= WHERE(Name EQ Info(Idxs).Keyword, Count)

	Idx	= WHERE(Name EQ Info.Keyword, Count)
	IF Count NE 1 THEN $
		MESSAGE, "Unknown/unsupported keyword '" + Name + "'"
	WIDGET_CONTROL, Info(Idx).Value, GET_UVALUE=Value
	RETURN, Value
END


;
;  Inter_ReadData
;	At this point we have all of the information to read the
;	data: File, Offset, Amount and Type.
;
PRO Inter_ReadData, Info, Data, Path

    ;	Byte/Block offset
    Offset	= GetIFSYM("data offset in bytes", Info)
    IF Offset EQ 0L THEN BEGIN
	Offset	= GetIFSYM("data starting block", Info)
	Offset	= Offset * 2048
    ENDIF

    FileName	= Path + GetIFSYM("name of data file", Info)
    Sz		= LONARR(6)
    Sz(0)	= 3	; 3 dimensions
    Sz(1:2)	= GetIFSYM("matrix size", Info)
    Sz(3)	= GetIFSYM("total number of images", Info)

    ;	Now the tricky one. Data Type:
    ;	Use elements size and number format.
    ;	I hope we blow up if things are wierd (3 bytes/pixel
    ;	or other unsupported conditions)
	
    ElemSize	= GetIFSYM("number of bytes per pixel", Info)
    InterType	= GetIFSYM("number format", Info)

    CASE InterType OF

    'bit':		MESSAGE, "Unsupported Data Type."

    'unsigned integer':	GOTO, IntData
    'signed integer':	BEGIN
    IntData:
	Type	= [ 1, 2, 0, 3 ]	; byte/int/error/long
	Type	= Type(ElemSize-1)
	END

    'short float':	Type	= 4
    'long float':	Type	= 5

    ENDCASE

    Sz(4)	= Type

    OPENR, Unit, FileName, /GET_LUN
    Data = MAKE_ARRAY(SIZE=Sz, /NOZERO)
    POINT_LUN, Unit, Offset
    READU, Unit, Data
    FREE_LUN, Unit

    ;	There are other combinations that require
    ;	byteswapping but this is what was found
    ;	so far.

    Endian	= GetIFSYM("imagedata byte order", Info)

    ;	Short int data. If we are on some machine where the
    ;	endianness is the reverse of that in the file...

    IF Type EQ 2 THEN BEGIN

	;	Determine the endianness of the machine

	LocalEndian	= (BYTE(1, 0, 1))(0)

	;	If the endianness of the machine doesn't
	;	match the endianness of the file then swap

	IF (Endian EQ 'littleendian' AND LocalEndian EQ 0) OR $
	   (Endian EQ 'bigendian' AND LocalEndian EQ 1) THEN BEGIN

	    BYTEORDER, Data, /SSWAP
	ENDIF
    ENDIF
END


PRO Read_Interfile, Filename, Data

    OPENR, Unit, Filename, /GET_LUN
    Inter_MakeInfo, Info, Filename
    Inter_ReadHdr, Unit, Info
    FREE_LUN, Unit
    Inter_ReadData, Info, Data, GetPath(Filename, /PATH)

    ; Release Information structure information
    FOR I=0,N_ELEMENTS(Info)-1 DO BEGIN
	IF Info(I).Value NE 0L THEN WIDGET_CONTROL, Info(I).Value, /DESTROY
	IF Info(I).Choices NE 0L THEN WIDGET_CONTROL, Info(I).Choices, /DESTROY
    ENDFOR
END
; $Id: read_pict.pro,v 1.2 1994/07/12 23:39:52 dave Exp $

pro read_pict_item, unit, data
; procedure reverse from big-endian to little endian or vis a versa.
; On entry:
;  DATA should be defined, and items are read from unit if it is > 0.
;  If Unit is < 0, DATA is already read.
;  The common block, write_pict_rev should already be set up.

common write_pict_rev, rev

if unit ge 0 then readu, unit, data		;Read it???
if rev eq 0 then return		;Nothing to do...
s = size(data)			;What type of data?
case s(s(0)+1) of
2:	byteorder, data, /SSWAP	;Swap shorts
3:	byteorder, data, /LSWAP ;longs
4:	byteorder, data, /LSWAP ;Float
5:	BEGIN			;Double
	n = n_elements(data)
	data = byte(data, 0, n*8)
	for i=0L,8*(n-1),8 do for j=0L,7 do data(i+j) = data(i+7-j)
	data = double(data, 0, n)
	ENDCASE
6:	byteorder, data, /LSWAP	;Complex => floats
8:	BEGIN			;Structure...
	for i=0, n_tags(data)-1 do begin	;Do each tag individually.
;	   tmp = data.(i)
	   read_pict_item, -1, tmp
;	   data.(i) = tmp
	   ENDFOR
	ENDCASE
else:				;Do nothing for bytes & strings
ENDCASE
end	


function UnPackData, width, height, unit

;	Function UnPackData
;	This function is used by the READ_PICT user library routine and
;	it performs the Quickdraw style run length decoding for PICT
;	files.  IMAGE is the unpacked data.  
;	NOPROGRESS is a keyword and when set, it suppressed the display of
;	the progress of the packing.


IMAGE = bytarr(width, height)
for scanline = height-1,0, -1 do begin
  scanlinecount = 0
  packlineindex = 0
  if(width gt 250) then count = 0 else count = 0b
  read_pict_item, unit, count
  packline = bytarr(count)
  readu, unit, packline
  while(scanlinecount lt width) do begin
    packcount = packline(packlineindex)
    packlineindex = packlineindex + 1
    if (packcount ge 128) then begin		; bits are packed
      packcount = 256 - packcount
      repeatedvalue = packline(packlineindex)
      packlineindex = packlineindex + 1
      IMAGE(scanlinecount:scanlinecount + packcount, scanline) = repeatedvalue
    endif else begin
      IMAGE(scanlinecount:scanlinecount + packcount,		$
	       scanline) = packline(packlineindex:packlineindex + packcount)
      packlineindex = packlineindex + packcount + 1
    endelse
    scanlinecount = scanlinecount + packcount + 1
  endwhile
  if(scanlinecount ne width) then begin
    print, "error in reading scanline ",scanline
    stop
  endif
endfor

return, IMAGE

end


PRO READ_PICT, filename, resultimage, r, g, b, DEBUG = DEBUG

;+
; NAME:		READ_PICT
; PURPOSE: 	Reads limited types of image files written in the PICT
;		Version 2 Format.  This format is used by the Apple 
;		Macintosh Computers.
; CATEGORY:	
; CALLING SEQUENCE:
;	READ_PICT, FILE, IMAGE		;Reads PICT file into IMAGE
;	READ_PICT, FILE, IMAGE, R, G, B	;Reads Image and loads color vectors
; INPUTS:
;       FILE = Scalar string giving the name of the PICT file to read.
;       IMAGE = 2D matrix to be input.  
; OPTIONAL INPUT PARAMETERS:
;       R, G, B = The Red, Green, and Blue color vectors to be read
;               with IMAGE.  If not specified, the color table associated
;		with the picture is ignored.
; OUTPUTS:
;	IMAGE - the image that is read in from the file.
;	R, G, B - the color vectors from the PICT file.
; SIDE EFFECTS:
;	A file is opened, UnPackData is called, I/O is performed
; RESTRICTIONS:
;	Only creates Version 2 PICT files.  Not intended to read all PICT
;	files.  Known to work with IDL PICT files written with write_pict
;	routine in IDL.
; PROCEDURE:
;	Read in the header, size, and the following quickdraw opcodes.
;
; MODIFICATION HISTORY:
;	Written 19 November 1990, Steve Richards.
;		19 November 1992, Steve Richards, Fixed a problem where
;			the color vectors returned were integer and not
;			bytes.
;		Jul 1994,  DMS, RSI.  Added code for both big and little
;			endian byte ordering.  Previous version would not
;			work on little endian machines.
;-

common write_pict_rev, rev

ON_ERROR, 2
i  = byte(1,0,2)		;Test byte ordering of this machine
rev = i(0) eq 1b 		;TRUE to reverse for little endian

if keyword_set(DEBUG) then DEBUG = 1 else DEBUG = 0
hdr = bytarr(512)
imagesize = 0
Rect = {rect, top:0, left:0, bottom:0, right:0}

openr, unit, filename, /get_lun
readu, unit, hdr
read_pict_item, unit, imagesize
read_pict_item, unit, Rect
image = bytarr(Rect.right - Rect.left, Rect.bottom - Rect.top)
done = 0
count = 0

while(done eq 0) do begin
  opcode = 0
  read_pict_item, unit, opcode
  count = count + 1
  
  case opcode of
    0: begin					;nop
	 if(DEBUG ne 0) then print, "---NOP Opcode"
       end

    1: begin					;clip region size
	 if(DEBUG ne 0) then print, "---Clip Opcode"
	 regionsize = 0
	 read_pict_item, unit, regionsize
	 if regionsize ne 10 then begin
	   print, "Non rectangular regions not supported"
	   print, "Region is of size ",regionsize
	   done = 1
         endif else begin
	   clipregion = Rect
	   read_pict_item, unit, clipregion
           if(DEBUG ne 0) then print, "Clip Region is ",clipregion
	 endelse
       end

    17:	begin					;version number
	  if(DEBUG ne 0) then print, "---Version Opcode"
	  versionnumber = 0b
	  lowbyte = 0b
	  readu, unit, versionnumber
	  readu, unit, lowbyte
	  if(DEBUG ne 0) then $
	    print, "  Reading PICT file with version number ",versionnumber, $
		   "   and lowbyte", lowbyte
        end

    30: begin					;default highlight operation
	  if(DEBUG ne 0) then print, "---DefHilite Opcode"
	end	  

    152: begin					;packed copybits operation
	   if(DEBUG ne 0) then print, "---PackBitsRect Opcode"
	   pixMap = {pixMapstr,	rowBytes:0,		$
				Boundtop:0,		$
				Boundleft:0,		$
				Boundbottom:0,		$
				Boundright:0,		$
				version:0,		$
				packType:0,		$
				packSize:0L,		$
				hRes:0L,		$
				vRes:0L,		$
				pixelType:0,		$
				pixelSize:0,		$
				cmpCount:0,		$
				cmpSize:0,		$
				planeBytes:0L,		$
				pmTable:0L,		$
				pmReserved:0L}
	   read_pict_item, unit, pixMap
	   if(DEBUG ne 0) then print, "read pixMap"
	   pixMap.rowBytes = pixMap.rowBytes and 32767	;strip high bit
	   coltable = {coltablestr,	ctseed:0L,	$
					transIndex:0,	$
					ctSize:0}
	   read_pict_item, unit, coltable
	   if(DEBUG ne 0) then help, /str, coltable
	   colors = intarr(4, coltable.ctSize + 1)
	   read_pict_item, unit, colors
	   if(DEBUG ne 0) then print, "read colors"
	   colors = byte(colors / 256)
	   r = reform(colors(1,*), n_elements(colors(1,*)), /overwrite)
	   g = reform(colors(2,*), n_elements(colors(2,*)), /overwrite)
	   b = reform(colors(3,*), n_elements(colors(3,*)), /overwrite)
	   srcRect = Rect
	   read_pict_item, unit, srcRect
	   if(DEBUG ne 0) then print, "read srcRect"
	   dstRect = Rect
	   read_pict_item, unit, dstRect
	   if(DEBUG ne 0) then print, "read dstRect"
	   mode = 0
	   read_pict_item, unit, mode
	   if(DEBUG NE 0) THEN PRINT, mode, "is the mode"
	   if(DEBUG ne 0) then print, "read mode"
	   if(pixMap.rowBytes lt 8) then begin	;data is unpacked
	     if(DEBUG ne 0) then print, "Data is unpacked"
	     datasize = pixMap.rowBytes*(pixMap.Boundbottom -	$
					 pixMap.Boundtop)
	     image = bytarr(pixMap.rowBytes*				$
			    (pixMap.Boundbottom - pixMap.BoundTop))
	     readu, unit, image
	   endif else begin			;data is packed
	     if(DEBUG ne 0) then print, "Data is packed"
	     image = UnPackData(pixMap.rowBytes,			$
				pixMap.Boundbottom - pixMap.BoundTop, unit)
	   endelse
	   done = 1
	 end

    154: begin		;reserved apple instruction
 	   if(DEBUG ne 0) then print, "---Reserved Apple Opcode 0x009A"
           datasize = 0
	   read_pict_item, unit, datasize
           if(datasize ne 0) then begin
	     trash = bytarr(datasize)
	     readu, unit, trash
	     if(DEBUG ne 0) then print, "  datasize ",datasize, "      data", $
					trash
	   endif else begin
	     if(DEBUG ne 0) then print, "  datasize = 0"
	   endelse
	 end

    255: begin					;end of pict file opcode
	   if(DEBUG ne 0) then begin
	     print, "---opEndPic Opcode"
 	     stuff = bytarr(16)
	     readu, unit, stuff
	     print, stuff, format = '("  Rest in HEX ",16(" ",Z2.2," "))'
	     print, stuff, format = '("  Rest in DEC ",16(I3.3," "))'
	   endif	   
	   done = 1
	 end

    3072: begin					;header operation
	    headerdata = bytarr(24)
	    readu, unit, headerdata
	    if(DEBUG ne 0) then print, "---HeaderOp Opcode"
	    if(DEBUG ne 0) then $
	      print, headerdata, $
		     format = '("  Header data is ",3(/"    ",8(Z2.2," ")))'
	  end

    else: begin					;unknown opcode
	    print, opcode, opcode, $
		   format = '("Stopped on unknown opcode $",Z4.4," or ",I)'
	    if(DEBUG ne 0) then begin 
	      print, "Dump follows"
	      opcodes = bytarr(10)
              readu, unit, opcodes
	      print, opcodes, format = '(10(I3,"  "))'
	    endif
	    done = 1
	  end
  endcase

endwhile

free_lun, unit
resultimage = image

end



; $Id: read_ppm.pro,v 1.1 1994/11/18 23:28:57 dave Exp $
; Copyright (c) 1994. Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;
Function READ_PPM_NEXT_LINE, unit
cr = string(13b)
repeat begin
    a = ''
    readf, unit, a
    l = strpos(a, '#')   ;Strip comments
    if l ge 0 then a = strmid(a,0,l)
    if strmid(a,0,1) eq cr then a = strmid(a,1,1000)  ;Leading <CR>
    if strmid(a,strlen(a)-1,1) eq cr then a = strmid(a,0,strlen(a)-1)
    a = strtrim(a,2)		;Remove leading & trailing blanks.
    a = strcompress(a)		;Compress white space.
endrep until strlen(a) gt 0
return, a
end

Function READ_PPM_NEXT_TOKEN, unit, buffer
if strlen(buffer) le 0 then buffer = READ_PPM_NEXT_LINE(unit)
white = strpos(buffer, ' ')
if white eq -1 then begin	;No blanks?
    result = buffer
    buffer = ''
endif else begin		;Strip leading token.
    result = strmid(buffer, 0, white)
    buffer = strmid(buffer, white+1, 1000)
endelse
return, result
end



PRO READ_PPM, FILE, IMAGE, MAXVAL = maxval
;
;+
; NAME:
;	READ_PPM
;
; PURPOSE:
;	Read the contents of a PGM (gray scale) or PPM (portable pixmap
;	for color) format image file and return the image in the form
;	of an IDL variable.
;	PPM/PGM format is supported by the PMBPLUS and Netpbm packages.
;
;	PBMPLUS is a toolkit for converting various image formats to and from
;	portable formats, and therefore to and from each other.
;
; CATEGORY:
;	Input/Output.
;
; CALLING SEQUENCE:
;	READ_PPM, File, Image 
;
; INPUTS:
;	File:	Scalar string giving the name of the PGM or PPM file.
;
; OUTPUTS:
;	Image:	The 2D byte array to contain the image.  In the case
;		of a PPM file, a (3, n, m) array is returned.
;
; KEYWORD Parameters:
;	MAXVAL = returned maximum pixel value.
; SIDE EFFECTS:
;	None.
; RESTRICTIONS:
;	Should adhere to the PGM/PPM "standard".
;	Accepts: P2 = graymap ASCII, P5 graymap RAWBITS, P3 true-color
;	ASCII pixmaps, and P6 true-color RAWBITS pixmaps.
;	Maximum pixel values are limited to 255.
;	Images are always stored with the top row first. (ORDER=1)
;
; EXAMPLE:
;	To open and read the PGM image file named "foo.pgm" in the current
;	directory, store the image in the variable IMAGE1 enter:
;
;		READ_PPM, "foo.gif", IMAGE1
;
; MODIFICATION HISTORY:
;	Written Nov, 1994, DMS.
;-
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;

ON_IOERROR, bad_io
ON_ERROR, 1

OPENR, unit, file, /GET_LUN, /BLOCK
image = 0
buffer = ''		;Read using strings
magic = READ_PPM_NEXT_TOKEN(unit, buffer)
if strmid(magic,0,1) ne 'P' then begin
Not_pgm: MESSAGE, 'File "'+file+'" is not a PGM/PPM file.'
    return
    endif

type = strmid(magic,1,1)

width = long(READ_PPM_NEXT_TOKEN(unit, buffer))
height = long(READ_PPM_NEXT_TOKEN(unit, buffer))
maxval = long(READ_PPM_NEXT_TOKEN(unit, buffer))
case type of
'2' : BEGIN
	image = bytarr(width, height, /nozero)
	readf, unit, image
      ENDCASE
'3' : BEGIN
	image = bytarr(3, width, height, /nozero)
	readf, unit, image
      ENDCASE
'5' : BEGIN
	image = bytarr(width, height, /nozero)
	readu, unit, image
      ENDCASE
'6' : BEGIN
	image = bytarr(3, width, height, /nozero)
	readu, unit, image
      ENDCASE
else :	goto, Not_pgm
ENDCASE

free_lun, unit
return
BAD_IO: Message, 'Error occured accessing PGM/PPM file:' + file
end

;$Id: read_spr.pro,v 1.4 1994/03/02 15:42:57 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       READ_SPR
;
; PURPOSE:
;       This function reads a row-indexed sparse matrix from a specified
;	file and returns it as the result.    Row-indexed sparse matrices
;	are created by using the Numerical Recipes routine NR_SPRSIN.
;
; CATEGORY:
;      	Sparse Matrix File I/O	
;
; CALLING SEQUENCE:
;       result = READ_SPR('Filename')
;
; INPUTS:
;	Filename:  Name of file containing a row-indexed sparse matrix
;                  
; KEYWORD PARAMETERS;
;	NONE
;
; OUTPUTS:
;	result:  Row-indexed sparse matrix
;
;
; MODIFICATION HISTORY:
;       Written by:     BMH, 1/94.
;-
 
FUNCTION  READ_SPR, filename

; result format = {sa:FLTARR(nmax) or sa:DBLARR(nmax), ija:LONARR(nmax)}
;
nmax = 0L
type = 0L

ON_IOERROR, BADFILE


OPENR, fileLUN, filename, /GET_LUN

;Read type and size information 
READU, fileLUN, nmax, type

;Define resulting structure based on the data size and type
IF (type EQ 4) THEN $ ; Value array is single precision
  result = {sa:FLTARR(nmax, /NOZERO),ija:LONARR(nmax, /NOZERO)} $
else  $               ; Value array is double precision 
  result = {sa:DBLARR(nmax, /NOZERO),ija:LONARR(nmax, /NOZERO)}

;Read sparse matrix
READU, fileLUN, result

FREE_LUN, fileLUN

RETURN, result


BADFILE:
IF (N_Elements(fileLUN) GT 0L) THEN $ 
   FREE_LUN, fileLUN
MESSAGE, 'Error reading sparse matrix file: ' + filename

END



; $Id: read_srf.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO READ_SRF, FILE, IMAGE, R, G, B
;
;+
; NAME:
;	READ_SRF
;
; PURPOSE:
;	Read the contents of a Sun rasterfile and return the image and
;	color table vectors (if present) in the form of IDL variables.
;
; CATEGORY:
;	Input/Output.
;
; CALLING SEQUENCE:
;	READ_SRF, File, Image [, R, G, B]
;
; INPUTS:
;	File:	Scalar string giving the name of the rasterfile to read
;
; OUTPUTS:
;	Image:	The 2D byte array to contain the image.
;
;
; OPTIONAL OUTPUT PARAMETERS:
;     R, G, B:	The variables to contain the Red, Green, and Blue color vectors
;		if the rasterfile containes colormaps.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	This routine only handles 1, 8, 24, and 32-bit rasterfiles of type
;	RT_OLD and RT_STANDARD.  See the file /usr/include/rasterfile.h
;	for the structure of Sun rasterfiles.
;
; EXAMPLE:
;	To open and read the Sun rasterfile named "sun.srf" in the current
;	directory, store the image in the variable IMAGE1, and store the color
;	vectors in the variables R, G, and B, enter:
;
;		READ_SRF, "sun.srf", IMAGE1, R, G, B
;
;	To load the new color table and display the image, enter:
;
;		TVLCT, R, G, B
;		TV, IMAGE1
; 
; MODIFICATION HISTORY:
;	Written fall 1897, AB
;	3/1/90, Added 24 bit images, DMS.
;	7/8/90, Added 32 bit images, DMS.
;	1/22/92, the colors within 24 bit images were not ordered
;		correctly, DMS.
;-
; Copyright (c) 1990, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;

; Define the Sun Raster File structure
a = {rasterfile, magic:0L, width:0L, height:0L, depth: 0L, $
	length:0L, type:0L, maptype:0L, maplength:0L}

OPENR, unit, file, /GET_LUN, /BLOCK

READU, unit, a
; Check the magic number
if (a.magic EQ '956aa659'XL) then begin
	byteorder, a, /ntohl		;Back to our order
	endif
	
IF (a.magic NE '59a66a95'X) THEN begin
	message, /CONTINUE, 'File ' + file + $
		' does not have a SUN rasterfile magic number.'
	GOTO, done
	ENDIF

; Only know how to do RT_OLD and RT_STANDARD style rasterfiles.
IF ((a.type NE 0) AND (a.type NE 1)) THEN BEGIN
	message, /CONTINUE, $
		'Don''t know how to handle this style of rasterfile, sorry...'
	GOTO, done
	ENDIF

; Only know how to handle 1 bit and 8 bit images
IF (a.depth NE 1) AND (a.depth NE 8) AND (a.depth ne 24) AND $
   (a.depth ne 32) then begin
	message, /CONTINUE, 'Can''t handle ' + string(a.depth) + ' bit images.'
	GOTO, done
	ENDIF

; Recompute length, since rasterfile.h says you have to for old files...
a.length = (a.width * a.height * a.depth) / 8
image = 0		;Delete original value of image var

; If image has color tables, read them
IF ( (a.maptype EQ 1) AND (a.maplength NE 0) ) THEN BEGIN
	maplen = a.maplength / 3
	r = BYTARR(maplen)
	g = BYTARR(maplen)
	b = BYTARR(maplen)
	READU, unit, r, g, b
	ENDIF

; Get a byte array for the image

; If the image is 1 bit, read it and decode into bytes
case a.depth of
1: begin
	ncols = ((a.width + 15)/16)*16  ;# of columns padded to short
	image = BYTARR(ncols, a.height) ;make the array
	temp = intarr(a.length/2)	; Get the packed shorts
	READU, unit, temp
        mask = ROTATE((2 ^ indgen(16)),2) ;Array of 16 bits
	FOR i = 0,15 DO BEGIN		;Unpack each bit
		ind = WHERE(temp AND mask(i))
		s = size(ind)
		if (s(0) ne 0) THEN image(ind * 16 + i) = 255
		ENDFOR
ENDCASE

8: BEGIN	; If the image is eight bit, read it
	ncols = ((a.width + 1)/2)*2  ;Pad to even number
	image = BYTARR(ncols, a.height)
	READU, unit, image
ENDCASE

24: BEGIN		;24 bit
	ncols = ((a.width + 1)/2)*2  ;Pad to even number
	image = BYTARR(3, ncols, a.height)
	readu, unit, image
ENDCASE

32:	BEGIN		;Read 32 bit into a (3,n,m) image
	image = BYTARR(3,a.width, a.height)
	row = bytarr(4,a.width)	;Read a row at a time
	indices = [3,2,1] # replicate(1,a.width*3) + $
		(4 * (indgen(a.width*3)/3))
	for i=0,a.height-1 do begin
		readu, unit, row
		image(0,0,i) = reform(row(indices),3,a.width,/over)
		endfor
ENDCASE
ENDCASE
done:
	FREE_LUN, unit
	END
; read_sylk.pro


; Returns TRUE if TestVal is in the range of LoVal through HiVal

FUNCTION ContainsVal, LoVal, TestVal, HiVal

    RETURN, ((LoVal LE TestVal) AND (TestVal LE HiVal))
END


; Scans the passed sylk data line and returns the new cell row.

FUNCTION GetSylkCellRow, szCellLine, iCurRow

    ON_ERROR, 2

    iRow = 0
    posRowData = STRPOS(szCellLine, ";Y")

    IF (posRowData NE -1) THEN BEGIN
    READS, STRMID(szCellLine, posRowData + 2, $
        STRLEN(szCellLine) - posRowData), iRow, FORMAT = "(I)"
    ENDIF
    RETURN, iRow - 1
END


; Scans the current sylk data line and returns the current cell column.

FUNCTION GetSylkCellCol, szCellLine

    ON_ERROR, 2

    iCol = 0
    posColData = STRPOS(szCellLine, ";X")

    IF (posColData NE -1) THEN BEGIN
        READS, STRMID(szCellLine, posColData + 2, $
            STRLEN(szCellLine) - posColData), iCol, FORMAT = "(I)"
    ENDIF
    RETURN, iCol - 1
END


; Reads in the entire sylk file and determines the complete range of cell data 
; therein.

FUNCTION GetSylkCellRange, lunFile, strCellRange

    ON_ERROR, 2

    szFileLine = ""
    iCurRow = 0
    iCurCol = 0
    iFirstRow = 32767
    iFirstCol = 32767
    iLastRow = 0
    iLastCol = 0

    WHILE (NOT EOF(lunFile)) DO BEGIN
        READF, lunFile, szFileLine

        iCurRow = GetSylkCellRow(szFileLine)
        IF (iCurRow NE -1) THEN BEGIN
            iFirstRow = (iCurRow < iFirstRow)
            iLastRow = (iCurRow > iLastRow)
        ENDIF

        iCurCol = GetSylkCellCol(szFileLine)
        IF (iCurCol NE -1) THEN BEGIN
            iFirstCol = (iCurCol < iFirstCol)
            iLastCol = (iCurCol > iLastCol)
        ENDIF
    ENDWHILE

    POINT_LUN, lunFile, 0

;    strCellRange.(0) = iFirstRow
;    strCellRange.(1) = iFirstCol
;    strCellRange.(2) = iLastRow
;    strCellRange.(3) = iLastCol

    RETURN, ((iLastRow - iFirstRow GT 0) OR (iLastCol - iFirstCol GT 0))
END
 

; Reads in sylk cell data line, determines the type of data in the cell and
; returns that data.

FUNCTION GetSylkCellContents, szFileLine, fUseLongs, fUseDoubles

    ON_ERROR, 2

    mdefCellContents = 0B
    szCellContents = ""
    posCellContents = STRPOS(szFileLine, ";K")
    
    IF (posCellContents NE -1) THEN BEGIN
        szCellContents = STRMID(szFileLine, posCellContents + 2, $ 
            STRLEN(szFileLine) - posCellContents)

        szCellContents = szCellContents + ";"

        ; Check to see if it's a string or not.  If it is, it will have a '"'
        ; as the first character.
        IF (STRPOS(szCellContents, 34B) EQ 0) THEN BEGIN

            ; Find the end of the cell's text contents, which will be the last
            ; '"' in the string before the next ";", and extract that text from 
            ; the string.
            mdefCellContents = STRMID(szCellContents, 1, $
            STRPOS(szCellContents, ";", 1) - 2)
                
        ; Check to see if it's a floating point value.  If it is, it will have a
        ; "." in the string before the next ";" delimeter.
        ENDIF ELSE BEGIN
            posPeriod = STRPOS(szCellContents, ".")
            IF ((posPeriod GT -1) AND $
                (posPeriod LT STRPOS(szCellContents, ";"))) THEN BEGIN

                ; If the user wishes to use double precision, return a DOUBLE.
                IF (fUseDoubles) THEN BEGIN
                    mdefCellContents = 0.0D
                    READS, szCellContents, mdefCellContents, FORMAT = "(D)"
                
                ; Otherwise, return a FLOAT.
                ENDIF ELSE BEGIN
                    mdefCellContents = 0.0
                    READS, szCellContents, mdefCellContents, FORMAT = "(F)"
                ENDELSE
    
            ; Otherwise, the sylk cell data must be an integer type.
            ENDIF ELSE BEGIN
        
                ; If the user wishes to use long ints, return a LONG.
                IF (fUseLongs) THEN BEGIN
                    mdefCellContents = 0L

                ; Otherwise, return an INT.
                ENDIF ELSE BEGIN
                    mdefCellContents = 0
                ENDELSE

                READS, szCellContents, mdefCellContents, FORMAT = "(I)"

            ENDELSE
        ENDELSE
    ENDIF

    RETURN, mdefCellContents
END


FUNCTION READ_SYLK, Infile, STARTROW = iStartRow, STARTCOL = iStartCol, $
    NROWS = nRows, NCOLS = nCols, ARRAY = fArray, COLMAJOR = fColMajor, $
    USEDOUBLES = fUseDoubles, USELONGS = fUseLongs 
;
;+
; NAME:
;   READ_SYLK
;
; PURPOSE:
;   Reads the contents of a sylk (Symbolic Link) format spreadsheet data file 
;   and returns a cell data range (if present) in the form of an IDL variable.
;
; CATEGORY:
;   Input/Output.
;
; CALLING SEQUENCE:
;   ReturnData = READ_SYLK(InFile [, STARTROW, STARTCOL, NROWS, NCOLS, ARRAY, 
;       COLMAJOR, USEDOUBLES, USELONGS])
;
; INPUT:
;   InFile: Scalar string with the name of the sylk file to read.
;
; OUTPUT:
;   ReturnData: The table (vector of structs) or matrix (2D array) that will
;       contain the spreadsheet cell data.  The size and type of this return
;       variable is set using the optional input parameters (keywords) below.
;
; OPTIONAL INPUT PARAMETERS:
;   STARTROW: The starting (0-based) row of spreadsheet cells to read.  If not
;       specified, this value defaults to the first row of cells found in the 
;       file.
;   STARTCOL: The starting (0-based) column of spreadsheet cells to read.  If 
;       not specified, this value defaults to the first column of cells found 
;       in the file.
;   NROWS: The number of spreadsheet rows to read in.  If not specified, this
;       defaults to all of the cell rows found in the file.
;   NCOLS: The number of spreadsheet columns to read in.  If not specified,
;       this value defaults to all of the cell columns found in the file.
;   ARRAY: Boolean flag.  If TRUE, the data type returned will be an IDL array.
;       Note that the data in the cell range must be of the same type to 
;       successfully return an array.  If this flag is not set, the routine
;       will return a table (vector of structs) instead.  The tags of this
;       struct will be labelled "Col0", "Col1", ..., "ColN" for a row major
;       table and "Row0", "Row1", ..., "RowN" for a column major table.
;   COLMAJOR: Boolean flag.  If TRUE, the range of spreadsheet cell data is
;       transposed and then read into an IDL variable.  This flag should be set 
;       when importing spreadsheet data which has column major organization 
;       (ie., listings by column rather than row).  The default is row major 
;       format.  
;   USEDOUBLES: Boolean flag.  If TRUE, any floating point cell data will be
;       read in and returned as a double precision rather than the default 
;       float type.
;   USELONGS: Boolean flag.  If TRUE, any integer cell data will be read in and
;       returned as a long rather than the default int type.
;
; SIDE EFFECTS:
;   None.
;
; RESTRICTIONS:
;   This routine *only* reads in numerical and string sylk data.  It igonores 
;   all spreadsheet and cell formatting information such as cell width, text 
;   justification, font type, date, time, and monetary notations, etc.  In
;   addition, only attempts to read spreadsheet tables, like-typed cell rows,
;   columns, or subsets thereof will succeed.
;
;
; EXAMPLES:
;   Consider the following row major spreadsheet table with the upper left cell
;   (value = "Index") at location (0, 0) that has been output to the sylk file
;   "foo.slk":
;   
;   Index   Name   Gender  Platform
;     1     Beth     F     Unix
;     2     Kirk     M     VMS
;     3     Mark     M     Windows
;     4     Dave     M     Macintosh
;
;   Note that the data format of the title row (STRING, STRING, STRING, STRING)
;   is inconsistant with the following four rows (INT, STRING, STRING, STRING)
;   in the table.   It is impossible to read all of the table into a single IDL
;   variable, but you could make two calls to READ_SYLK to import all of the
;   data:
;
;       strTitle = READ_SYLK("foo.slk", NROWS = 1)
;       arrstrTable = READ_SYLK("foo.slk", STARTROW = 1)
;
;   The return data are as follows:
;
;       IDL> HELP, strTitle
;       STRTITLE        STRUCT    = -> <Anonymous> Array(1)
;
;       IDL> PRINT, strTitle        
;       { Index Name Gender Platform}
;
;       IDL> HELP, arrstrTable
;       ARRSTRTABLE     STRUCT    = -> <Anonymous> Array(4)
;
;       IDL> PRINT, arrstrTable
;       {       1 Beth F Unix}{       2 Kirk M VMS}{       3 Mark M 
;       Windows}{       4 Dave M Macintosh}
;
;
;   Further, consider the following call from the same sylk file:
;
;       arrszNames = READ_SYLK("foo.slk", /ARRAY, STARTROW = 1, STARTCOL = 1, $
;           NCOLS = 1)
;
;   The return data is now:
;
;       IDL> HELP, arrszNames
;       ARRSZTABLE      STRING    = Array(4)
;
;       IDL> PRINT, arrszNames
;       Beth Kirk Mark Dave 
;
;
;   If the COLMAJOR keyword flag is set the return value differs in type:
;
;       arrszNames = READ_SYLK("foo.slk", /ARRAY, /COLMAJOR, STARTROW = 1, $
;           STARTCOL = 1, NCOLS = 1)
;
;   The return data is now:
;
;       IDL> HELP, arrszNames
;       ARRSZTABLE      STRING    = Array(1, 4)
;
;       IDL> PRINT, arrszNames
;       Beth 
;       Kirk 
;       Mark 
;       Dave 
;
;
; MODIFICATION HISTORY:
;   Written October 1994, AJH
;-
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;

    ON_ERROR, 2
    ON_IOERROR, CleanUp
    
    iCurRow = 0
    iCurCol = 0
    strCellRange = {iStartRow:0, iStartCol:0, iEndRow:0, iEndCol:0}
    szFileLine = ""
    htopSylkData = 0L
    lunInfile = 0
    ReturnData = 0

    ; First check to see if the correct number of positional parameters have 
    ; been passed.
    IF (N_PARAMS() NE 1) THEN BEGIN
        MESSAGE, "Calling sequence - ReturnData = READ_SYLK(Infile [, " + $
            "STARTROW, STARTCOL, NROWS, NCOLS, ARRAY, COLMAJOR, " + $
            "USEDOUBLES, USELONGS])", /CONTINUE
        GOTO, CleanUp    
    ENDIF

    ; Check for the validity of the file parameter
    IF (N_ElEMENTS(Infile) EQ 0) THEN BEGIN
        MESSAGE, "Error - A STRING filename must be passed in the Infile " + $
            "parameter.", /CONTINUE
        GOTO, CleanUp
    ENDIF
    
    ; If Infile is a filename, open it for reading and get its lun
    IF ((SIZE(Infile))(1) EQ 7) THEN BEGIN
        OPENR, lunInfile, Infile, /GET_LUN, ERROR = fOpenRead
        IF (fOpenRead NE 0) THEN BEGIN
            MESSAGE, "Error - File " + STRCOMPRESS(Infile, /REMOVE_ALL) + $
                " cannot be opened.", /CONTINUE
            GOTO, CleanUp
        ENDIF
        fstatResult = FSTAT(lunInfile)
        IF (fstatResult.READ EQ 0) THEN BEGIN
            MESSAGE, "Error - File with LUN of " + $
                STRCOMPRESS(STRING(lunInfile), /REMOVE_ALL) + $
                " cannot be read from.", /CONTINUE
            GOTO, CleanUp
        ENDIF
    ENDIF

    ; Get the actual cell range from the file.
    fResult = GetSylkCellRange(lunInfile, strCellRange)
    IF (fResult EQ 0) THEN BEGIN
        MESSAGE, "Error - there is no sylk cell data in the input file " + $
            "specified.", /CONTINUE
        GOTO, CleanUp
    ENDIF

    ; Setup values for cell range based on keywords and actual range.
    IF (N_ELEMENTS(iStartRow) EQ 0) THEN BEGIN
        iStartRow = strCellRange.iStartRow
    ENDIF ELSE BEGIN
        iStartRow = (strCellRange.iStartRow > iStartRow)
    ENDELSE

    IF (N_ELEMENTS(iStartCol) EQ 0) THEN BEGIN
        iStartCol = strCellRange.iStartCol
    ENDIF ELSE BEGIN
        iStartCol = (strCellRange.iStartCol > iStartCol)
    ENDELSE

    IF (N_ELEMENTS(nRows) EQ 0) THEN BEGIN
        nRows = (strCellRange.iEndRow - iStartRow) + 1
    ENDIF ELSE BEGIN
        nRows = (1 > nRows)
        nRows = ((strCellRange.iEndRow - iStartRow) + 1 < nRows)
    ENDELSE

    IF (N_ELEMENTS(nCols) EQ 0) THEN BEGIN
        nCols = (strCellRange.iEndCol - iStartCol) + 1
    ENDIF ELSE BEGIN
        nCols = (1 > nCols)
        nCols = ((strCellRange.iEndCol - iStartCol) + 1 < nCols)
    ENDELSE     

    ; Setup keyword boolean flags.
    IF (N_ELEMENTS(fColMajor) EQ 0) THEN fColMajor = 0
    IF (N_ELEMENTS(fArray) EQ 0) THEN fArray = 0
    IF (N_ELEMENTS(fUseDoubles) EQ 0) THEN fUseDoubles = 0
    IF (N_ELEMENTS(fUseLongs) EQ 0) THEN fUseLongs = 0

    ; Create a 2D array that will hold the IDs for the cell data handles so
    ; they can be easily referenced.
    arrHandles = MAKE_ARRAY(nRows, nCols, /LONG)
    
    ; Create the parent handle that will own the sylk cell data handles.
    htopSylkData = HANDLE_CREATE()

    ; While not yet at the end of the input file, read in sylk data.
    WHILE (NOT EOF(lunInfile)) DO BEGIN

        ; Read in a line of test from the sylk file.
        READF, lunInfile, szFileLine

        ; Set the current row and column indeces.

        iRow = GetSylkCellRow(szFileLine)
        IF (iRow NE -1) THEN BEGIN
            iCurRow = iRow
        ENDIF

        iCol = GetSylkCellCol(szFileLine)
        IF  (iCol NE -1) THEN BEGIN
            iCurCol = iCol
        ENDIF
        
        ; Check to see if the file line contains cell data that is within range
        ; of the sylk cell range desired.
        IF (ContainsVal(iStartRow, iCurRow, iStartRow + nRows - 1) AND $
            ContainsVal(iStartCol, iCurCol, iStartCol + nCols - 1) AND $
            STRPOS(szFileLine, "C;") EQ 0) THEN BEGIN

            ; Create a handle containing the data in the cell and put it's ID
            ; into the array at it's row and column location.
            arrHandles(iCurRow - iStartRow, iCurCol - iStartCol) = $
                HANDLE_CREATE(htopSylkData, VALUE = $
                GetSylkCellContents(szFileLine, fUseLongs, fUseDoubles))            

        ENDIF
    ENDWHILE
    
    IF (fColMajor) THEN BEGIN
        szTagPrefix = "Row"
        arrHandles = TRANSPOSE(arrHandles)
        iMax = nCols
        jMax = nRows
    ENDIF ELSE BEGIN
        szTagPrefix = "Col"
        iMax = nRows
        jMax = nCols
    ENDELSE

    ; Find the first valid handle in the array of handles, and determine
    ; the data type to which it refers.
    fIsValid = 0
    i = -1

    REPEAT BEGIN
        i = i + 1
        j = 0
        REPEAT BEGIN
            IF (arrHandles(i, j) NE 0L) THEN BEGIN
                fIsValid = 1
                HANDLE_VALUE, arrHandles(i, j), value       
                typeValue = (SIZE(value))(1)
            ENDIF ELSE BEGIN
                j = j + 1
            ENDELSE
        END UNTIL ((j EQ jMax - 1) OR (fIsValid))
    END UNTIL ((i EQ iMax - 1) OR (fIsValid))

    ; If there was no valid handle in the array of handles, make the return
    ; data type bytes
    IF (NOT fIsValid) THEN BEGIN
        typeValue = 1
    ENDIF

    ; If the user wants a matrix of the same type of data
    IF (fArray) THEN BEGIN

        ; Create an array of that type.
        ReturnData = MAKE_ARRAY(iMax, jMax, TYPE = typeValue)

        ; Fill the array.
        FOR i = 0, iMax - 1 DO BEGIN
            FOR j = 0, jMax - 1 DO BEGIN
                IF (arrHandles(i, j) NE 0L) THEN BEGIN
                    HANDLE_VALUE, arrHandles(i, j), value
                    IF ((SIZE(value))(1) NE typeValue) THEN BEGIN
                        MESSAGE, "Error - Mixed data types found in cell " + $
                            "range specified; unable to create and return " + $
                            "an array.", /CONTINUE
                        GOTO, CleanUp
                    ENDIF
                ENDIF ELSE BEGIN
                    value = 0B
                ENDELSE 
                ReturnData(i, j) = value
            ENDFOR  
        ENDFOR
    
    ; Otherwise, the user wants a table, so create a vector of structs in the
    ; return variable.
    ENDIF ELSE BEGIN
        szTag = STRCOMPRESS(szTagPrefix + STRING(0), /REMOVE_ALL)
        
        ; Create the first tag in the structure.
        HANDLE_VALUE, arrHandles(i, j), value
        strData = CREATE_STRUCT(szTag, value)

        ; Step through each column in the array of handles and create a tag
        ; and appropriate type in the structure.
        FOR j = 1, jMax - 1 DO BEGIN
            szTag = STRCOMPRESS(szTagPrefix + STRING(j), /REMOVE_ALL)
            IF (arrHandles(0, j) NE 0L) THEN BEGIN
                HANDLE_VALUE, arrHandles(0, j), value
            ENDIF ELSE BEGIN
                value = 0B
            ENDELSE
            strData = CREATE_STRUCT(strData, szTag, value)
        ENDFOR
            
        ; Create the vector of structures.
        ReturnData = MAKE_ARRAY(iMax, VALUE = strData)
            
        ; Load the values into the vector of structures.
        FOR i = 0, iMax - 1 DO BEGIN
            FOR j = 0, jMax - 1 DO BEGIN
                IF (arrHandles(i, j) NE 0L) THEN BEGIN
                    HANDLE_VALUE, arrHandles(i, j), value
                ENDIF ELSE BEGIN
                    value = 0B
                ENDELSE

                ; Compare type of data in array of handles and the type of
                ; data in the structure.
;                IF ((size(value))(1) NE (size(ReturnData(i).(j)))(1)) THEN BEGIN
                    IF (fColMajor) THEN BEGIN
                        MESSAGE, "Error - data in cell range specified " + $
                            "is not a column major table.  Unable to " + $
                            "create and return a vector of like-typed " + $
                            "structures.", /CONTINUE
 ;                       GOTO, CleanUp                               
                    ENDIF ELSE BEGIN
                        MESSAGE, "Error - data in cell range specified " + $
                            "is not a row major table.  Unable to " + $
                            "create and return a vector of like-typed " + $
                            "structures.", /CONTINUE
                        GOTO, CleanUp
                    ENDELSE
 ;               ENDIF
;                ReturnData(i).(j) = value
            ENDFOR
        ENDFOR
    ENDELSE

    CleanUp: BEGIN
        ; Clean up dynamically allocated memory.
        IF (htopSylkData NE 0L) THEN BEGIN
            HANDLE_FREE, htopSylkData
        ENDIF
        ; Free the file.
        IF (lunInfile NE 0) THEN BEGIN
            FREE_LUN, lunInfile
        ENDIF
    END

    RETURN, ReturnData

END
; $Id: read_wave.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION getword, BIN = BIN

COMMON waverdln, unit

ON_IOERROR, done

IF (KEYWORD_SET(BIN)) THEN BEGIN
  wordlen = 0L
  READU, unit, wordlen
  theword = bytarr(wordlen)
  READU, unit, theword
ENDIF ELSE BEGIN
  filestat = FSTAT(unit)
  current = filestat.cur_ptr
  buffsize = 100 < (filestat.size - current)
  linebuffer = bytarr(100)
  READU, unit, linebuffer
  i = 0
  WHILE (linebuffer(i) EQ 32) OR (linebuffer(i) EQ 10) DO i = i + 1
  wordstart = i
  WHILE (linebuffer(i) NE 32) AND (linebuffer(i) NE 10) DO i = i + 1
  theword = linebuffer(wordstart:i - 1)
  POINT_LUN, unit, current + i
ENDELSE

return, string(theword)

RETURN, STRCOMPRESS(STRING(theword(WHERE(theword NE 10))), /REMOVE_ALL)

done: RETURN, ""

END


FUNCTION getdef, BIN = BIN, BLOCK = BLOCK

COMMON waverdln, unit

ON_IOERROR, done

IF (KEYWORD_SET(BIN)) THEN BEGIN
  IF (KEYWORD_SET(BLOCK)) THEN BEGIN
    def = 0L
    READU, unit, def
    IF (def NE 257L) THEN MESSAGE, "Error, " +$
		"definition expected in binary read (" + def + ")"
  ENDIF
  type = 0L
  READU, unit, type
ENDIF ELSE BEGIN
  IF (KEYWORD_SET(BLOCK)) THEN BEGIN
    def = getword(BIN = BIN)
    IF (def EQ "") THEN GOTO, done
    IF (STRMID(def, 0, 1) EQ "#") THEN BEGIN
      ignore = ""
      READF, unit, ignore
      def = getword(BIN = BIN)
    ENDIF
    IF (def NE "define") THEN $
      MESSAGE, "Error, definition expected in text read (" + def + ")"
  ENDIF
  type = getword(BIN = BIN)
  CASE type OF
    "vdata": 		type = 258L
    "reg_topology": 	type = 259L
    "elem_samp": 	type = 260L
    "irr_topology":	type = 262L
    "count":		type = 263L
    "elems":		type = 264L
    "reg_grid": 	type = 265L
    "grid_samp": 	type = 266L
    "origin": 		type = 267L
    "step":		type = 268L
    "irr_grid":		type = 270L
    "node_vdata":	type = 271L
    "mesh": 		type = 273L
    "mesh_topology":	type = 274L
    "mesh_grid":	type = 275L
    "volume": 		type = 276L
    "volume_mesh":	type = 277L
    "volume_vdata":	type = 278L
    ELSE: BEGIN
	    MESSAGE, type + " was the unrecognized type"
	  END
  ENDCASE
ENDELSE

RETURN, type

done: RETURN, -1L

END


FUNCTION getnum, BIN = BIN

COMMON waverdln, unit

IF (KEYWORD_SET(BIN)) THEN BEGIN
  num = 0L
  READU, unit, num
ENDIF ELSE BEGIN
  num = LONG(getword(BIN = BIN))
ENDELSE
  return, num
END

FUNCTION readarray, len

COMMON waverdln, unit

line = ""
READF, unit, line
endofline = fstat(unit)
current = endofline.cur_ptr

valueline = SHIFT(BYTE(STRCOMPRESS(line)), -1)
spaces = WHERE(valueline EQ 32, numspaces)
IF (numspaces NE 0) THEN BEGIN
  values = INTARR(len)
  last = 0
  FOR i = 0, numspaces - 1 DO BEGIN
    values(i) = STRING(valueline(last:spaces(i) - 1))
    last = spaces(i)
  ENDFOR
ENDIF

return, values
END


PRO read_wave, filename, variables, names, dimensions, $
		MESHNAMES = MESHNAMES
;+
; NAME:
;	READ_WAVE
; PURPOSE:
;	READ a .wave or .bwave file created by the Advanced Data Visualizer
;	into an series of IDL variables.
; CALLING SEQUENCE:
;	READ_WAVE, FILE, VARIABLES, NAMES, DIMENSIONS
; INPUTS:
;	FILE = Scalar string giving the name of the Wavefront file to write.
; KEYWORD PARAMETERS:
;	MESHNAMES = The name of the mesh used in the Wavefront file
;		for each variable.
; OUTPUTS:
;	VARIABLES = Upon return, this variable contains a block of the 
;		variables contained in the wavefront file.  Since each
;		variable in a wavefront file can have more than one field
;		(for instance, a vector variable has 3 fields), the fields
;		of each variable make up the major index into the variable 
;		block.  For instance, if a Wavefront file had one scalar 
;		variable and one vector variable, the scalar would be
;		extracted as follows:
;
;			vector_scalar = variables(0,*,*,*)
;
;		and the vector variable would be extracted as follows:
;
;			vector_variable = variables(1:3,*,*,*)
;
;		To find the dimensions of the returned variable, see the
;		description below regarding DIMENSIONS
;
;	NAMES = Upon return, this variable contains the string names of each
;		variable contained in the file.
;	DIMENSIONS = Upon return, this variable is a long array that describes
;		how many fields in the large returned variable block each
;		variable occupies.  In the above example of one scalar variable
;		followed by a vector variable, the dimension variable would 
;		be:
;			DIMENSIONS = [1,3]
;		So the first field of the returned variable block would be
;		the scalar variable and the following 3 fields would comprise
;		the vector variable.
; RESTRICTIONS:
;	This routine only preserved the structure of the variables if they
;	are regularly grided variables.  
; MODIFICATION HISTORY:
;	Written July 16, 1991, by Steve Richards.
;-
; Copyright (c) 1990, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;

COMMON waverdln, unit

IF (KEYWORD_SET(DEBUG)) THEN DEBUG = 1 ELSE DEBUG = 0

volnum = 0
voldesclist = 0
voldesc = {vldesc,	name:"", $
  			volmeshdesc:"", $
  			voldata:""}
meshnum = 0
meshdesclist = 0
meshdesc = {mshdesc,	name:"", $
			topdesc:"", $
			griddesc:""}
topnum = 0
topdesclist = 0
topdesc = {tpdesc,	name:"", $
			elem_samp:intarr(8)}
gridnum = 0
griddesclist = 0
griddesc = {grddesc,	name:"", $
			grid_samp:intarr(8)}

datafieldnum = 0
datafieldlist = 0
datafield = {dtfld,	name:"", $
			size:0}

variables = 0

OPENR, unit, filename, /GET_LUN

adot = STRPOS(filename, ".")

WHILE (adot NE -1) DO BEGIN
  dot = adot
  adot = STRPOS(filename, ".", adot + 1)
END

ext = STRMID(filename, dot + 1, 100)

IF (ext EQ "bwave") THEN BIN = 1 ELSE BIN = 0

ON_IOERROR, done

curval = getdef(BIN = BIN, /BLOCK)
WHILE (curval NE -1) DO BEGIN				;while new blocks to
  CASE (curval) OF					;the definition type

    258L:BEGIN						;definevdata
	   newnumvars = getnum(BIN = BIN)
  	   newvarnames = strarr(newnumvars)
  	   newvardims = intarr(newnumvars) + 1
  	   FOR i = 0, newnumvars - 1 DO BEGIN		;determine variable
  	     newvarnames(i) = getword(BIN = BIN)	;names and dimensional
  	     parenth = STRPOS(newvarnames(i), "(", 0)	;information if it is
  	     IF(parenth NE -1) THEN BEGIN		;present
  	       newvardims(i) = FIX(STRMID(newvarnames(i), $
  				      parenth + 1, $
  				      10))
	       newvarnames(i) = STRMID(newvarnames(i), $
  				   0, $
  				   parenth)
	       datafieldloc = where(datafieldlist.name EQ newvarnames(i))
	       datafieldlist(datafieldloc).size = $
			datafieldlist(datafieldloc).size * newvardims(i)
  	     ENDIF
  	   ENDFOR
	   newnumdatalines = getnum(BIN = BIN)
  	   newvars = FLTARR(TOTAL(newvardims), newnumdatalines)
	   IF (KEYWORD_SET(BIN)) THEN $
	     READU, unit, newvars $
	   ELSE $
	     READF, unit, newvars
	   varsize = SIZE(variables)
	   IF (varsize(0) EQ 0) THEN BEGIN
	     variables = newvars
	     numvars = newnumvars
	     varnames = newvarnames
	     vardims = newvardims
	   ENDIF ELSE BEGIN
	     newvariables = FLTARR(varsize(1) + $
			TOTAL(newvardims), newnumdatalines)
	     newvariables(0:varsize(1)-1,*) = variables
	     newvariables(varsize(1):*,*) = newvars
	     variables = newvariables
	     numvars = numvars + newnumvars
	     varnames = [varnames, newvarnames]
	     vardims = [vardims, newvardims]
	   ENDELSE
	   END

    259L:BEGIN						;definereg_topology
           topnum = topnum + 1
           IF(KEYWORD_SET(topdesclist)) THEN $
             topdesclist = [topdesclist, topdesc] $
	   ELSE topdesclist = REPLICATE(topdesc, 1)
           topdesclist(topnum - 1).name = getword(BIN = BIN)
	   IF (getdef(BIN = BIN) NE 260L) THEN $	;if not elem_samp
	     MESSAGE, "incorrect format, elem_samp should" + $
			" follow define reg_topology"
	   topdesclist(topnum - 1).elem_samp(0) = getnum(BIN = BIN)
	   topdesclist(topnum - 1).elem_samp(1) = getnum(BIN = BIN)
	   topdesclist(topnum - 1).elem_samp(2) = getnum(BIN = BIN)
	   END

    262L:BEGIN						;define irr_topology
	   gridname = getword(BIN = BIN)
	   countdef = getdef(BIN = BIN)
	   IF (countdef NE 263L) THEN $
		MESSAGE, "incorrect format, count should " +$
			"follow define irr_topology"
	   count = getnum(BIN = BIN)
	   elemsdef = getdef(BIN = BIN)
	   IF (elemsdef NE 264L) THEN $
		MESSAGE, "incorrect format, elems should " +$
			"follow count definition"
	   elemsname = getword(BIN = BIN)
	   elemscount = getnum(BIN = BIN)
	   toss = intarr(4,elemscount)
	   IF (KEYWORD_SET(BIN)) THEN $
	     READU, unit, toss $
	   ELSE $
	     READF, unit, toss
	   toss = 0
	   END

    265L:BEGIN						;define reg_grid
           gridnum = gridnum + 1
           IF(KEYWORD_SET(griddesclist)) THEN $
             griddesclist = [griddesclist,griddesc] $
	   ELSE griddesclist = REPLICATE(griddesc, 1)
           griddesclist(gridnum - 1).name = getword(BIN = BIN)
	   IF (getdef(BIN = BIN) NE 266L) THEN $	;if not grid_samp
	     MESSAGE, "incorrect format, grid_samp should" + $
			" follow define reg_grid"
	   griddesclist(gridnum - 1).grid_samp(0) = getnum(BIN = BIN)
	   griddesclist(gridnum - 1).grid_samp(1) = getnum(BIN = BIN)
	   griddesclist(gridnum - 1).grid_samp(2) = getnum(BIN = BIN)
	   IF (getdef(BIN = BIN) NE 267L) THEN $	;if not origin
	     MESSAGE, "incorrect format, origin" + $
			" follow define grid_samp"
	   orig = fltarr(3)
	   orig(0) = getnum(BIN = BIN)
	   orig(1) = getnum(BIN = BIN)
	   orig(2) = getnum(BIN = BIN)
	   IF (getdef(BIN = BIN) NE 268L) THEN $	;if not step
	     MESSAGE, "incorrect format, step" + $
			" follow define origin"
	   steps = FLTARR(3)
	   steps(0) = getnum(BIN = BIN)
	   steps(1) = getnum(BIN = BIN)
	   steps(2) = getnum(BIN = BIN)
	   END

    270L:BEGIN						;defineirr_grid
	   gridname = getword(BIN = BIN)
	   griddef = getdef(BIN = BIN)
	   IF (griddef NE 271) THEN $
		MESSAGE, "incorrect format, grid_vdata should " +$
			"follow define irr_grid"
	   datafieldnum = datafieldnum + 1
           IF(KEYWORD_SET(datafieldlist)) THEN $
             datafieldlist = [datafieldlist, datafield] $
	   ELSE datafieldlist = REPLICATE(datafield, 1)
           datafieldlist(datafieldnum - 1).name = getword(BIN = BIN)
	   datafieldlist(datafieldnum - 1).size = -1
	   END

    273L:BEGIN						;definemesh
           meshnum = meshnum + 1
           IF(KEYWORD_SET(meshdesclist)) THEN $
             meshdesclist = [meshdesclist, meshdesc] $
           ELSE meshdesclist = REPLICATE(meshdesc, 1)
           meshdesclist(meshnum - 1).name = getword(BIN = BIN)
	   IF (getdef(BIN = BIN) NE 274L) THEN $	;if not mesh_topology
	     MESSAGE, "incorrect format, mesh_topology should" + $
			" follow define mesh"
	   meshdesclist(meshnum - 1).topdesc = getword(BIN = BIN)
	   IF (getdef(BIN = BIN) NE 275L) THEN $	;if not mesh_grid
	     MESSAGE, "incorrect format, mesh_grid" + $
			" follow define mesh_topology"
	   meshdesclist(meshnum - 1).griddesc = getword(BIN = BIN)
	   END

    276L:BEGIN						;definevolume
	     volnum = volnum + 1
             IF(KEYWORD_SET(voldesclist)) THEN $
               voldesclist = [voldesclist,voldesc] $
	     ELSE voldesclist = REPLICATE(voldesc, 1)
             voldesclist(volnum - 1).name = getword(BIN = BIN)
	     IF (getdef(BIN = BIN) NE 277L) THEN $	;if not define vol_mesh
	       MESSAGE, "incorrect format, volume_mesh should" + $
			" follow define volume"
	     voldesclist(volnum - 1).volmeshdesc = getword(BIN = BIN)
	     IF (getdef(BIN = BIN) NE 278L) THEN $     ;if not define vol_dvata
	       MESSAGE, "incorrect format, volume_vdata should" + $
			" follow define volume_mesh"
	     voldesclist(volnum - 1).voldata = getword(BIN = BIN)
	     datafieldnum = datafieldnum + 1
             IF(KEYWORD_SET(datafieldlist)) THEN $
               datafieldlist = [datafieldlist, datafield] $
	     ELSE datafieldlist = REPLICATE(datafield, 1)
             datafieldlist(datafieldnum - 1).name = $
			voldesclist(volnum - 1).name
	     datafieldlist(datafieldnum - 1).size = 1
	   END
    ELSE: print, "no case for type ", curval
  ENDCASE
  curval = getdef(BIN = BIN, /BLOCK)
ENDWHILE

done:

FREE_LUN, unit

nomesh = 0

FOR i = 0, volnum - 1 DO BEGIN
  IF (meshnum EQ 0) OR (gridnum EQ 0) OR (topnum EQ 0) THEN BEGIN
    nomesh = 1
  ENDIF ELSE BEGIN
    meshloc = WHERE(voldesclist(i).volmeshdesc EQ $
 		  meshdesclist.name, meshfound)
    dataloc = WHERE(voldesclist(i).voldata EQ $
  		  varnames, datafound)
    IF ((NOT meshfound) OR (NOT datafound)) THEN nomesh = 1
    toploc = WHERE(meshdesclist(meshloc).topdesc EQ $
  		 topdesclist.name, topfound)
    gridloc = WHERE(meshdesclist(meshloc).griddesc EQ $
  		 griddesclist.name, gridfound)
    IF ((NOT topfound) OR (NOT gridfound))THEN nomesh = 1

    griddims = griddesclist(gridloc).grid_samp( $
  	WHERE(griddesclist(gridloc).grid_samp NE 0))
  ENDELSE
ENDFOR

IF NOT(nomesh) THEN BEGIN
  variables = reform(variables, [TOTAL(vardims), griddims])
  MESHNAMES = meshdesclist.name
ENDIF

names = voldesclist.name

startindex = 0
FOR i = 0, datafieldnum - 1 DO BEGIN
  IF(datafieldlist(i).size GE 1) THEN BEGIN
    IF (KEYWORD_SET(validdata)) THEN BEGIN
      validdata = [validdata, INDGEN(datafieldlist(i).size) + startindex]
      dimensions = [dimensions, datafieldlist(i).size]
    ENDIF ELSE BEGIN
      validdata = INDGEN(datafieldlist(i).size) + startindex
      dimensions = datafieldlist(i).size
    ENDELSE
  ENDIF
  startindex = startindex + ABS(datafieldlist(i).size)
ENDFOR

variables = variables(validdata, *, *, *)

END
; $Id: read_x11_bitmap.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;+
; NAME:
;	READ_X11_BITMAP
;
; PURPOSE:
;	Read bitmaps stored in the X11 format.
;
;	The X Windows bitmap(1) program produces a C header file
;	containing the definition of a bitmap produced by that program.
;	This procedure reads such a file and creates an IDL byte array
;	containing the bitmap.
;
;	This procedure is used primarily to read bitmaps to be used as
;	IDL widget button labels.
;
; CATEGORY:
;	Bitmaps, X Windows, widgets.
;
; CALLING SEQUENCE:
;	READ_X11_BITMAP, File, Bitmap [, X, Y]
;
; INPUTS:
;	File: The name of the file containing the bitmap.
;
; KEYWORD PARAMETERS:
;
;	EXPAND_TO_BYTES: return a 2-D array which has one bit per byte
;		(0 for a 0 bit), (255 for a 1 bit) instead. (See example)
;
; OUTPUTS:
;	Bitmap: The variable in which to store the bitmap.  This variable
;		is returned as a byte array.
;
; OPTIONAL OUTPUT PARAMETERS:
;	X:	The width of the bitmap is returned in this variable.
;
;	Y:	The height of the bitmap is returned in this variable.
;
; COMMON BLOCKS:
;	None.
;
; EXAMPLE:
;	To open and read the X11 bitmap file named "my.x11" in the current 
;	directory, store the bitmap in the variable BITMAP1, and the width
;	and height in the variables X and Y, enter:
;
;		READ_X11_BITMAP, "my.x11", BITMAP1, X, Y
;
;	To display the new bitmap, enter:
;
;		READ_X11_BITMAP, "my.x11", Image, /EXPAND_TO_BYTES
;		TV, Image, /ORDER
;
; MODIFICATION HISTORY:
;	10 January 1991, AB
;	1 Apr, 1992, CF fixed bug with bitmaps larger than 32k bytes.
;	24 March 1993, JWG fixed EXPAND_TO_BYTES option
;-
;

pro READ_X11_BITMAP, FILE, BITMAP, X, Y, EXPAND_TO_BYTES=EXPAND

on_error, 2		; On error, return to caller

expand	= keyword_set(expand)

; This array, indexed by an ASCII character, returns the hex value associated
; with that character in the least significant 4 bits of the byte.
lo_ascii=bytarr(256, /nozero)
lo_ascii((byte('0'))(0):(byte('9'))(0)) = bindgen(10)
lo_ascii((byte('A'))(0):(byte('F'))(0)) = bindgen(6)+10B
lo_ascii((byte('a'))(0):(byte('f'))(0)) = bindgen(6)+10B

; This array, indexed by an ASCII character, returns the hex value associated
; with that character in the most significant 4 bits of the byte.
hi_ascii=bytarr(256, /nozero)
hi_ascii((byte('0'))(0):(byte('9'))(0)) = bindgen(10)*16B
hi_ascii((byte('A'))(0):(byte('F'))(0)) = (bindgen(6)+10)*16B
hi_ascii((byte('a'))(0):(byte('f'))(0)) = (bindgen(6)+10)*16B


openr, unit, file, /get_lun

; The width
line = ''
while (((p=strpos(line, '_width'))) eq -1) do begin
  if (eof(unit)) then message,'Not an X11 bitmap file: ' + FILE
  readf, unit, line
endwhile
x = long(strmid(line, p+6, 32767))

; The height
readf, unit, line
while (((p=strpos(line, '_height'))) eq -1) do readf, unit, line
y = long(strmid(line, p+7, 32767))

; The result array
  x_bytes = (x + 7) / 8
  BITMAP=bytarr(X_BYTES, Y, /nozero)

; Get to the start of the data
while (((p=strpos(line, '[]'))) eq -1) do readf, unit, line

; Read it
readf, unit, line
pos=0
for i = 0L, x_bytes * y - 1 do begin
  pos = strpos(line, '0x', pos)
  if (pos eq -1) then begin
    readf, unit, line
    pos = strpos(line, '0x')
  endif
  tmp = byte(strmid(line, pos+2, 2))
  pos=pos+4
  bitmap(i) = hi_ascii(tmp(0)) + lo_ascii(tmp(1))
endfor

  if (expand) then begin
    tmp=bitmap
    bitmap=bytarr(X, Y)
    for i=0,X-1 do begin
	byte = i / 8
	mask = 2 ^ (i mod 8)
	ind = where( tmp(byte,*) and mask, count)
	if count ne 0 then bitmap(i, ind) = 255
    endfor
  endif
free_lun, unit
end
; $Id: read_xwd.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION READ_XWD, FILE_NAME, RED, GREEN, BLUE
;+
; NAME:
;	READ_XWD
;
; PURPOSE:
;	Read the contents of files created by the XWD (X Windows Dump)
;	command and return the image and color table vectors in the form of
;	IDL variables.
;
; CATEGORY:
;	Input/Output.
;
; CALL:
;	Result = READ_XWD(File_Name [, R, G, B])
;
; INPUTS:
;   File_Name:	Scalar string giving the name of the xwd file to read
;
; OUTPUTS:
;	READ_XWD returns a 2D byte array containing the image.  If the file
;	cannot be open or read, the return value is zero.
;
; OPTIONAL OUTPUT PARAMETERS:
;     R, G, B:	The variables to contain the Red, Green, and Blue color
;		vectors if the XWD file contains color tables.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	I/O is performed.
;
; RESTRICTIONS:
;	This function is intended to be used only on files containing
;	8-bit pixmaps.  It is not intended to be used with all XWD files.
;	No guarantees are made that all XWD files will work with this routine.
;	This routine will not work with XWD files with version less than 6.
;
; PROCEDURE:
;	The header is read into a structure and the bytes are reversed
;	if necessary.  Then the colormap and image portions of the
;	file are read into their respective variables.
;
; EXAMPLE:
;	To open and read the X Windows Dump file named "my.xwd" in the current
;	directory, store the image in the variable IMAGE1, and store the color 
;	vectors in the variables, R, G, and B, enter:
;
;		IMAGE1 = READ_XWD("my.xwd", R, G, B)
;
;	To load the new color table and display the image, enter:
;
;		TVLCT, R, G, B
;		TV, IMAGE1
;
;
; MODIFICATION HISTORY:
;	September, 1990 DMS and SMR, Research Systems, Inc.
;-


on_error, 2				; return to caller on error
on_ioerror, error			; goto error section on error
openr,unit, FILE_NAME, /get_lun		; open the file

hdr = { XWD_FILE_HEADER, $		; definition of xwd header struct
	header_size : 0L, $
	file_version : 0L, $
	pixmap_format: 0L, $
	pixmap_depth: 0L, $
	pixmap_width: 0L, $
	pixmap_height: 0L, $
	xoffset: 0L, $
	byte_order: 0L, $
	bitmap_unit: 0L, $
	bitmap_bit_order: 0L, $
	bitmap_pad: 0L, $
	bits_per_pixel: 0L, $
	bytes_per_line: 0L, $
	visual_class: 0L, $
	red_mask: 0L, $
	green_mask: 0L, $
	blue_mask: 0L, $
	bits_per_rgb: 0L, $
	colormap_entries: 0L, $
	ncolors: 0L, $
	window_width: 0L, $
	window_height: 0L, $
	window_x: 0L, $
	window_y: 0L, $
	window_bdrwidth: 0L }

Color = { XWDColor, $			;The xwd color element structure
	pixel: 0L, $
	red: 0,$
	green: 0, $
	blue: 0, $
	flags: 0B, $
	pad: 0B }	

readu, unit, hdr			; read the header
test = 1L				; do a test to check the system's byte
byteorder, test, /htonl			; order. If needed switch the byte 
if (test ne 1L) then $			; order to correspond to network byte
   byteorder, hdr, /htonl		; order

point_lun, unit, hdr.header_size	; seek to beginning of colormap

colormap = replicate(color, hdr.ncolors)
readu, unit, colormap			; read the colormap entries from file

if hdr.pixmap_format ne 2 then begin
	message,'READ_XWD: can only handle Z format pixmaps.'
	endif


IMAGE = bytarr(hdr.pixmap_width, hdr.pixmap_height)  ;Create the pixmap
line = bytarr(hdr.bytes_per_line)		; get one scan line

for i=0, hdr.pixmap_height-1 do begin	;Read each scan line
	readu, unit, line		
	if hdr.pixmap_width eq hdr.bytes_per_line then $
		IMAGE(0,hdr.pixmap_height - i -1) = line $
	else image(0, hdr.pixmap_height - i - 1) = line(0:hdr.pixmap_width-1)
	endfor

free_lun, unit				; close and free the file

pixel = colormap.pixel			; Extract pixel value separately
if test ne 1L then begin		; switch byte order if needed
	byteorder, colormap, /htons	; Swap whole structure
	byteorder, pixel, /htonl	; & pixel separately
	endif
RED = ishft(colormap.red, -8)
GREEN = ishft(colormap.green, -8)
BLUE = ishft(colormap.blue, -8)

return, IMAGE

;------------ the error message ------------

error: message, "READ_XWD: Error reading file: " + FILE_NAME
end


; $Id: recon3.pro,v 1.8 1994/11/23 02:31:47 dan Exp $

;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;
;+
; NAME:
;	RECON3
;
; PURPOSE:
;	This function can reconstruct a 3-dimensional data array from
;       two or more images (or projections) of an object.   For example,
;       if you placed a dark object in front of a white background and
;       then photographed it three times (each time rotating the object a
;       known amount) then these three images could be used with RECON3
;       to approximate a 3-D volumetric representation of the object.
;       RECON3 also works with translucent projections of an object.
;       RECON3 returns a 3-D byte array.   RECON3 uses the back-projection
;       method.   In medical imaging and other applications, a method
;       known as "Filtered Backprojection" is often desired.   This may
;       be accomplished here by first filtering the images as desired,
;       and then using the filtered images for the reconstruction.
;
; CATEGORY:
;	Volume Reconstruction
;
; CALLING SEQUENCE:
;       vol = RECON3(Images, Obj_Rot, Obj_Pos, Focal, Dist, $
;                    Vol_Pos, Img_Ref, Img_Mag, Vol_Size)
;
; INPUTS:
;       Images:   The images to use to reconstruct the volume.   Execution
;                 time increases linearly with more images.
;                 Data Type: 8-bit (byte) array with dimensions (x, y, n)
;                 where x is the horizontal image dimension, y is the vertical
;                 image dimension, and n is the number of images.
;
;       Obj_Rot:  The the amount the object is rotated to make it appear as
;                 it does in each image.   The object is first rotated
;                 about the X axis, then about the Y axis, and finally
;                 about the Z axis (with the object's reference point at the
;                 origin.
;                 Data Type: (3, n) Float array where Obj_Rot(0, *) is the X
;                 rotation for each image, Obj_Rot(1, *) is the Y rotation, 
;                 and Obj_Rot(2, *) is the Z rotation.
;                 
;       Obj_Pos:  The position of the the object's reference point RELATIVE to
;                 the camera lens.   The camera lens is located at the
;                 coordinate origin and points in the negative Z direction
;                 (the view up vector points in the positive Y direction).
;                 Obj_Pos should be expressed in this coordinate system.
;                 The values for Obj_Pos, Focal, Dist, and Vol_Pos should all
;                 be expressed in the same units (mm, cm, m, in, ft, etc.).
;                 Data Type: (3, n) Float array where Obj_Pos(0, *) is the X
;                 position for each image, Obj_Pos(1, *) is the Y position, 
;                 and Obj_Pos(2, *) is the Z position.   All the values in
;                 Obj_Pos(2, *) should be less than zero.
;
;       Focal:    The focal length of the lens for each image.   Focal may be
;                 set to zero to indicate a parallel image projection
;                 (infinite focal length).
;                 Data Type: Float array with n elements.
;
;       Dist:     The distance from the camera lens to the image plane (film)
;                 for each image.   Dist should be greater than Focal.
;                 Data Type: Float array with n elements.
;
;       Vol_Pos:  The two opposite corners of a cube that surrounds the object.
;                 Vol_Pos should be expressed in the object's coordinate system
;                 RELATIVE to the object's reference point.
;                 Data Type: (3, 2) Float array where Vol_Pos(*, 0) specifies
;                 one corner and Vol_Pos(*, 1) specifies the opposite corner.
;
;       Img_Ref:  The pixel location at which the object's reference point
;                 appears in each of the images.
;                 Data Type: (2, n) Int or Float array where Img_Ref(0, *) is
;                 the X coordinate for each image and Img_Ref(1, *) is the Y
;                 coordinate.
;
;       Img_Mag:  The magnification factor for each image.   This number is
;                 actually the length (in pixels) that a test object would
;                 appear in an image if it were N units long and N units
;                 distant from the camera lens.
;                 Data Type: (2, n) Int or float array where Img_Mag(0, *) is
;                 the X dimension (in pixels) of a test object for each image,
;                 and Img_Mag(1, *) is the Y dimension.   All elements in
;                 Img_Mag should be greater than or equal to 1.
;
;       Vol_Size: The size of the volume to return.   The returned volume will
;                 be a 3-D byte array with dimensions equal to Vol_Size.
;                 Execution time (and resolution) increases exponentially with
;                 larger values for Vol_Size.
;                 Data Type: Int array with 3 elements where Vol_Size(0)
;                 specifies the X dimension of the volume, Vol_Size(1) specifies
;                 the Y dimension, and Vol_Size(2) specifies the Z dimension.
;
; KEYWORD PARAMETERS:
;       CUBIC:    If set, then cubic interpolation is used.   The default is
;                 to use tri-linear interpolation, which is slightly faster.
;
;       MISSING:  The value for cells in the 3-D volume that do not map to
;                 any of the supplied images.   The Missing value is passed
;                 to the IDL "INTERPOLATE" function.
;                 Data Type: Byte.
;                 Default : 0B
;
;       MODE:     If Mode is less than zero then each cell in the 3-D volume
;                 is the MINIMUM of the corresponding pixels in the images.
;                 If Mode is greater than zero then each cell in the 3-D volume
;                 is the MAXIMUM of the corresponding pixels in the images.
;                 If Mode is equal to zero then each cell in the 3-D volume
;                 is the AVERAGE of the corresponding pixels in the images.
;                 Mode should usually be (-1) when the images contain a bright
;                 object in front of a dark background.   Mode should usually
;                 be (+1) when the images contain a dark object in front of a
;                 light background.   AVERAGE mode requires more memory since
;                 the volume array must temporarily be kept as an INT array
;                 instead of a BYTE array.
;                 Data Type: Int
;                 Default : 0 (average cells)
;
; OUTPUTS:
;	RECON3 returns a 3-D byte array containing the reconstructed object.
;
;       If the images contain low (dark) values where the object is and high
;       (bright) values where the object isn't, then Mode should be set to (+1).
;       If the above is true then the returned volume will have low values
;       where the object is, and high values where the object isn't.
;
;       If the images contain high (bright) values where the object is and low
;       (dark) values where the object isn't, then Mode should be set to (-1).
;       If the above is true then the returned volume will have high values
;       where the object is, and low values where the object isn't.
;
; RESTRICTIONS:
;       In general, the object must be CONVEX for a good reconstruction to be
;       possible.   Concave regions are not easily reconstructed.
;       An empty coffee cup, for example, would be reconstructed as if it
;       were full.
;
;	The images should show strong light/dark contrast between the object
;       and the background.
;
;       The more images the better.   Images from many different angles will
;       improve the quality of the reconstruction.   It is also important to
;       supply images that are parallel and perpendicular to any axes of
;       symmetry.   Using the coffee cup as an example, at least one image
;       should be looking through the opening in the handle.
;
;       Telephoto images are also better for reconstruction purposes than
;       wide angle images.
;
; PROCEDURE:
;	A 4x4 transformation matrix is created for each image based upon the
;       parameters Obj_Rot, Obj_Pos, Focal, Dist, and Img_Ref.   Each cell in
;       the volume is assigned a 3-D coordinate based upon the parameters
;       Vol_Pos and Vol_Size.   These coordinates are multiplied by the
;       transformation matricies to produce x,y image coordinates.   Each cell
;       in the volume is assigned a value that is the AVERAGE, MINIMUM, or
;       MAXIMUM of the image values at the x,y position (depending on Mode).
;
; EXAMPLE:
; ------------------------------------------------------------------------------
;       ; Assumptions for this example :
;       ; The object's major axis is parallel to the Z axis.
;       ; The object's reference point is at its center.
;       ; The camera lens is pointed directly at this reference point.
;       ; The reference point is 5000 mm in front of the camera lens.
;       ; The focal length of the camera lens is 200 mm.
;
;       ; If the camera is focused on the reference point, then the
;       ; distance from the lens to the camera's image plane must be
;       ;    dist = (d * f) / (d - f) =
;       ;    (5000 * 200) / (5000 - 200) = (1000000 / 4800) = 208.333 mm
;
;       ; The object is roughly 600 mm wide and 600 mm high.
;       ; The reference point appears in the exact center of each image.
;
;       ;  If the object is 600 mm high and 5000 mm distant from the camera
;       ;  lens, then the object image height must be
;       ;     hi = (h * f) / (d - f)  =
;       ;     (600 * 200) / (5000 - 200) = (120000 / 4800) = 25.0 mm
;       ;  The object image appears 200 pixels high so the final magnification
;       ;  factor is
;       ;     img_mag = (200 / 25) = 8.0
; 
;
;       imgy = 256
;       frames = 3
; 
;       images = Bytarr(imgx, imgy, frames, /Nozero)
;       obj_rot = Fltarr(3, frames)
;       obj_pos = Fltarr(3, frames)
;       focal = Fltarr(frames)
;       dist = Fltarr(frames)
;       vol_pos = Fltarr(3, 2)
;       img_ref = Fltarr(2, frames)
;       img_mag = Fltarr(2, frames)
; 
;       vol_size = [40, 40, 40]
; 
;       ; The object is 5000 mm directly in front of the camera.
;       obj_pos(0, *) =     0.0
;       obj_pos(1, *) =     0.0
;       obj_pos(2, *) = -5000.0
; 
;       ; The focal length of the lens is constant for all the images.
;       focal(*) = 200.0
; 
;       ; The distance from the lens to the image plane is also constant.
;       dist(*) = 208.333
; 
;       ; The cube surrounding the object is 600 mm X 600 mm.
;       vol_pos(*, 0) = [-300.0, -300.0, -300.0]
;       vol_pos(*, 1) = [ 300.0,  300.0,  300.0]
; 
;       ; The image reference point appears at the center of all the images.
;       img_ref(0, *) = imgx / 2
;       img_ref(1, *) = imgy / 2
; 
;       ; The image magnification factor is constant for all images.
;       ; (The images haven't been cropped or resized).
;       img_mag(*, *) = 8.0
; 
;       ; Only the object rotation changes from one image to the next.
;       ; Note that the object is rotated about the X axis first, then Y,
;       ; and then Z.
; 
;       ; Create some fake images for this example.
;       images(30:160, 20:230, 0) = 255
;       images(110:180, 160:180, 0) = 180
;       obj_rot(*, 0) = [-90.0, 0.0, 0.0]
; 
;       images(70:140, 100:130, 1) = 255
;       obj_rot(*, 1) = [-70.0, 75.0, 0.0]
; 
;       images(10:140, 70:170, 2) = 255
;       images(80:90, 170:240, 2) = 150
;       obj_rot(*, 1) = [-130.0, 215.0, 0.0]
; 
;       ; Reconstruct the volume.
;       vol = RECON3(images, obj_rot, obj_pos, focal, dist, vol_pos, img_ref, $
;                    img_mag, vol_size, Missing=255B, Mode=(-1))
; ------------------------------------------------------------------------------
;
; MODIFICATION HISTORY:
; 	Written by:	Daniel Carr	Thu Feb  4 02:54:29 MST 1993
;	KDB - 23 Dec., 1993 - Variable dist had a conflict with Userlib
;			      function DIST and could cause compile errors.
;			      Renamed variable dist to distance.
;       Modified by:    Daniel Carr     Mon Nov 21 14:21:57 MST 1994
;          Improved performance and added CUBIC keyword.
;       Modified by:    Daniel Carr     Tue Nov 22 12:18:15 MST 1994
;          Fixed bug which affected small focal length images.
;          Improved performance again.
;-

FUNCTION RECON3, images, obj_rot, obj_pos, focal, distance, vol_pos, img_ref, $
                 img_mag, vol_size, Missing=missing, Mode=mode, Cubic=cubic

; *** Check inputs.

sz_images = Size(images)
IF (sz_images(0) NE 3) THEN $
   Message, 'Image array must have 3 dimensions.'
frames = sz_images(3)
ysize = sz_images(2)
xsize = sz_images(1)

sz_obj_rot = Size(obj_rot)
IF (sz_obj_rot(0) NE 2) THEN $
   Message, 'Obj_Rot must be a (3, n) array.'
IF (sz_obj_rot(1) NE 3) THEN $
   Message, 'Obj_Rot must be a (3, n) array.'
IF (sz_obj_rot(2) NE frames) THEN $
   Message, 'Obj_Rot must be a (3, n) array, where n is the number of images.'
obj_rot1 = Float(obj_rot)

sz_obj_pos = Size(obj_pos)
IF (sz_obj_pos(0) NE 2) THEN $
   Message, 'Obj_Pos must be a (3, n) array.'
IF (sz_obj_pos(1) NE 3) THEN $
   Message, 'Obj_Pos must be a (3, n) array.'
IF (sz_obj_pos(2) NE frames) THEN $
   Message, 'Obj_Pos must be a (3, n) array, where n is the number of images.'
ind = Where(obj_pos(2, *) GE 0.0)
IF (ind(0) GE 0) THEN $
   Message, 'The object Z position must be < 0 for all images.'
obj_pos1 = Float(obj_pos)

IF (N_Elements(focal) NE frames) THEN $
   Message, $
      'Focal must contain the same number of elements as there are images.'
ind = Where(focal(*) LE 0.0)
IF (ind(0) GE 0) THEN $
   Message, 'Focal must be > 0 for all images.'
focal1 = Float(focal(*))

IF (N_Elements(distance) NE frames) THEN $
   Message, 'Len must contain the same number of elements as Focal.'
ind = Where(distance(*) LE focal(*))
IF (ind(0) GE 0) THEN $
   Message, 'Len must be greater than Focal for all images.'
dist1 = Float(distance(*))

sz_vol_pos = Size(vol_pos)
IF (sz_vol_pos(0) NE 2) THEN $
   Message, 'Vol_Pos must be a (3, 2) array.'
IF (sz_vol_pos(1) NE 3) THEN $
   Message, 'Vol_Pos must be a (3, 2) array.'
IF (sz_vol_pos(2) NE 2) THEN $
   Message, 'Vol_Pos must be a (3, 2) array.'
vol_pos1 = Float(vol_pos)
IF (vol_pos(0, 0) EQ vol_pos(0, 1)) THEN $
   Message, 'Vol_Pos contains invalid X coordinates.'
IF (vol_pos(1, 0) EQ vol_pos(1, 1)) THEN $
   Message, 'Vol_Pos contains invalid Y coordinates.'
IF (vol_pos(2, 0) EQ vol_pos(2, 1)) THEN $
   Message, 'Vol_Pos contains invalid Z coordinates.'
vpx1 = vol_pos(0, 0) < vol_pos(0, 1)
vpy1 = vol_pos(1, 0) < vol_pos(1, 1)
vpz1 = vol_pos(2, 0) < vol_pos(2, 1)
vpx2 = vol_pos(0, 0) > vol_pos(0, 1)
vpy2 = vol_pos(1, 0) > vol_pos(1, 1)
vpz2 = vol_pos(2, 0) > vol_pos(2, 1)

sz_img_ref = Size(img_ref)
IF (sz_img_ref(0) NE 2) THEN $
   Message, 'Img_Ref must be a (2, n) array.'
IF (sz_img_ref(1) NE 2) THEN $
   Message, 'Img_Ref must be a (2, n) array.'
IF (sz_img_ref(2) NE frames) THEN $
   Message, 'Img_Ref must be a (2, n) array, where n is the number of images.'
img_ref1 = Float(img_ref)

sz_img_mag = Size(img_mag)
IF (sz_img_mag(0) NE 2) THEN $
   Message, 'Img_Mag must be a (2, n) array.'
IF (sz_img_mag(1) NE 2) THEN $
   Message, 'Img_Mag must be a (2, n) array.'
IF (sz_img_mag(2) NE frames) THEN $
   Message, 'Img_Mag must be a (2, n) array, where n is the number of images.'
ind = Where(img_mag(*) LT 1)
IF (ind(0) GE 0L) THEN $
   Message, 'All elements in Img_Mag must be >= 1.'
img_mag1 = Float(img_mag)

IF (N_Elements(vol_size) NE 3) THEN $
   Message, 'Vol_size must contain 3 elements.'
vol_size1 = Long(Abs(vol_size(*)))

; *** Check keywords.

miss = 0B
IF (N_Elements(missing) GT 0L) THEN miss = Byte(missing(0))

eval_mode = 0
IF (N_Elements(mode) GT 0L) THEN eval_mode = Fix(mode(0))

; *** Set up variables.

vx = vol_size1(0)
vy = vol_size1(1)
vz = vol_size1(2)
vxm1 = vx - 1
vym1 = vy - 1
vzm1 = vz - 1

; *** Cell coordinates.
rx = ((vpx2 - vpx1) * Findgen(vx) / Float(vxm1)) + vpx1
ry = ((vpy2 - vpy1) * Findgen(vy) / Float(vym1)) + vpy1
rz = ((vpz2 - vpz1) * Findgen(vz) / Float(vzm1)) + vpz1
xplane = Reform((Temporary(rx) # Replicate(1.0, vy)), (vx * vy))
yplane = Reform((Replicate(1.0, vx) # Temporary(ry)), (vx * vy))
coords = [[Temporary(xplane)], [Temporary(yplane)], $
          [Fltarr((vx * vy), /Nozero)], [Replicate(1.0, (vx * vy))]]

; *** Save current view matrix.
save_t3d = !P.T

; *** Create the volume.
IF (eval_mode GT 0) THEN vol = Bytarr(vx, vy, vz)
IF (eval_mode EQ 0) THEN vol = Intarr(vx, vy, vz)
IF (eval_mode LT 0) THEN vol = Replicate(255B, vx, vy, vz)

FOR j=0, (frames-1) DO BEGIN
   ; *** Set up transform.
   T3d, /Reset
   T3d, Rotate=[obj_rot1(0, j), 0.0, 0.0]
   T3d, Rotate=[0.0, obj_rot1(1, j), 0.0]
   T3d, Rotate=[0.0, 0.0, obj_rot1(2, j)]
   T3d, Translate=obj_pos1(*, j)
   IF (focal1(j) GT 0.0) THEN BEGIN
      T3d, Translate=[0.0, 0.0, -dist1(j)]
      T3d, Perspective=$
           ((focal1(j) / obj_pos1(2, j)) * (obj_pos1(2, j) - dist1(j)))
   ENDIF
   T3d, Scale=[img_mag1(0, j), img_mag1(1, j), 1.0]
   T3d, Translate=[img_ref1(0, j), img_ref1(1, j), 0.0]

   ; *** Fill in the volume one plane at a time.
   FOR i=0, vzm1 DO BEGIN
      coords(0, 2) = Replicate(rz(i), (vx * vy))
      plane_index = coords # !P.T
      vol_x  = plane_index(*, 0) / plane_index(*, 3)
      vol_y  = plane_index(*, 1) / plane_index(*, 3)

      IF (eval_mode LT 0) THEN $
         vol(0, 0, i) = vol(*, *, i) < $
            Interpolate(images(*, *, j), vol_x, vol_y, Missing=miss, $
                        Cubic=Keyword_Set(cubic))

      IF (eval_mode GT 0) THEN $
         vol(0, 0, i) = vol(*, *, i) > $
            Interpolate(images(*, *, j), vol_x, vol_y, Missing=miss, $
                        Cubic=Keyword_Set(cubic))

      IF (eval_mode EQ 0) THEN $
         vol(0, 0, i) = vol(*, *, i) + $
            Fix(Interpolate(images(*, *, j), vol_x, vol_y, Missing=miss, $
                            Cubic=Keyword_Set(cubic)))

   ENDFOR
   Print, 'Completed image ' + String(j+1)
ENDFOR

IF (eval_mode EQ 0) THEN vol = Byte(vol / frames)

; *** Restore view matrix.
!P.T = save_t3d

RETURN, vol
END
; $Id: reduce_colors.pro,v 1.2 1993/10/06 16:34:05 doug Exp $

PRO REDUCE_COLORS, Image, Values
;+
; NAME:
;	REDUCE_COLORS
;
; PURPOSE:
;	This procedure reduces the number of colors used in an image
;	by eliminating pixel values without members.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	REDUCE_COLORS, Image, Values
;
; INPUTS:
;	Image:  The original image array. Note that the input array is
;		replaced by its color-reduced equivalent.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	Image:  The color-reduced image array.
;	Values: A vector of non-zero pixel values. If Image contains
;		pixel values from 0 to M, Values will be an M+1 element
;		vector containing the mapping from the old values to
;		the new. Values(I) contains the new color index of old
;		pixel index I.
;
; SIDE EFFECTS:
;	Input array is overwritten.
;
; PROCEDURE:
;	The pixel distribution histogram is obtained and the WHERE
;	function is used to find bins with non-zero values. Next,
;	a lookup table is made where table(old_pixel_value) contains
;	new_pixel_value, and then applied to the image.
;		
; EXAMPLE:
;	To reduce the number of colors and display an image with the
;	original color tables R, G, B:
;	  REDUCE_COLORS, Image, V
;	  TVLCT, R(V), G(V), B(V)
;
; MODIFICATION HISTORY:
;	DMS,	RSI, Oct, 1992.
;-

h = histogram(image, omax = mx, min = 0) ;Find distribution
Values = where(h)			;Non-zero elements
	;Make translation table using lowest possible precision
if mx le 255 then table = bytarr(mx+1) $
else if mx le 32767 then table = intarr(mx+1L) $
else table = lonarr(mx+1L)

table(values) = lindgen(n_elements(values))	;Fill the table

	;Translate to reduced palette
image = table(temporary(image))
end
; $Id: regress.pro,v 1.2 1993/10/26 23:29:57 doug Exp $

FUNCTION REGRESS,X,Y,W,YFIT,A0,SIGMA,FTEST,R,RMUL,CHISQ, $
                 RELATIVE_weight=relative_weight
;+
; NAME:
;	REGRESS
;
; PURPOSE:
;	Perform a multiple linear regression fit.
;
;	REGRESS fits the function:
;		Y(i) = A0 + A(0)*X(0,i) + A(1)*X(1,i) + ... + 
;                      A(Nterms-1)*X(Nterms-1,i)
;
; CATEGORY:
;       G2 - Correlation and regression analysis.
;
; CALLING SEQUENCE:
;	Result = REGRESS(X, Y, W, Yfit, A0, Sigma, Ftest, R, Rmul, Chisq)
;
; INPUTS:
;       X:	The array of independent variable data.  X must 
;		be dimensioned as an array of Nterms by Npoints, where 
;		there are Nterms coefficients (independent variables) to be 
;		found and Npoints of samples.
;
;       Y:	The vector of dependent variable points.  Y must have Npoints 
;		elements.
;
;	W:	The vector of weights for each equation.  W must be a vector
;		of Npoints elements.  For instrumental weighting, 
;		W(i) = 1/standard_deviation(Y(i))^2.  For statistical 
;		weighting, w(i) = 1./Y(i).  For no weighting, set w(i)=1,
;		and also set the RELATIVE_WEIGHT keyword.
;
; OUTPUTS:
;	REGRESS returns a column vector of coefficients that has Nterms 
;	elements.
;
; OPTIONAL OUTPUT PARAMETERS:
;	Yfit:	Vector of calculated values of Y with Npoints elements.
;
;	A0:	Constant term.
;
;	Sigma:	Vector of standard deviations for coefficients.
;
;	Ftest:	The value of F for test of fit.
;
;	Rmul:	The multiple linear correlation coefficient.
;
;	R:	Vector of linear correlation coefficients.
;
;	Rmul:   The multiple linear correlation coefficient.
;
;	Chisq:	Reduced, weighted chi squared.
;
; KEYWORDS:
; RELATIVE_WEIGHT:  If this keyword is set, the input weights
;		(W vector) are assumed to be relative values, and not based
;		on known uncertainties in the Y vector.  Set this keyword in 
;		the case of no weighting, W(*) = 1.
;
; PROCEDURE:
;	Adapted from the program REGRES, Page 172, 
;	Bevington, Data Reduction and Error Analysis for the 
;	Physical Sciences, 1969.
;
; MODIFICATION HISTORY:
;	Written, DMS, RSI, September, 1982.
;	Added RELATIVE_WEIGHT keyword    W. Landsman   August 1991
;       Fixed bug in invert  Bobby Candey 1991 April 22
;-
;
On_error,2              ;Return to caller if an error occurs 
SY = SIZE(Y)            ;Get dimensions of x and y.  
SX = SIZE(X)
IF (N_ELEMENTS(W) NE SY(1)) OR (SX(0) NE 2) OR (SY(1) NE SX(2)) THEN $
  message, 'Incompatible arrays.'
;
NTERM = SX(1)           ;# OF TERMS
NPTS = SY(1)            ;# OF OBSERVATIONS
;
SW = TOTAL(W)           ;SUM OF WEIGHTS
YMEAN = TOTAL(Y*W)/SW   ;Y MEAN
XMEAN = (X * (REPLICATE(1.,NTERM) # W)) # REPLICATE(1./SW,NPTS)
WMEAN = SW/NPTS
WW = W/WMEAN
;
NFREE = NPTS-1          ;DEGS OF FREEDOM
SIGMAY = SQRT(TOTAL(WW * (Y-YMEAN)^2)/NFREE) ;W*(Y(I)-YMEAN)
XX = X- XMEAN # REPLICATE(1.,NPTS)      ;X(J,I) - XMEAN(I)
WX = REPLICATE(1.,NTERM) # WW * XX      ;W(I)*(X(J,I)-XMEAN(I))
SIGMAX = SQRT( XX*WX # REPLICATE(1./NFREE,NPTS)) ;W(I)*(X(J,I)-XM)*(X(K,I)-XM)
R = WX #(Y - YMEAN) / (SIGMAX * SIGMAY * NFREE)
ARRAY = (WX # TRANSPOSE(XX))/(NFREE * SIGMAX #SIGMAX)
IF (SX(1) EQ 1) THEN ARRAY = 1 / ARRAY ELSE ARRAY = INVERT(Array)
A = (R # ARRAY)*(SIGMAY/SIGMAX)         ;GET COEFFICIENTS
YFIT = A # X                            ;COMPUTE FIT
A0 = YMEAN - TOTAL(A*XMEAN)             ;CONSTANT TERM
YFIT = YFIT + A0                        ;ADD IT IN
FREEN = NPTS-NTERM-1 > 1                ;DEGS OF FREEDOM, AT LEAST 1.
CHISQ = TOTAL(WW*(Y-YFIT)^2)*WMEAN/FREEN ;WEIGHTED CHI SQUARED
IF KEYWORD_SET(relative_weight) then varnce = chisq $
                                else varnce = 1./wmean
sigma = sqrt(array(indgen(nterm)*(nterm+1))*varnce/(nfree*sigmax^2)) ;Error term
RMUL = TOTAL(A*R*SIGMAX/SIGMAY)         ;MULTIPLE LIN REG COEFF
IF RMUL LT 1. THEN FTEST = RMUL/NTERM / ((1.-RMUL)/FREEN) ELSE FTEST=1.E6
RMUL = SQRT(RMUL)
RETURN,A
END
; $Id: resolve_all.pro,v 1.1 1995/02/03 21:54:16 dave Exp $
;
; Copyright (c) 1995, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	RESOLVE_ALL
;
; PURPOSE:
;	Resolve (by compiling) all procedures and functions.
;	This is useful when preparing .sav files containing all the IDL
;	routines required for an application.
; CATEGORY:
;	Programming.
; CALLING SEQUENCE:
;	RESOLVE_ALL
; INPUTS:
;	None.
; KEYWORD PARAMETERS:
;	QUIET = if set, produce no messages.
; OUTPUTS:
;	No explicit outputs.
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:
; RESTRICTIONS:
;	Will not resolve procedures or functions that are called via
;	CALL_PROCEDURE, CALL_FUNCTION, or EXECUTE.  Only explicit calls
;	are resolved.
;
;	If an unresolved procedure or function is not in the IDL 
;	search path, an error occurs, and no additional routines
;	are resolved.
;
; PROCEDURE:
;	This routine iteratively determines the names of unresolved calls
;	to user-written or library procedures and functions, and then
;	compiles them.  The process stops when there are no unresolved
;	routines.
; EXAMPLE:
;	RESOLVE_ALL.
; MODIFICATION HISTORY:
; 	Written by:	Your name here, Date.
;	DMS, RSI, January, 1995.
;-

PRO resolve_all, QUIET = quiet

if n_elements(quiet) ne 0 then begin
    quiet_save=!quiet
    !quiet = quiet
endif else quiet = 0

repeat begin
    cnt = 0
    a = ROUTINE_NAMES(/PROC, /UNRESOLVED)
    if strlen(a(0)) gt 0 then begin
	cnt = cnt + n_elements(a)
	if quiet eq 0 then print,'Resolving procedures: ', a
	resolve_routine, a
	endif
    a = ROUTINE_NAMES(/FUNC, /UNRESOLVED)
    if strlen(a(0)) gt 0 then begin
	cnt = cnt + n_elements(a)
	if quiet eq 0 then print,'Resolving functions: ', a
	resolve_routine, a, /IS_FUNCTION
	endif
endrep until cnt eq 0

if n_elements(quiet_save) ne 0 then !quiet = quiet_save
end
; $Id: reverse.pro,v 1.2 1994/09/16 21:12:24 dave Exp $

function reverse, a, subscript	;Reverse a vector or array about the subscript
; subscript = 1 or omitted to reverse 1st dim, =2 for 2nd dim.
; This function simply calls rotate with the correct parameter.
;+
; NAME:
;	REVERSE
;
; PURPOSE:
;	Reverse the order of rows or columns in an array or vector.
;
; CATEGORY:
;	Array manipulation.
;
; CALLING SEQUENCE:
;	Result = REVERSE(Array [, Subscript_Index])
;
; INPUTS:
;	Array:	The array or vector containing the original data.
;
; OPTIONAL INPUT PARAMETERS:
; Subscript_Index:  If this parameter is omitted or 1, the first subscript is
;		reversed (i.e., rows are reversed).  Set this parameter to
;		2 to reverse columns.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	REVERSE returns a copy of the original array that is reversed about 
;	one of its dimensions.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	Only works for 1-, 2-, or 3-dimensional arrays.
;
; PROCEDURE:
;	Uses the ROTATE function.
;
; MODIFICATION HISTORY:
;	Old.
;	Apr, 1991, DMS,	Added 3D reversing.
;       Sept, 1992 Mark L. Rivers, added simple return for scaler argument
;	Sept, 1994. Added default for 3D case.
;-

on_error,2                             ;Return to caller if an error occurs
s = size(a)
ndims = s(0)
if ndims eq 0 then return, a
if ndims eq 3 then begin		;3D?
	b = a
	if n_elements(subscript) le 0 then subscript = 1  ;Default case
	case subscript of
	1: begin			;(x,*,*)
		n = s(1)
		for i=0,(n-1)/2 do begin
			t0 = b(i,*,*) & t1 = b(n-1-i,*,*)
			b(n-i-1,0,0) = t0
			b(i,0,0) = t1
			endfor
		endcase
	2: begin			;(*,x,*)
		n = s(2)
		for i=0,(n-1)/2 do begin
			t0 = b(*,i,*) & t1 = b(*,n-1-i,*)
			b(0,n-i-1,0) = t0
			b(0,i,0) = t1
			endfor
		endcase
	3: begin			;(x,*,*)
		n = s(3)
		for i=0,(n-1)/2 do begin
			t0 = b(*,*,i) & t1 = b(*,*,n-i-1)
			b(0,0,n-i-1) = t0
			b(0,0, i) = t1
			endfor
		endcase
	else: message, "REVERSE: Subscript parameter out of range"
	endcase
	return,b
endif			
if n_params() then return, rotate(a,5) ;default = 1st dim.
if subscript eq 1 then return,rotate(a,5) else $
	return, rotate(a,7)
end
; $Id: rot.pro,v 1.2 1993/11/03 18:59:40 dave Exp $

;Rotate and magnify an image
FUNCTION ROT,A,ANGLE,MAG,X0,y0, INTERP = interp, MISSING = missing, $
        PIVOT = pivot, CUBIC = cubic
;+
; NAME:
;	ROT
;
; PURPOSE:
;	Rotate, magnify or demagnify, and/or translate an image.
;
; CATEGORY:
;	Z3 - Image processing, geometric transforms.
;
; CALLING SEQUENCE:
;	Result = ROT(A, Angle, [Mag, X0, Y0], MISSING = missing,
;		INTERP = Interp, CUBIC = Cubic)
;
; INPUTS:
;	A:	The image array to be rotated.  This array may be of any type,
;		but it must have two dimensions.
;
;	ANGLE:	Angle of rotation in degrees CLOCKWISE. (Why?,
;		because of an error in the old ROT.)
;
; OPTIONAL INPUT PARAMETERS:
;	MAG:	Magnification/demagnification factor.  A value of 1.0 = no
;		change, > 1 is magnification and < 1 is demagnification.
;
;	X0:	X subscript for the center of rotation.  If omitted, X0 equals
;		the number of columns in the image divided by 2.
;
;	Y0:	Y subscript for the center of rotation.  If omitted, y0 equals
;		the number of rows in the image divided by 2.
;
; KEYWORDS:
;	INTERP:	Set this keyword for bilinear interpolation.  If this keyword
;		is set to 0 or omitted, nearest neighbor sampling is used.
;		Note that setting this keyword is the same as using the 
;		ROT_INT User Library function.  This change (and others) 
;		essentially makes ROT_INT obsolete.
;
;	CUBIC:	If set, uses "Cubic convolution" interpolation.  A more
;		accurate, but more time-consuming, form of interpolation.
;		CUBIC has no effect when used with 3 dimensional arrays.
;
;      MISSING:	The data value to substitute for pixels in the output image 
;		that map outside the input image.
;
;      PIVOT: Setting this keyword causes the image to pivot around the point
;		X0, Y0, so that this point maps into the same point in the
;		output image.  If this keyword is set to 0 or omitted, then the
;		point X0, Y0 in the input image is mapped into the center of
;		the output image.
;
; OUTPUTS:
;	ROT returns a rotated, magnified, and translated version of the
;	input image.  Note that the dimensions of the output image are
;	always the same as those of the input image.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	The POLY_2D function is used to translate, scale, and
;	rotate the original image.
;
; EXAMPLE:
;	Create and display an image.  Then display a rotated and magnified
;	version.  Create and display the image by entering:
;
;		A = BYTSCL(DIST(256))
;		TV, A
;
;	Rotate the image 33 degrees and magnify it 1.5 times.  Use bilinear
;	interpolation to make the image look nice.  Enter:
;
;		B = ROT(A, 33, 1.5, /INTERP)
;		TV, B
;	
; MODIFICATION HISTORY:
;	June, 1982. 	Written by DMS, RSI.
;
;	Feb, 1986. 	Modified by Mike Snyder, ES&T Labs, 3M Company.
;	 		Adjusted things so that rotation is exactly on the 
;			designated center.
;
;	October, 1986.  Modified by DMS to use the POLY_2D function.
;
;	Aug, 1988.	Added INTERP keyword.
;       Dec, 1992.      Added PIVOT keyword, William Thompson, NASA/GSFC.
;	Nov, 1993.	Added CUBIC keyword, DMS/RSI.
;-
;
;
on_error,2		;Return to caller if error
B = FLOAT(SIZE(A))	;Get dimensions
IF N_PARAMS(0) LT 5 THEN BEGIN
	X0 = (B(1)-1)/2.		;Center of rotation in X.
	Y0 = (B(2)-1)/2.		; and in Y.
	IF N_PARAMS(0) LT 3 THEN MAG = 1. ;Mag specified?
	ENDIF
;
	IF KEYWORD_SET(PIVOT) THEN BEGIN
		XC = X0
		YC = Y0
	END ELSE BEGIN
		xc = (b(1)-1)/2.        ;center of output image.
		yc = (b(2)-1)/2.
	ENDELSE
	theta = -angle/!radeg		;angle in degrees CLOCKWISE.
	c = cos(theta)*mag		;cos theta * mag
	s = sin(theta)*mag
;
	kx = -xc+c*x0-s*y0		;useful constants.
	ky = -yc+s*x0+c*y0
	kk = 1./(1.+s^2/c^2)
;
	cx = kk* [s/c^2*ky+kx/c,s/c^2,1/c,0.] ;x coeff...
	cy = kk * [-s/c^2*kx+ky/c,1/c,-s/c^2,0.] ;y coeff.

	i = 0				;assume no interpolation
	if keyword_set(interp) then i=1 ;Bilinear
	if keyword_set(Cubic) then i=2  ;Cubic

	if n_elements(missing) eq 0 then return,poly_2d(a,cx,cy, i) $
	else return, poly_2d(a,cx,cy, i, missing = missing) 
END
;$Id: rs_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       RS_TEST
;
; PURPOSE:
;       This function tests the hypothesis that two sample popultions,
;       {X(i), Y(i)}, have the same mean of distribution against the
;       hypothesis that they differ. The result is a two-element vector
;       containing the nearly-normal test statistic Z and the one-tailed
;       probability of obtaining a value of Z or greater. This type of 
;       test is often refered to as the Wilcoxon Rank-Sum Test or Mann-
;       Whitney U-Test.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = RS_test(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An m-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
;      UX:    Use this keyword to specify a named variable which returns
;             the Mann-Whitney statistic for X.
;
;      UY:    Use this keyword to specify a named variable which returns
;             the Mann-Whitney statistic for Y.
;
; EXAMPLE:
;       Define the vectors of sample data.
;         x = [-14,   3,   1, -16, -21,   7,  -7, -13, -22, -17, -14, -8, $
;                7, -18, -13,  -9, -22, -25, -24, -18, -13, -13, -18, -5]
;         y = [-18, -9, -16, -14,  -3,  -9, -16, 10, -11, -3, -13, $
;              -21, -2, -11, -16, -12, -13,  -6, -9,  -7, -11, -9]
;       Test the hypothesis that two sample popultions, {X(i), Y(i)},
;       have the same mean of distribution against the hypothesis that they
;       differ at the 0.05 significance level.
;         result = rs_test(x, y, ux = ux, uy = uy)
;       The result should be the 2-element vector:
;         [1.45134, 0.0733429]
;       The keyword parameters should be returned as:
;         ux = 330.000, uy = 198.000
;       The computed probability (0.0733429) is greater than the 0.05
;       significance level and therefore we do not reject the hypothesis
;       that X and Y have the same mean of distribution. 
;
; PROCEDURE:
;       RS_TEST computes the nonparametric Rank Sum Test for populations of
;       equal or unequal size. The populations X(i) and Y(i) are combined
;       and individual elements are ranked based on magnitude. Elements of
;       identical magnitude are ranked using a rank equal to the mean of the
;       ranks that would otherwise be assigned. The Mann-Whitney statistics
;       (Ux and Uy) are computed and used to determine the nearly-normal test
;       statistic (Z) and the one-tailed probability of obtaining a value of 
;       Z or greater. The hypothesis that two sample populations have the same
;       mean of distribution is rejected if Ux and Uy differ with statistical 
;       significance. If either population contains 10 or fewer samples, the
;       test statistic (Z) and the one-tailed probability of obtaining a value
;       of Z or greater are returned as zero. In this case, consult published
;       tables such as the ones available in the REFERENCE given below. 
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, August 1994
;-

pro crank, w, s
  ;Replace elements of the sorted array "w" by their rank.
  ;Identical observations ("ties") are ranked according to their means.
  ;s = f^3 - f (f is the number of elements in identical observations.)
  n = n_elements(w)
  w = [0.0, w]  ;operate on elements w(1), ... , w(n) of the shifted
                ;n+1 element float array (w).
  s = 0.0
  j = 1
  while(j lt n) do begin
    if(w(j+1) ne w(j)) then begin
      w(j) = j
      j = j+1
    endif else begin
      for jt = j+1, n do $
        if (w(jt) ne w(j)) then goto, case2
      jt = n + 1
      case2:
      rank = 0.5 * (j + jt - 1)
      for ji = j, jt-1 do $
        w(ji) = rank
      t = jt - j
      s = s + t^3 - t
      j = jt
    endelse
  endwhile
  if(j eq n) then w(n) = n
  w = w(1:*)
end

function rs_test, x, y, ux = ux, uy = uy

  on_error, 2

  nx = n_elements(x)
  ny = n_elements(y)

  ;An alternate method of error handling if Ux and Uy are not required.
  ;if min([nx, ny]) le 10 then message, $
  ;    'Consult statistical tables for samples of 10 or fewer elements.'

  ;Number of "ties" (identical data).
  ties = where(x - y eq 0, zdiff)

  if nx eq ny and zdiff eq nx then message, $
    'x and y contain identical data.'

  ;Sort and rank the combined x and y vectors.
  xy = [x, y]            ;Combine vectors.
  is = sort(xy)          ;Sort xy into ascending order.
  xy = xy(is)
  crank, xy              ;Rank sorted xy vector.
  xy = xy(sort(is))
  
  ;Rank-sum totals.
  wx = total(xy(0:nx-1))
  wy = total(xy(nx:*))

  ;Compute the Mann-Whitney statistics.
  ux = nx * ny + (nx * (nx + 1.0) / 2.0) - wx
  uy = nx * ny + (ny * (ny + 1.0) / 2.0) - wy

  ;Compute the Z statistic with respect to ux.
  z = (ux - (nx*ny/2.0)) / sqrt(nx*ny*(nx+ny+1.0)/12.0)

  ;Probability of obtaining z or something greater.
  prob = 1.0 - gauss_pdf(abs(z)) 

  ;If either sample is <= 10, consult published statistical tables.
  if min([nx, ny]) le 10 then return, [0, 0] $
  else return, [z, prob] 

end
; $Id: rstrpos.pro,v 1.2 1993/10/06 16:50:03 doug Exp $

FUNCTION RSTRPOS, Expr, SubStr, Pos
;+
; NAME:
;       RSTRPOS
;
; PURPOSE:
;	This function finds the last occurrence of a substring within
;	an object string. If the substring is found in the expression,
;	RSTRPOS returns the character position of the match, otherwise
;	it returns -1.
;
; CATEGORY:
;	String processing.
;
; CALLING SEQUENCE:
;        Result = RSTRPOS(Expr, SubStr [, Pos])
;
; INPUTS:
;       Expr:	The expression string in which to search for the substring.
;	SubStr: The substring to search for.
;
; OPTIONAL INPUTS:
;	Pos:	The character position before which the search is bugun.
;	      	If Pos is omitted, the search begins at the last character
;	      	of Expr.
;
; OUTPUTS:
;        Returns the position of the substring, or -1 if the
;	 substring was not found within Expr.
;
; SIDE EFFECTS:
;        Unlike STRPOS, Expr and SubStr must be strings.
;
; EXAMPLE:
;	Expr = 'Holy smokes, Batman!'	; define the expression.
;	Where = RSTRPOS(Exp, 'smokes')	; find position.
;	Print, Where			; print position.
;		5			; substring begins at position 5
;					; (the sixth character).
;
; MODIFICATION HISTORY:
;        JWG, January, 1993
;-
	Len	= STRLEN(Expr)
	IF N_ELEMENTS(Pos) EQ 0 THEN Start=0 ELSE Start = Len - Pos

	;	Reverse the string
	RString	= REVERSE(BYTE(Expr))

	;	Reverse the substring

	RSubStr	= REVERSE(BYTE(SubStr))

	SubPos	= STRPOS(STRING(RString),STRING(RSubStr),Start)
	IF SubPos NE -1 THEN SubPos = Len - SubPos - STRLEN(SubStr)
	RETURN, SubPos
END
;$Id: r_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       R_TEST
;
; PURPOSE:
;       This function tests the hypothesis that a binary sequence (a 
;       sequence of 1s and 0s) represents a "random sampling". This
;       test is based on the "theory of runs" and is often refered to
;       as the Runs Test for Randomness. The result is a two-element
;       vector containing the nearly-normal test statistic Z and the 
;       one-tailed probability of obtaining a value of Z or greater.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = R_test(X)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;             Elements not equal to 0 or 1 are removed and the length
;             of X is correspondingly reduced.
;
; KEYWORD PARAMETERS:
;       R:    Use this keyword to specify a named variable which returns
;             the number of runs (clusters of 0s and 1s) in X.       
;
;      N0:    Use this keyword to specify a named variable which returns
;             the number of 0s in X.
;
;      N1:    Use this keyword to specify a named variable which returns
;             the number of 1s in X.
;
; EXAMPLE:
;       Define a vector of 1s and 0s.
;         x = [0,1,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1]
;
;       Test the hypothesis that x represents a random sampling against the 
;       hypothesis that it does not represent a random sampling at the 0.05 
;       significance level.
;         result = r_test(x, r = r, n0 = n0, n1 = n1)
;
;       The result should be the 2-element vector:
;         [2.26487, 0.0117604]
;       The keyword parameters should be returned as:
;         r = 22.0000, n0 = 16.0000, n1 = 14.0000 
;
;       The computed probability (0.0117604) is less than the 0.05
;       significance level and therefore we reject the hypothesis that x
;       represents a random sampling. The results show that there are too 
;       many runs, indicating a non-random cyclical pattern.
;
; PROCEDURE:
;       R_TEST computes the nonparametric Runs Test for Randomness. A 
;       "run" is a cluster of identical symbols within a sequence of two
;       distinct symbols. The binary sequence (x) defined in EXAMPLE has 
;       22 runs (or clusters). The first run contains one 0, the second 
;       run contains two 1s, the third run contains one 0, and so on.
;       In general, the randomness hypothesis will be rejected if there
;       are lengthy runs of 0s or 1s or if there are alternating patters
;       of many short runs.
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, August 1994
;-

function r_test, x, r = r, n0 = n0, n1 = n1

  on_error, 2

  nx = n_elements(x)

  if nx le 10 then message, $
    'Not defined for input vectors of 10 or fewer elements.'

  ;Remove any sequence elements that are not 0s or 1s.
  data = where(x eq 0 or x eq 1, nb)
  if nb ne 0 then x = x(data)

  sx = size(x)

  h0 = where(x eq 0, n0)
  if n0 ne 0 then hi = where(h0+1 ne shift(h0, -1), nn0) $
  else nn0 = 0L

  n1 = sx(1) - n0

  if x(sx(1)-1) ne x(0) then nn1 = nn0 $
  else if x(0) eq 1 then nn1 = nn0 + 1 $
  else nn1 = nn0 - 1

  if n0 eq 0 or n1 eq 0 then message, $
    'x is a sequence of identical data.'

  r = nn0 + nn1
  e = 2.0 * n0 * n1 / (n0 + n1) + 1.0
  v = 2.0 * n0 * n1 * (2.0 * n1 * n0 - n0 - n1) / $
                      ((n0 + n1 -1.0) * (n1 + n0)^2)
  z = (r - e) / sqrt(v)

  prob = 1.0 - gauss_pdf(abs(z))

  return, [z, prob]

end


; $Id: scale3d.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro scale3d		;Scale !p.t to bring unit cube into viewing area
;+
; NAME:
;	SCALE3D
;
; PURPOSE:
;	Scale the 3D unit cube (a cube with the length of each side equal
;	to 1) into the viewing area.
;
; CATEGORY:
;	Graphics, 3D.
;
; CALLING SEQUENCE:
;	SCALE3D
;
; INPUTS:
;	No explicit inputs.  !P.T is an implicit input.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	No explicit outputs.  !P.T is an implicit output.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	!P.T is modified.
;
; RESTRICTIONS:
;	Doesn't work for all forms of perspective transformations.
;
; PROCEDURE:
;	Eight, 3D data points are created at the vertices of the 3D
;	unit cube.  They are transformed by !P.T.  The system
;	is translated to bring the minimum (x,y,z) point to the origin, 
;	and then scaled to make each coordinates maximum value equal to 1.
;
; MODIFICATION HISTORY:
;	DMS, May, 1988.
;-

on_error,2              ;Return to caller if an error occurs
for i = 0,7 do begin	;Find 8 corners
	p = [ i and 1, (i/2) and 1, ((i/4) and 1),1] # !p.t
	p = p / p(3)	;normalize homogenous coords
	if i eq 0 then begin
		pmin = p & pmax = p
	  endif else begin
		pmin = pmin < p & pmax = pmax > p
	  endelse
	endfor
;
;print,'PMAX: ',transpose(pmax)
;print,'PMIN: ',transpose(pmin)
;	avoid dividing by 0 if there is no Z transformation.
if pmax(2) eq pmin(2) then pmax(2) = pmin(2)+1
t3d,tr = [ -pmin(0), -pmin(1), -pmin(2)], sc=1./(pmax(0:2)-pmin(0:2))
end
; $Id: scale3.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro scale3,ax=ax, az=az, xrange=xr, yrange=yr, zrange=zr
;+
; NAME:
;	SCALE3
;
; PURPOSE:
;	Set up transformation and scaling for basic 3D viewing.
;
;	This procedure is similar to SURFR and SCALE3D, except that the
;	data ranges must be specified and the scaling does not vary with 
;	rotation.
;
; CATEGORY:
;	Graphics, 3D.
;
; CALLING SEQUENCE:
;	SCALE3, XRANGE = xr, YRANGE = yr, ZRANGE = zr [, AX = ax] [, AZ = az]
;
; INPUTS:
;	No plain parameters.
;
; KEYWORD PARAMETERS:
;	XRANGE:	Two-element vector containing the minimum and maximum X values.
;		If omitted, the X-axis scaling remains unchanged.
;
;	YRANGE:	Two-element vector containing the minimum and maximum Y values.
;		If omitted, the Y-axis scaling remains unchanged.
;
;	ZRANGE:	Two-element vector containing the minimum and maximum Z values.
;		If omitted, the Z-axis scaling remains unchanged.
;
;	AX:	Angle of rotation about the X axis.  The default is 30 degrees.
;
;	AZ:	Angle of rotation about the Z axis.  The default is 30 degrees.
;
; OUTPUTS:
;	No explicit outputs.  Results are stored in the system variables 
;	!P.T, !X.S, !Y.S, and !Z.S.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The 4 by 4 matrix !P.T (the 3D-transformation system variable), 
;	receives the homogeneous transformation matrix generated by this 
;	procedure.
;
;	The axis scaling variables, !X.S, !Y.S, and !Z.S are set
;	from the data ranges.
;
; RESTRICTIONS:
;	Axonometric projections only.
;
; PROCEDURE:
; 	Set the axis scaling variables from the supplied ranges, then:
;
; 	1) Translate the unit cube so that the center (.5,.5,.5) is moved
;	   to the origin.
;
; 	2) Scale by 1/SQRT(3) so that the corners do not protrude.
;
; 	3) Rotate -90 degrees about the X axis to make the +Z
;	   axis of the data the +Y axis of the display.  The +Y data axis
;	   extends from the front of the display to the rear.
;
; 	4) Rotate about the Y axis AZ degrees.  This rotates the
;	   result counterclockwise as seen from above the page.
;
; 	5) Then it rotates about the X axis AX degrees, tilting the data
;	   towards the viewer.
;
; 	6) Translate back to the (0,1) cube.
;
; 	This procedure may be easily modified to affect different rotations
;	transformations.
;
; EXAMPLE:
;	Set up a 3D transformation where the data range is 0 to 20 for each
;	of the 3 axes and the viewing area is rotated 20 degrees about the
;	X axis and 55 degrees about the Z axis.  Enter:
;
;	SCALE3, XRANGE=[0, 20], YRANGE=[0, 20], ZRANGE=[0, 20], AX=20, AZ=55 
;
; MODIFICATION HISTORY:
;	DMS, June, 1991.
;-
on_error,2                      ;Return to caller if an error occurs
if n_elements(ax) eq 0 then ax=30	;Supply defaults
if n_elements(az) eq 0 then az=30

if n_elements(xr) ge 2 then !x.s = [ -xr(0), 1.]  / (xr(1)-xr(0))
if n_elements(yr) ge 2 then !y.s = [ -yr(0), 1.]  / (yr(1)-yr(0))
if n_elements(zr) ge 2 then !z.s = [ -zr(0), 1.]  / (zr(1)-zr(0))

;Translate to center about origin, then scale down by 1/sqrt(3)
;so that the corners don't stick out.
t3d, /RESET, TRANSLATE=[-.5,-.5,-.5], SCALE=replicate(1./sqrt(3),3)
t3d, ROTATE = [-90,az,0]	;rotate so +Z axis is now +Y
t3d, ROTATE = [ax,0,0]
t3d, TRANSLATE = [.5, .5, .5]	;& back to 0,1 cube
end
; $Id: search2d.pro,v 1.2 1993/10/06 16:51:53 doug Exp $

; Copyright (c) 1992-1993, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	SEARCH2D
;
; PURPOSE:
;	This function finds "objects" or regions of similar data
;       values within a 2-D array of data. Given a starting location
;       and a range of values to search for, SEARCH2D will find all
;       the cells within the array that are within the specified range
;       of values, and have some path of connectivity through these cells
;       to the starting location. In addition to searching for cells
;       within a global range of data values, SEARCH2D can also search
;       for adjacent cells whose values deviate from their neighbors within
;       specified tolerances. See the procedure "SEARCH3D" for the
;       three dimensional case.
;
;       This function returns a list of the array subscripts that define
;       the selected object or region.
;
; CATEGORY:
;       Data subsetting.
;	Image manipulation.
;
; CALLING SEQUENCE:
;       Region = SEARCH2D(Array, Xpos, Ypos, Min_val, Max_val)
;
; INPUTS:
;       Array:      The 2-D array of data to search.
;                   Data type : Any 2-D array except string or structure.
;       Xpos:       The X coordinate (first subscript into the 2-D Array)
;                   of the starting cell for the search.
;                   Data type : Long.
;       Ypos:       The Y coordinate (second subscript into the 2-D Array)
;                   of the starting cell for the search.
;                   Data type : Long.
;       Min_val:    The minimum data value to search for. All cells that
;                   are connected to the starting cell, and have a value
;                   greater than or equal to Min_val and less that or equal
;                   to Max_val, will be considered part of the "object".
;       Max_val:    The maximum data value to search for.
;
; KEYWORD PARAMETERS:
;       DECREASE:   If the DECREASE or INCREASE keywords are specified,
;                   then SEARCH2D creates an internal copy of Array.
;                   This internal copy is then processed to enhance the
;                   object edges by using an algorithm similar to the
;                   "SOBEL" edge enhancement process. Any adjacent
;                   cells will be found if their corresponding data value
;                   in the edge enhanced array is greater than DECREASE and
;                   less than INCREASE. In any case, the adjacent cells
;                   will NEVER be selected if their data value is not
;                   between Min_val and Max_val.
;                   The default is 0.0 if INCREASE is specified.
;                   Otherwise, the default is no edge checking.
;                   Data type : Int or Float (usually less than zero).
;       INCREASE:   The maximum value in the edge enhanced array for
;                   a cell to be considered part of the selected object.
;                   Some savings in execution time and memory usage result
;                   when DECREASE and INCREASE are omitted.
;                   See DECREASE above.
;                   The default is 0.0 if DECREASE is specified.
;                   Otherwise, the default is no edge checking.
;                   Data type : Int or Float (usually greater than zero).
;       LPF_BAND:   This keyword indicates what (if any) Low Pass Filtering
;                   is performed on the edge enhanced array before the
;                   search begins. If LPF_BAND is set to 3 or higher
;                   then the edge enhanced array will be smoothed using
;                   LPF_BAND as the width of the smoothing window.
;                   If LPF_BAND is less than 3 then no smoothing is
;                   performed. This keyword only has effect when the
;                   DECREASE or INCREASE keywords are supplied.
;                   See DECREASE above.
;                   The default is zero (no smoothing).
;                   Data type : Int.
;       DIAGONAL:   Normally, cells are considered adjacent only when
;                   squares surrounding the cells share a common edge.
;                   If a non-zero value is passed to DIAGONAL then
;                   SEARCH2D will also locate cells meeting the search
;                   criteria whose surrounding squares share a common
;                   corner. Specifying diagonal search mode requires
;                   more memory and execution time.
;                   The default is no diagonal searching.
;                   Data type : int
;
; OUTPUTS:
;       This function returns a list of the indices into the 2-D array
;       that are part of the located object or region. This list is
;       returned as a LONARR(n) where n is the number of cells found.
;
;       If the returned array of indices is called Region, and the
;       size of the 2-D array of data is size_x by size_y, then the
;       actual X and Y indices can be obtained by using the following
;       algorithm :
;
;          index_y = Region / size_x
;          index_x = Region - (index_y * size_x)
;
;       The object within the 2-D Array could then be subscripted as :
;
;          Array(Region)
;       OR
;          Array(index_x, index_y)
;
; EXAMPLE:
;       Find all the indices corresponding to an object contained in a
;       2-D array of data.
;
;       ; Create some data.
;          img = FLTARR(512, 512)
;          img(3:503, 9:488) = 0.7
;          img(37:455, 18:438) = 0.5
;          img(144:388, 90:400) = 0.7
;          img(200:301, 1:255) = 1.0
;          img(155:193, 333:387) = 0.3
;
;       ; Display the image.
;          TVSCL, img
;
;       ; Search for an object starting at (175, 300) whose data values
;       ; are between (0.6) and (0.8).
;          Region = SEARCH2D(img, 175, 300, 0.6, 0.8, /DIAGONAL)
; 
;       ; Scale the background cells into the range 0 to 127.
;          img = BYTSCL(img, TOP=127B)
;
;       ; Highlight the object region by setting it to 255.
;          img(Region) = 255B
; 
;       ; Display the array with the highlighted object in it.
;          TVSCL, img
;
; MODIFICATION HISTORY:
;       Written by:     Daniel Carr. Thu Sep  3 15:36:17 MDT 1992
;-

FUNCTION Search2d, array, xpos, ypos, min_val, max_val, $
                   Decrease=decrease, Increase=increase, $
                   Lpf_band=smooth_band, Diagonal=diagonal

; *** Test inputs

size_array = Size(array)
IF (size_array(0) NE 2L) THEN BEGIN
   Print, 'Array must have two dimensions'
   STOP
ENDIF
x_size = size_array(1)
y_size = size_array(2)

xpos = Long(xpos(0))
ypos = Long(ypos(0))
IF (xpos LT 0L) THEN BEGIN
   Print, 'Xpos must be >= 0'
   STOP
ENDIF
IF (xpos GE x_size) THEN BEGIN
   Print, 'Xpos must be < array size'
   STOP
ENDIF
IF (ypos LT 0L) THEN BEGIN
   Print, 'Ypos must be >= 0'
   STOP
ENDIF
IF (ypos GE y_size) THEN BEGIN
   Print, 'Ypos must be < array size'
   STOP
ENDIF

min_val = min_val(0)
max_val = max_val(0)

IF (max_val LT min_val) THEN BEGIN
   Print, 'Max value must be >= min value'
   STOP
ENDIF

start_val = array(xpos,ypos)
IF ((start_val LT min_val) OR (start_val GT max_val)) THEN BEGIN
   Print, 'Value of array at (xpos,ypos) must be >= min_val and <= max_val'
   STOP
ENDIF

dec = 0.0
inc = 0.0
range = 0B
IF (N_Elements(decrease) GT 0L) THEN BEGIN
   dec = Float(decrease(0))
   range = 1B
ENDIF
IF (N_Elements(increase) GT 0L) THEN BEGIN
   inc = Float(increase(0))
   range = 1B
ENDIF

sb = 0
IF (N_Elements(smooth_band) GT 0L) THEN sb = Fix(smooth_band(0))
IF ((sb GE x_size) OR (sb GE y_size)) THEN BEGIN
   Print, 'Smooth band must be < size of array'
   STOP
ENDIF

diag = 0B
IF (N_Elements(diagonal) GT 0L) THEN diag = Byte(diagonal(0))

IF (range) THEN BEGIN

   ; *** Calculate the edge enhanced array

   IF (diag) THEN BEGIN
      diff_array = Float(array)
      diff_array = diff_array < (diff_array - Shift(diff_array,  0,  1)) < $
                                (diff_array - Shift(diff_array,  1,  1)) < $
                                (diff_array - Shift(diff_array,  1,  0)) < $
                                (diff_array - Shift(diff_array,  1, -1)) < $
                                (diff_array - Shift(diff_array,  0, -1)) < $
                                (diff_array - Shift(diff_array, -1, -1)) < $
                                (diff_array - Shift(diff_array, -1,  0)) < $
                                (diff_array - Shift(diff_array, -1,  1))
      IF (sb GT 0) THEN diff_array = Smooth(diff_array, sb)
   ENDIF ELSE BEGIN
      diff_array = Float(array)
      diff_array = diff_array < (diff_array - Shift(diff_array,  0,  1)) < $
                                (diff_array - Shift(diff_array,  1,  0)) < $
                                (diff_array - Shift(diff_array,  0, -1)) < $
                                (diff_array - Shift(diff_array, -1,  0))
      IF (sb GT 0) THEN diff_array = Smooth(diff_array, sb)
   ENDELSE
ENDIF

; *** Set up the required variables

similar_val = 1B
connect_val = 2B

c_array = Bytarr(x_size, y_size)
c_array(Where((array GE min_val) AND (array LE max_val))) = similar_val

x_size_m1 = x_size - 1L
y_size_m1 = y_size - 1L

x_ind = xpos
y_ind = ypos
just_found = (y_ind * x_size) + x_ind

c_array(just_found) = connect_val
num_found = 1L

; *** Start the search

IF (diag EQ 0B) THEN BEGIN   ; *** No diagonal mode
   nsew_ind = Lonarr(4, 1)
   nsew_ind(0, *) = (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
   nsew_ind(1, *) = (((y_ind - 1L) > 0L) * x_size) + x_ind
   nsew_ind(2, *) = (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
   nsew_ind(3, *) = (y_ind * x_size) + ((x_ind - 1L) > 0L)

   cc_array = c_array(nsew_ind(*))
   just_found = Where(cc_array EQ similar_val)

   ; *** Loop while cells are still being found

   WHILE (just_found(0) GE 0L) DO BEGIN
      cc_array(just_found) = connect_val
      c_array(nsew_ind(just_found)) = cc_array(just_found)
      y_ind = nsew_ind(just_found) / (x_size)
      x_ind = nsew_ind(just_found) - (y_ind * x_size)

      num_found = N_Elements(just_found)
      nsew_ind = Lonarr(4, num_found, /Nozero)

      nsew_ind(0, *) = (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
      nsew_ind(1, *) = (((y_ind - 1L) > 0L) * x_size) + x_ind
      nsew_ind(2, *) = (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
      nsew_ind(3, *) = (y_ind * x_size) + ((x_ind - 1L) > 0L)

      nsew_ind = nsew_ind(Sort(nsew_ind(*)))
      nsew_ind = nsew_ind(Uniq(nsew_ind))

      cc_array = c_array(nsew_ind(*))

      IF (range) THEN BEGIN
         t_array = diff_array(nsew_ind(*))
         just_found = Where((cc_array EQ similar_val) AND $
                           ((t_array GE dec) AND $
                            (t_array LE inc)))
      ENDIF ELSE BEGIN
         just_found = Where(cc_array EQ similar_val)
      ENDELSE
   ENDWHILE
ENDIF ELSE BEGIN   ; *** Diagonal mode
   nsew_ind = Lonarr(8, 1)
   nsew_ind(0, *) = (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
   nsew_ind(1, *) = (((y_ind - 1L) > 0L) * x_size) + x_ind
   nsew_ind(2, *) = (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
   nsew_ind(3, *) = (y_ind * x_size) + ((x_ind - 1L) > 0L)
   nsew_ind(4, *) = (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind(5, *) = (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind(6, *) = (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind(7, *) = (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)

   cc_array = c_array(nsew_ind(*))
   just_found = Where(cc_array EQ similar_val)

   ; *** Loop while cells are still being found

   WHILE (just_found(0) GE 0L) DO BEGIN
      cc_array(just_found) = connect_val
      c_array(nsew_ind(just_found)) = cc_array(just_found)
      y_ind = nsew_ind(just_found) / (x_size)
      x_ind = nsew_ind(just_found) - (y_ind * x_size)

      num_found = N_Elements(just_found)
      nsew_ind = Lonarr(8, num_found, /Nozero)

      nsew_ind(0, *) = (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
      nsew_ind(1, *) = (((y_ind - 1L) > 0L) * x_size) + x_ind
      nsew_ind(2, *) = (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
      nsew_ind(3, *) = (y_ind * x_size) + ((x_ind - 1L) > 0L)
      nsew_ind(4, *) = (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind(5, *) = (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind(6, *) = (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind(7, *) = (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)

      nsew_ind = nsew_ind(Sort(nsew_ind(*)))
      nsew_ind = nsew_ind(Uniq(nsew_ind))

      cc_array = c_array(nsew_ind(*))

      IF (range) THEN BEGIN
         t_array = diff_array(nsew_ind(*))
         just_found = Where((cc_array EQ similar_val) AND $
                           ((t_array GE dec) AND $
                            (t_array LE inc)))
      ENDIF ELSE BEGIN
         just_found = Where(cc_array EQ similar_val)
      ENDELSE
   ENDWHILE
ENDELSE

; *** Clean up and return

x_ind = 0
y_ind = 0
nsew_ind = 0
cc_array = 0
t_array = 0
diff_array = 0

index = Where(c_array EQ connect_val)

RETURN, index
END
; $Id: search3d.pro,v 1.4 1995/06/01 16:50:53 dan Exp $

; Copyright (c) 1992-1993, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	SEARCH3D
;
; PURPOSE:
;	This function finds "objects" or regions of similar data
;       values within a 3-D array of data. Given a starting location
;       and a range of values to search for, SEARCH3D will find all
;       the cells within the volume that are within the specified range
;       of values, and have some path of connectivity through these cells
;       to the starting location. In addition to searching for cells
;       within a global range of data values, SEARCH3D can also search
;       for adjacent cells whose values deviate from their neighbors within
;       specified tolerances. See the procedure "SEARCH2D" for the
;       two dimensional case.
;
;       This function returns a list of the array subscripts that define
;       the selected object or region.
;
; CATEGORY:
;       Data subsetting.
;	Volume manipulation.
;
; CALLING SEQUENCE:
;       Region = SEARCH3D(Array, Xpos, Ypos, Zpos, Min_val, Max_val)
;
; INPUTS:
;       Array:      The 3-D volume of data to search.
;                   Data type : Any 3-D array except string or structure.
;       Xpos:       The X coordinate (first subscript into the 3-D Array)
;                   of the starting cell for the search.
;                   Data type : Long.
;       Ypos:       The Y coordinate (second subscript into the 3-D Array)
;                   of the starting cell for the search.
;                   Data type : Long.
;       Zpos:       The Z coordinate (third subscript into the 3-D Array)
;                   of the starting cell for the search.
;                   Data type : Long.
;       Min_val:    The minimum data value to search for. All cells that
;                   are connected to the starting cell, and have a value
;                   greater than or equal to Min_val and less that or equal
;                   to Max_val, will be considered part of the "object".
;       Max_val:    The maximum data value to search for.
;
; KEYWORD PARAMETERS:
;       DECREASE:   If the DECREASE or INCREASE keywords are specified,
;                   then SEARCH3D creates an internal copy of Array.
;                   This internal copy is then processed to enhance the
;                   object edges by using an algorithm similar to the
;                   "SOBEL" edge enhancement process (in 3-D). Any
;                   adjacent cells will be found if their corresponding
;                   data value in the edge enhanced array is greater
;                   than DECREASE and less than INCREASE. In any case,
;                   the adjacent cells will NEVER be selected if their
;                   data value is not between Min_val and Max_val.
;                   The default is 0.0 if INCREASE is specified.
;                   Otherwise, the default is no edge checking.
;                   Data type : Int or Float (usually less than zero).
;       INCREASE:   The maximum value in the edge enhanced array for
;                   a cell to be considered part of the selected object.
;                   Some savings in execution time and memory usage result
;                   when DECREASE and INCREASE are omitted.
;                   See DECREASE above.
;                   The default is 0.0 if DECREASE is specified.
;                   Otherwise, the default is no edge checking.
;                   Data type : Int or Float (usually greater than zero).
;       LPF_BAND:   This keyword indicates what (if any) Low Pass Filtering
;                   is performed on the edge enhanced array before the
;                   search begins. If LPF_BAND is set to 3 or higher
;                   then the edge enhanced array will be smoothed using
;                   LPF_BAND as the width of the smoothing window.
;                   If LPF_BAND is less than 3 then no smoothing is
;                   performed. This keyword only has effect when the
;                   DECREASE or INCREASE keywords are supplied.
;                   See DECREASE above.
;                   The default is zero (no smoothing).
;                   Data type : Int.
;       DIAGONAL:   Normally, cells are considered adjacent only when
;                   cubes surrounding the cells share a common face.
;                   If a non-zero value is passed to DIAGONAL then
;                   SEARCH3D will also locate cells meeting the search
;                   criteria whose surrounding cubes share a common
;                   edge or corner. Specifying diagonal search mode
;                   requires more memory and execution time.
;                   The default is no diagonal searching.
;                   Data type : int
;
; OUTPUTS:
;       This function returns a list of the indices into the 3-D array
;       that are part of the located object or region. This list is
;       returned as a LONARR(n) where n is the number of cells found.
;
;       If the returned array of indices is called Region, and the
;       size of the 3-D volume of data is size_x by size_y by size_z,
;       then the actual X, Y, and Z indices can be obtained by using
;       the following algorithm :
;
;          index_z = Region / (size_x * size_y)
;          index_y = (Region - (index_z * size_x * size_y)) / size_x
;          index_x = (Region - (index_z * size_x * size_y)) - (index_y * size_x)
;
;       The object within the 3-D Array could then be subscripted as :
;
;          Array(Region)
;       OR
;          Array(index_x, index_y, index_z)
;
; EXAMPLE:
;       Find all the indices corresponding to an object contained in a
;       3-D volume of data.
;
;       ; Create some data.
;          vol = RANDOMU(s, 40, 40, 40)
;          vol(3:13, 1:15, 17:33) = 1.3
;          vol(15:25, 5:25, 15:25) = 0.2
;          vol(5:30,17:38,7:28) = 1.3
;          vol(9:23, 16:27, 7:33) = 1.5
;
;       ; Search for an object starting at (6, 22, 16) whose data values
;       ; are between (1.2) and (1.4)..
;          Region = SEARCH3D(vol, 6, 22, 16, 1.2, 1.4, /DIAGONAL)
; 
;       ; Scale the background cells into the range 0 to 127.
;          vol = BYTSCL(vol, TOP=127B)
;
;       ; Highlight the object region by setting it to 255.
;          vol(Region) = 255B
; 
;       ; Set up a 3-D view.
;          Window, 0, Xsize=640, Ysize=512, Retain=2
;          Create_View, Xmax=39, Ymax=39, Zmax=39, ax=(-30), az=30, zoom=0.8
; 
;       ; Display the volume with the highlighted object in it.
;          TVSCL, PROJECT_VOL(vol, 64, 64, 40, Depth_Q=0.4)
;
; MODIFICATION HISTORY:
;       Written by:     Daniel Carr. Thu Sep  3 17:36:04 MDT 1992
;-

FUNCTION Search3d, array, xpos, ypos, zpos, min_val, max_val, $
                   Decrease=decrease, Increase=increase, $
                   Lpf_band=smooth_band, Diagonal=diagonal
; *** Test inputs

size_array = Size(array)
IF (size_array(0) NE 3L) THEN BEGIN
   Print, 'Array must have three dimensions'
   STOP
ENDIF
x_size = size_array(1)
y_size = size_array(2)
z_size = size_array(3)

xpos = Long(xpos(0))
ypos = Long(ypos(0))
zpos = Long(zpos(0))
IF (xpos LT 0L) THEN BEGIN
   Print, 'Xpos must be >= 0'
   STOP
ENDIF
IF (xpos GE x_size) THEN BEGIN
   Print, 'Xpos must be < array size'
   STOP
ENDIF
IF (ypos LT 0L) THEN BEGIN
   Print, 'Ypos must be >= 0'
   STOP
ENDIF
IF (ypos GE y_size) THEN BEGIN
   Print, 'Ypos must be < array size'
   STOP
ENDIF
IF (zpos LT 0L) THEN BEGIN
   Print, 'Zpos must be >= 0'
   STOP
ENDIF
IF (zpos GE z_size) THEN BEGIN
   Print, 'Zpos must be < array size'
   STOP
ENDIF

min_val = min_val(0)
max_val = max_val(0)

IF (max_val LT min_val) THEN BEGIN
   Print, 'Max value must be >= min value'
   STOP
ENDIF

start_val = array(xpos,ypos,zpos)
IF ((start_val LT min_val) OR (start_val GT max_val)) THEN BEGIN
   Print, 'Value of array at (xpos,ypos,zpos) must be >= min_val and <= max_val'
   STOP
ENDIF

dec = 0.0
inc = 0.0
range = 0B
IF (N_Elements(decrease) GT 0L) THEN BEGIN
   dec = Float(decrease(0))
   range = 1B
ENDIF
IF (N_Elements(increase) GT 0L) THEN BEGIN
   inc = Float(increase(0))
   range = 1B
ENDIF

sb = 0
IF (N_Elements(smooth_band) GT 0L) THEN sb = Fix(smooth_band(0))
IF ((sb GE x_size) OR (sb GE y_size)) THEN BEGIN
   Print, 'Smooth band must be < size of array'
   STOP
ENDIF

diag = 0B
IF (N_Elements(diagonal) GT 0L) THEN diag = Byte(diagonal(0))

IF (range) THEN BEGIN

   ; *** Calculate the edge enhanced array

   IF (diag) THEN BEGIN
      diff_array = Float(array)
      diff_array = diff_array < $
                     (diff_array - Shift(array,  0,  1,  0)) < $
                     (diff_array - Shift(array,  1,  1,  0)) < $
                     (diff_array - Shift(array,  1,  0,  0)) < $
                     (diff_array - Shift(array,  1, -1,  0)) < $
                     (diff_array - Shift(array,  0, -1,  0)) < $
                     (diff_array - Shift(array, -1, -1,  0)) < $
                     (diff_array - Shift(array, -1,  0,  0)) < $
                     (diff_array - Shift(array, -1,  1,  0)) < $
                     (diff_array - Shift(array,  0,  1,  1)) < $
                     (diff_array - Shift(array,  1,  1,  1)) < $
                     (diff_array - Shift(array,  1,  0,  1)) < $
                     (diff_array - Shift(array,  1, -1,  1)) < $
                     (diff_array - Shift(array,  0, -1,  1)) < $
                     (diff_array - Shift(array, -1, -1,  1)) < $
                     (diff_array - Shift(array, -1,  0,  1)) < $
                     (diff_array - Shift(array, -1,  1,  1)) < $
                     (diff_array - Shift(array,  0,  1, -1)) < $
                     (diff_array - Shift(array,  1,  1, -1)) < $
                     (diff_array - Shift(array,  1,  0, -1)) < $
                     (diff_array - Shift(array,  1, -1, -1)) < $
                     (diff_array - Shift(array,  0, -1, -1)) < $
                     (diff_array - Shift(array, -1, -1, -1)) < $
                     (diff_array - Shift(array, -1,  0, -1)) < $
                     (diff_array - Shift(array, -1,  1, -1)) < $
                     (diff_array - Shift(array,  0,  0,  1)) < $
                     (diff_array - Shift(array,  0,  0, -1))
      IF (sb GT 0) THEN diff_array = Smooth(diff_array, sb)
   ENDIF ELSE BEGIN
      diff_array = Float(array)
      diff_array = diff_array < $
                     (diff_array - Shift(array,  0,  1,  0)) < $
                     (diff_array - Shift(array,  1,  0,  0)) < $
                     (diff_array - Shift(array,  0, -1,  0)) < $
                     (diff_array - Shift(array, -1,  0,  0)) < $
                     (diff_array - Shift(array,  0,  0,  1)) < $
                     (diff_array - Shift(array,  0,  0, -1))
      IF (sb GT 0) THEN diff_array = Smooth(diff_array, sb)
   ENDELSE
ENDIF

; *** Set up the required variables

similar_val = 1B
connect_val = 2B

c_array = Bytarr(x_size, y_size, z_size)
c_array(Where((array GE min_val) AND (array LE max_val))) = similar_val

x_size_m1 = x_size - 1L
y_size_m1 = y_size - 1L
z_size_m1 = z_size - 1L

x_ind = xpos
y_ind = ypos
z_ind = zpos
just_found = (z_ind * y_size * x_size) + (y_ind * x_size) + x_ind

c_array(just_found) = connect_val
num_found = 1L

; *** Start the search

IF (diag EQ 0B) THEN BEGIN   ; *** No diagonal mode
   nsew_ind = Lonarr(6, 1)
   nsew_ind(0, *) = (z_ind * y_size * x_size) + $
                    (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
   nsew_ind(1, *) = (z_ind * y_size * x_size) + $
                    (((y_ind - 1L) > 0L) * x_size) + x_ind
   nsew_ind(2, *) = (z_ind * y_size * x_size) + $
                    (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
   nsew_ind(3, *) = (z_ind * y_size * x_size) + $
                    (y_ind * x_size) + ((x_ind - 1L) > 0L)
   nsew_ind(4, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                    (y_ind * x_size) + x_ind
   nsew_ind(5, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                    (y_ind * x_size) + x_ind

   cc_array = c_array(nsew_ind(*))
   just_found = Where(cc_array EQ similar_val)

   ; *** Loop while cells are still being found

   WHILE (just_found(0) GE 0L) DO BEGIN
      cc_array(just_found) = connect_val
      c_array(nsew_ind(just_found)) = cc_array(just_found)
      z_ind = nsew_ind(just_found) / (y_size * x_size)
      y_ind = (nsew_ind(just_found) - (z_ind * y_size * x_size)) / (x_size)
      x_ind = (nsew_ind(just_found) - (z_ind * y_size * x_size)) - $
              (y_ind * x_size)

      num_found = N_Elements(just_found)
      nsew_ind = Lonarr(6, num_found, /Nozero)

      nsew_ind(0, *) = (z_ind * y_size * x_size) + $
                       (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
      nsew_ind(1, *) = (z_ind * y_size * x_size) + $
                       (((y_ind - 1L) > 0L) * x_size) + x_ind
      nsew_ind(2, *) = (z_ind * y_size * x_size) + $
                       (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
      nsew_ind(3, *) = (z_ind * y_size * x_size) + $
                       (y_ind * x_size) + ((x_ind - 1L) > 0L)
      nsew_ind(4, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                       (y_ind * x_size) + x_ind
      nsew_ind(5, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                       (y_ind * x_size) + x_ind

      nsew_ind = nsew_ind(Sort(nsew_ind(*)))
      nsew_ind = nsew_ind(Uniq(nsew_ind))

      cc_array = c_array(nsew_ind(*))

      IF (range) THEN BEGIN
         t_array = diff_array(nsew_ind(*))
         just_found = Where((cc_array EQ similar_val) AND $
                           ((t_array GE dec) AND $
                            (t_array LE inc)))
      ENDIF ELSE BEGIN
         just_found = Where(cc_array EQ similar_val)
      ENDELSE
   ENDWHILE
ENDIF ELSE BEGIN   ; *** Diagonal mode
   nsew_ind = Lonarr(26, 1)
   nsew_ind( 0, *) = (z_ind * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
   nsew_ind( 1, *) = (z_ind * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + x_ind
   nsew_ind( 2, *) = (z_ind * y_size * x_size) + $
                     (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
   nsew_ind( 3, *) = (z_ind * y_size * x_size) + $
                     (y_ind * x_size) + ((x_ind - 1L) > 0L)
   nsew_ind( 4, *) = (z_ind * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind( 5, *) = (z_ind * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind( 6, *) = (z_ind * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind( 7, *) = (z_ind * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind( 8, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
   nsew_ind( 9, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + x_ind
   nsew_ind(10, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
   nsew_ind(11, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (y_ind * x_size) + ((x_ind - 1L) > 0L)
   nsew_ind(12, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind(13, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind(14, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind(15, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind(16, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
   nsew_ind(17, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + x_ind
   nsew_ind(18, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
   nsew_ind(19, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (y_ind * x_size) + ((x_ind - 1L) > 0L)
   nsew_ind(20, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind(21, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind(22, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (((y_ind + 1L) < y_size_m1) * x_size) + $
                     ((x_ind - 1L) > 0L)
   nsew_ind(23, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (((y_ind - 1L) > 0L) * x_size) + $
                     ((x_ind + 1L) < x_size_m1)
   nsew_ind(24, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                     (y_ind * x_size) + x_ind
   nsew_ind(25, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                     (y_ind * x_size) + x_ind

   cc_array = c_array(nsew_ind(*))
   just_found = Where(cc_array EQ similar_val)

   ; *** Loop while cells are still being found

   WHILE (just_found(0) GE 0L) DO BEGIN
      cc_array(just_found) = connect_val
      c_array(nsew_ind(just_found)) = cc_array(just_found)
      z_ind = nsew_ind(just_found) / (y_size * x_size)
      y_ind = (nsew_ind(just_found) - (z_ind * y_size * x_size)) / (x_size)
      x_ind = (nsew_ind(just_found) - (z_ind * y_size * x_size)) - $
              (y_ind * x_size)

      num_found = N_Elements(just_found)
      nsew_ind = Lonarr(26, num_found, /Nozero)
      nsew_ind( 0, *) = (z_ind * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
      nsew_ind( 1, *) = (z_ind * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + x_ind
      nsew_ind( 2, *) = (z_ind * y_size * x_size) + $
                        (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
      nsew_ind( 3, *) = (z_ind * y_size * x_size) + $
                        (y_ind * x_size) + ((x_ind - 1L) > 0L)
      nsew_ind( 4, *) = (z_ind * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind( 5, *) = (z_ind * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind( 6, *) = (z_ind * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind( 7, *) = (z_ind * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind( 8, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
      nsew_ind( 9, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + x_ind
      nsew_ind(10, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
      nsew_ind(11, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (y_ind * x_size) + ((x_ind - 1L) > 0L)
      nsew_ind(12, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind(13, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind(14, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind(15, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind(16, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + x_ind
      nsew_ind(17, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + x_ind
      nsew_ind(18, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (y_ind * x_size) + ((x_ind + 1L) < x_size_m1)
      nsew_ind(19, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (y_ind * x_size) + ((x_ind - 1L) > 0L)
      nsew_ind(20, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind(21, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind(22, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (((y_ind + 1L) < y_size_m1) * x_size) + $
                        ((x_ind - 1L) > 0L)
      nsew_ind(23, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (((y_ind - 1L) > 0L) * x_size) + $
                        ((x_ind + 1L) < x_size_m1)
      nsew_ind(24, *) = (((z_ind + 1L) < z_size_m1) * y_size * x_size) + $
                        (y_ind * x_size) + x_ind
      nsew_ind(25, *) = (((z_ind - 1L) > 0L) * y_size * x_size) + $
                        (y_ind * x_size) + x_ind

      nsew_ind = nsew_ind(Sort(nsew_ind(*)))
      nsew_ind = nsew_ind(Uniq(nsew_ind))

      cc_array = c_array(nsew_ind(*))

      IF (range) THEN BEGIN
         t_array = diff_array(nsew_ind(*))
         just_found = Where((cc_array EQ similar_val) AND $
                           ((t_array GE dec) AND $
                            (t_array LE inc)))
      ENDIF ELSE BEGIN
         just_found = Where(cc_array EQ similar_val)
      ENDELSE
   ENDWHILE
ENDELSE

; *** Clean up and return

x_ind = 0
y_ind = 0
nsew_ind = 0
cc_array = 0
t_array = 0
diff_array = 0

index = Where(c_array EQ connect_val)

RETURN, index
END
; $Id: setup_keys.pro,v 1.2 1994/11/23 05:54:48 ali Exp $

;+
; NAME:
;	SETUP_KEYS
;
; PURPOSE:
;	Set up function keys for use with IDL.
;
;	Under Unix, the number of function keys, their names, and the
;	escape sequences they send to the host computer vary
;	enough between various keyboards that IDL cannot be
;	written to understand all keyboards.  Therefore, it provides
;	a very general routine named DEFINE_KEY that allows the
;	user to specify the names and escape sequences of function keys.
;
;	SETUP_KEYS uses DEFINE_KEY (called via modular procedures) to
;	enter the keys for known keyboards (Sun3, DEC VT200, HP, 
;	Mips, PSTERM, SGI).
;
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	SETUP_KEYS
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;	NOTE:  If no keyword is specified, SETUP_KEYS uses !VERSION to
;	determine the type of machine running IDL. It assumes that the
;	keyboard involved is of the same type (usually this is correct).
;
;    EIGHTBIT:	When establishing VT200 function key definitions,
;		use the 8-bit versions of the escape codes instead
;		of the default 7-bit.
;
;	SUN:	Establish function key definitions for a Sun3 keyboard.
;
;	VT200:	Establish function key definitions for a DEC VT200 keyboard.
;
;	HP9000:	Establish function key definitions for an HP 9000 series
;		300 keyboard.  Although the HP 9000 series 300 supports both
;		xterm and hpterm windows, IDL supports only user-definable
;		key definitions in xterm windows - hpterm windows use
;		non-standard escape sequences which IDL does not attempt
;		to handle.
;
;	IBM	Establish function key definitions for an IBM keyboard.
;
;	MIPS:	Establish function key definitions for a Mips RS series
;		keyboard.
;
;	PSTERM:	Establish function key definitions for PSTERMS such as those
;		found on the Sun Sparc Station.
;
;	SGI:	Establish function key definitions for SGI keyboards.
;
;  APP_KEYPAD:	Will define escape sequences for the group of keys
;		in the numeric keypad, enabling these keys to be programmed
;		within IDL.
;
;  NUM_KEYPAD:	Will disable programmability of the numeric keypad.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The definitions for the function keys are entered.  The new keys
;	can be viewed using the command HELP, /KEYS.
;
;	For the HP keyboard, the upper right-hand group of four keys (at the
;	same height as the function keys) are called "BLANK1" through
;	"BLANK4", since they have no written labels.  Keys defined to have
;	labels beginning with a capital "K" belong to the numeric keypad
;	group.  For example, "K9" refers to keypad key "9".
;
;	Although the HP 9000 series 300 can create both xterm and hpterm
;	windows, IDL supports only user-definable key definitions in xterm
;	windows - hpterm windows use non-standard escape sequences which
;	IDL does not attempt to handle.
;
; MODIFICATION HISTORY:
;	AB, 26 April 1989
;	TJA, July 1990.	Added key definitions for HP 9000 series 300, as
;			well as Mips RS series; also rearranged code into 
;			separate files.
;
;	SMR, April, 1991.  Added key definitions for SGI and PSTERM
;	AB, 22 November 1994, Added key definitions for IBM.
;-
PRO setup_keys, SUN = SUN, VT200 = VT200, EIGHTBIT = EIGHTBIT, $
	HP9000 = HP9000, MIPS = MIPS, APP_KEYPAD = APP_KEYPAD, $
	NUM_KEYPAD = NUM_KEYPAD, PSTERM = PSTERM, SGI = SGI, $
	IBM = IBM

ON_ERROR,2                              	;Return to caller if an error
						;occurs

IF (!VERSION.OS EQ 'vms') THEN $		;VMS keys are fixed
  MESSAGE, 'VMS key names are "pre-set" by the Screen Management Utility.'

do_sun		= KEYWORD_SET(SUN)
do_psterm	= KEYWORD_SET(PSTERM)
do_dec		= KEYWORD_SET(VT200)
do_hp		= KEYWORD_SET(HP9000)
do_mips		= KEYWORD_SET(MIPS)
do_sgi		= KEYWORD_SET(SGI)
do_ibm		= KEYWORD_SET(IBM)

IF ((NOT do_sun) AND $				;Default to Sun if sunos, HP 
    (NOT do_psterm) AND $			;if hp-ux, mips if mipqs 
    (NOT do_dec) AND $				;arch., else vt200 (DEC)
    (NOT do_hp) AND $
    (NOT do_mips) AND $
    (NOT do_ibm) AND $
    (NOT do_sgi)) THEN BEGIN
  
  IF (!VERSION.OS EQ "sunos") THEN do_sun = 1 $
  ELSE IF (!VERSION.OS EQ "hp-ux") THEN do_hp = 1 $
  ELSE IF (!VERSION.OS EQ "IRIX") THEN do_sgi = 1 $
  ELSE IF (!VERSION.OS EQ "AIX") THEN do_ibm = 1 $
  ELSE IF (STRPOS(!VERSION.ARCH,"mips") NE -1) THEN do_mips = 1 $
  ELSE do_dec = 1
ENDIF

IF (do_psterm) THEN skey_sun, /PSTERM $
ELSE IF (do_sun) THEN skey_sun, PSTERM = PSTERM $
ELSE IF (do_dec) THEN skey_dec, EIGHTBIT = EIGHTBIT, $
			APP_KEYPAD = APP_KEYPAD, $
			NUM_KEYPAD = NUM_KEYPAD $
ELSE IF (do_hp) THEN skey_hp, APP_KEYPAD = APP_KEYPAD, $
			NUM_KEYPAD = NUM_KEYPAD $
ELSE IF (do_sgi) THEN skey_sgi $
ELSE IF (do_ibm) THEN skey_ibm $
ELSE IF (do_mips) THEN skey_mips, APP_KEYPAD = APP_KEYPAD, $
			NUM_KEYPAD = NUM_KEYPAD
END
function sfit, z, degree, kx=kx
;+
; NAME:
;	SFIT
;
; PURPOSE:
;	This function determines a polynomial fit to a surface.
;
; CATEGORY:
;	Curve and surface fitting.
;
; CALLING SEQUENCE:
;	Result = SFIT(Data, Degree)
;
; INPUTS:
; 	Data:	The two-dimensional array of data to fit. The sizes of
;		the dimensions may be unequal.
;
;	Degree:	The maximum degree of fit (in one dimension).
;
; OUTPUT:
;	This function returns a fitted array.
;
; OUTPUT KEYWORDS:
;	Kx:	The array of coefficients for a polynomial function
;		of x and y to fit data.
;		This parameter is returned as a (Degree+1) by (Degree+1) 
;		element array.
;
; PROCEDURE:
; 	Fit a 2D array Z as a polynomial function of x and y.
; 	The function fitted is:
;  	    F(x,y) = Sum over i and j of kx(j,i) * x^i * y^j
; 	where kx is returned as a keyword.
;
; MODIFICATION HISTORY:
;	July, 1993, DMS		Initial creation
;
;-

   on_error, 2

   s = size(z)
   nx = s(1)
   ny = s(2)
   m = nx * ny		;# of points to fit
   n2=(degree+1)^2		;# of coefficients to solve
   x = findgen(nx) # replicate(1., ny)   ;X values at each point
   y = replicate(1.,nx) # findgen(ny)

   ut = dblarr(n2, m, /nozero)
   for i=0, degree do for j=0,degree do $
	ut(i*(degree+1) + j, 0) = reform(x^i * y^j, 1, m)

   kk = invert(ut # transpose(ut)) # ut
   kx = fltarr(degree+1, degree+1) + float(kk # reform(z, m, 1))
   fit = reform(reform(kx,n2) # ut, nx, ny)
   return, fit
end


; $Id: shade_surf_irr.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro SHADE_SURF_IRR, z, x, y, AX = ax, AZ = az, SHADES = shades, $
	PLIST = plist,  IMAGE = Image
;+
; NAME:
;	SHADE_SURF_IRR
;
; PURPOSE:
;	Make a shaded surface representation of an irregulary gridded
;	elevation dataset.
;
;	The data must be representable as an array of quadrilaterals.  This 
;	routine should be used when the (X, Y, Z) arrays are too irregular to 
;	be drawn by SHADE_SURF, but are still semi-regular.
;
; CATEGORY:
;	Graphics, surface plotting.
;
; CALLING SEQUENCE:
;	SHADE_SURF_IRR, Z, X, Y
;
; INPUTS:
;	Z:	A 2D array of elevations.  This array must be dimensioned 
;		as (NX, NY).
;
;	X:	A 2D array containing the X location of each Z value.  This
;		array must be dimensioned as (NX, NY).
;
;	Y:	A 2D array containing the Y location of each Z value.  This
;		array must be dimensioned as (NX, NY).
;
; KEYWORD PARAMETERS:
;	AX:	The angle of rotation about the X axis.  The default is 30
;		degrees.  This parameter is passed to SURFR.
;
;	AZ:	The angle of rotation about the Z axis.  The default is 30
;		degrees.  This parameter is passed to SURFR.
;
;	IMAGE:	Set this keyword to an array that will contain the resulting
;		shaded surface image.  The variable is returned as a byte 
;		array of the same size as the currently selected graphics 
;		device.
;
;	PLIST:	Set this keyword to an array that will contain the polygon
;		list on return.  This feature is useful when you want to make a
;		number of images from the same set of vertices and polygons.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The currently selected display is modified.
;
; RESTRICTIONS:
;	The grid described by X and Y must consist of quadrilaterals,
;	must be semi-regular, and must be in "CLOCKWISE" order:
;	i.e., each cell must be defined by the vertices:
;
;		v(i,j), v(i+1,j),v(i+1,j+1), and v(i,j+1).
;
;	Clockwise ordering:
;
;		x(i,j) <= x(i+1, j) ... for all j
;	and	y(i,j) <= y(i, j+1) ... for all i.
;
;	WARNING:  This restriction is not checked.
;
; PROCEDURE:
;	First, SURFR is called to establish the 3D to 2D transformation.
;	Then the vertex and polygon data structures required by the
;	POLYSHADE function are built and passed that function.  POLYSHADE
;	returns the shaded image which is then displayed by TV.
;
;	This simple procedure can be modified to use and/or accept
;	additional keywords.
;
; MODIFICATION HISTORY:
;	Oct, 1989, DMS.	
;	DMS, 	Modified to use SURFR instead of SURFACE. and to return the
;		polygon list.
;-

on_error,2                      ;Return to caller if an error occurs
s = size(z)
if s(0) ne 2 then begin
	print,'Shade - Not 2d'
	return
	endif

nx = s(1)			; # of columns
ny = s(2)			; # of rows

if n_elements(ax) eq 0 then ax = 30.	;Default rotations
if n_elements(az) eq 0 then az = 30.
;
;	Establish axis scaling:
;
scale = 0.9			;The fraction of the screen we use.
minx = min(x, max = maxx)
miny = min(y, max = maxy)
minz = min(z, max = maxz)

sx = scale / (maxx - minx)	;Scale factors
sy = scale / (maxy - miny)
sz = scale / (maxz - minz)

!x.s = [(1.-scale)/2. - minx * sx, sx]  ;Set axis scalings
!y.s = [(1.-scale)/2. - miny * sy, sy]
!z.s = [(1.-scale)/2. - minz * sz, sz]

surfr, ax = ax, az = az  ;establish rotation

plist = intarr(5,nx-1,ny-1)	;Make polygons

for i=0,nx-2 do for j=0,ny-2 do begin
	ll = i + j*nx		;Vertex index
	plist(0,i,j) = [ 4, ll, ll+1, ll+nx+1, ll+nx]
	endfor
if n_elements(shades) eq 0 then $
  image = polyshade(x,y,z,plist,/t3d,/data) $
 else $
  image = polyshade(x,y,z,plist,/t3d,/data, shades = shades)

tv, image
end
; $Id: show3.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro show3, image, interp = interp, sscale=sscale  ;Show an image three ways...
;+
; NAME:
;	SHOW3
;
; PURPOSE:
;	Show a 2D array three ways in a display that combines SURFACE, 
;	CONTOUR, and an image (color/gray scale pixels).
;
; CATEGORY:
;	Display, graphics.
;
; CALLING SEQUENCE:
;	SHOW3, Image [, INTERP = Interp, SSCALE = Sscale]
;
; INPUTS:
;	Image:	The 2-dimensional array to display.
;
; KEYWORD PARAMETERS:
;	INTERP:	Set this keyword to use bilinear interpolation on the pixel 
;		display.  This technique is slightly slower, but for small 
;		images, it makes a better display.
;
;	SSCALE:	Reduction scale for surface. The default is 1.  If this
;		keyword is set to a value other than 1, the array size 
;		is reduced by this factor for the surface display.  That is, 
;		the number of points used to draw the wire-mesh surface is
;		reduced.  If the array dimensions are not an integral multiple
;		of SSCALE, the image is reduced to the next smaller multiple.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A new plot is generated.
;
; RESTRICTIONS:
;	The display gets too "busy" when displaying larger (say 50 by 50),
;	images, especially if they are noisy.  It can be helpful to use
;	the SSCALE keyword or the SMOOTH and/or REBIN functions to smooth the 
;	surface plot.
;
;	You might want to modify the calls to CONTOUR and SURFACE slightly
;	to customize the display to your tastes, i.e., with different colors,
;	skirts, linestyles, contour levels, etc.
;
; PROCEDURE:
;	First, do a SURFACE with no data to establish the 3D to 2D scaling.
;	Then convert the coordinates of the corner pixels of the array to
;	2D.  Use POLYWARP to get the warping polynomial to warp the
;	2D image into the area underneath the SURFACE plot.  Output the image,
;	output the surface (with data) and then output the contour plot at
;	the top (z=1).
;
; MODIFICATION HISTORY:
;	DMS. Jan, 1988.
;	Added fudges for PostScript, April, 1988.
;	Fixed bug where contour plot was occasionally clipped. Dec, 1990.
;-
on_error,2              ;Return to caller if an error occurs
s = size(image)		;Get size of image
nx = s(1)		;Columns
ny = s(2)		;Rows

if n_elements(sscale) eq 0 then sscale = 1 ;Default scale
sscale = fix(sscale)		;To Integer

if ((nx mod sscale) ne 0) or ((ny mod sscale) ne 0) then begin
	nx = (nx/sscale) * sscale ;To multiple
	ny = (ny/sscale) * sscale
	img = image(0:nx-1, 0:ny-1)
  endif else img = image

surface,img,/save,/nodata,xst=1,yst=1,zaxis=1 ;Set up scaling
empty			;Don't make 'em wait watching an empty screen.

xorig = [0.,nx-1,0.,nx-1]	;4 corners X locns in image
yorig = [0.,0.,ny-1,ny-1]	;4 corners Y locns

x = xorig * !x.s(1) + !x.s(0)	;Normalized X coord
y = yorig * !y.s(1) + !y.s(0)	;Normalized Y
			;To Homogeneous coords,  and transform
p = [[x],[y],[fltarr(4)],[replicate(1,4)]] # !P.T 
u = p(*,0)/p(*,3) * !d.x_vsize	;Scale U coordinates to device
v = p(*,1)/p(*,3) * !d.y_vsize	;and V
;
;	Now, the 4 corners of the place for the image are in u and v
;
u0 = min(u) & v0 = min(v)		;Lower left corner of screen box
su = max(u)- u0+1 & sv = max(v) - v0+1	;Size of new image
if (!d.flags and 1) eq 1 then begin	;Scalable pixels (PostScript)?
	fact = 50		;Yes, shrink it
	miss = 255		;Missing values are white
	c_color=[0,0]		;Contour in only one color, black
 endif else begin
	fact = 1 		;one pixel/output coordinate
	miss = 0		;missing is black
	c_color=[150,200,250]
 endelse

if (!d.flags and 512) ne 0 then $  ;White background?
	miss = 255 else miss = 0
;
	;Get polynomial coeff for warp
if !d.n_colors gt 2 then top = !d.n_colors -1 else top = 255
polywarp, xorig, yorig, (u-u0)/fact, (v-v0)/fact, 1, kx, ky 
if n_elements(interp) eq 0 then interp = 0
a = poly_2d(bytscl(img, top=top), kx, ky, interp,su/fact,sv/fact,$
		 missing = miss) ;Warp it
tv,a,u0,v0,xsize = su, ysize = sv
surface,rebin(img,nx/sscale, ny/sscale),$
	/save,/noerase,xst=1,yst=1, bot=128 ;Show the surface
			;And finally, draw contour on top
contour,img,/t3d,/noerase,zval=1.0,xst=1,yst=1,c_color = c_color,/noclip
end
; $Id: showfont.pro,v 1.3 1995/01/25 23:43:23 billo Exp $

PRO SHOWFONT, FONT, NAME, ENCAPSULATED = encapsulated
; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
;+
; NAME:
;	SHOWFONT
;
; PURPOSE:
;	This procedure displays a vector-drawn font on the current
;	graphics device.
;
; CATEGORY:
;	Fonts.
;
; CALLING SEQUENCE:
;	SHOWFONT, Font, Name
;
; INPUTS:
;	Font:	 The index number of the font (may range from 3 to 29).
;	Name:	 Title text to appear at top of display.
;
; KEYWORD PARAMETERS:
;	ENCAPSULATED:	If this keyword is set, and if the current graphics
;			device is "PS", makes encapsulated PostScript output.
;
; OUTPUTS:
;	No explicit outputs.
;
; SIDE EFFECTS:
;	A display is made.
;
; RESTRICTIONS:
;	Not very flexible.
;
; PROCEDURE:
;	Straightforward.
;
; EXAMPLE:
;	To create a display of Font 3 for PostScript:
;		SET_PLOT, 'PS'
;		SHOWFONT, 3, "Simplex Roman"
;
; MODIFICATION HISTORY:
; 	Written by:
;	DMS, Nov, 1992
;	WSO, 1/95, Updated for new directory structure
;-

if !d.name eq 'PS' then begin
	device, encap=KEYWORD_SET(encapsulated)	;Set encapsulated PS attribute
endif

erase
sesc = '!'+strtrim(font,2)	; Font selecting string

openr, unit, /GET_LUN, filepath('hersh1.chr', subdir=['resource', 'fonts'])  ;Peek into font file
hdr = lonarr(2,40)
readu, unit, hdr
		;Determine # of chars in font:
if hdr(1,font) lt 0 then nchars = 224 else nchars = 96  ;8 or 7 bits?
FREE_LUN, unit

;	Title line:
xyouts,0.5,.95,'!3Font '+strtrim(font,2)+', '+name,siz=2.5,$
	alig=0.5,/norm

nrows = nchars / 16
y0 = 0.87		;Top line
y1 = 0.03		;Bottom
dy = (y1-y0) / nrows
x0 = 0.03		;Left
x1 = .97		;Right
dx = (x1-x0) / 17

for ix=0,16 do begin	;Each column
	x = x0 + ix * dx
	y = y0 + 0.01
	xx = x + dx/2
	if ix eq 0 then s = '!3Octal' else $   ;Column header
		s = string((ix-1) and 15, format='(O2.2)')
	xyouts, xx, y, s, /NORM, ALIGN=0.5
	plots, [x,x],[y0,y1], /norm
	endfor

plots, [x1, x1], [y0, y1], /NORM 
plots, [x0, x1], [y0, y0], /NORM

for iy=0, nrows-1 do begin
	y = y0 + (iy+1) * dy
	plots, [x0, x1], [y, y], /NORM
	xyouts, x0+dx/2, y-dy/5, /NORM, ALIGN=0.5, $
		string((iy*16+32)/8, format="('!3',O2.2,'x')")
	for ix=0,15 do begin		;Each character
	    X = (ix+1) * dx + x0
	    k = iy*16 + ix + 32
	    s = string(byte(k))
	    if s eq '!' then s = '!!'
	    xyouts,x+.0225,y+.005,sesc+s,size=2.0,/norm,font=-1
	    endfor
	ENDFOR
RETURN
END

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

PRO ShowInfoEventHndlr, event

   WIDGET_CONTROL, GET_UVALUE = state, event.top, /NO_COPY

   CASE event.id OF

      state.wInfoWindow: BEGIN

           ; Get the new size of the window
         WIDGET_CONTROL, state.wInfoWindow, TLB_GET_SIZE=windowSize
         
           ; Determine the change in the window size
         deltaX = windowSize(0) - state.windowSize(0)
         deltaY = windowSize(1) - state.windowSize(1)

           ; Store the new size in the state structure for later comparisons
         state.windowSize = windowSize

           ; Get the pixel size of the text widget
         textEditGeometry = WIDGET_INFO(state.wInfoText, /GEOMETRY)
         
           ; Determine the new size based on the amount the window grew
         newTextEditXSize = textEditGeometry.scr_xsize + deltaX
         newTextEditYSize = textEditGeometry.scr_ysize + deltaY

           ; Resize the text widget accordingly
         WIDGET_CONTROL, state.wInfoText, SCR_XSIZE=newTextEditXSize, $
           SCR_YSIZE=newTextEditYSize

         ENDCASE

      ENDCASE

   WIDGET_CONTROL, SET_UVALUE = state, event.top, /NO_COPY

END


FUNCTION GetInfoText, fileName, WIDTH=width, HEIGHT=height

   OPENR, unit, fileName, /GET_LUN, ERROR=error		;open the file and then

     ; If an error occurred when opening the file
   IF error LT 0 THEN $ 
      buttonPushed = WIDGET_MESSAGE(/ERROR, $
                          [!err_string, ' Can not get information from "' + $
                           fileName + '"']) $
      
   ELSE BEGIN
      maxLines = 1000
      lineInc = 250
      infoText = STRARR(MAXLINES)	;Maximum # of lines
      lineNumber = 0
      lineOfText = '' 
      lineLength  = 0
      longestLength  = 0
   	WHILE NOT EOF(unit) DO BEGIN

   		READF, unit, lineOfText

                lineLength = lineLength > STRLEN(lineOfText)
            
   		infoText(lineNumber) = lineOfText

   		lineNumber = lineNumber + 1

                ;If the maximum number of lines is hit,
                ;increase the array size by lineInc
                IF (lineNumber EQ maxLines) THEN BEGIN
                   infoText = [infoText, STRARR(lineInc)]
                   maxLines = maxLines + lineInc
                ENDIF

   	   ENDWHILE

   	infoText = infoText(0:(lineNumber-1) > 0)

      IF KEYWORD_SET(height) NE 0 THEN $
         height = lineNumber-1
      IF KEYWORD_SET(width) NE 0 THEN $
         width = lineLength

   	FREE_LUN, unit				; Free the file unit.

      RETURN, infoText
      ENDELSE

   RETURN, ""

END


PRO ShowInfo, fileName, TITLE = title, GROUP = group, WIDTH = width, $
		HEIGHT = height, INFOTEXT = infoText, FONT = font, $
                XOFFSET = xOffset, YOFFSET=yOffset, NO_NEWLINE=noNewLine

   IF (NOT(KEYWORD_SET(noNewLine))) THEN $
      noNewLine = 0
   IF (NOT(KEYWORD_SET(infoText))) THEN BEGIN

      IF (NOT(KEYWORD_SET(fileName))) THEN BEGIN
         buttonPushed = WIDGET_MESSAGE(/ERROR, $
            'Filename missing in call to the procedure "ShowInfo"')
         RETURN
         ENDIF

      IF (NOT(KEYWORD_SET(title))) THEN $
         title = fileName

      WIDGET_CONTROL, /HOURGLASS
      
      infoText = GetInfoText(fileName)

      textSize = SIZE(infoText)
      IF (textSize(0) EQ 0) THEN $
         RETURN

      ENDIF $
   ELSE BEGIN
      IF (NOT(KEYWORD_SET(title))) THEN $
         title = "Info"
      ENDELSE

   IF (NOT(KEYWORD_SET(width))) THEN $
      width = 80
   IF (NOT(KEYWORD_SET(height))) THEN $
      height = 30

   IF (KEYWORD_SET(xOffset)) AND (KEYWORD_SET(yOffset)) THEN $
      wInfoWindow = WIDGET_BASE(TITLE=title, UVALUE="INFO_WINDOW", $
        /TLB_SIZE_EVENTS, XOFFSET=xOffset, YOFFSET=yOffset) $
   ELSE $
      wInfoWindow = WIDGET_BASE(TITLE=title, UVALUE="INFO_WINDOW", $
        /TLB_SIZE_EVENTS)
   
   IF N_ELEMENTS(font) GT 0 THEN $
		  ; Create a text widget with the desired font
      wInfoText = WIDGET_TEXT(wInfoWindow, XSIZE=width, YSIZE=height, $
   		           /SCROLL, FONT=font, VALUE=infoText, $
                           NO_NEWLINE=noNewLine, /WRAP) $
   ELSE $
		  ; Create a text widget when no font is specified
      wInfoText = WIDGET_TEXT(wInfoWindow, XSIZE=width, YSIZE=height, $
   		           /SCROLL, VALUE=infoText, NO_NEWLINE=noNewLine,$
                           /WRAP)

   WIDGET_CONTROL, wInfoWindow, /REALIZE			; Display the Window

   WIDGET_CONTROL, wInfoWindow, TLB_GET_SIZE=windowSize

   state = { $
             wInfoWindow : wInfoWindow, $
             wInfoText : wInfoText, $
             windowSize : windowSize $
           }

   WIDGET_CONTROL, wInfoWindow, SET_UVALUE=state

	  ; Register it with the widget manager
   Xmanager, "ShowInfo", wInfoWindow, GROUP_LEADER=group, $
   		EVENT_HANDLER="ShowInfoEventHndlr" 

END  ;--------------------- procedure ShowInfo ----------------------------
; $Id: skey_dec.pro,v 1.2 1993/06/16 22:26:28 ali Exp $

pro skey_dec,eightbit=eightbit,app_keypad=app_keypad, num_keypad=num_keypad
;+
; NAME:
;	SKEY_DEC
;
; PURPOSE:
;	Under Unix, the number of function keys, their names, and the
;	escape sequences they send to the host computer vary
;	enough between various keyboards that IDL cannot be
;	written to understand all keyboards. Therefore, it provides
;	a very general routine named DEFINE_KEY that allows the
;	user to specify the names and escape sequences. This
;	routine uses DEFINE_KEY to enter the keys for a DEC
;	VT200-style keyboard.
;
;	Note: SKEY_DEC is primarily designed to be called by
;	SETUP_KEYS, which attempts to automatically detect the correct
;	keyboard type in use, and define the keys accordingly.
;	Nonetheless, SKEY_DEC can be called as a standalone
;	routine.
;
;	This procedure is for Unix systems - NOT VMS.
;
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	SKEY_DEC
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;    EIGHTBIT:	When establishing VT200 function key definitions,
;		use the 8-bit versions of the escape codes instead
;		of the default 7-bit.
;
;  APP_KEYPAD:	Defines escape sequences for the group of keys
;		in the numeric keypad, enabling these keys to be programmed
;		within IDL.
;
;  NUM_KEYPAD:	Disables programmability of the numeric keypad.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The definitions for the function keys have been entered, and
;	can be viewed using the command HELP, /KEYS .
;
; MODIFICATION HISTORY:
;	AB, 26 April 1989
;	TJA, July 1990, setup_keys_dec created by the "breakup" of setup_keys
;		into separate files.  Also, keywords added to enable and
;		disable programmability of the numeric keypad.
;	AB, 21 September 1992,renamed from SETUP_KEYS_DEC to SKEY_DEC to
;		avoid DOS filename limitations.
;	AB, 16 June 1993, The IDL scanner used to treat octal string escapes
;		in a manner similar to the C language, but this ability was
;		removed to make the MS DOS port possible (conflicts with
;		file path specifications). Removed all uses of that here.
;-
if (keyword_set(app_keypad)) then print,string(byte([27,61])) ; Enable keypad
if (keyword_set(num_keypad)) then print,string(byte([27,62])) ; Disable keypad
if keyword_set(eightbit) then begin
  esc = string(155B)			; \233
  keypad = string(143B)			; \217
  ; Eight bit arrow keys
  define_key, "UP_ARROW (EIGHT BIT)", esc=esc+'A', /PREVIOUS_LINE
  define_key, "DOWN_ARROW (EIGHT BIT)", esc=esc+'B', /NEXT_LINE
  define_key, "RIGHT_ARROW (EIGHT BIT)", esc=esc+'C', /FORWARD_CHARACTER
  define_key, "LEFT_ARROW (EIGHT BIT)", esc=esc+'D', /BACK_CHARACTER
endif else begin
  esc = string(27B) + '['
  keypad = string(27B) + 'O'
endelse
; Top row function keys
start = [6, 12, 17]
finish = [10, 14, 20]
offset = [11, 12, 14]
for i = 0, 2 do begin
  for j=start(i),finish(i) do begin
    define_key,'F'+strtrim(j,2),escape=esc+strtrim(j+offset(i),2)+'~'
  endfor
endfor
; Help and Do keys
define_key, 'HELP', escape=esc+'28~'
define_key, 'DO', escape=esc+'29~'
; Top two rows of middle keypad (with arrow keys)
names = ['FIND','INSERT-HERE','REMOVE','SELECT','PREV-SCREEN','NEXT-SCREEN']
for i = 1, 6 do define_key, names(i-1), escape=esc+strtrim(i, 2)+'~'
; Application keypad
for i = 49B, 52B do define_key, 'PF'+string(i), escape=keypad+string(i+31B)
for i = 48B, 57B do define_key, string(i), escape=keypad+string(i+64B)
for i = 44B, 46B do define_key, string(i), escape=keypad+strtrim(i+64B)
define_key, 'ENTER', escape=keypad+'M'
return	; DEC VT200 keyboard (Unix)
end
; $Id: skey_hp.pro,v 1.2 1993/06/16 22:26:28 ali Exp $

pro skey_hp,app_keypad=app_keypad,num_keypad=num_keypad
;+
; NAME:
;	SKEY_HP
;
; PURPOSE:
;	Under Unix, the number of function keys, their names, and the
;	escape sequences they send to the host computer vary
;	enough between various keyboards that IDL cannot be
;	written to understand all keyboards. Therefore, it provides
;	a very general routine named DEFINE_KEY that allows the
;	user to specify the names and escape sequences. This
;	routine uses DEFINE_KEY to enter the keys for the HP 9000
;	series 300 keyboard.
;
;	Note: SKEY_HP is primarily designed to be called by
;	SETUP_KEYS, which attempts to automatically detect the correct
;	keyboard type in use, and define the keys accordingly.
;	Nonetheless, SKEY_HP can be called as a standalone
;	routine.
;
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	SKEY_HP
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;  APP_KEYPAD:	Defines escape sequences for the group of keys
;		in the numeric keypad, enabling these keys to be programmed
;		within IDL.
;
;  NUM_KEYPAD:	Disables programmability of the numeric keypad.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The definitions for the function keys have been entered, and
;	can be viewed using HELP,/KEYS .
;
;	The upper right-hand group of four keys (at the same height as
;	the function keys) are called "BLANK1" through "BLANK4", since
;	they have no written labels.  Keys defined to have labels beginning
;	with a capital "K" belong to the numeric keypad group.  For example,
;	"K9" refers to keypad key "9".
;
;	Although the HP 9000 series 300 can create both xterm and hpterm
;	windows, IDL supports only user-definable key definitions in xterm
;	windows - hpterm windows use non-standard escape sequences which
;	IDL does not attempt to handle.
;
; MODIFICATION HISTORY:
;	TJA & AB, July 1990, setup_keys_hp created, and call to setup_keys_hp
;		placed in procedure setup_keys
;	AB, 21 September 1992,renamed from SETUP_KEYS_HP to SKEY_HP to
;		avoid DOS filename limitations.
;	AB, 16 June 1993, The IDL scanner used to treat octal string escapes
;		in a manner similar to the C language, but this ability was
;		removed to make the MS DOS port possible (conflicts with
;		file path specifications). Removed all uses of that here.
;-
if (keyword_set(app_keypad)) then print,string(byte([27,61])) ; Enable keypad
if (keyword_set(num_keypad)) then print,string(byte([27,62])) ; Disable keypad
esc = string(27B)
newl = string(13B)
; Top row of function keys
fkeys='12345678'
fvals='12345789' ; Not a mistake - no 6!
for i=1,8 do define_key,'F'+strmid(fkeys,(i-1),1), $
             escape=esc+'[1'+strmid(fvals,(i-1),1)+'~'
; Menu key on top row
define_key,'MENU',escape=esc+'[29~'
; Upper righthand "unlabelled" keys (same height as the function keys)
bkeys='1234'
bvals='0134'  ; No 2!
for i=1,4 do define_key,'BLANK'+strmid(bkeys,(i-1),1), $
             escape=esc+'[2'+strmid(bvals,(i-1),1)+'~'
; Labelled keys near the Return key
define_key,'PREV',escape=esc+'[5~'
define_key,'SELECT',escape=esc+'[4~'
define_key,'NEXT',escape=esc+'[6~'
; Numeric keypad - This only works if application keypad is enabled!
define_key,'K*',escape=esc+'Oj'
define_key,'K/',escape=esc+'Oo'
define_key,'K+',escape=esc+'Ok'
define_key,'K-',escape=esc+'Om'
define_key,'K_ENTER',escape=esc+'OM'
nkeys='0123456789'
nvals='pqrstuvwxy'
for i=0,9 do define_key,'K'+strmid(nkeys,i,1), $
             escape=esc+'O'+strmid(nvals,i,1)
define_key,'K,',escape=esc+'Ol'
define_key,'K_TAB',escape=esc+'OI'
define_key,'K.',escape=esc+'On'
return ; HP 9000 Series 300 keyboard (xterm only)
end
; $Id: skey_mips.pro,v 1.2 1993/06/16 22:26:28 ali Exp $

pro skey_mips,app_keypad=app_keypad,num_keypad=num_keypad
;+
; NAME:
;	SKEY_MIPS
;
; PURPOSE:
;	Under Unix, the number of function keys, their names, and the
;	escape sequences they send to the host computer vary
;	enough between various keyboards that IDL cannot be
;	written to understand all keyboards. Therefore, it provides
;	a very general routine named DEFINE_KEY that allows the
;	user to specify the names and escape sequences. This
;	routine uses DEFINE_KEY to enter the keys for the MIPS RS
;	series keyboard.
;
;	Note: SKEY_MIPS is primarily designed to be called by
;	SETUP_KEYS, which attempts to automatically detect the correct
;	keyboard type in use, and define the keys accordingly.
;	Nonetheless, SKEY_MIPS can be called as a standalone
;	routine.
;
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	SKEY_MIPS
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;  APP_KEYPAD:	Defines escape sequences for the group of keys
;		in the numeric keypad, enabling these keys to be programmed
;		within IDL.
;
;  NUM_KEYPAD:	Disables programmability of the numeric keypad.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The definitions for the function keys have been entered, and
;	can be viewed using HELP,/KEYS .
;
;	The <Print Scrn>, <Scroll Lock>, and <Pause> keys are not defined,
;	as they do not generate standard escape sequences.  The same is
;	true for <Home>, <Delete>, and <End> in the grouping of six keys above
;	the arrow keys; however, the other three in the group ARE defined.
;	Keys defined to have labels beginning with a capital "K" belong
;	to the numeric keypad group.  For example, "K9" refers to keypad
;	key "9".  The <Num Lock> key is the only one within the keypad
;	which is not defined.
;
; MODIFICATION HISTORY:
;	TJA , July 1990.  SETUP_KEYS_MIPS created, and call to SETUP_KEYS_MIPS
;			  placed in procedure SETUP_KEYS.
;	AB, 21 September 1992,renamed from SETUP_KEYS_MIPS to SKEY_MIPS to
;		avoid DOS filename limitations.
;	AB, 16 June 1993, The IDL scanner used to treat octal string escapes
;		in a manner similar to the C language, but this ability was
;		removed to make the MS DOS port possible (conflicts with
;		file path specifications). Removed all uses of that here.
;-
if (keyword_set(app_keypad)) then print,string(byte([27,61])) ; Enable keypad
if (keyword_set(num_keypad)) then print,string(byte([27,62])) ; Disable keypad
esc = string(27B)
newl = string(13B)
; Top row of function keys
fvals=[11,12,13,14,15,17,18,19,20,21,23,24]
for i=1,12 do define_key,'F'+strtrim(string(i),2), $
              escape=esc+'['+string(fvals(i-1),'(i2)')+'~'
; Labelled keys above the arrow keys (HOME, DELETE, and END are not definable)
define_key,'INSERT',escape=esc+'[2~'
define_key,'PAGE_UP',escape=esc+'[5~'
define_key,'PAGE_DOWN',escape=esc+'[6~'
; Numeric keypad - This only works if application keypad is enabled!
define_key,'K/',escape=esc+'Oo'
define_key,'K*',escape=esc+'Oj'
define_key,'K-',escape=esc+'Om'
define_key,'K+',escape=esc+'Ok'
define_key,'K_ENTER',escape=esc+'OM'
nkeys='0123456789'
nvals='pqrstuvwxy'
for i=0,9 do define_key,'K'+strmid(nkeys,i,1), $
             escape=esc+'O'+strmid(nvals,i,1)
define_key,'K.',escape=esc+'On'
return ; MIPS RS keyboard
end
; $Id: skey_sgi.pro,v 1.2 1993/06/16 22:26:28 ali Exp $

PRO skey_sgi
;+
; NAME:		SKEY_SGI
; PURPOSE:	Under Unix, the number of function keys, their names, and the
;		escape sequences they send to the host computer vary
;		enough between various keyboards that IDL cannot be
;		written to understand all keyboards. Therefore, it provides
;		a very general routine named DEFINE_KEY that allows the
;		user to specify the names and escape sequences. This
;		routine uses DEFINE_KEY to enter the keys for a Sun keyboard.
;
;		Note: SKEY_SGI is primarily designed to be called by
;		SETUP_KEYS, which attempts to automatically detect the correct
;		keyboard type in use, and define the keys accordingly.
;		Nonetheless, SKEY_SGI may be called as a standalone
;		routine.
;
; CATEGORY:	Misc.
; CALLING SEQUENCE:
;	SKEY_SGI
; INPUTS:
;	None.
; KEYWORD PARAMETERS:
;	None.
; OUTPUTS:
;	None.
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:

;	The definitions for the function keys have been entered, and
;	can be viewed using HELP,/KEYS .
; MODIFICATION HISTORY:
;	AB, 26 April 1989
;	TJA, July 1990, setup_keys_sun created by the "breakup" of setup_keys
;		into separate files.
;	SMR, April 1991, setup_keys_sgi created by modifying setup_keys_sun
;	AB, 21 September 1992,renamed from SETUP_KEYS_SGI to SKEY_SGI to
;		avoid DOS filename limitations.
;	AB, 16 June 1993, The IDL scanner used to treat octal string escapes
;		in a manner similar to the C language, but this ability was
;		removed to make the MS DOS port possible (conflicts with
;		file path specifications). Removed all uses of that here.
;-

; F1-F12
FOR i = 1,12 DO $
  IF (i NE 4) THEN $				;function 4 is used for paste
    define_key, 'F' + STRTRIM(i,2), $		;from the SGI scratch buffer
	ESCAPE = string(27B) + '[' + $
		 STRING(STRTRIM(i,2), format = '(I3.3)') + 'q'

END	; Sgi keyboard




; $Id: skey_sun.pro,v 1.2 1993/06/16 22:26:28 ali Exp $

pro skey_sun, psterm=psterm
;+
; NAME:
;	SKEY_SUN
;
; PURPOSE:
;	Under Unix, the number of function keys, their names, and the
;	escape sequences they send to the host computer vary
;	enough between various keyboards that IDL cannot be
;	written to understand all keyboards. Therefore, it provides
;	a very general routine named DEFINE_KEY that allows the
;	user to specify the names and escape sequences. This
;	routine uses DEFINE_KEY to enter the keys for a Sun keyboard.
;
;	Note: SKEY_SUN is primarily designed to be called by
;	SETUP_KEYS, which attempts to automatically detect the correct
;	keyboard type in use, and define the keys accordingly.
;	Nonetheless, SKEY_SUN can be called as a standalone
;	routine.
;
; CATEGORY:
;	Misc.
;
; CALLING SEQUENCE:
;	SKEY_SUN
;
; INPUTS:
;	None.
;
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The definitions for the function keys have been entered, and
;	can be viewed using the command HELP, /KEYS .
;
; MODIFICATION HISTORY:
;	AB, 26 April 1989
;	TJA, July 1990, SETUP_KEYS_SUN created by the "breakup" of SETUP_KEYS
;			into separate files.
;	AB, 21 September 1992,renamed from SETUP_KEYS_SUN to SKEY_SUN to
;		avoid DOS filename limitations.
;	AB, 16 June 1993, The IDL scanner used to treat octal string escapes
;		in a manner similar to the C language, but this ability was
;		removed to make the MS DOS port possible (conflicts with
;		file path specifications). Removed all uses of that here.
;-

CSI=string(27B)+'['
if(keyword_set(psterm)) then $			;the difference between psterm
  define_key, "F1", escape = CSI+'224z'	;and sun is function 1.

; F2-F9
for i=2,9 do define_key,'F'+strtrim(i,2),escape=CSI+strtrim(i+223,2)+'z'

; R1 - R15
for i=1,15 do define_key,'R'+strtrim(i,2),escape=CSI+strtrim(i+207,2)+'z'

; Arrow keys in function code mode, and R13, R15
define_key, 'R8', /PREVIOUS_LINE
define_key, 'R10', /BACK_CHARACTER
define_key, 'R12', /FORWARD_CHARACTER
define_key, 'R13', /BACK_WORD
define_key, 'R14', /NEXT_LINE
define_key, 'R15', /FORWARD_WORD
return ; Sun3 keyboard
end
; $Id: slicer.pro,v 1.17 1995/06/30 20:17:42 dave Exp $

; MODIFICATION HISTORY:
; bmh - 10/14/93 - The following minor bug fixes.
;                  When no elements are found during an iso-surface display,
;                  an error message was displayed to an invalid device name.
;                  When no oblique slices are selected, the slicer_oblique
;                  should return.
;
;
; Conventions:
; Faces = faces of cube.  Numbered 0 to 5:
;		0 = X = c0(0)  (Corner 0)
;		1 = Y = c0(1)
;		2 = Z = c0(2)
;		3 = X = c1(0)  (Corner 1)
;		4 = Y = c1(1)
;		5 = Z = c1(2)
; Orientations:
;	6 = reset to default.
;	0 = xy exchange, 1 = xz exchange, 2 = yz exchange.
;	3 = x reverse, 4 = y reverse, 5 = z reverse.
; Vertex indices:	Faces
;	0	0,0,0   0,1,2
;	1	N,0,0	1,2,3
;	2	0,N,0	0,2,4
;	3	N,N,0	2,3,4
;	4	0,0,N	0,1,5
;	5	N,0,N	1,3,5
;	6	0,N,N	0,4,5
;	7	N,N,N	3,4,5
;
; Edge Index	Vertex Indices
;	0	0-1
;	1	1-2
;	2	2-3
;	3	3-1
;	4	0-4
;	5	1-5
;	6	2-6
;	7	3-7
;	8	4-5
;	9	5-6
;	10	6-7
;	11	7-4
;
; Modes:
;	0 = Slices
;	1 = Cube
;	2 = Cut
;	3 = Isosurface
;	4 = Probe
;	5 = rotations


function p_inside_poly, polyv, p
;	polyv = (2,n) array of polygon vertices, either clockwise or
;		counter-clockwise order.  Polygon must be convex.
;	p = (2) point coordinates.
;	return 0 if point is outside polygon, 1 if inside.
;
x = float(p(0))
y = float(p(1))
np = n_elements(polyv)/2		;# of vertices
x1 = polyv(0,np-1)		;Start at last point
y1 = polyv(1,np-1)

pos = -1
for i=0,np-1 do BEGIN
	x2 = polyv(0,i)
	y2 = polyv(1,i)
	k = (x*(y1-y2) + y * (x2-x1) + x1*y2-y1*x2)  ;Side of line point is on
	if k eq 0 THEN BEGIN	;On line?
	    if (y lt (y1< y2)) or (y gt (y1 > y2)) or  $  ;Check more
		(x lt (x1 < x2)) or (x gt (x1 > x2)) THEN return,0
	ENDIF ELSE BEGIN		;Not on line
		k = k gt 0		;1 if on right side
		if pos lt 0 then pos = k
		if pos ne k THEN return,0
	ENDELSE
	x1=x2		;Previous vertex
	y1=y2
	ENDFOR
return,1
end




Function slicer_plane_int, dummy
; Return the intersections of the plane with the volume cube.
; V(3,12) = intersections of plane with the 12 edges.
; Flags(12) = 1 if there is an intersection at that edge.
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

Jn = sl.orthop(0:2)			;Plane eqn
Jd = sl.orthop(3)

v = fltarr(3,12)
k = 0

for i=0,11 do begin			;Faces
    p0 = sl.p0(*,sl.edges(0,i))		;Beginning of edge
    p1 = sl.p0(*,sl.edges(1,i))		;End of edge
    lv = p1-p0
    t = total(lv * Jn)
    if t ne 0 then begin
	t = -(jd + total(p0 * Jn)) / t
	p = p0 + t * lv			;Point of intersection
	d = min((p - p0) * (p1-p))
	if d ge 0.0 then begin		;Within edge?
	    v(0,k) = p			;Yes, save intersection
	    k = k + 1
	    endif		  
	endif				;T ne 0
    endfor		    		;i

; Sort into order:
d = max(abs(Jn), m)			;Largest plane coeff = what we ignore
u = v([m+1, m+2] mod 3, 0:k-1)		;Get other 2 coords
a = fltarr(k)				;Angle measure
d = min(u(1,*), dmin)			;Get lowest point
u_dx = u(0,*)-u(0,dmin)
u_dy = u(1,*)-u(1,dmin)
zero_ind = Where((u_dx EQ 0.0) AND (u_dy EQ 0.0))
if (zero_ind(0) GE 0L) THEN u_dx(zero_ind) = 1.0
a=atan(u_dy, u_dx)
zero_ind=0 & u_dx=0 & u_dy=0
a(dmin) = -100.				;Anchor = first
n = sort(a)				;Go around anchor point & back
return, v(*, [n, n(0)])
end




PRO SLICER_PLAYBACK, FILE = file, Commands
; Play back a journal.  Commands are either in the designated file
; or in the string array Commands".
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
COMMON slicer_common1, old_slice, d0, z0, az, el

if n_elements(file) gt 0 THEN BEGIN	;Read from file
	OPENR, unit, /GET_LUN, file, ERROR = i
	if i ne 0 then begin	;OK?
		widget_control, sl.file_text(1), set_value = !ERR_STRING
		return
		ENDIF
	commands = strarr(100)		;Read up to 100 lines
	i = 0
	a = ''
	while not eof(unit) do begin
		readf, unit, a
		commands(i) = a
		i = i + 1
		endwhile
	ncommands = i
	free_lun, unit
ENDIF ELSE ncommands = n_elements(commands)

IF mode ne 7 THEN BEGIN			;Not our mode?
	if sl.mode_bases(mode) ne 0 THEN $  ;Remove panel if mapped
		WIDGET_CONTROL, sl.mode_bases(mode), MAP=0
	mode = 7			;New mode = ours
	WIDGET_CONTROL, sl.mode_bases(mode), MAP=1
	ENDIF

pars = fltarr(10)

for i=0, ncommands-1 do begin		;Each command
	s = strtrim(strcompress(commands(i)))	;Parse it, extracting fields
	j = 0
	m = 0
	while j lt strlen(s) do begin	;While string left
		k = strpos(s, ' ', j)	;Find next blank
		if k le 0 then k = strlen(s)  ;if none, go to end of string
		if j eq 0 then cmd = strmid(s,0,k) $
		else begin pars(m) = strmid(s,j,k) & m=m+1 & endelse
		j = k+1
		endwhile
	WIDGET_CONTROL, sl.file_text(1), SET_VALUE = strmid(s,0,32)
	case strupcase(cmd) of		;Interpret commands.....
"UNDO": slicer_undo
"ORI":  BEGIN    ;AXIS(3), AXIS_REVERSE(3), ROTATIONS(2)
	sl.axex = pars(0:2)
	sl.axrev = pars(3:5)
	sl.rotation = pars(6:7)
	for j=0,1 do WIDGET_CONTROL, sl.rslide(j), SET_VALUE = sl.rotation(j)
	WIDGET_CONTROL, sl.rslide(2), SET_VALUE=string(pars(8))  ;Aspect
	SLICER_ORIENTATION
	ENDCASE
"TRANS": BEGIN   ;On/Off Threshold(%)
	sl.trans = pars(0)
	if sl.trans eq 0 then pars(1) = 100
	sl.threshold = pars(1) /100. * sl.nc3
	WIDGET_CONTROL, sl.threshold_slider, SET_VALUE = pars(1)
	ENDCASE
"SLICE": BEGIN	  ;Axis, slice_value, interp, expose, 0 for orthogonal
		;Azimuth, Elev, interp, expose, 1, x0, y0, z0 for oblique
	sl.interp = pars(2)
	sl.expose = pars(3)
	if pars(4) eq 0 then begin	;Orthogonal slices?
	    WIDGET_CONTROL, sl.draw_butt(sl.expose), /SET_BUTTON
	    SLICER_DRAW, pars(0), pars(1)
	ENDIF ELSE BEGIN		;Oblique slice
	    az = pars(0)
	    el = pars(1)
	    s = sin(el * !DTOR)
	    sl.orthop(0) = sin(-az * !dtor) * s
	    sl.orthop(1) = cos(-az * !dtor) * s
	    sl.orthop(2) = cos(el * !dtor)
	    z0 = pars(5:7)
	    sl.orthop(3) = -total(sl.orthop * z0)
	    d0 = slicer_plane_int()
	    slicer_oblique
	ENDELSE
	ENDCASE
"COLOR": BEGIN	 ;Table_num (-1 = present), low, high, shading
	sl.stretch = pars(1:2)
	sl.shading = pars(3)/100.
	for j=0,2 do WIDGET_CONTROL, sl.cslide(j), SET_VALUE = pars(j+1)
	slicer_colors, 	pars(0)
	ENDCASE
"ISO":  BEGIN		;value, hi/lo
	sl.isop.value = pars(0) / 100. * (sl.amax-sl.amin) + sl.amin
	sl.isop.hi_lo = pars(1)
	DO_ISOSURFACE
	ENDCASE
"ERASE":  slicer_erase
"WAIT":  wait, pars(0)
"CUBE": BEGIN		;mode (1 = block, 0 = cutout), cut_ovr, interp,
			; start_coords(3), end_coords(3)
	mode = pars(0)
	sl.cut_ovr = pars(1)
	sl.interp = pars(2)
	sl.p0cube = reform(pars(3:8), 3,2)
	DO_CUBE	
	ENDCASE
    ENDCASE
  ENDFOR
mode=7
WIDGET_CONTROL, sl.file_text(1), SET_VALUE = 'Playback Done'
end

; Journal events if journal file is open.
PRO SLICER_JOURNAL, name, params
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

if sl.journal le 0 then return
if n_elements(params) le 0 then params = 0.
printf, sl.journal, name, params, format='(A, 1x, 10F10.3)'
end


PRO SLICER_UNDO		;Undo last operation
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

SLICER_JOURNAL, "UNDO"
if n_elements(zb_last) le 1 then return
set_plot,'Z'
tmp = tvrd(/WORDS, CHANNEL=1)  ;Read depth buffer & swap
tv, zb_last, CHANNEL=1, /WORDS
zb_last = temporary(tmp)
tmp = tvrd()		;Swap them
tv, z_last
slicer_show, z_last
z_last = tmp
end


PRO slicer_orientation, i	;i = orientation
;  Set the New Orientation
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
if n_elements(i) gt 0 THEN BEGIN
	if i le 2 THEN BEGIN
		j = 2 * i
		ll = ([0,1,0,2,1,2])(j:j+1)  ;axes to swap
		t = sl.axex(ll(0)) & sl.axex(ll(0)) = sl.axex(ll(1)) & 
		sl.axex(ll(1)) = t
	ENDIF ELSE if i eq 6 THEN BEGIN
		sl.axex = [0,1,2]		;default transformation
		sl.axrev = intarr(3)
	ENDIF ELSE sl.axrev(i-3) = 1-sl.axrev(i-3)  ;reverse
ENDIF		

d = [ 0., dims(0), 0., dims(1), 0., dims(2)]
f = 1.0
WIDGET_CONTROL, sl.rslide(2), GET_VALUE=s
ON_IOERROR, bad_aspect
f = (float(s))(0)
if (f le 0.0) then goto, bad_aspect
IF f gt 1. THEN BEGIN
	x = (f-1)/2.
	d(0) = [-x * dims(0), (x+1) * dims(0), -x * dims(1), (x+1) * dims(1)]
ENDIF ELSE BEGIN
	x = (1-f)/2
	d(4) = [-x * dims(2), (x+1) * dims(2)]
ENDELSE
bad_aspect:
SLICER_JOURNAL, "ORI", [sl.axex, sl.axrev, sl.rotation, f ]

for i=0,2 do if sl.axrev(i) THEN BEGIN	;Swap endpoints for reversed axes
	j=i*2
	t = d(j) & d(j) = d(j+1) & d(j+1) = t
	ENDIF

!x.type = 0		;make sure its linear
scale3, xrange=d(0:1), yrange=d(2:3), zrange=d(4:5), ax = sl.rotation(0), $
	az = sl.rotation(1)

k = 1		;current y axis
if sl.axex(0) ne 0 THEN BEGIN	;swap x?
	if sl.axex(0) eq 1 THEN BEGIN &	t3d, /XYEXCH & k = 0
	ENDIF ELSE t3d,/XZEXCH
ENDIF

if k ne sl.axex(1) THEN t3d,/YZEXCH
slicer_erase
if mode le 2 THEN draw_orientation
sl.pt_inverse = invert(!p.t)
end





PRO slicer_oblique		;Do an oblique slice
;	Plane eqn is in sl.orthop
;	d0 is the intersections of the plane with the edges of the volume
;		cube.
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
COMMON slicer_common1, old_slice, d0, z0, az, el

if n_elements(d0) le 3 then return		;Anything?

SLICER_JOURNAL, "TRANS", [sl.trans, sl.threshold * 100. / sl.nc3]
SLICER_JOURNAL, "SLICE", [az, el, sl.interp, sl.expose, 1., z0 ]

widget_control, sl.pos_text, set_value = 'Extracting Oblique Slice'
set_plot,'Z'
z = (z_last = tvrd())			;save previous image & z
zb = (zb_last = tvrd(CHANNEL=1, /WORDS))
erase
polyfill, d0, /T3D, /DATA	;Mark the slice
z1 = tvrd(CHANNEL=1, /WORDS)	;Read depth buffer

if sl.expose then points = where((z1 lt zb_last) and (z1 ne z1(0,0))) $
	else points = where(z1 gt zb_last)

if points(0) lt 0 then begin
	z=z_last
	zb = zb_last
	goto, done
	endif

widget_control, sl.pos_text, set_value = $
	STRING(n_elements(points), FORMAT="(i6, ' points')")

ones = replicate(1., n_elements(points))

	;Make 3D homogen array in  data array subscripts coords
v = [ [(points mod !d.x_size) / float(!d.x_size)], $ ;Norm X
	[(points / !d.x_size)   / float(!d.y_size)], $ ;Norm Y
	[ z1(points)/65530. + 0.5], $		;Normalized Z coords
	[ ones ]]				;Homogeneous coord

v = ((temporary(v) # sl.pt_inverse) - $		;To v subscripts
		(ones # [!x.s(0), !y.s(0), !z.s(0)])) / $
		(ones # [ !x.s(1), !y.s(1), !z.s(1)])


;		Either interpolate or pick nearest neighbor
if sl.interp THEN v = interpolate(a, v(*,0), v(*,1), v(*,2)) $
    else v = a(long(temporary(v)) # [1, dims(0), dims(0) * dims(1)])

v = bytscl(temporary(v), max=sl.amax, min=sl.amin, top = sl.nc3-1) ;face data

if sl.trans THEN BEGIN		;Transparency?  Remove those under thresh.
	good = where(v ge sl.threshold)
	v = v(good)
	points = points(good)
	endif

dummy = max(abs(sl.orthop(0:2)), kmax)	;Axis with smallest variation
if kmax ne 0 then z(points) = v + byte(kmax * sl.nc3)  $ ;Shade it
else z(points) = v

zb(points) = z1(points)		;Update depth buffer

done: tv, z					;Now show it
tv, zb, /WORDS, CHANNEL=1		;and update depth buffer

widget_control, sl.pos_text, set_value = $
	  STRING(z0, az, el, FORMAT="('(',3f5.1,') A=', i4, ' E=',i4)")
slicer_show
end




PRO slicer_draw, ax, slice		;draw a slice.
;  ax = axis, 0 for x, 1 for Y, 2 for Z. slice = plane number.
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

WIDGET_CONTROL, sl.base, /HOURGLASS
SLICER_JOURNAL, "TRANS", [sl.trans, sl.threshold * 100. / sl.nc3]
SLICER_JOURNAL, "SLICE", [ax, slice, sl.interp, sl.expose, 0.]

set_plot,'Z'
z_last = tvrd()			;save previous image & z
zb_last = tvrd(CHANNEL=1, /WORDS)

d0 = [0,0,0]
d1 = dims -1
d0(ax) = slice
d1(ax) = slice

if sl.expose THEN erase		;Get a clean slice
				;extract & scale the slice
offset = byte(ax*sl.nc3)	;bias for this slice
p = bytscl(a(d0(0):d1(0), d0(1):d1(1), d0(2):d1(2)), $
	max=sl.amax, min=sl.amin, top = sl.nc3-1)

if sl.trans THEN t = (sl.threshold > 1) + offset $  ;lower limit
	ELSE t = 0
if ax ne 0 THEN p = p + offset	;add bias
d1 = dims-1
s = replicate(slice, 4)

case ax of
0:	polyfill, s, [0,d1(1),d1(1),0],[0,0,d1(2),d1(2)],/T3D,$
		pat=reform(p, dims(1), dims(2), /OVER), $
		image_coord = [0,0, d1(1),0, d1(1),d1(2), 0,d1(2)], $
		image_interp= sl.interp, trans=t
1:	polyfill, [0,d1(0),d1(0),0],s,[0,0,d1(2),d1(2)],/T3D,$
		pat=reform(p, dims(0), dims(2), /OVER), $
		image_coord = [0,0, d1(0),0, d1(0),d1(2), 0,d1(2)], $
		image_interp= sl.interp, trans=t
2:	polyfill,[0,d1(0),d1(0),0],[0,0,d1(1),d1(1)],s,/T3D,$
		pat=reform(p, dims(0), dims(1), /OVER),$
		image_coord = [0,0, d1(0),0, d1(0),d1(1), 0,d1(1)], $
		image_interp= sl.interp, trans=t
	ENDCASE

if sl.expose THEN BEGIN
	z = tvrd(/WORDS, CHANNEL=1)	;The new slice
	pnts = where((z gt zb_last) + (z eq z(0,0))) ;where we display prev
	if n_elements(pnts) gt 1 then begin
		z(pnts) = zb_last(pnts)		;New Z
		tv, z, /WORDS, CHANNEL=1
		z = tvrd()			;New display
		z(pnts) = z_last(pnts)
		tv, z
		ENDIF
	ENDIF
slicer_show
end

PRO slicer_colors, table	;load our color table
; Table = index of color table to load, -1 to retain present.
; The color palette is repeated 3 times, once for each of the possible face
; directions.  The colors indices:
;  3 * sl.nc3  = red
;  3 * sl.nc3 + 1 = green
;  3 * sl.nc3 + 2 = blue
;  3 * sl.nc3 + 3 = white

COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

v = [0, .5, 1.]		;Shading of the planes.
if n_params() eq 0 then table = -1
if table ge 0 then loadct, /SILENT, table
SLICER_JOURNAL, "COLOR", [table, sl.stretch, 100. * sl.shading]

if sl.stretch(0) eq sl.stretch(1) then $
	q = lindgen(sl.nc3) * sl.nc1 / (sl.nc3-1) $
else BEGIN		;Use contrast max and min
	s = 100./(sl.stretch(1)-sl.stretch(0))
	int = -s * sl.stretch(0)/100.
	q = long(3*(findgen(sl.nc3) * s + int))
ENDELSE

r_curr = bytarr(3*sl.nc3)
g_curr = r_curr
b_curr = r_curr
s = 1.-sl.shading
for i=0,2 do begin		;3 faces
	v0 = sl.shading * v(i) * 255
	r_curr(i*sl.nc3) = s * r_orig(q) + v0
	g_curr(i*sl.nc3) = s * g_orig(q) + v0
	b_curr(i*sl.nc3) = s * b_orig(q) + v0
	endfor
tvlct, r_curr, g_curr, b_curr
	; load last 4 colors as red, green, blue, white
tvlct, [255,0,0,255],[0,255,0,255],[0,0,255,255],3*sl.nc3
end

PRO DO_ISOSURFACE		;Draw the isosurface
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed


WIDGET_CONTROL, sl.base, /HOURGLASS
SLICER_JOURNAL, "ISO", [(sl.isop.value-sl.amin)/(sl.amax-sl.amin)*100, $
		sl.isop.hi_lo]
set_plot,'Z'
widget_control, sl.pos_text, set_value='Computing Polygons'
shade_volume, a, sl.isop.value, verts, polys, $
	low = sl.isop.hi_lo
if n_elements(verts) eq 0 then begin
	widget_control, sl.pos_text, set_value = $
	'No surface at this value'
	set_plot,sl.gdev
endif else begin
  widget_control, sl.pos_text, set_value = $
	strtrim((size(verts))(2),2)+' Vertices, ' + $
	strtrim((size(polys))(1)/4,2) + ' Polygons.'
  z_last = tvrd()			;Save old display
  zb_last = tvrd(CHANNEL=1, /WORDS)
  SET_SHADING, Values=[0, sl.nc3-1]
  b = polyshade(verts,polys,/T3D,top=sl.nc3-1)
  verts = 0 & polys = 0		;Free space
  slicer_show
endelse
end



PRO draw_cube, c0, c1, faces, color
;	draw a cube whose opposite corners are [c0(0),c0(1),c0(2)],
;	and [c1(0), c1(1), p2(3)].
;	color = drawing color.
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
p0 = intarr(3,8)
p1 = float(p0)
cc = [[c0],[c1]]
for i=0,7 do BEGIN
	p0(0,i) = [ cc(0, i and 1), cc(1, (i/2 and 1)), cc(2, (i/4 and 1))]
	p1(0,i) = convert_coord(p0(*,i), /T3D,/TO_DEVICE,/DATA)
	ENDFOR

if n_elements(color) le 0 THEN color = sl.nc1
f = sl.facevs
flags = bytarr(8,8)	;line flags, dont draw same line twice
for i=0,n_elements(faces)-1 do BEGIN
    ff = [ f(*,faces(i)), f(0,faces(i))]  ;Vertex indices
    for j=0,3 do begin
	k = ff(j) < ff(j+1) & l = ff(j) > ff(j+1)
	if not flags(k,l) then plots, p1(*,[k,l]), color = color, /dev
	flags(k,l) = 1
	ENDFOR
    ENDFOR
end
 




PRO slicer_erase		;draw the background
;	call with no params to erase all.
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

SLICER_JOURNAL, "ERASE"
set_plot,'Z'
erase
sl.p1 = convert_coord(sl.p0, /T3D, /TO_DEVICE, /DATA)  ;save dev coords
s = strarr(8)
for i=0,7 do BEGIN
	s(i) = string(sl.p0(*,i),format ="(' (',i0,',',i0,',',i0,')')")
	ENDFOR
junk = max(sl.p1(2,*), j)
sl.v_close = j			;index of closest vertex
p = where(sl.facevs eq sl.v_close)/4   ;indices of closest verts
colors = [ sl.nc1, sl.nc3*3+1]  ;white, green
for i=0,5 do BEGIN		;draw faces
	k= (where(p eq i))(0) lt 0 	;1 = not close, 0 = close
	draw_cube, [0,0,0], dims-1, i, colors(k)
	ENDFOR
for i=0,7 do xyouts, sl.p1(0,i),sl.p1(1,i),/DEVICE,s(i), $
	color=colors(i ne sl.v_close)
z_last = tvrd()
zb_last = tvrd(CHANNEL=1, /WORDS)
slicer_show
end



Function slicer_plane_int, dummy
; Return the intersections of the plane with the volume cube.
; V(3,12) = intersections of plane with the 12 edges.
; Flags(12) = 1 if there is an intersection at that edge.
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

Jn = sl.orthop(0:2)			;Plane eqn
Jd = sl.orthop(3)

v = fltarr(3,12)
k = 0

for i=0,11 do begin			;Faces
    p0 = sl.p0(*,sl.edges(0,i))		;Beginning of edge
    p1 = sl.p0(*,sl.edges(1,i))		;End of edge
    lv = p1-p0
    t = total(lv * Jn)
    if t ne 0 then begin
	t = -(jd + total(p0 * Jn)) / t
	p = p0 + t * lv			;Point of intersection
	d = min((p - p0) * (p1-p))
	if d ge 0.0 then begin		;Within edge?
	    v(0,k) = p			;Yes, save intersection
	    k = k + 1
	    endif		  
	endif				;T ne 0
    endfor		    		;i

; Sort into order:
d = max(abs(Jn), m)			;Largest plane coeff = what we ignore
u = v([m+1, m+2] mod 3, 0:k-1)		;Get other 2 coords
a = fltarr(k)				;Angle measure
d = min(u(1,*), dmin)			;Get lowest point
;p0 = u(*,dmin)
;for i=0,k-1 do if i ne dmin then begin	;Get angles
;	d = u(*,i) - p0			;Dx,dy
;	d0 = total(abs(d))		;abs(dx) + abs(dy)
;	if d0 ne 0. then begin
;	    t = d(1) / d0		;Proportional to angle w. horizontal
;	    if d(0) lt 0. then t = 2. - t $
;	    else if d(1) lt 0. then t = t + 4
;	    endif else t = 0.
;	a(i) = t
;	endif
u_dx = u(0,*)-u(0,dmin)
u_dy = u(1,*)-u(1,dmin)
zero_ind = Where((u_dx EQ 0.0) AND (u_dy EQ 0.0))
if (zero_ind(0) GE 0L) THEN u_dx(zero_ind) = 1.0
a=atan(u_dy, u_dx)
zero_ind=0 & u_dx=0 & u_dy=0
a(dmin) = -100.				;Anchor = first
n = sort(a)				;Go around anchor point & back
return, v(*, [n, n(0)])
end

PRO slicer_show, image
;move the Z buffer to the X display.  leave device set to X.
; if parameter is present, show it rather than reading the Z buffer
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

if n_params() eq 0 then begin
	set_plot,'Z'
	image = tvrd()
	endif
set_plot,sl.gdev
wset, sl.window
tv, image
sl.cube_on = 0
end

PRO draw_orientation	;draw the orientation cube in the small window
; Draw the outline of the 3 frontmost faces of the main cube.
; Draw the fixed axis plane in green.
; If the mode is cut or cube, draw the selected cube.  Draw the back faces
;	in blue, and label the selection points.

COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
COMMON slicer_common1, old_slice, d0, z0, az, el

i = sl.mode_bases(mode)
widget_control, i, get_uvalue = draw		;the widget id
widget_control, draw(0), get_value=window	;the window number
wset, window
device, set_graph = 3				;Copy mode
kc = 3 * sl.nc3 + 1				;Drawing color
erase

if mode le 0 then begin			;Single slice?
    if sl.ortho eq 0 then begin		;Orthogonal?
	mark_oblique, kc
	goto, done
    endif
	z = [0,0,0]
	d1 = dims-1
  endif else begin			;Block.
	z = sl.p0cube(*,0) < sl.p0cube(*,1)
	d1 = sl.p0cube(*,0) > sl.p0cube(*,1)
  endelse
					; draw fixed plane:
nlines = 6
p = z
d = (d1-z) / float(nlines-1)

p(fixed) = (d1(fixed) + z(fixed))/2.
d(fixed) = 0.0

for i=0,nlines-1 do BEGIN		;draw fixed direction
	xx = replicate(p(0),2)
	yy = replicate(p(1),2)
	zz = replicate(p(2),2)
	if fixed ne 0 THEN plots, [z(0),d1(0)], yy,zz, /T3D, COLOR=kc, /DATA
	if fixed ne 1 THEN plots, xx, [z(1),d1(1)],zz, /T3D, COLOR=kc, /DATA
	if fixed ne 2 THEN plots, xx, yy, [z(2),d1(2)],/T3D, COLOR=kc, /DATA
	p = p + d
	ENDFOR

if mode ne 0 then begin		;Do cube
	draw_cube, sl.p0cube(*,0), sl.p0cube(*,1), indgen(6), kc+1  ;all faces
		;Close faces in white
	draw_cube, sl.p0cube(*,0), sl.p0cube(*,1), $
			where(sl.facevs eq sl.v_close)/4
	for i=0,1 do begin		;Label them
		p = convert_coord(sl.p0cube(*,i), /T3D, /TO_DEV, /DATA)
		xyouts, p(0), p(1), strtrim(i,2), /device
		endfor
	endif

done: 
draw_cube, [0,0,0], dims-1, where(sl.facevs eq sl.v_close)/4  ;draw close faces
wset, sl.window
return
end


PRO mark_oblique, color			;Draw an oblique slice
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
COMMON slicer_common1, old_slice, d0, z0, az, el

if n_elements(d0) lt 3 then return

plots, d0, /T3D, COLOR=color, /DATA
z1 = [[z0], [z0]]
for i=0,2 do begin
	z2 = z1
	z2(i,0) = 0. & z2(i,1) = dims(i)-1.
	plots, z2, /T3D, COLOR = color, /DATA
	endfor
return
end



PRO mark_slice, ev		;mark a horizontal or vertical slice

COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
COMMON slicer_common1, old_slice, d0, z0, az, el

;		loop until the mouse is released.
oldbuttons = sl.lbuttons
sl.lbuttons = oldbuttons and (not ev.release) or (ev.press)
press = ev.press and 1			;New left button press?
p = float([ev.x, ev.y])			;device coords of mouse

if (n_elements(old_slice) le 0) or (ev.press ne 0) then old_slice = -1
kslice = -1				;assume no face
kc = sl.xcol				;XOR drawing color

if sl.lbuttons and 1 THEN BEGIN		;Marking a face?
    f = where(sl.facevs eq sl.v_close)/4  ;3 faces to check that are front
    d1 = dims-1
    z1 = intarr(3)
    d = ''
    for i=0,2 do BEGIN			;find the face
	j = f(i)			;face index
	p1 = sl.p1(0:1, sl.facevs(*,j))	;vertices
	if p_inside_poly(p1, p) THEN BEGIN
	    face = j
	    p = p / [ !d.x_size, !d.y_size]	;Get data coords. normalized
	    face_dim = face mod 3	;Fixed coord along face
	    if face le 2 THEN k = 0 ELSE k = dims(face_dim)-1
	    p = COORD2to3(p(0), p(1), face_dim, k, sl.pt_inverse)
	    ip = fix(p + 0.5)		;round
	    if ip(fixed) ge dims(fixed) then goto, NO_BREAK	;Outside
	    kslice = ip(fixed)		;slice number
	    d1(fixed) = kslice
	    z1(fixed) = kslice
	    goto, NO_BREAK
	    ENDIF
    ENDFOR
  NO_BREAK:
ENDIF					;Marking a face

device, SET_GRAPH=6	 		;set XOR mode
valid = kslice ge 0

if sl.ortho eq 0 then begin		;Oblique???
    if n_elements(az) eq 0 then begin	;Initialize?
	az = 0.  & el = 0. & z0 = dims / 2.
	sl.orthop = [ 0., 0., 1., -total(dims)/2]
	endif
    el1 = el & az1 = az & z1 = z0	;Old params
    if (sl.lbuttons and 4) ne 0 then begin	;New azimuth/elev?
	if sl.oangle then $
	    el1 = fix((p(0)/!d.x_size * 198) - 99.) > (-90) < 90 $
	else az1 = fix((p(0)/!d.x_size * 396) - 198.) > (-180) < 180
	if (el1 ne el) or (az1 ne az) then begin
	    s = sin(el1 * !dtor)
	    sl.orthop(0) = sin(-az1 * !dtor) * s
	    sl.orthop(1) = cos(-az1 * !dtor) * s
	    sl.orthop(2) = cos(el1 * !dtor)
	    valid = 1
	    endif
    endif else if valid then begin	;New origin?
	p(face_dim) = z0(face_dim)	;New coords, 1 remains unchanged
	z1 = p
	valid = total(abs(z0-z1)) ne 0.	;Change...
	ENDIF

    if (valid) then begin		;Draw new
	sl.orthop(3) = -total(sl.orthop * z0)
        IF old_slice gt 0 THEN mark_oblique, kc	;Erase old
	old_slice = 0
	el = el1 & az = az1 & z0 = z1	;New parameters
	if valid and (sl.lbuttons ne 0) THEN BEGIN  ;Update obliq outline
	    WIDGET_CONTROL, sl.pos_text, set_value = $
		STRING(z0, az, el, FORMAT="('(',3f5.1,') A=', i4, ' E=',i4)")
	    d0 = slicer_plane_int()		;New intersections
	    mark_oblique, kc	;Draw new
	    old_slice = 1		;show its visible
	    ENDIF
	ENDIF			;Valid
    if ev.release ne 0 then begin	;Released button?
	if old_slice then mark_oblique, kc
	draw_orientation	;Draw resulting plane
	old_slice = 0
	endif
ENDIF ELSE BEGIN			;Orthogonal.
    IF (kslice ne old_slice) THEN BEGIN ;Movement?
        if (press eq 0) and (old_slice ge 0)then $    ;Erase old?
	    draw_cube, z0, d0, fixed, kc
	if valid then $
          d = 'Position: ' + string(ip, format="('(',i4,',',i4,',',i4,')')") $
	else d = ''
	WIDGET_CONTROL, sl.pos_text, set_value=d
	if valid and sl.lbuttons THEN BEGIN
	    draw_cube, z1, d1, fixed, kc
	    z0 = z1
	    d0 = d1
	    ENDIF
	IF (ev.release eq 1) and (old_slice ge 0) THEN BEGIN
	    device, SET_GRAPH=3
	    slicer_draw, fixed, old_slice	;Mark the slice
	    ENDIF			;Release
	old_slice = kslice		;Save current position
	ENDIF				;Movement
ENDELSE

device, SET_GRAPH=3    ;normal mode
end


PRO do_cube				;Draw a cube or cut
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

WIDGET_CONTROL, sl.base, /HOURGLASS
SET_PLOT, 'Z'
z =  (z_last = tvrd())			;Save previous image & current cont
zb = (zb_last = tvrd(CHANNEL=1, /WORDS))


SLICER_JOURNAL, "TRANS", [sl.trans, sl.threshold * 100. / sl.nc3]
SLICER_JOURNAL, "CUBE", [ mode, sl.cut_ovr, sl.interp, reform(sl.p0cube, 6) ]

d0 = sl.p0cube(*,0) < sl.p0cube(*,1)		;Lower corner
d1 =  (sl.p0cube(*,0) > sl.p0cube(*,1)) -d0
coords = fltarr(3,8)
for i=0,7 do coords(0,i) = $		;Verts of our cube
   [ (i and 1) * d1(0), (i and 2)/2 *d1(1), (i and 4)/4 * d1(2)] + d0
faces = where(sl.facevs eq sl.v_close)/4   ;close faces
relation = mode eq 1

FOR face = 0, 5 do $			;Draw the faces of the cube or cut
  IF ((where(face eq faces))(0) ge 0) eq relation then begin  ;Do this face?
	v = 0 & ones = 0 & z0 = 0 & q = 0	;Clear things out
	erase					;Reset Z buffer
	verts = sl.facevs(*,face)		;Vertices
	polyfill, coords(*, verts), /T3D	;Draw polygon for face
	z0 = tvrd(CHANNEL=1, /WORDS)		;Now read the Z buffer
	if mode eq 1 then $			;Cube? or Cut?
		points = where(z0 gt zb) $	;New points for cube
	else if sl.cut_ovr then points = where(z0 ne z0(0,0)) $ ;Cut mode?
	else points = where((z0 ne z0(0,0) and (zb gt z0)))  ;Over mode

	widget_control, sl.pos_text, set_value = $
		'Creating face ' + strtrim(face,2)
	if points(0) ne -1 THEN	BEGIN		;Anything to do?
	  ones = replicate(1, n_elements(points))
		;Make 3D homogen array in  data array subscripts coords
	  v = [ [(points mod !d.x_size) / float(!d.x_size)], $ ;Norm X
		[(points / !d.x_size)   / float(!d.y_size)], $ ;Norm Y
		[ z0(points)/65530. + 0.5], $		;Normalized Z coords
		[ ones ]]				;Homogeneous coord
		;Get subscripts in data cube (data coords)
	  v = ((v # sl.pt_inverse) - $
			(ones # [!x.s(0), !y.s(0), !z.s(0)])) / $
			(ones # [ !x.s(1), !y.s(1), !z.s(1)])
;		Either interpolate or pick nearest neighbor
	  widget_control, sl.pos_text, set_value = $
		(['Sampling','Interpolating'])(sl.interp) + $
		' face ' + strtrim(face,2) + ',  ' + $
		strtrim(n_elements(v)/3,2) + ' Pixels'

	  if sl.interp THEN v = interpolate(a, v(*,0), v(*,1), v(*,2)) $
	  else v = a(long(temporary(v)) # [1, dims(0), dims(0) * dims(1)])
					;Update our points
	  if sl.trans THEN BEGIN	;Transparency?
		good = where(v ge sl.threshold, count)
		if count le 0 then goto, skipit
		v = v(good)
		points = points(good)
		endif
	  offset = byte((face mod 3) * sl.nc3)   ;Offset
	  q = bytscl(v, max=sl.amax, min=sl.amin, top = sl.nc3-1) ;face data
				   ;Get subscripts in data cube
	  if offset ne 0 then q = q + offset
	  z(points) = q			;Store the new face
	  zb(points) = z0(points)	;in both buffers
    skipit:
	ENDIF				;Anything to do
  ENDIF					;Each face
tv, z					;Now show it
tv, zb, /WORDS, CHANNEL=1		;and update depth buffer
v = 0 & ones = 0 & z0 = 0 & q = 0	;Clear things out
z = 0 & zb = 0
widget_control, sl.pos_text, set_value = 'Done.'
slicer_show
end




PRO mark_cube1, p0, ip	;Draw the outline of the cube in the main drawable
; p0 = cube coordinates (3,2).
; ip = index of corner that is marked (0 or 1).
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

draw_cube, p0(*,0),p0(*,1), indgen(6), sl.xcol   ;Basic cube
p1 = [[p0(*,ip)], [p0(*,ip)]]
p = sl.p0(*,sl.v_close)
for i=0,2 do begin		;Lines to faces
	p1(i,0) = p(i)
	plots, p1, color=128, /T3D
	p1(i,0) = p1(i,1)
	endfor
end



PRO mark_cube, ev			;Mark a cube in the main window
;  Use the XOR graphics mode to avoid killing the display
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed

if n_params() eq 0 then	begin		;Erase old cube?
	device, SET_GRAPHICS = 6	;Set XOR mode
	if sl.cube_on then mark_cube1, sl.p0cube, sl.cube_ip
	sl.cube_on = 0
	device, SET_GRAPHICS=3
	return
	ENDIF

oldbuttons = sl.lbuttons
sl.lbuttons = oldbuttons and (not ev.release) or (ev.press)
press = ev.press and 1			;New left button press?

if sl.lbuttons eq 0 then begin		;Released all buttons?
	if oldbuttons ne 0 then draw_orientation  ;Update viewbox
	return
	ENDIF

x = ev.x / float(!d.x_size)		;Normalized coords
y = ev.y / float(!d.y_size)
d1 = dims -1

p0cube = sl.p0cube		;Save old coords
cube_ip = sl.cube_ip

sl.cube_ip = sl.lbuttons eq 2		;Corner index
q = sl.p0cube(fixed, sl.cube_ip)	;Fixed axis/point
p = fix(COORD2TO3(x, y, fixed, q, pti)+0.5) ;3D coords
sl.p0cube(*,sl.cube_ip) = p < d1 > 0	;New corner value
sl.p0cube(fixed, sl.cube_ip) = q
if (total(abs(sl.p0cube - p0cube)) eq 0.0) and $ ;No change?
   cube_ip eq sl.cube_ip then return

device, SET_GRAPHICS = 6	;Set XOR mode
if sl.cube_on then mark_cube1, p0cube, cube_ip  ;Erase prev
sl.cube_on = 1
mark_cube1, sl.p0cube, sl.cube_ip
d = string(sl.p0cube, format="('(', 3i4, ') (', 3i4, ')')")
widget_control, sl.pos_text, set_value = d  ;label it
DEVICE, SET_GRAPHICS = 3		;Restore
end





PRO slicer_event, ev
COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed


wset, sl.window		;Our window

if ev.id eq sl.draw THEN BEGIN		;mouse press?
  IF mode le 2 THEN BEGIN		;Slice or cube mode?
    IF  ((ev.press and 4) ne 0) and sl.ortho THEN BEGIN  ;Right but= chg plane?
	fixed = (fixed + 1) mod 3	;bump plane
	draw_orientation
	return
	ENDIF	
    if mode eq 0 then BEGIN		;Slice mode?
	if (ev.press and 2) ne 0 then goto, probe_it  ;Middle = probe
	i = sl.lbuttons or ev.press	;New state
	if ((sl.ortho eq 0) and (i ne 0)) or (sl.ortho and i) THEN BEGIN
	    mark_slice, ev		;mark the slice
	    return
	    endif
    ENDIF ELSE if mode le 2 THEN BEGIN
	mark_cube, ev 			;Move the cube
    ENDIF
    return
  ENDIF	ELSE BEGIN			;Other modes
    if ev.press eq 0 then return
  probe_it: if (n_elements(zb_last) le 1) THEN return
    set_plot,'Z'
    z = float(tvrd(ev.x, ev.y, /WORD, /CHANNEL))/65530. + .5 ;To 0-1
    set_plot,sl.gdev
    p = [ ev.x, ev.y, z(0)] / [!d.x_size, !d.y_size, 1.] ;normalized coords
    d = 'No Data Value'
    if p(2) gt .01 THEN BEGIN	;anything there?
	  p = [p,1] # sl.pt_inverse	;inverse transform to normalized
	  p = (p - [!x.s(0),!y.s(0),!z.s(0)])/[!x.s(1),!y.s(1),!z.s(1)]
	  p = fix(p + 0.5)		;round
	  p = p > 0 < (dims-1)		;to range
	  x = a(p(0), p(1), p(2))+0
	  y = fix(100.*(x - sl.amin)/(sl.amax - sl.amin))  ;To %
	  d = 'Position: '+string(p,format="('(',i0,',',i0,',',i0,')')") + $
		', Data= ' + strtrim(x,2) + ' (' + strtrim(y,2) + '%)'
	ENDIF			;Something there
	widget_control, sl.pos_text, set_value = d
  ENDELSE
  return
ENDIF			;Drawable window

if ev.id eq sl.isop.drawable then begin		;Isosurface threshold
	if ev.press eq 0 then return
	x = (ev.x - sl.isop.xs(0)) / sl.isop.xs(1)
	x = x > sl.amin < sl.amax
	WIDGET_CONTROL, sl.isop.slider, $
	   SET_VALUE = 100.*(x - sl.amin) / (sl.amax-sl.amin)
	sl.isop.value = x
	return
	ENDIF
if ev.id eq sl.file_text(0) then return	;Ignore return in file name widget
if ev.id eq sl.rslide(2) then BEGIN
	slicer_orientation
	return
	ENDIF
;		here, it must be a button or a slider:
widget_control, ev.id, get_uvalue = eventval
case eventval of
"CANCUBE" : mark_cube		;Undraw outline
"COLORS" : slicer_colors, (where(sl.color_button eq ev.id))(0)
"CUTINTO": sl.cut_ovr = 0
"CUTOVER": sl.cut_ovr = 1
"ERASE"  : slicer_erase
"EXIT"   : BEGIN
	widget_control, ev.top, /DESTROY
	if sl.rbase ne 0 then WIDGET_CONTROL, sl.rbase, /DESTROY
	z_last = 0
	zb_last = 0
	goto, close_journal
	ENDCASE
"EXPOSE0": sl.expose = 0
"EXPOSE1": sl.expose = 1
"GOCUBE" : do_cube
"HELP" : BEGIN
	xdisplayfile, filepath("slicer.txt", subdir=['help', 'widget']), $
		title = "Slicer help", $
		group = ev.top, $
		width = 72, height = 24
	return
	ENDCASE

"INTERP0": BEGIN
	sl.interp = 0
	goto, set_interp
	ENDCASE
"INTERP1": BEGIN
	sl.interp = 1
  set_interp:  i = WIDGET_INFO(ev.id, /parent)
	WIDGET_CONTROL, i, GET_UVALUE = i	;Buttons
	WIDGET_CONTROL, i(1-sl.interp), /SENS
	WIDGET_CONTROL, i(sl.interp), SENS=0
	ENDCASE

"ORTHO0":  BEGIN			;On oblique
	sl.ortho = 0
	WIDGET_CONTROL, sl.obuttons, MAP=1
	draw_orientation
	ENDCASE
"ORTHO1":  BEGIN
	sl.ortho = 1
	WIDGET_CONTROL, sl.obuttons, MAP=0
	draw_orientation
	ENDCASE
"AZIM" : sl.oangle = 0
"ELEV" : sl.oangle = 1
"GOOBL" :  BEGIN			;Do an oblique slice
	WIDGET_CONTROL, ev.top, /HOURGLASS
	slicer_oblique
	end


"ORIENTATION": SLICER_ORIENTATION, (where(sl.ori_butt eq ev.id))(0)
"PLAYBACK" : BEGIN
	WIDGET_CONTROL, sl.file_text(0), GET_VALUE=name
	name = strtrim(name(0),2)
	SLICER_PLAYBACK, FILE = name
	ENDCASE
"RECORD" : BEGIN
start_journal: if sl.journal ne 0 then free_lun, sl.journal  ;Close old
	sl.journal = 0
	WIDGET_CONTROL, sl.file_text(0), GET_VALUE=name
	name = strtrim(name(0))
	openw, i, name, ERROR=j, /GET_LUN
	if j ne 0 then begin		;OK?
		widget_control, sl.file_text(1), set_value = !ERR_STRING
		return
		ENDIF
	widget_control, sl.file_text(1), set_value = 'Journal Active'
	sl.journal = i
	ENDCASE
"RECORDOFF" : BEGIN
	widget_control, sl.file_text(1), set_value = 'Journal Closed'
close_journal: if sl.journal ne 0 then free_lun, sl.journal  ;Close old
	sl.journal = 0
	ENDCASE
"THRESHOLD" : BEGIN
	sl.threshold = sl.nc3 * ev.value / 100.
	sl.trans = (ev.value ge 1) and (ev.value le 99)  ;On if reasonable
	ENDCASE
"HIGH": sl.isop.hi_lo = 0
"LOW" : sl.isop.hi_lo = 1
"ISOSLIDE" : sl.isop.value = (ev.value / 100.)*(sl.amax-sl.amin) + sl.amin
"GO":   do_isosurface
"SHADING": BEGIN
	sl.shading = ev.value /100.
	slicer_colors
	ENDCASE
"STMAX": BEGIN
	sl.stretch(1) = ev.value
	slicer_colors
	ENDCASE
"STMIN": BEGIN
	sl.stretch(0) = ev.value
	slicer_colors
	ENDCASE
"UNDO" : slicer_undo
"XROTATION": BEGIN
	sl.rotation(0) = ev.value
	slicer_orientation
	ENDCASE
"ZROTATION": BEGIN
	sl.rotation(1) = ev.value
	slicer_orientation
	ENDCASE

ELSE :   BEGIN			;mode button?
	k = where(eventval eq sl.mode_names, count)  ;Match with mode name?
	if count eq 1 THEN BEGIN		;switch mode
		if sl.cube_on then mark_cube	;Remove the cube if vis
		fixed = 0			;Reset fixed direction
		if sl.mode_bases(mode) ne 0 THEN $  ;Remove panel if mapped
			WIDGET_CONTROL, sl.mode_bases(mode), MAP=0
		mode = k(0)			;New mode
		if sl.mode_bases(mode) ne 0 THEN $  ;Map new base
			WIDGET_CONTROL, sl.mode_bases(mode), MAP=1
		if mode le 2 THEN BEGIN		;Slice or cube?
			draw_orientation
			ENDIF
		if mode eq 3 THEN BEGIN		;Draw histogram
			WSET, sl.isop.window
			type = size(a)
			int = type(type(0) + 1) le 3  ;True if int type
			j = (sl.amax -sl.amin)/100. ;bin size
			if int then j = j > 1
			h = histogram(a, max=sl.amax, min = sl.amin, bin=j)
			if int THEN j = fix(j + .99)
			k = sort(h)
			n = n_elements(h)
			x = findgen(n) * j + sl.amin < sl.amax
			xsave = !x.s & ysave = !y.s
			PLOT,x,h, xst = 9, yst=8, ymargin=[2,0], $
				yrange= [0,h(k(n-8))], yticks=1, chars=.75, $
				xticks=4
			sl.isop.xs = !x.s * !d.x_size
			WSET, sl.window
			!x.s = xsave & !y.s = ysave
			ENDIF			;Isosurface
		widget_control, sl.obuttons, $	;Oblique controls
			MAP = (mode eq 0) and (sl.ortho eq 0)
		RETURN
	ENDIF
	print,'Unknown event: ', eventval
	help, /STRUCT, ev
	ENDCASE
ENDCASE
end

PRO slicer, GROUP = group, RANGE = range, COMMANDS = commands, $
	CMD_FILE = cmd_file, RESOLUTION = resolution, DETACHED = detached, $
        MODAL = modal
;+
; NAME:
;	SLICER
;
; PURPOSE:
;	Widget based application to show 3D volume slices and isosurfaces.
;
; CATEGORY:
;	Volume display / rendering.
;
; CALLING SEQUENCE:
;	COMMON VOLUME_DATA, A
;	A = your_volume_data
;	SLICER
;
; INPUTS:
;	Variable A in VOLUME_DATA common contains volume data.  See EXAMPLE
;	section below.
;
; KEYWORD PARAMETERS:
;     COMMANDS:	An optional string array of commands to execute
;		before entering the interactive mode.  Commands are
;		in the form of a keyword optionally followed one or more 
;		numeric, blank-separated parameters.  For example:
;			"COMMAND P1 P2 P3 ... Pn"
;		Keywords and parameters are:
;		UNDO:	Undo previous operation.
;		ORI X_Axis Y_Axis Z_axis X_Rev Y_Rev Z_Rev X_Rot Z_Rot Asp
;			This command sets the orientation for the SLICER 
;			display.  X_Axis, Y_Axis, and Z_Axis should be 0 for 
;			data x, 1 for data y, and 2 for data z.  
;			X_Rev, Y_Rev, and Z_Rev should be 0 for normal, 1 for 
;			reversed.  Asp is the Z axis aspect ratio w/ respect 
;			to X, Y.  X_Rot and Z_Rot are the rotations of the 
;			X and Z axes in degrees (30 is the default).
;			For example, to interchange the X and Z axes and
;			reverse the Y use the string:
;				ORI 2 1 0 0 1 0 30 30
;		TRANS On_Off Threshold:  Use this command to turn transparency 
;			on or off and set the transparency threshold value.
;			1 means on, 0 means off.  Threshold is expressed in 
;			percent of data range (0 = min data value, 100 = max 
;			data value).
;		SLICE Axis Value Interp 0:  Draw an orthogonal slice along
;			the given axis (0=x, 1=y, 2=z) at Value.  Set Interp
;			equal to 1 for interpolation, 0 for nearest neighbor.
;			Expose = 1 to remove, 0 for normal slice.
;		SLICE Azimuth, Elev, Interp, Expose, 1, x0, y0, z0:  Draw
;			an oblique slice.  The oblique plane crosses the
;			XY plane at angle Azimuth, with an elevation of Elev.
;			It passes thru the point (x0, y0, z0).
;		COLOR Table_Index Low High Shading:  Set the color tables.
;			Table_Index is the pre-defined color table number (see
;			LOADCT), or -1 to retain the present table.  Low, High
;			and Shading are expressed in percent.
;		ISO Threshold Hi_Lo:  Draw an iso-surface.  Threshold is the 
;			isosurface threshold value.  Hi_Lo should be set to 1
;			to view the low side, 0 for the high side.
;		ERASE:	Erase the display.
;		CUBE Mode Cut_Ovr Interp X0 Y0 Z0 X1 Y1 Z1:  Draw cube 
;			(mode = 1) or cut-out (mode = 0).
;			Cut_Ovr should be set to  1 for cut-over, 0 for 
;			cut-thru.  Interp should be 1 for interpolation, 0 
;			for nearest neighbor.  (X0,Y0,Z0) is the lower corner 
;			of the cube.  (X1,Y1,Z1) is the upper corner. 
;			(X0 < X1, etc.)
;		WAIT Secs:  Wait the designated time (in seconds).
;
;     CMD_FILE:	A string that contains the name of a file containing SLICER
;		commands to execute as described above.
;
;	DETACHED: if set, put the drawable in a separate window. (Good
;		for large windows.)
;	GROUP:	The base ID of the widget that calls SLICER.  When this 
;		keyword is specified, the death of the caller results in the
;		death of the SLICER.
;
;	RANGE:	A two-element array containing minimum and maximum data
;		values of interest.  If this keyword is omitted, the data is 
;		scanned for the minimum and maximum.
;       MODAL:  If set, then the slicer runs in modal mode.
;
;    RESOLUTION: a two element vector giving the width and height of
;		the drawing window.  Default = 55% by 44% of screen width.
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	COMMON VOLUME_DATA, A   ;Used to pass in the volume data.
;	COMMON SLICER_COMMON   ;Used internally.
;	COMMON SLICER_COMMON1  ;Used internally.
;
; SIDE EFFECTS:
;	On exit, the Z-buffer contains the most recent image generated by
;	SLICER.  The image may be redisplayed on a different device by 
;	reading the Z-buffer contents, plus the current color table.
;	Widgets are created on the X window display.
;
; RESTRICTIONS:
;	Widgets are required.
;	The volume data must fit in memory.
;
; PROCEDURE:
;	The slicer program has the following modes:
;	Slices:         Displays orthogonal slices thru the data volume.
;	Block:          Displaces the surfaces of a selected block inside
;	                the volume. 
;	Cutout:         Cuts blocks from previously drawn objects.
;	Isosurface:     Draws an isosurface contour.
;	Probe:          Displays the position and value of objects
;	                using the mouse.
;	Colors:         Manipulates the color tables and contrast.
;	Rotations:      Sets the orientation of the display.
;
; EXAMPLE:
;	Data is transferred to the SLICER via the VOLUME_DATA common block
;	instead of as an argument.  This technique is used because volume
;	datasets can be very large and hence, the duplication that occurs when
;	passing values as arguments is a waste of memory.  Suppose that you 
;	want to read some data from the file "head.dat" into IDL for use
;	in the SLICER.  Before you read the data, establish the VOLUME_DATA
;	common block with the command:
;
;		COMMON VOLUME_DATA, VOL
;
;	The VOLUME_DATA common block has just one variable in it.  The variable
;	can have any name.  Here, we're using the name "VOL".  Now read the
;	data from the file into VOL.  For example:
;
;		OPENR, 1, "head.dat"
;		VOL = FLTARR(20, 30, 42)
;		READU, 1, VOL
;		CLOSE, 1
;
;	Now you can run the SLICER widget application by entering:
;
;		SLICER
;
;	The data stored in VOL is the data being worked on by the SLICER.
;
;	To obtain the image in the slicer window after slicer is finished:
;	(Use the image with the current color tables).
;
;	SET_PLOT, 'Z'   ;Use the Z buffer graphics device
;	a = TVRD()	;Read the image
;
; MODIFICATION HISTORY:
;	DMS - RSI, Oct, 1991.
;	DMS - RSI, Mar, 1992.  Added Journaling and expose mode.
;				Fixed bug with 24 bit color.
;	DMS - RSI, Jan, 1993.  Added oblique slices.
;       DJC - RSI, Jun, 1994.  Fixed oblique slice initialization and
;                              atan(0,0) problem (on HP).
;       DJC - RSI, Feb, 1995.  Added modal keyword.
;       DJC - RSI, Feb, 1995.  Changed "poly" variable to "polyv" to
;                              avoid clash with math "poly" function.
;       DJC - RSI, Mar, 1995.  Fixed shading values for iso-surface.
;-



COMMON volume_data, a
COMMON slicer_common, dims, sl, z_last, zb_last, mode, fixed
COMMON slicer_common1, old_slice, d0, z0, az, el



mode = 0
fixed = 0
sl_width = 240		;Slider width

mode_names = [ 'Slices', 'Block', 'Cutout', 'Isosurface', 'Probe', 'Colors', $
	'Rotations', 'Journal' ]
nmodes = n_elements(mode_names)		;# of modes

isop = { ISOP, hi_lo : 1, value: 0.0, window : 0, drawable : 0L, slider : 0L, $
		xs : fltarr(2) }

;	Main data structure
sl = {  SLICER, base : 0L, $		;Main base
	draw:0L, $			;Big drawable
	window:0, $			;Big drawable window index
	trans:0, $			;Transparency flag
	threshold_slider: 0L, $		;Threshold slider 
	threshold:0b, $			;Transp threshold in pixel values
	mode_names : mode_names, $	;Names of modes
	interp: 1, $			;Interpolation flag
	ortho : 1, $			;TRUE for orthogonal slices
	orthop : fltarr(4), $		;Plane eqn for ortho slices
	mode_bases : lonarr(nmodes), $	;Mode panel bases
	nc3: 0, $			;# of colors per partition (3 of them)
	nc1: 0, $			;# of colors we use
	amax : 0.0, $			;Data max, min
	amin : 0.0, $
	xcol : 0, $			;XOR Drawing color
	color_button:lonarr(24), $	;Color  table buttons (up to 24)
	axex: intarr(3), $		;TRUE to reverse axis
	axrev: intarr(3), $		;Axis permutations
	ori_butt: lonarr(7), $		;Orientation buttons
	draw_butt: lonarr(4), $		;Slice draw/expose buttons
	pos_text : 0L, $		;Label widget at bottom
	rotation: [ 30., 30.], $	;Current rotations
	v_close: 0, $			;Index of closest vertex
	p0 : fltarr(3,8), $		;Data coords of cube corners
	p1 : fltarr(3,8), $		;Device coords of cube corners
	pt_inverse : fltarr(4,4), $	;Inverse of !P.T
	vfaces : intarr(3,8), $		;Face index vs vertex index
	facevs : intarr(4,6), $		;Vertex index vs faces
	edges : intarr(2,12), $		;Vertices vs edge index
	isop: isop, $			;Isosurface parameters
	p0cube : intarr(3,2), $		;Corner coords of cube selection
	cut_ovr : 0, $			;Cut mode
	cube_on : 0, $			;If cube is on
	cube_ip : 0, $			;Corner of cube
	shading : 0.20, $		;Amount of differential shading
	file_text : LONARR(2), $	;File name text widgets
	cslide : LONARR(3), $		;Color sliders
	rslide : LONARR(3), $		;Rotation sliders, aspect text
	journal : 0, $			;Journal file
	stretch : [0,100], $		;Stretch params
	lbuttons : 0, $			;Last button state
	expose : 0, $			;Sice mode (0=slice, 1=expose)
	gdev : !D.NAME, $		;Graphics device
	obuttons : 0L, $		;Oblique buttons
	oangle : 1, $			;active angle for oblique
	rbase: 0L }			;Drawable base

;  Faces vs vertex index
sl.vfaces = [[0,1,2],[1,2,3],[0,2,4],[2,3,4],[0,1,5], [1,3,5], [0,4,5], $
		[3,4,5]]
;  Vertex indices vs faces  (clockwise order).
sl.facevs = [ [0,2,6,4], [0,4,5,1], [2,0,1,3], [1,5,7,3], [3,7,6,2], $
		[6,7,5,4]]
;
; vertex numbers vs Edge index (12 edges)
sl.edges = [[0,1],[1,3],[2,3],[0,2], [0,4], [1,5],[2,6],[3,7], $
	  [4,5],[5,7],[6,7],[4,6]]

if XRegistered("slicer") THEN RETURN
if n_elements(resolution) lt 2 then begin
	device, get_screen = resolution
	resolution(0) = 5 * resolution(0) / 9
	resolution(1) = 4 * resolution(0) / 5
	endif

set_plot,'Z'
device, /z_buffering, set_resolution = resolution
set_plot,sl.gdev

z_last = 0
zb_last = 0

s = size(a)
if s(0) ne 3 THEN $
	MESSAGE,'Slicer: volume_data common block does not contain 3D data'
dims = s(1:3)
d1 = dims-1

sl.p0cube = [[dims/4], [3 * dims/4]]
for i=0,7 do sl.p0(*,i) = $		;Data coords of corners
	[ (i and 1) * d1(0), (i and 2)/2 * d1(1), (i and 4)/4 * d1(2)]

sl.orthop = [ 0., 0., 1., -dims(2)/2.]	;Initial orthogonal plane

if n_elements(range) ge 2 THEN BEGIN	;Range specified?
	sl.amax = range(1)
	sl.amin = range(0)
ENDIF ELSE BEGIN
	sl.amax = max(a, min = q)
	sl.amin = q
ENDELSE

old_slice = 0
az = 0.0
el = 0.0
z0 = [0.0, 0.0, 0.0]
d0 = slicer_plane_int()

sl.base = WIDGET_BASE(TITLE='IDL Slicer', /ROW)
lbase = WIDGET_BASE(sl.base, /COLUMN)
if keyword_set(detached) THEN BEGIN
	rbase = WIDGET_BASE(Title='Slicer', EVENT_PRO='SLICER_EVENT')
	sl.rbase = rbase
endif else rbase = WIDGET_BASE(sl.base)


sl.obuttons = WIDGET_BASE(rbase, /ROW)
junk = WIDGET_BASE(sl.obuttons, /exclusive, /row)
junk1 = WIDGET_BUTTON(junk, VALUE='Azimuth', UVALUE='AZIM')
junk1 = WIDGET_BUTTON(junk, VALUE='Elevation', UVALUE='ELEV')
WIDGET_CONTROL, junk1, /SET_BUTTON
junk1 = WIDGET_BUTTON(sl.obuttons, VALUE = 'Go', UVALUE='GOOBL')
WIDGET_CONTROL, sl.obuttons, MAP=0   ;Remove buttons for oblique mode

sl.draw = WIDGET_DRAW(rbase, XSIZE=resolution(0), YSIZE=resolution(1),$
	RETAIN=2, /BUTTON_EVENTS, /MOTION)

junk = WIDGET_BASE(lbase, COLUMN=3)
junk1 = WIDGET_BUTTON(junk, value="Done", uvalue = "EXIT", /NO_REL)
junk1 = WIDGET_BUTTON(junk, value="Erase", uvalue = "ERASE", /NO_REL)
junk1 = WIDGET_BUTTON(junk, value="Undo", uvalue = "UNDO", /NO_REL)
junk1 = WIDGET_BUTTON(junk, value="Help", uvalue = "HELP", /NO_REL)
junk1 = WIDGET_BUTTON(junk, VALUE='Orientation',/MENU)
ori_names = [ 'X Y Exchange', 'X Z Exchange', 'Y Z Exchange',$
	'X Reverse','Y Reverse','Z Reverse', 'Reset']
for i=0,6 do sl.ori_butt(i) = WIDGET_BUTTON(junk1, VALUE=ori_names(i),$
		UVALUE = 'ORIENTATION')
widget_control, sl.ori_butt(0), SET_BUTTON=1

junk1 = WIDGET_BUTTON(junk, VALUE='Interpolation',/MENU)
junk2 = WIDGET_BUTTON(junk1, VALUE='Off', UVALUE='INTERP0')
junk3 = WIDGET_BUTTON(junk1, VALUE='On', UVALUE='INTERP1')
WIDGET_CONTROL, junk3, SENS=0		;Its on now.
widget_control, junk1, set_uvalue=[junk2, junk3]

junk1 = WIDGET_BASE(lbase, /FRAME, COLUMN=3, /EXCLUSIVE)

for i=0,nmodes-1 do $	; Mode buttons
    junk2 = WIDGET_BUTTON(junk1, value=sl.mode_names(i), $
		uvalue=sl.mode_names(i), /NO_RELEASE)

junk = WIDGET_BASE(lbase, /FRAME, /COLUMN)
mode_base = WIDGET_BASE(junk)		;For the mode dependent bases

for i=0,nmodes-1 do $
   if i ne 2 then sl.mode_bases(i) = WIDGET_BASE(mode_base, uvalue=0L, /COLUMN)


parent = sl.mode_bases(0)		; slices mode
junk = WIDGET_DRAW(parent, XSIZE = sl_width, $
	YSIZE = sl_width * float(resolution(1)) / resolution(0))
WIDGET_CONTROL, parent, SET_UVALUE= junk

junk2 = WIDGET_BASE(parent, /ROW)
junk3 = WIDGET_BASE(junk2, /EXCLUSIVE, /ROW)
sl.draw_butt(0) = $
    WIDGET_BUTTON(junk3, VALUE = 'Draw', UVALUE='EXPOSE0', /NO_REL)
sl.draw_butt(1) = $
    WIDGET_BUTTON(junk3, VALUE = 'Expose', UVALUE='EXPOSE1', /NO_REL)
junk3 = WIDGET_BASE(junk2, /EXCLUSIVE, /ROW)
sl.draw_butt(2) = $
    WIDGET_BUTTON(junk3, VALUE = 'Orthogonal', UVALUE='ORTHO1', /NO_REL)
sl.draw_butt(3) = $
    WIDGET_BUTTON(junk3, VALUE = 'Oblique', UVALUE='ORTHO0', /NO_REL)

WIDGET_CONTROL, sl.draw_butt(0), /SET_BUTTON
WIDGET_CONTROL, sl.draw_butt(2), /SET_BUTTON

parent = sl.mode_bases(1)		;Cube & Cut modes
junk = WIDGET_BASE(parent, /ROW)
junk1 = WIDGET_BUTTON(junk, value=' GO ', uvalue='GOCUBE', /NO_RELEASE)
junk1 = WIDGET_BUTTON(junk, value=' Cancel ', uvalue='CANCUBE', /NO_REL)
junk1 = WIDGET_BASE(junk, /EXCLUSIVE, /ROW)
junk = WIDGET_BUTTON(junk1, VALUE="Cut Into", UVALUE="CUTINTO", /NO_REL)
junk = WIDGET_BUTTON(junk1, VALUE="Cut Over", UVALUE="CUTOVER", /NO_REL)
junk = WIDGET_DRAW(parent, XSIZE = sl_width, $
	YSIZE = sl_width * float(resolution(1)) / resolution(0))
widget_control, parent, set_uvalue= junk

sl.mode_bases(2) = sl.mode_bases(1)	;Cut is copy of cube

parent = sl.mode_bases(3) 		 ; Isosurface mode
junk = widget_button(parent, value='GO', UVALUE='GO')
junk = widget_base(parent, /row)
junk1 = widget_label(junk, value='Display: ')
junk = widget_base(junk, /row, /exclusive)
junk1 = widget_button(junk, value='High Side', uvalue='HIGH', /NO_REL)
junk1 = widget_button(junk, value='Low Side', uvalue='LOW', /NO_REL)
widget_control, junk1, /set_button	;Set low value
sl.isop.slider = WIDGET_SLIDER(parent, xsize=sl_width, MINIMUM = 0, $
		UVALUE = "ISOSLIDE", $
		TITLE = 'Isosurface Threshold (%)', $
		MAXIMUM = 100)
isodraw = WIDGET_DRAW(parent, XSIZE=sl_width, YSIZE = 100, /BUTTON_EVENTS)

;	Color tables
parent = sl.mode_bases(5)
junk1 = widget_base(parent, /ROW)
junk = WIDGET_BUTTON(junk1, VALUE = 'Color Tables', /MENU)
junk2 = 0
loadct, get_names = junk2
n = n_elements(junk2) < 24		;# of buttons to make
FOR i = 0, n-1 DO sl.color_button(i) = $	;Make color pull down buttons
	WIDGET_BUTTON(junk, VALUE=STRTRIM(junk2(i),2), uvalue='COLORS')

sl.cslide(0) = WIDGET_SLIDER(parent, xsize = sl_width, MINIMUM=0, /DRAG, $
	MAXIMUM=100, UVALUE = "STMIN", Title="Contrast Minimum", VALUE=0)
sl.cslide(1) = WIDGET_SLIDER(parent, xsize = sl_width, MINIMUM=0, /DRAG, $
	MAXIMUM=100, UVALUE = "STMAX", Title="Contrast Maximum", VALUE=100)
sl.cslide(2) = WIDGET_SLIDER(parent, xsize = sl_width, MINIMUM=0, /DRAG, $
	MAXIMUM=100, UVALUE = "SHADING", Title="Differential Shading (%)", $
	VALUE=20)


parent = sl.mode_bases(6)		;Rotations mode
sl.rslide(0) = WIDGET_SLIDER(parent, xsize=sl_width, MINIMUM=-90, MAXIMUM=90, $
	UVALUE = "XROTATION", Title="X Axis Rotation", VALUE=30)
sl.rslide(1) = WIDGET_SLIDER(parent, xsize=sl_width, MINIMUM=-179, $
	MAXIMUM=179, UVALUE = "ZROTATION", Title="Z Axis Rotation", VALUE=30)
junk = WIDGET_BASE(parent, /frame, /row)
junk1 = WIDGET_LABEL(junk, VALUE='Z Aspect Ratio:')
sl.rslide(2) = WIDGET_TEXT(junk, VALUE='1.0     ', /EDIT, YSIZE=1, XSIZE=10)


parent = sl.mode_bases(7)		;Journal mode
junk = WIDGET_BASE(parent, /COLUMN)
junk1 = WIDGET_BUTTON(junk, VALUE='Start Recording', UVALUE='RECORD', /NO_REL)
junk1 = WIDGET_BUTTON(junk, VALUE='Stop Recording', UVALUE='RECORDOFF',$
		/NO_REL)
junk1 = WIDGET_BUTTON(junk, VALUE='Playback', UVALUE='PLAYBACK', /NO_REL)
junk = WIDGET_BASE(parent, /ROW)
junk1 = WIDGET_LABEL(junk, value='File Name:')
sl.file_text(0) = WIDGET_TEXT(junk, xsize=24, ysize=1, $
	value='slicer.jou'+string(replicate(32b,14)), /EDIT, /FRAME)
sl.file_text(1) = WIDGET_TEXT(parent, xsize=32, ysize=1, $
	value='Journal Closed', /FRAME)

;	Transparency buttons / slider
junk = WIDGET_BASE(lbase, /FRAME, /COLUMN)
sl.threshold_slider = WIDGET_SLIDER(junk, xsize=sl_width, $
	MINIMUM=0, MAXIMUM=100,$
	UVALUE="THRESHOLD", TITLE="Transparency Threshold (%)", VALUE=0)

junk1 = WIDGET_BASE(lbase, /FRAME)	;Message base
sl.pos_text = WIDGET_TEXT(junk1, xsize=40, ysize=1)

; Unmap mode dependent widgets  (Leave journal mapped because of obscure bug)
for i=1, nmodes-1 do widget_control, sl.mode_bases(i), MAP=0

WIDGET_CONTROL, sl.base, /REALIZE
if sl.rbase ne 0 then WIDGET_CONTROL, sl.rbase, /REALIZE
DEVICE, SET_GRAPHICS=3		;Ensure copy graphics mode

WIDGET_CONTROL, sl.draw, get_value = junk
sl.window = junk		;Main window
WIDGET_CONTROL, isodraw, get_value = junk
sl.isop.window = junk		;Isosurface drawable
sl.isop.drawable = isodraw

sl.nc1 = (!d.n_colors < 256) -1 ;Colors we can use
sl.nc3 = (sl.nc1-3)/3		;Colors per orientation

slicer_orientation,6		;Reset to default orientation, erase
slicer_colors, 0

if n_elements(commands) gt 0 then slicer_playback, commands  ;Execute cmds?
if n_elements(cmd_file) gt 0 then slicer_playback, file = cmd_file

device,	TRANSLATION = tbl	;Read hdw translation table
				;Distance between white and black
if !d.name eq 'X' then sl.xcol = tbl(0) xor tbl(sl.nc1)  $
else sl.xcol = 196		;Windows.

tbl=0				;Kill it
XManager, "slicer", sl.base, EVENT_HANDLER = slicer_events, GROUP = group, $
   MODAL = Keyword_Set(modal)
end
; $Id: slide_image.pro,v 1.3 1994/09/23 14:07:54 kirk Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	SLIDE_IMAGE
;
; PURPOSE:
;	Create a scrolling graphics window for examining large images.
;	By default, 2 draw widgets are used.  The left draw widget shows
;	a reduced version of the complete image, while the draw widget on
;	the right displays the actual image with scrollbars that allow sliding
;	the visible window.
;
; CALLING SEQUENCE:
;	SLIDE_IMAGE [, Image]
;
; INPUTS:
;	Image:	The 2-dimensional image array to be displayed.  If this 
;		argument is not specified, no image is displayed. The 
;		FULL_WINDOW and SCROLL_WINDOW keywords can be used to obtain 
;		the window numbers of the 2 draw widgets so they can be drawn
;		into at a later time.
;
; KEYWORDS:
;      CONGRID:	Normally, the image is processed with the CONGRID
;		procedure before it is written to the fully visible
;		window on the left. Specifying CONGIRD=0 will force
;		the image to be drawn as is.
;
;  FULL_WINDOW:	A named variable in which to store the IDL window number of \
;		the non-sliding window.  This window number can be used with 
;		the WSET procedure to draw to the scrolling window at a later
;		point.
;
;	GROUP:	The widget ID of the widget that calls SLIDE_IMAGE.  If this
;		keyword is specified, the death of the caller results in the
;		death of SLIDE_IMAGE.
;
;	ORDER:	This keyword is passed directly to the TV procedure
;		to control the order in which the images are drawn. Usually,
;		images are drawn from the bottom up.  Set this keyword to a
;		non-zero value to draw images from the top down.
;
;     REGISTER:	Set this keyword to create a "Done" button for SLIDE_IMAGE
;		and register the widgets with the XMANAGER procedure.
;
;		The basic widgets used in this procedure do not generate
;		widget events, so it is not necessary to process events
;		in an event loop.  The default is therefore to simply create
;		the widgets and return.  Hence, when register is not set, 
;		SLIDE_IMAGE can be displayed and the user can still type 
;		commands at the "IDL>" prompt that use the widgets.
;
;	RETAIN:	This keyword is passed directly to the WIDGET_DRAW
;		function, and controls the type of backing store
;		used for the draw windows.  If not present, a value of
;		2 is used to make IDL handle backing store.
;
; SLIDE_WINDOW:	A named variable in which to store the IDL window number of 
;		the sliding window.  This window number can be used with the 
;		WSET procedure to draw to the scrolling window at a later 
;		time.
;
;	TITLE:	The title to be used for the SLIDE_IMAGE widget.  If this
;		keyword is not specified, "Slide Image" is used.
;
;	TOP_ID:	A named variable in which to store the top widget ID of the 
;		SLIDE_IMAGE hierarchy.  This ID can be used to kill the 
;		hierarchy as shown below:
;
;			SLIDE_IMAGE, TOP_ID=base, ...
;			.
;			.
;			.
;			WIDGET_CONTROL, /DESTROY, base
;
;	XSIZE:	The maximum width of the image that can be displayed by
;		the scrolling window.  This keyword should not be confused 
;		with the visible size of the image, controlled by the XVISIBLE
;		keyword.  If XSIZE is not specified, the width of Image is 
;		used.  If Image is not specified, 256 is used.
;
;     XVISIBLE:	The width of the viewport on the scrolling window.  If this 
;		keyword is not specified, 256 is used.
;
;	YSIZE:	The maximum height of the image that can be displayed by
;		the scrolling window.  This keyword should not be confused 
;		with the visible size of the image, controlled by the YVISIBLE
;		keyword.  If YSIZE is not present the height of Image is used.
;		If Image is not specified, 256 is used.
;
;     YVISIBLE:	The height of the viewport on the scrolling window. If
;		this keyword is not present, 256 is used.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Widgets for displaying a very large image are created.
;	The user typically uses the window manager to destroy
;	the window, although the TOP_ID keyword can also be used to
;	obtain the widget ID to use in destroying it via WIDGET_CONTROL.
;
; RESTRICTIONS:
;	Scrolling windows don't work correctly if backing store is not 
;	provided.  They work best with window-system-provided backing store
;	(RETAIN=1), but are also usable with IDL provided backing store 
;	(RETAIN=2).
;
;	Various machines place different restrictions on the size of the
;	actual image that can be handled.
;
; MODIFICATION HISTORY:
;	7 August, 1991, Written by AB, RSI.
;	10 March, 1993, ACY, Change default RETAIN=2
;	23 Sept., 1994  KDB, Fixed Typo in comments. Fixed error in
;			Congrid call. xvisible was used instead of yvisible.
;-


pro SLIDE_IMG_EVENT, ev
  WIDGET_CONTROL, ev.top, /DESTROY
end







pro slide_image, image, CONGRID=USE_CONGRID, ORDER=ORDER, REGISTER=REGISTER, $
	RETAIN=RETAIN, SHOW_FULL=SHOW_FULL, SLIDE_WINDOW=SLIDE_WINDOW, $
	XSIZE=XSIZE, XVISIBLE=XVISIBLE, YSIZE=YSIZE, YVISIBLE=YVISIBLE, $
	TITLE=TITLE, TOP_ID=BASE, FULL_WINDOW=FULL_WINDOW, GROUP = GROUP

  if (n_params() ne 0) then begin
    image_size = SIZE(image)
    if (image_size(0) ne 2) then message,'Image must be a 2-D array'
    if (n_elements(XSIZE) eq 0) then XSIZE = image_size(1)
    if (n_elements(YSIZE) eq 0) then YSIZE = image_size(2)
  endif else begin
    image_size=bytarr(1)
    if (n_elements(XSIZE) eq 0) then XSIZE = 256
    if (n_elements(YSIZE) eq 0) then YSIZE = 256
  endelse
  if (n_elements(xvisible) eq 0) then XVISIBLE=256
  if (n_elements(Yvisible) eq 0) then YVISIBLE=256
  if(n_elements(SHOW_FULL) eq 0) THEN SHOW_FULL = 1
  if(not KEYWORD_SET(ORDER)) THEN ORDER = 0
  if(not KEYWORD_SET(USE_CONGRID)) THEN USE_CONGRID = 1
  if(n_elements(RETAIN) eq 0) THEN RETAIN = 2
  if(n_elements(TITLE) eq 0) THEN TITLE='Slide Image'
  if(not KEYWORD_SET(REGISTER)) THEN REGISTER = 0

  if (REGISTER) then begin
    base = WIDGET_BASE(title=title, /COLUMN)
    junk = WIDGET_BUTTON(WIDGET_BASE(base), value='Done')
    ibase = WIDGET_BASE(base, /ROW)
  endif else begin
    base = WIDGET_BASE(title=title, /ROW)
    ibase = base
  endelse

  if (SHOW_FULL) then begin
      fbase = WIDGET_BASE(ibase, /COLUMN, /FRAME)
        junk = WIDGET_LABEL(fbase, value='Full Image')
        all = widget_draw(fbase,retain=retain,xsize=xvisible,ysize=yvisible)
      sbase = WIDGET_BASE(ibase, /COLUMN, /FRAME)
        junk = WIDGET_LABEL(sbase, value='Full Resolution')
        scroll = widget_draw(sbase, retain=retain,xsize=xsize,ysize=ysize, $
		/scroll, x_scroll_size=xvisible, y_scroll_size=yvisible)
    WIDGET_CONTROL, /REAL, base
    WIDGET_CONTROL, get_value=FULL_WINDOW, all
  endif else begin
    scroll = widget_draw(ibase, retain=retain, xsize=xsize, ysize=ysize, $
	/frame, /scroll, x_scroll_size=xvisible, y_scroll_size=yvisible)
    WIDGET_CONTROL, /REAL, base
    FULL_WINDOW=-1
  endelse

  WIDGET_CONTROL, get_value=SLIDE_WINDOW, scroll

  ; Show the image(s) if one is present
  if (image_size(0) ne 0) then begin
    cur_win = !d.window
    if (SHOW_FULL) then begin
      WSET, FULL_WINDOW
      if (use_congrid) then begin
	TV, congrid(image, xvisible, yvisible), ORDER=ORDER
      endif else begin
	TV, image, ORDER=ORDER
      endelse
    endif
  WSET, SLIDE_WINDOW
  TV, image, ORDER=ORDER
  if (cur_win ne -1) then WSET, cur_win
  endif
  if (n_elements(group) eq 0) then group=base

  if (REGISTER) then XMANAGER, 'SLIDE_IMAGE', base, event='SLIDE_IMG_EVENT', $
	GROUP_LEADER = GROUP

end
;
; $Id: slider_alloc.pro,v 1.8 1995/01/20 19:41:01 tonyh Exp $
;
;  WidSlider
;   Widget Slider class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  SLIDER_Icon
;       Return the slider toolbar icon
;
FUNCTION SLIDER_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 2b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 128b, 3b, 0b ], $
    [ 0b, 192b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 0b, 3b, 0b ], $
    [ 0b, 192b, 15b, 0b ], $
    [ 0b, 224b, 31b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 12b, 248b, 127b, 16b ], $
    [ 12b, 8b, 67b, 32b ], $
    [ 12b, 8b, 67b, 16b ], $
    [ 12b, 8b, 67b, 32b ], $
    [ 12b, 8b, 67b, 16b ], $
    [ 12b, 8b, 67b, 32b ], $
    [ 12b, 248b, 127b, 16b ], $
    [ 172b, 170b, 170b, 42b ], $
    [ 84b, 85b, 85b, 21b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END

;
;  SLIDER_Copy
;   Copy a slider.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO SLIDER_Copy, Ptr, Copy
    GenCopy, Ptr, Copy
END


;
;  SLIDER_Destroy
;   Release resources for the given slider
;
PRO SLIDER_Destroy, Ptr
    GenDestroy, Ptr
END


;
;  SLIDER_Event
;   Event handling routine for slider dialog
;
PRO SLIDER_Event, Event
    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'NAME':     Obj.Name        = Event.Value
    'TITLE':    Obj.Title       = Event.Value
    'SMIN':     Obj.SliderMin   = Event.Value
    'SINIT':    Obj.SliderStart = Event.Value
    'SMAX':     Obj.SliderMax   = Event.Value
    'FONT':     Obj.Font        = Event.Value
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'XSIZE':    Obj.XSize       = Event.Value
    'YSIZE':    Obj.YSize       = Event.Value
    'XOFFSET':  Obj.XOffset     = Event.Value
    'YOFFSET':  Obj.YOffset     = Event.Value

    'XFONT':    DoXFont, Obj, Binfo.Foci(4)

    'DO_DRAG':      Obj.SliderDrag      = 1 - Obj.SliderDrag
    'DO_VERTICAL':  Obj.SliderVertical  = 1 - Obj.SliderVertical
    'DO_SUPPRESS':  Obj.SliderSuppress  = 1 - Obj.SliderSuppress

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  SLIDER_Build
;   Create a dialog box a slider object.  If ptr is nil then
;   create the object as well.
;
PRO SLIDER_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    SLIDER_Alloc, ParPtr, Ptr               ; Allocate object if necessary
    MgrName = 'WE_SLIDER' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN   ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(12)

    ;   Event Related Info

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
    Foci(0) = Field(Base1, "Slider Title:",Obj.Title,'TITLE',SIZE=50,/STRING)
    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(1) = Field(Base2, "Minimum:", Obj.SliderMin, 'SMIN', SIZE=8, /LONG)
    Foci(2) = Field(Base2, "Initial:", Obj.SliderStart, 'SINIT', SIZE=8, /LONG)
    Foci(3) = Field(Base2, "Maximum:", Obj.SliderMax, 'SMAX', SIZE=8, /LONG)

    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(4) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")

    Base2   = WIDGET_BASE(Base1, /ROW, /NONEXCLUSIVE)
    Button  = WIDGET_BUTTON(Base2, VALUE='Generate Drag Events', $
                            UVALUE='DO_DRAG')
    IF Obj.SliderDrag THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Vertical Slider', $
                            UVALUE='DO_VERTICAL')
    IF Obj.SliderVertical THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Suppress display of current value', $
                            UVALUE='DO_SUPPRESS')
    IF Obj.SliderDrag THEN WIDGET_CONTROL, Button, /SET_BUTTON

    BuildOther, Base1, Obj, Foci, 5, /FRAME

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Slider Appearance Controls")
    BuildXY, Base1, Obj, Foci, 8, /SIZE, /OFFSET
    BuildOkCancel, Base, Obj

    DlgInfo     = { $
        Foci:       Foci, $
        ObjPtr:     Ptr $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='SLIDER_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  SLIDER_Save
;   Save slider information to a file.
;   This is a simple object to save.
;
PRO SLIDER_Save, Unit, Ptr
    GenWrite, Unit, Ptr
END


;
;  SLIDER_Restore
;   Read in a slider object from a file
;
PRO SLIDER_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "SLIDER", 0
END


;
;  SLIDER_Generate
;   Create a slider object for previewing
;
PRO SLIDER_Generate, Base, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Value may not be outside of min/max

    Value   = Obj.SliderMin > Obj.SliderStart < Obj.SliderMax

    Cmd = 'Id = WIDGET_SLIDER(Base'
    SAddCmd, Cmd, Obj.Font, 'FONT'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IF Obj.SliderMin NE Obj.SliderMax THEN BEGIN
        IAddCmd, Cmd, Obj.SliderMin, 'MINIMUM', /FORCE
        IAddCmd, Cmd, Obj.SliderMax, 'MAXIMUM', /FORCE
    ENDIF
    IAddCmd, Cmd, Obj.SliderSuppress, 'SUPPRESS_VALUE'
    SAddCmd, Cmd, Obj.Title, 'TITLE'
    IAddCmd, Cmd, Value, 'VALUE', /FORCE
    IAddCmd, Cmd, Obj.SliderVertical, 'VERTICAL'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'

    Obj2Ptr, Obj, Ptr

    ; Create slider

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Slider ' + VarName(Ptr)
    ENDIF
END


;
;  SLIDER_GenWid
;   Create IDL code for creating a SLIDER
;
PRO SLIDER_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)            ; Get name for slider
    Ptr2Obj, Ptr, Obj               ; Get object information

    ;   Value may not be outside of min/max

    Value   = Obj.SliderMin > Obj.SliderStart < Obj.SliderMax

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_SLIDER( ",A)', $
        Name, Parent, /NO_EOL
    ISaveCmd, Unit, Obj.SliderDrag, "DRAG"
    SSaveCmd, Unit, Obj.Font, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    IF Obj.SliderMin NE Obj.SliderMax THEN BEGIN
        ISaveCmd, Unit, Obj.SliderMax, "MAXIMUM", /FORCE
        ISaveCmd, Unit, Obj.SliderMin, "MINIMUM", /FORCE
    ENDIF
    ISaveCmd, Unit, Obj.SliderSuppress, "SUPPRESS"
    SSaveCmd, Unit, Obj.Title, "TITLE"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Value, "VALUE", /FORCE
    ISaveCmd, Unit, Obj.SliderVertical, "VERTICAL"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  SLIDER_Alloc
;       Allocate a slider object.  Don't allocate if ptr is non-nil
;
PRO SLIDER_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr = WIDGET_BASE(GROUP=TopDlg)         ; Make a pointe

    Obj = {                     $
        WE_SLIDER,              $
        Type:           'SLIDER',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; object name
        Title:          '',     $ ; Slider title
        FrameSize:      0,      $
        Font:           '',     $
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        UValue:         '',     $
        SliderDrag:     0,      $ ; Slider flags
        SliderVertical: 0,      $
        SliderSuppress: 0,      $
        SliderMin:      0L,     $ ; Slider basic info
        SliderStart:    0L,     $
        SliderMax:      0L      $
    }
    Obj2Ptr, Obj, Ptr
END
; $Id: sph_4pnt.pro,v 1.6 1994/11/29 20:42:40 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       SPH_4PNT
;
; PURPOSE:
;       Given four 3-dimensional points, this procedure returns the
;       center and radius necessary to define the unique sphere passing
;       through those points.
;
; CATEGORY:
;       Analytic Geometry.
;
; CALLING SEQUENCE:
;       SPH_4PNT, X, Y, Z, Xc, Yc, Zc, R
;
; INPUTS:
;       X: A 4-element vector containing the X coordinates of the points.
;       Y: A 4-element vector containing the Y coordinates of the points.
;       Z: A 4-element vector containing the Z coordinates of the points.
;
;	Note: X, Y, and Z should be floating-point or double-precision
;	      vectors.
;
; OUTPUTS:
;       Xc: The sphere's center x-coordinate. 
;       Yc: The sphere's center y-coordinate.
;       Zc: The sphere's center z-coordinate.
;       R:  The sphere's radius.
;
; RESTRICTIONS:
;       Points may not coincide.
;
; EXAMPLE:
;       Find the center and radius of the unique sphere passing through
;       the points: (1, 1, 0), (2, 1, 2), (1, 0, 3), (1, 0, 1)
;       
;       Define the floating-point vectors containing the x, y and z 
;       coordinates of the points. 
;         X = [1, 2, 1, 1] + 0.0
;	  Y = [1, 1, 0, 0] + 0.0
;	  Z = [0, 2, 3, 1] + 0.0
;
;       Compute the sphere's center and radius.
;         SPH_4PNT, X, Y, Z, Xc, Yc, Zc, R
;
;       Print the results.
;         PRINT, Xc, Yc, Zc, R
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, Jan 1993
;       Modified:    GGS, RSI, March 1994
;                    Rewrote documentation header.
;                    Uses the new Numerical Recipes NR_LUDCMP/NR_LUBKSB.
;       Modified:    GGS, RSI, November 1994
;                    Changed internal array from column major to row major.
;                    Changed NR_LUDCMP/NR_LUBKSB to LUDC/LUSOL
;-

PRO SPH_4PNT, x, y, z, xc, yc, zc, r

;Define the relationships between x, y and z as the transposed
;linear system.
  a = fltarr(3, 3)
  for k = 0, 2 do begin
    a(0, k) = x(k) - x(k+1)
    a(1, k) = y(k) - y(k+1)
    a(2, k) = z(k) - z(k+1)
  endfor

;Define right-side of linear system.
  q = x^2 + y^2 + z^2
  c = 0.5 * (q(0:2) - q(1:3))

;Solve the linear system Ay = c where y = (Xc, Yc, Zc)
  ludc, a, index
;Solution y is stored in C
  c = lusol(a, index, c)

;The sphere's center x-coordinate.
  xc = c(0)

;The sphere's center y-coordinate.
  yc = c(1)

;The sphere's center z-coordinate.
  zc = c(2)

;The sphere's radius.
  r = sqrt(q(0) - 2*(x(0)*xc + y(0)*yc + z(0)*zc) + xc^2 + yc^2 + zc^2)

end
; $Id: sph_scat.pro,v 1.1 1995/02/02 21:33:26 dave Exp $
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

function sph_scat, lon, lat, f, GS = gs, BOUNDS = bounds, NLON=nlon, $
	NLAT = nlat, GOUT = gsout, BOUT = boundsout
;+
; NAME:
;	SPH_SCAT
;
; PURPOSE:
;	Interpolate to a regular grid given scattered samples on the
;	surface of a sphere.
; CATEGORY:
;	Interpolation.
; CALLING SEQUENCE:
;	Result = SPH_SCAT(lon, lat, f)
; INPUTS:
;	lon = sample longitudes, a vector, in degrees.  lon, lat, and 
;		f must have the same number of points.
;	lat = sample latitudes, a vector, in degreees.
;	f = data values measured at lon and lat.  f(i) = sample value
;		at lon(i), lat(i).  
; KEYWORD PARAMETERS:
;	GS:	  If present, GS must be a two-element vector [XS, YS],
;		  where XS is the spacing between grid points in longitude,
;		  and YS is the spacing in latitude. The default is based on
;		  the extents of lon and lat. If the grid starts at longitude
;		  Lonmin and ends at Lonmax, then the default horizontal
;		  spacing is (Lonmax - Lonmin)/(NX-1). YS is computed in the
;		  same way. The default grid size, if neither NX or NY
;		  are specified, is 26 by 26.
;	BOUNDS:   If present, BOUNDS must be a four element array containing
;		  the grid limits in longitude and latitude of the output grid:
;		  [Lonmin, Latmin, Lonmax, Latmax]. If not specified, the grid
;		  limits are set to the extent of lon and lat.   Warning:
;		  to cover all longitudes, you must directly specify BOUNDS.
;	NX:       The output grid size in the longitude direction. NX need not
;	  	  be specified if the size can be inferred from GS and
;		  BOUNDS. The default value is 26.
;	NY:       The output grid size in the latitude direction. See NX. 
;	BOUT:	  the actual extent of the regular grid, arranged as in
;		  bounds.  An optional output parameter.
;	GOUT:     The actual grid spacing, a two element optional output array.
;	
; OUTPUTS:
;	Result = regularly interpolated result.
; COMMON BLOCKS:
;	None.
; SIDE EFFECTS:
;	None.
; RESTRICTIONS:
;	Timing. on a Sun SPARCstation LX producing a 36 x 36 output
;	grid (1296 points), t is ~ .578 + .00368 * N + 2.39e-06 * N^2.
;	For example:  
;	N	16	64	256	1024	4096
;	Time	.7	.8	1.6	6.6	56
;	Output points are produced at a rate of approximately 2000
;	points per second.
;	
; PROCEDURE:
;	This routine is a convenience interface to the Spherical gridding
;	and interpolation provided by TRIANGULATE and TRIGRID.  The
;	methods are based on the work of Robert Renka, Interpolation of Data
;	on the Surface of a Sphere, Oak Ridge Natl Lab Technical Paper
;	CSD-108.  The procedure consists of generating a triangulation of the
;	scattered data points, estimating the gradients with a local method,
;	and then constructing a triangle based interpolant of the data and
;	gradient estimates.  The interpolant is C(1) continuous.
; EXAMPLE:
;	Create 50 random longitudes and latitudes, make a function value,
;	and then interpolate, obtaining a 360 x 360 array of
;	10 degree by 5 degree resolution that covers the sphere:
;
;	lon = randomu(seed, 50) * 360. -180.  ;Make random scattered points
;	lat = randomu(seed, 50) * 180. -90.
;	z = sin(lat*!DTOR)		;Make a function to fit
;	c = cos(lat*!DTOR)
;	x = cos(lon*!DTOR) * c
;	y = sin(lon*!DTOR) * c
;	f =  sin(x+y) * sin(x*z)	;The dependent variable
;  ** Now, given lon, lat, and f, interpolate the data:
;	result = sph_scat(lon, lat, f, bounds=[0, -90, 350, 85], gs=[10,5])
;	
; MODIFICATION HISTORY:
;	DMS, November, 1994.  Written.
;-

n = n_elements(lon)
if n ne n_elements(lat) or n ne n_elements(f) then $
	message, 'lon, lat, and f must have the same number of elements'
if n le 3 then $
	message, 'Must have at least 3 points'
;		Construct bounds if necessary
if n_elements(bounds) ne 4 then $
    boundsout = [ min(lon, max=lonmax), min(lat, max=latmax), lonmax, latmax] $
else boundsout = bounds
;		Get gs, nx, and ny.
if n_elements(gs) ne 2 then begin
    if n_elements(nx) le 0 then nx = 26
    if n_elements(ny) le 0 then ny = 26
    gsout = [boundsout(2)-boundsout(0), boundsout(3)-boundsout(1)] / $
		float([nx-1, ny-1])
endif else gsout = gs
fcopy = f		;will be rearranged.
TRIANGULATE, 1.0*lon, 1.0*lat, SPHERE=s, tr, FVALUE=fcopy, /DEGREES
return, TRIGRID(fcopy, SPHERE=s, gsout, boundsout, /DEGREES)
end
; $Id: spline_p.pro,v 1.3 1994/02/01 22:18:38 dave Exp $
; Copyright (c) 1993, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	SPLINE_P
;
; PURPOSE:
;	This procedure performs parameteric cubic spline interpolation.
;
; CATEGORY:
;	Interpolation - E1.
;
; CALLING SEQUENCE:
;	SPLINE_P, X, Y, Xr, Yr
;
; INPUTS:
;	X:	  The abcissa vector (should be floating or double).
;	Y:	  The vector of ordinate values corresponding to X.
;	Neither X or Y need be monotonic.
;
; KEYWORD PARAMETERS:
;	INTERVAL: The interval in XY space between interpolants. If
;		  omitted, approximately 8 interpolants per XY segment
;		  will result.
;	TAN0:	  The tangent to the spline curve at X(0), Y(0). If omitted,
;		  the tangent is calculated to make the curvature of the
;		  result zero at the beginning. This is a two element vector,
;		  containing the X and Y components of the tangent.
;	TAN1:	  The tangent to the spline curve at X(N-1), Y(N-1). If omitted,
;		  the tangent is calculated to make the curvature of the
;		  result zero at the end. This is a two element vector,
;		  containing the X and Y components of the tangent.
;
; OUTPUTS:
;	XR:	  The abcissa values of the interpolated function. This
;		  may NOT be the same variable as either X or Y.
;	YR:	  The ordinate values of the interpolated function. This
;		  may NOT be the same variable as either X or Y.
;
; RESTRICTIONS:
;	X and Y should be floating or double.
;
; PROCEDURE:
;	Cubic spline interpolation with relaxed or clamped end conditions
;	as used in the Numerical Recipes.
;
;	This routine is both more general and faster than the
;	user's library function SPLINE. One call to SPLINE_P is equivalent
;	to two calls to SPLINE, as both the X and Y are interpolated with
;	splines. It is suited for interpolating between randomly 
;	placed points, and the abcissae	values need not be monotonic.
;	In addition, the end conditions may be optionally specified via
;	tangents.
;
; EXAMPLE:
;	The commands below show a typical use of SPLINE_P:
;	  X = [0.,1,0,-1,0]	  ;Abcissae for square with a vertical diagonal
;	  Y = [0.,1,2,1,0]	  ;Ordinates
;	  SPLINE_P, X, Y, XR, YR  ;Interpolate with relaxed end conditions
;	  PLOT, XR, YR		  ;Show it
;
; 	As above, but with setting both the beginning and end tangents:
; 	  SPLINE_P, X, Y, XR, YR, TAN0=[1,0], TAN1=[1,0]
;
; 	This yields approximately 32 interpolants.
;
; 	As above, but with setting the interval to 0.05, making more
;	interpolants, closer together:
; 	  SPLINE_P, X, Y, XR, YR, TAN0=[1,0], TAN1=[1,0], INTERVAL=0.05
;
; 	This yields 116 interpolants and looks close to a circle.
;
; MODIFICATION HISTORY:
;	DMS, RSI.	August, 1993.	Written.
;	DMS, RSI.	Jan, 1994.  Modified to use NR_ spline routines.
;-

PRO SPLINE_P, x, y, xr, yr, $
	INTERVAL=interval, TAN0=tan0, TAN1=tan1

n = n_elements(x)
if n ne n_elements(y) then $
	message,'X and Y must have the same number of points'

ni = n-1		;Number of intervals

dx = x - shift(x,1)	;Delta x and y
dy = y - shift(y,1)	;dx(i) = x(i) - x(i-1)
dx(0) = 0.
dy(0) = 0.

t = sqrt(dx^2 + dy^2)	;interpoint Distance
ni = n-1
big = 2.0e30

; Default interval = approx 8 points per interval....
if n_elements(interval) le 0 then interval = total(t) / (8*ni)

r = ceil(t/interval)		;# of elements in each interval
nr = long(total(r))		;# of elements in result

tt = fltarr(nr+1, /nozero)
j = 0L

for int = 0, ni-1 do begin	;Each interval
    i1 = int+1
    nn = r(i1)			;# pnts in this interval
    tt(j) = t(i1) / nn * findgen(nn) + t(int)
    t(i1) = t(i1) + t(int)
    j = j + nn
    endfor
tt(nr) = t(int)

; Use end tangents, or use relaxed condition.
if n_elements(tan0) ge 2 then begin	;Clamped on left?
    xp0 = tan0(0)
    yp0 = tan0(1)
endif else begin			;Relaxed
    xp0 = big
    yp0 = big
endelse

if n_elements(tan1) ge 2 then begin	;Clamped on right?
    xpn = tan1(0)
    ypn = tan1(1)
endif else begin
    xpn = big
    ypn = big
endelse

; Compute result & quit
xr = nr_splint(t,x, nr_spline(t,x, yp1 = xp0, ypn = xpn), tt)
yr = nr_splint(t,y, nr_spline(t,y, yp1 = yp0, ypn = ypn), tt)
end
; $Id: spline.pro,v 1.3 1993/10/06 17:29:55 doug Exp $

function spline,x,y,t,sigma
;+
; NAME:
;	SPLINE
;
; PURPOSE:
;	This function performs cubic spline interpolation.
;
; CATEGORY:
;	Interpolation - E1.
;
; CALLING SEQUENCE:
;	Result = SPLINE(X, Y, T [, Sigma])
;
; INPUTS:
;	X:	The abcissa vector. Values MUST be monotonically increasing.
;
;	Y:	The vector of ordinate values corresponding to X.
;
;	T:	The vector of abcissae values for which the ordinate is 
;		desired. The values of T MUST be monotonically increasing.
;
; OPTIONAL INPUT PARAMETERS:
;	Sigma:	The amount of "tension" that is applied to the curve. The 
;		default value is 1.0. If sigma is close to 0, (e.g., .01),
;		then effectively there is a cubic spline fit. If sigma
;		is large, (e.g., greater than 10), then the fit will be like
;		a polynomial interpolation.
;
; OUTPUTS:
;	SPLINE returns a vector of interpolated ordinates.
;	Result(i) = value of the function at T(i).
;
; RESTRICTIONS:
;	Abcissa values must be monotonically increasing.
;
; EXAMPLE:
;	The commands below show a typical use of SPLINE:
;
;		X = [2.,3.,4.]  	;X values of original function
;		Y = (X-3)^2     	;Make a quadratic
;		T = FINDGEN(20)/10.+2 	;Values for interpolated points.
;					;twenty values from 2 to 3.9.
;		Z = SPLINE(X,Y,T) 	;Do the interpolation.
;
;
;
; MODIFICATION HISTORY:
;	Author:	Walter W. Jones, Naval Research Laboratory, Sept 26, 1976.
;	Reviewer: Sidney Prahl, Texas Instruments.
;	Adapted for IDL: DMS, Research Systems, March, 1983.
;
;-
;
on_error,2                      ;Return to caller if an error occurs
if n_params(0) lt 4 then sigma = 1.0 else sigma = sigma > .001	;in range?
n = n_elements(x) < n_elements(y)
;
if n le 1 then message, 'X and Y must be arrays.'

;
xx = x * 1.			;Make X values floating if not.
yp = fltarr(n*2)		;temp storage
delx1 = xx(1)-xx(0)		;1st incr
dx1=(y(1)-y(0))/delx1
;
nm1 = n-1L
np1 = n+1L
if (n eq 2) then begin
	yp(0)=0.
	yp(1)=0.
   end else begin
	delx2 = xx(2)-xx(1)
	delx12 = xx(2)-xx(0)
	c1 = -(delx12+delx1)/delx12/delx1
	c2 = delx12/delx1/delx2
	c3 = -delx1/delx12/delx2
;
	slpp1 = c1*y(0)+c2*y(1)+c3*y(2)
	deln = xx(nm1)-xx(nm1-1)
	delnm1 = xx(nm1-1)-xx(nm1-2)
	delnn = xx(nm1)-xx(nm1-2)
	c1=(delnn+deln)/delnn/deln
	c2=-delnn/deln/delnm1
	c3=deln/delnn/delnm1
	slppn = c3*y(nm1-2)+c2*y(nm1-1)+c1*y(nm1)
   endelse
;
	sigmap = sigma*nm1/(xx(nm1)-xx(0))
	dels = sigmap*delx1
	exps = exp(dels)
	sinhs = .5d0*(exps-1./exps)
	sinhin=1./(delx1*sinhs)
	diag1 = sinhin*(dels*0.5d0*(exps+1./exps)-sinhs)
	diagin = 1./diag1
	yp(0)=diagin*(dx1-slpp1)
	spdiag = sinhin*(sinhs-dels)
	yp(n)=diagin*spdiag
;
	if  n gt 2 then for i=1L,nm1-1 do begin
		delx2 = xx(i+1)-xx(i)
		dx2=(y(i+1)-y(i))/delx2
		dels = sigmap*delx2
		exps = exp(dels)
		sinhs = .5d00 *(exps-1./exps)
		sinhin=1./(delx2*sinhs)
		diag2 = sinhin*(dels*(.5*(exps+1./exps))-sinhs)
		diagin = 1./(diag1+diag2-spdiag*yp(n+i-1))
		yp(i)=diagin*(dx2-dx1-spdiag*yp(i-1))
		spdiag=sinhin*(sinhs-dels)
		yp(i+n)=diagin*spdiag
		dx1=dx2
		diag1=diag2
	   endfor
;

	diagin=1./(diag1-spdiag*yp(n+nm1-1))
	yp(nm1)=diagin*(slppn-dx2-spdiag*yp(nm1-1))
	for i=n-2,0,-1 do yp(i)=yp(i)-yp(i+n)*yp(i+1)		
;
;
	m = n_elements(t)
	subs = replicate(long(nm1),m) ;subscripts
	s = xx(nm1)-xx(0)
	sigmap = sigma*nm1/s
	j=0L
	for i=1L,nm1 do $ ;find subscript where xx(subs) > t(j) > xx(subs-1)
		while xx(i) gt t(j) do begin
			subs(j)=i
			j=j+1
			if j eq m then goto,done
			endwhile
	
done:	subs1 = subs-1
	del1 = t-xx(subs1)
	del2 = xx(subs)-t
	dels = xx(subs)-xx(subs1)
	exps1=exp(sigmap*del1)
	sinhd1 = .5*(exps1-1./exps1)
	exps=exp(sigmap*del2)
	sinhd2=.5*(exps-1./exps)
	exps = exps1*exps
	sinhs=.5*(exps-1./exps)
	spl=(yp(subs)*sinhd1+yp(subs1)*sinhd2)/sinhs+ $
		((y(subs)-yp(subs))*del1+(y(subs1)-yp(subs1))*del2)/dels
	if m eq 1 then return,spl(0) else return,spl
end
;$Id: s_test.pro,v 1.4 1994/12/19 19:44:41 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       S_TEST
;
; PURPOSE:
;       This function tests the hypothesis that two sample popultions, 
;       {X(i), Y(i)}, have the same mean of distribution against the 
;       hypothesis that they differ. The result is a two-element vector
;       containing the maximum number of signed differences between 
;       corresponding pairs of X(i) and Y(i) and the one-tailed level of
;       significance. This type of test is often refered to as the Sign
;       Test.
;       
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = S_test(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An n-element vector of type integer, float or double.
;
; KEYWORD PARAMETERS:
;   ZDIFF:    Use this keyword to specify a named variable which returns the
;             number of differences between corresponding pairs of X(i) and 
;             Y(i) resulting in zero. Paired data resulting in a difference 
;             of zero are excluded from the ranking and the sample size is 
;             correspondingly reduced.
;
; EXAMPLE:
;       Define the n-element vectors of sample data.
;         x = [47, 56, 54, 49, 36, 48, 51, 38, 61, 49, 56, 52]
;         y = [71, 63, 45, 64, 50, 55, 42, 46, 53, 57, 75, 60]
;       Test the hypothesis that two sample popultions, {X(i), Y(i)}, have 
;       the same mean of distribution against the hypothesis that they differ
;       at the 0.05 significance level.
;         result = s_test(x, y, zdiff = zdiff)
;       The result should be the 2-element vector:
;         [9.00000, 0.0729981]
;       The keyword parameter should be returned as:
;         zdiff = 0
;       The computed probability (0.0729981) is greater than the 0.05 
;       significance level and therefore we do not reject the hypothesis that
;       X and Y have the same mean of distribution.
;
; PROCEDURE:
;       S_TEST computes the nonparametric Sign Test. Differences between 
;       corresponding pairs of X(i) and Y(i) are ranked as either positive or
;       negative with equal probability of occurance. Differences between 
;       pairs of X(i) and Y(i) that result in zero are excluded from the 
;       ranking and the sample size is correspondingly reduced. The result is 
;       a two-element vector [diff, p] containing the maximum number of signed 
;       differences between corresponding pairs of X(i) and Y(i) and the one-
;       tailed level of significance. Using the Binomial random variable X, 
;       we can accept of reject the proposed hypothesis. If the sample size 
;       exceeds 25, then the Gaussian distribution is used to approximate the 
;       cumulative Binomial distribution. The one-tailed probability of
;       obtaining at least (diff) signed differences in an n-element sample is
;       equal to (p). Prob(X >= diff) = p. 
;       The hypothesis that two sample popultions have the same mean
;       of distribution is rejected if the number of positive ranks and the
;       number of negative ranks differ with statistical significance. 
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, August 1994
;-

function s_test, x, y, zdiff = zdiff

  on_error, 2
  n = n_elements(x)
  if n ne n_elements(y) then message, $
      'x and y must be vectors of equal size.'

  diff = x - y

  ;Number of "ties" (identical data).
  psize = where(diff eq 0, zdiff)

  ;Population sample size. 
  psize = n - zdiff 

  if psize eq 0 then message, $
    'x and y contain identical data.'

  ;Number of positive ranks.
  ipn = where(diff gt 0, npos)

  ;Number of negative ranks.
  nneg = psize - npos

  if npos gt nneg then begin
  ;Probability that the number of positive ranks is at least (npos) with a
  ;population size (psize).     Prob(# of positive ranks >= npos)
    prob = binomial(npos, psize, 0.5)
  endif else if nneg gt npos then begin 
  ;Prob(# of negative ranks >= nneg)
    prob = binomial(nneg, psize, 0.5)
  endif else $
    ;prob = binomial(npos, psize/2, 0.5)
    prob = 0.5

  ;Maximum number of signed differences and the one-tailed probability.
  return, [max([npos, nneg]), prob]

end

; $Id: stretch.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Pro Stretch, Low, High, Gamma, CHOP = Chop
;+
; NAME:
;	STRETCH
;
; PURPOSE:
;	Stretch the image display color tables so the full range 
;	runs from one color index to another.
;
; CATEGORY:
;	Image processing, point operations.
;
; CALLING SEQUENCE:
;	STRETCH, Low, High [, /CHOP]
;
; INPUTS:
;	Low:	The lowest pixel value to use.  If this parameter is omitted,
;		0 is assumed.  Appropriate values range from 0 to the number 
;		of available colors-1.
;
;	High:	The highest pixel value to use.  If this parameter is omitted,
;		the number of colors-1 is assumed.  Appropriate values range 
;		from 0 to the number of available colors-1.
;
; OPTIONAL INPUTS:
;	Gamma:	Gamma correction factor.  If this value is omitted, 1.0 is 
;		assumed.  Gamma correction works by raising the color indices
;		to the Gamma power, assuming they are scaled into the range 
;		0 to 1.
;
; KEYWORD PARAMETERS:
;	CHOP:	If this keyword is set, color values above the upper threshold
;		are set to color index 0.  Normally, values above the upper 
;		threshold are set to the maximum color index.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	COLORS:	The common block that contains R, G, and B color
;		tables loaded by LOADCT, HSV, HLS and others.
;
; SIDE EFFECTS:
;	Image display color tables are loaded.
;
; RESTRICTIONS:
;	Common block COLORS must be loaded before calling STRETCH.
;
; PROCEDURE:
;	New R, G, and B vectors are created by linearly interpolating
;	the vectors in the common block from Low to High.  Vectors in the 
;	common block are not changed.
;
;	If NO parameters are supplied, the original color tables are
;	restored.
;
; EXAMPLE:
;	Load the STD GAMMA-II color table by entering:
;
;		LOADCT, 5
;
;	Create and display and image by entering:
;
;		TVSCL, DIST(300)
;
;	Now adjust the color table with STRETCH.  Make the entire color table
;	fit in the range 0 to 70 by entering:
;
;		STRETCH, 0, 70
;
;	Notice that pixel values above 70 are now colored white.  Restore the
;	original color table by entering:
;
;		STRETCH
;
; MODIFICATION HISTORY:
;	DMS, RSI, Dec, 1983.
;	DMS, April, 1987.	Changed common.
;	DMS, October, 1987.	For unix.
;	DMS, RSI, Nov., 1990.	Added GAMMA parameter.
;-
;
	common colors,r,g,b,cur_red,cur_green,cur_blue
	on_error,2		;Return to caller if error
	nc = !d.table_size	;# of colors entries in device
	if nc eq 0 then message, $
		"Device has static color tables.  Can't modify."

	if n_elements(r) le 0 then begin	;color tables defined?
		r=indgen(nc) & g=r & b=r & endif
	if n_params(0) lt 1 then low = 0
	if n_params(0) lt 2 then high = nc-1
	if n_params(0) lt 3 then gamma = 1.0	;Default gamma
	if high eq low then return		;Nonsensical

	if gamma eq 1.0 then begin		;Simple case
		slope = float(nc-1)/(high-low)  ;Scale to range of 0 : nc-1
		intercept = -slope*low
		p = long(findgen(nc)*slope+intercept) ;subscripts to select
	endif else begin			;Gamma ne 0
		slope = 1. / (high-low)		;Range of 0 to 1.
		intercept = -slope * low
		p = findgen(nc) * slope + intercept > 0.0
		p = long(nc * (p ^ gamma))
	endelse
	if keyword_set(Chop) then begin
		too_high = where(p ge nc, n)
		if n gt 0 then p(too_high)  = 0L
		endif
	cur_red = r(p) & cur_green = g(p) & cur_blue = b(p)
	tvlct,cur_red, cur_green, cur_blue
	return
end

; $Id: str_sep.pro,v 1.3 1995/01/06 21:59:22 dave Exp $
; Copyright (c) 1992-1995, CreaSo Creative Software Systems GmbH,
;	and Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;    STR_SEP
;
; PURPOSE:
;    This routine cuts a string into pieces which are separated by the 
;    separator string.
; CATEGORY:
;    String processing.
; CALLING SEQUENCE:
;    arr = STR_SEP(string, separator)
;
; INPUTS:
;    str - The string to be separated.
;    sep - The separator.
;
; KEYWORDS:
;    ESC = escape character.  Only valid if separator is a single character.
;		Characters following the escape character are treated
;		literally and not interpreted as separators.
;		For example, if the separator is a comma,
;		and the escape character is a backslash, the character
;		sequence 'a\,b' is a single field containing the characters
;		'a,b'.
;    REMOVE = if set, remove all blanks from fields.
;    TRIM = if set, remove only leading and trailing blanks from fields.
;
; OUTPUT: 
;    An array of strings as function value.
;
; COMMON BLOCKS:
;    None
;
; SIDE EFFECTS:
;    No known side effects.
;
; RESTRICTIONS:
;    None.
;
; EXAMPLE:
;    array = STR_SEP ("ulib.usca.test", ".")
;
; MODIFICATION HISTORY:
;	July 1992, AH,	CreaSo		Created.
;	December, 1994, DMS, RSI	Added TRIM and REMOVE.
;-
function STR_SEP, s, sep, REMOVE = remove, TRIM = trim, ESC=esc


spos = 0L
if n_elements(esc) gt 0 then begin		;Check for escape character?
  if strpos(s, esc) lt 0 then goto, no_esc	;None in string, use fast case
  besc = (byte(esc))(0)
  bsep = (byte(sep))(0)
  new = bytarr(strlen(s)+1)
  new(0) = byte(s)
  j = 0
  for i=0, n_elements(new)-2 do begin
    if new(i) eq besc then begin
	new(j) = new(i+1)
	i = i + 1
    endif else if new(i) eq bsep then new(j) = 1b $   ;Change seps to 1b char
    else new(j) = new(i)
    j = j + 1
    endfor
  new = string(new(0:j-1))
  w = where(byte(new) eq 1b, count)  ;where seps are...
  arr = strarr(count+1)
  for i=0, count-1 do begin
	arr(i) = strmid(new, spos, w(i)-spos)
	spos = w(i) + 1
	endfor
  arr(count) = strmid(new, spos, strlen(s))  ;Last element
  goto, done
  endif			;esc

no_esc:
if strlen(sep) eq 1 then begin	;Single character separator?
    w = where(byte(s) eq (byte(sep))(0), count)  ;where seps are...
    arr = strarr(count+1)
    for i=0, count-1 do begin
	arr(i) = strmid(s, spos, w(i)-spos)
	spos = w(i) + 1
	endfor
    arr(count) = strmid(s, spos, strlen(s))  ;Last element
endif else begin		;Multi character separator....
    n = 0		   ; Determine number of seperators in string.
    repeat begin
	pos = strpos (s, sep, spos)
	spos = pos + strlen(sep)
	n = n+1
    endrep until pos eq -1

    arr = strarr(n)	   ; Create result array
    spos = 0
    for i=0, n-1 do begin   ; Separate substrings
      pos = strpos (s, sep, spos)
      if pos ge 0 then arr(i) = strmid (s, spos, pos-spos) $
      else arr(i) = strmid(s, spos, strlen(s))
      spos = pos+strlen(sep)
   endfor
endelse

done:
if keyword_set(trim) then arr = strtrim(arr,2) $
else if keyword_set(remove) then arr = strcompress(arr, /REMOVE_ALL)
return, arr
end
; $Id: surfr.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro surfr,ax=ax, az=az	;Set up transformation for surface
;+
; NAME:
;	SURFR
;
; PURPOSE:
;	Set up 3D transformations.
;
;	This procedure duplicates the rotation, translation, and scaling 
;	features of the SURFACE routine.
;
; CATEGORY:
;	Graphics, 3D.
;
; CALLING SEQUENCE:
;	SURFR [, AX = ax]  [, AZ = az]
;
; INPUTS:
;	No plain parameters.
;
; KEYWORD PARAMETERS:
;	AX:	Angle of rotation about the X axis.  The default is 30 degrees.
;
;	AZ:	Angle of rotation about the Z axis.  The default is 30 degrees.
;
; OUTPUTS:
;	No explicit outputs.  Results are stored in !P.T.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	The 4 by 4 matrix, !P.T, the 3D transformation system variable, 
;	receives the homogeneous transformation matrix generated by this 
;	procedure.
;
; RESTRICTIONS:
;	Axonometric projections only.
;
; PROCEDURE:
;	1. Translate the unit cube so that the center (.5,.5,.5) is moved
;	   to the origin.
;
;	2. Rotate -90 degrees about the X axis to make the +Z
;	   axis of the data the +Y axis of the display.  The +Y data axis
;	   extends from the front of the display to the rear.
;
;	3. Rotate about the Y axis AZ degrees.  This rotation is 
;	   counterclockwise as seen from above the page.
;
;	4. Rotate about the X axis AX degrees, tilting the data
;	   toward the viewer.
;
;	5. Translate back to the origin and scale the data so
;	   that the data are still contained within the unit cube after
;	   transformation.  This step uses the user procedure SCALE3D.
;
; MODIFICATION HISTORY:
;	DMS, may, 1988.
;-
on_error,2                      ;Return to caller if an error occurs
if n_elements(ax) eq 0 then ax=30
if n_elements(az) eq 0 then az=30

t3d,/reset,tr=[-.5,-.5,-.5]	;Translate to center about origin
t3d,ro=[-90,az,0]		;rotate so +Z axis is now +Y
t3d,ro=[ax,0,0]
scale3d				;Scale it
end
; $Id: svdfit.pro,v 1.2 1995/04/07 23:50:26 dave Exp $

FUNCTION SVDFIT,X,Y,M, YFIT = yfit, WEIGHT = weight, CHISQ = chisq, $
	SINGULAR = sing, VARIANCE = var, COVAR = covar, Funct = funct
;+
; NAME:
;	SVDFIT
;
; PURPOSE:
;	Perform a general least squares fit with optional error estimates.
;
;	This version uses SVD.  A user-supplied function or a built-in
;	polynomial is fit to the data.
;
; CATEGORY:
;	Curve fitting.
;
; CALLING SEQUENCE:
;	Result = SVDFIT(X, Y, M)
;
; INPUTS:
;	X:	A vector representing the independent variable.
;
;	Y:	Dependent variable vector.  This vector should be same length 
;		as X.
;
;	M:	The number of coefficients in the fitting function.  For 
;		polynomials, M is equal to the degree of the polynomial + 1.
;
; OPTIONAL INPUTS:
;	Weight:	A vector of weights for Y(i).  This vector should be the same
;		length as X and Y.
;
;		If this parameter is ommitted, 1 is assumed.  The error for 
;		each term is weighted by Weight(i) when computing the fit.  
;		Frequently, Weight(i) = 1./Sigma(i) where Sigma is the 
;		measurement error or standard deviation of Y(i).
;
;	Funct:	A string that contains the name of an optional user-supplied 
;		basis function with M coefficients. If omitted, polynomials
;		are used.
;
;		The function is called:
;			R = FUNCT(X,M)
;		where X is an N element vector, and the function value is an 
;		(N, M) array of the N inputs, evaluated with the M basis 
;		functions.  M is analogous to the degree of the polynomial +1 
;		if the basis function is polynomials.  For example, see the 
;		function COSINES, in the IDL User Library, which returns a 
;		basis function of:
;			R(i,j) = cos(j*x(i)).
;		For more examples, see Numerical Recipes, page 519.
;
;		The basis function for polynomials, is R(i,j) = x(i)^j.
;		
; OUTPUTS:
;	SVDFIT returns a vector of M coefficients.
;
; OPTIONAL OUTPUT PARAMETERS:
;	NOTE:  In order for an optional keyword output parameter
;	to be returned, it must be defined before calling SVDFIT.
;	The value or structure doesn't matter.  For example:
;
;		YF = 1				;Define output variable yf.
;		C = SVDFIT(X, Y, M, YFIT = YF) 	;Do SVD, fitted Y vector is now
;						;returned in variable YF.
;
;	YFIT:	Vector of calculated Y's.
;
;	CHISQ:	Sum of squared errors multiplied by weights if weights
;		are specified.
;
;	COVAR:	Covariance matrix of the coefficients.
;
;    VARIANCE:	Sigma squared in estimate of each coeff(M).
;
;    SINGULAR:	The number of singular values returned.  This value should
;		be 0.  If not, the basis functions do not accurately
;		characterize the data.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; MODIFICATION HISTORY:
;	Adapted from SVDFIT, from the book Numerical Recipes, Press,
;	et. al., Page 518.
;	minor error corrected April, 1992 (J.Murthy)
;-
;	ON_ERROR,2		;RETURN TO CALLER IF ERROR
;	set variables
	THRESH = 1.0E-9		;Threshold used in editing singular values


	XX = X*1.		;BE SURE X IS FLOATING OR DOUBLE
	N = N_ELEMENTS(X) 	;SIZE
	IF N NE N_ELEMENTS(Y) THEN BEGIN ;SAME # OF DATA POINTS.
	  message, 'X and Y must have same # of elements.'
	  ENDIF

	if n_elements(weight) ne 0 then begin
		if n_elements(weight) ne n then begin
		  message, 'Weights have wrong number of elements.'
		  endif
	  b = y * weight	;Apply weights
	  endif else b = y	;No weights
;

	if n_elements(funct) eq 0 then begin ;Use polynomial?
	  A = FLTARR(N,M)			;COEFF MATRIX
	  if n_elements(weight) ne 0 then xx = float(weight) $
	  else xx = replicate(1.,n)	;Weights are 1.
	  for i=0,m-1 do begin		;Make design matrix
		a(0,i) = xx
		xx = xx * x
		endfor
	endif else begin		;Call user's function
		z = execute('a='+funct+'(x,m)')
		if z ne 1 then begin
			message, 'Error calling user fcn: ' + funct
			endif
		if n_elements(weight) ne 0 then $
		  a = a * (weight # replicate(1.,m)) ;apply wts to A
	endelse

	svd,a,w,u,v			;Do the svd

	good = where(w gt (max(w) * thresh), ng) ;Cutoff for sing values
	sing = m - ng		;# of singular values
	if sing ne 0 then begin
		message, 'Warning:' + strcompress(sing, /REMOVE) + $
			' singular values found.'
;modified J.M.
small=where(w le max(w)*thresh)
w(Small)=0
;
		if ng eq 0 then return,undefined
		endif
;modified J.M

svbksb,u,w,v,b,coeff
;
	wt = fltarr(m)
	wt(good)=1./w(good)

	if (n_elements(weight) eq 0) then xx=replicate(1.,n) else $
		xx=weight
	if (n_elements(yfit) ne 0) or (n_elements(chisq) ne 0) then begin
	  if n_elements(funct) eq 0 then yfit = poly(x,coeff) $
		else begin 
		yfit = fltarr(n)
		for i=0,m-1 do yfit = yfit + coeff(i) * a(*,i) $
			/ xx	;corrected J.M.
		endelse
	  endif

	if n_elements(chisq) ne 0 then begin	;Compute chisq?
		chisq = (y - yfit)
		if n_elements(weight) ne 0 then chisq = chisq * weight
		chisq = total(chisq ^ 2)
		endif

	wt = wt*wt		;Use squared w

	if n_elements(covar) ne 0 then begin	;Get covariance?
		covar = fltarr(m,m)
		for i=0,m-1 do for j=0,i do begin
		  s = 0.
		  for k=0,m-1 do s = s + wt(k) * v(i,k) * v(j,k)
		  covar(i,j) = s
		  covar(j,i) = s
		endfor
	  endif

	if n_elements(var) ne 0 then begin
		var = fltarr(m)
		for j=0,m-1 do for i=0,m-1 do $
		   var(j) = var(j) + v(j,i)^2 * wt(i)
		endif

	return,coeff
end


; $Id: swap_endian.pro,v 1.2 1993/10/06 17:44:20 doug Exp $
;
; Copyright (c) 1993, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	SWAP_ENDIAN
;
; PURPOSE:
;	This fucntion reverses the byte ordering of arbitrary scalars,
;	arrays or structures. It may be used, for example, to make little
;	endian numbers big, or big endian numbers little.
;
; CATEGORY:
;	Utility.
;
; CALLING SEQUENCE:
;	Result = SWAP_ENDIAN(A)
;
; INPUTS:
;	A:	The scalar, array, or structure to be swapped.
;
; OUTPUTS:
;	Result:	The same type and structure as the input, with the
;		pertinent bytes reversed.
;
; PROCEDURE:
;	Swap arrays and scalars directly using BYTEORDER.
;	Swap structures recursively.
;
; EXAMPLE:
;	A = SWAP_ENDIAN(A)  ;Reverses the "endianness" of A
;
; MODIFICATION HISTORY:
;	DMS, RSI, May, 1993.	Written.
;-

function swap_endian, in
t = in			;Make a copy
s = size(t)
case s(s(0)+1) of 	;Type code
1: return, t		;don't change bytes
2: byteorder, t, /SSWAP  ;shorts
3: byteorder, t, /LSWAP  ;Longs
4: byteorder, t, /LSWAP  ;single floats
5: BEGIN		;Double, swap longs & then swap even/odds
   n = n_elements(t)
   t = long(temporary(t), 0, 2 * n)  ;Cvt to longs
   byteorder, t, /LSWAP   ;swap each long
   t = t(lindgen(2*n) xor 1L)  ;swap pairs
   return, double(temporary(t), 0, n)  ;make double
   ENDCASE
6: byteorder, t, /LSWAP  ;Complex
7: return, t		;String
;8: for i=0, n_tags(t)-1 do t.(i) = swap_endian(t.(i))    ;Structure
ENDCASE
return, t
end

; $Id: t3d.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

pro t3d, translate = trans, scale = scale, rotate=rota, $
	reset = reset, perspective = pers, oblique = oblique, $
	xyexch = xyexch, xzexch = xzexch, yzexch = yzexch
;+
; NAME:
;	T3D
;
; PURPOSE:
;	Implement three-dimensional transforms.
;
;	This routine accumulates one or more sequences of translation,
;	scaling, rotation, perspective, and oblique transformations
;	and stores the result in !P.T, the 3D transformation system variable.
;	All the IDL graphic routines use this (4,4) matrix for output.
;
; CATEGORY:
;	Graphics.
;
; CALLING SEQUENCE:
;	T3D [, /RESET, TRANSLATE = T, SCALE = S, ROTATE = R, ... ]
;
; INPUTS:
;	No non-keyword inputs.
;
; KEYWORDS:
;	All inputs to T3D are in the form of keywords.  Any, all, or none of 
;	the following keywords can be present in a call to T3D.  The order of 
;	the input parameters does not matter.
;
;	The transformation specified by each keyword is performed in the
;	order of their descriptions below (e.g., if both TRANSLATE and
;	SCALE are specified, the translation is done first):
;
;	RESET:	Set this keyword to reset the transformation to the default 
;		identity matrix.
;
;    TRANSLATE:	A three-element vector of the translations in the X, Y, and Z 
;		directions.
;
;	SCALE:	A three-element vector of scale factors for the X, Y, and Z 
;		axes.
;
;       ROTATE:	A three-element vector of the rotations, in DEGREES, 
;		about the X, Y, and Z axes.  Rotations are performed in the
;		order of X, Y, and then Z.
;
;  PERSPECTIVE:	Perspective transformation.  This parameter is a scalar (p) 
;		that indicates the Z distance of the center of the projection.
;		Objects are projected into the XY plane at Z=0, and the "eye" 
;		is at point (0,0,p).
;
;      OBLIQUE:	A two-element vector of oblique projection parameters.
;		Points are projected onto the XY plane at Z=0 as follows:
;			x' = x + z(d COS(a)), and y' = y + z(d SIN(a)).
;		where OBLIQUE(0) = d, and OBLIQUE(1) = a.
;
;	XYEXCH:	Exchange the X and Y axes.
;
;	XZEXCH:	Exchange the X and Z axes.
;
;	YZEXCH:	Exchange the Y and Z axes.
;
; OUTPUTS:
;	The 4 by 4 transformation matrix !P.T is updated with the
;	resulting transformation.  !P.T3D is NOT set, so for the 
;	transformations to have effect you must set !P.T3D = 1 (or set
;	the T3D keyword in subsequent calls to graphics routines).
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	!P.T is changed.
;
; RESTRICTIONS:
;	This routine implements general rotations about the three axes.
;	The routines SURFACE and SHADE_SURF may only be used in conjunction 
;	with T3D rotations that project the Z axis in 3 dimensions to
;	a line parallel to the Y axis in 2 dimensions.
;
; PROCEDURE:
;	This program follows that of Foley & Van Dam, "Fundamentals of
;	Interactive Computer Graphics", Chapter 8, "Viewing in Three
;	Dimensions".
;
;	The matrix notation is reversed from the normal IDL sense,
;	i.e., here, the first subscript is the column, the second is the row,
;	in order to conform with the above reference.
;
;	A right-handed system is used.  Positive rotations are COUNTER-
;	CLOCKWISE when looking from a positive axis to the origin.
;
; EXAMPLES:
;	To reset the transformation, rotate 30 degs about the X axis
;	and do perspective transformation with the center of the projection
;	at Z = -1, X=0, and Y=0, enter:
;
;		T3D, /RESET, ROT = [ 30,0,0], PERS = 1.
;
;	Transformations may be cascaded, for example:
;
;		T3D, /RESET, TRANS = [-.5,-.5,0], ROT = [0,0,45]
;		T3D, TRANS = [.5,.5,0]
;
;	The first command resets, translates the point (.5,.5,0) to the 
;	center of the viewport, then rotates 45 degrees counterclockwise 
;	about the Z axis.  The second call to T3D moves the origin back to 
;	the center of the viewport.
;
; MODIFICATION HISTORY:
;	DMS, Nov, 1987.
;
;	DMS, June 1990.	Fixed bug that didn't scale or translate
;			matrices with perspective properly.
;-

on_error,2              ;Return to caller if an error occurs
id = fltarr(4,4)	;Make identity matrix
for i=0,3 do id(i,i)= 1.0

if n_elements(reset) eq 0 then reset = 0
if reset then a = id else a = !p.t ;Use either !P.T or identity

if n_elements(trans) ne 0 then begin	;Translate?
	ri = id
	for i=0,2 do ri(3,i) = trans(i)
	a = a # ri			;Apply translation
	endif

if n_elements(scale) ne 0 then begin	;Scale
	ri = id
	for i=0,2 do ri(i,i) = scale(i)
	a = a # ri			;Apply scale
	endif

if n_elements(rota) ne 0 then begin	;Rotate?
	ri = id(0:2,0:2)		;Use 3 by 3's
	r = ri
	sx = sin(rota/!radeg) & cx = cos(rota/!radeg)

	if rota(0) ne 0.0 then begin	;X Angle
		r(1,1) = cx(0) & r(1,2) = sx(0)
		r(2,1) = -sx(0) & r(2,2) = cx(0)
		endif
	if rota(1) ne 0 then begin	;Y angle
		rr = ri
		rr(0,0) = cx(1) & rr(0,2) = -sx(1)
		rr(2,0) = sx(1) & rr(2,2) = cx(1)
		r =  r # rr
		endif
	if rota(2) ne 0 then begin	;Z angle
		rr = ri
		rr(0,0)= cx(2) & rr(0,1) = sx(2)
		rr(1,0) = -sx(2) & rr(1,1) = cx(2)
		r =  r # rr
		endif
	rr = fltarr(4,4) 
	rr(0,0) = r & rr(3,3)=1.0
	a = a # rr			;Apply cumulative rot transforms
	endif

if n_elements(pers) ne 0 then begin	;Perspective?
	r = id
	r(2,3) = -1./pers
	a = a # r
	endif

if n_elements(oblique) ne 0 then begin  ;Oblique projection?
	r = id
	r(2,2)=0.0
	r(2,0) = oblique(0) * cos(oblique(1)/ !radeg)
	r(2,1) = oblique(0) * sin(oblique(1)/ !radeg)
	a = a # r
	endif

if keyword_set(xyexch) then exch = [0,1]	;Code to exchange axes.
if keyword_set(xzexch) then exch = [0,2]
if keyword_set(yzexch) then exch = [1,2]
if n_elements(exch) ne 0 then begin	;Exchange axes.
	t = a(exch(0),*)
	a(exch(0),0) = a(exch(1),*)
	a(exch(1),0) = t
	endif

!p.t =  a	;Save final projection
end
;$Id: t_cvf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       T_CVF
;
; PURPOSE:
;       This function computes the cutoff value (v) such that:
;                   Probability(X > v) = p
;       where X is a random variable from the Student's t distribution
;       with (df) degrees of freedom.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = t_cvf(P, DF)
;
; INPUTS:
;       P:    A non-negative scalar, in the interval [0.0, 1.0], of type
;             float or double that specifies the probability of occurance
;             or success.
;
;      DF:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the Student's t 
;             distribution.
;
; EXAMPLE:
;       Compute the cutoff value (v) such that Probability(X > v) = 0.025
;       from the Student's t distribution with (df = 5) degrees of freedom. 
;       The result should be 2.57058
;         result = t_cvf(0.025, 5)
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function t_cvf , a1, df
  
  on_error, 2  ;Return to caller if error occurs.

  a = a1 
  if a lt 0. or a gt 1. then message, $
    'p must be in the interval [0.0, 1.0]'
  if (a gt 0.5) then adjust = 1 else begin
    adjust = 0
    a = 1.0 - a 
  endelse
  if a1 eq 0 then return,  1.0e12
  if a1 eq 1 then return, -1.0e12

  case 1 of
    df eq 1: up = 100 > (100 * 0.005/a1)
    df eq 2: up = 10  > (10  * 0.005/a1)
    df gt 2 and df le 5:  up = 5 > (5 * 0.005/a1)
    df gt 5 and df le 14: up = 4 > (4 * 0.005/a1)
    else: up = 3 > (3 * 0.005/a1)				
  endcase

  while t_pdf(up, df) lt a do begin
    below = up
    up = 2 * up
  endwhile
  
  x = bisect_pdf([a, df], 't_pdf', up, 0)
  if (adjust) then return, -x   $
    else return, x
end

; $Id: tek_color.pro,v 1.3 1993/06/28 23:57:20 dave Exp $

pro tek_color, Start_index, Ncolors
;+
; NAME:
;	TEK_COLOR
;
; PURPOSE:
;	Load a color table similar to the default Tektronix 4115 color table.
;
; CATEGORY:
;	Graphics.
;
; CALLING SEQUENCE:
;	TEK_COLOR [[, Start_index] , Ncolors]
;
; INPUTS:
;	Start_index = optional starting index of palette.  If omitted,
;		use 0.
;	Ncolors = Number of colors to load.  32 is the max and the default.
; KEYWORD PARAMETERS:
;	None.
; OUTPUTS:
;	No explicit outputs.
; COMMON BLOCKS:
;	Colors.
; SIDE EFFECTS:
;	Ncolors color indices, starting at Start_index are loaded with
;	the Tektronix 4115 default color map.
; RESTRICTIONS:
;	None.
; PROCEDURE:
;	Just copy the colors.  This table is useful for the
;	display of graphics in that the colors are distinctive.
;
;	Basic colors are:  0 - black, 1 - white, 2 - red, 3 - green, 
;	4 - blue, 5 - cyan, 6 - magenta, 7 - yellow, 8 - orange, etc.
; MODIFICATION HISTORY:
;	DMS, Jan, 1989.
;	DMS, June, 1992.  Added colors common.
;	DMS, Apr, 1993, Added start_index and ncolors.
;-
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

if n_elements(ncolors) le 0 then ncolors = 32
if n_elements(start_index) le 0 then start_index = 0

if n_elements(r_orig) lt (ncolors + start_index) then begin
	r_orig = bytscl(indgen(256), max=!d.n_colors-1, min = 0)
	g_orig = r_orig
	b_orig = r_orig
	endif

;	The tektronix colors
r = bytscl([ 0,100,100,0,0,0,100,100,100,60,0,0,55,100,33,67, $
	100,75,45,17,25,50,75,100,67,40,17,17,17,45,75,90])
g = bytscl([ 0,100,0,100,0,100,0,100,50,83,100,50,0,0,33,67, $
	100,100,100,100,83,67,55,33,90,90,90,67,50,33,17,9])
b = bytscl([ 0,100,0,0,100,100,83,0,0,0,60,100,83,55,33,67, $
	33,45,60,75,83,83,83,90,45,55,67,90,100,100,100,100])

if ncolors lt 32 then begin		;Trim?
	r = r(0:ncolors-1)
	g = g(0:ncolors-1)
	b = b(0:ncolors-1)
	endif
s = start_index < (256 - ncolors)	;Never over top

r_orig(s) = r
g_orig(s) = g
b_orig(s) = b

tvlct, r_orig, g_orig, b_orig
r_curr = r_orig
g_curr = g_orig
b_curr = b_orig
end
;
;	Main program to run a demonstration program.
;
; This IDL program reads a script file, showing each line that is executed
;	and waiting a fixed period of time after each statement is executed.
; The first character of each line has the following significance:
;	;  for comment, line is printed and there is no wait.
;	@  to execute a new file.
;	All others, statement to be executed.
; You can run it with a different delay (default = 1.0 seconds) by setting
;	demo$delay to the desired period.
;
demo$line  = ''			;null string for input strings
demo$msg = 'IO Error occured'	;assume error
if n_elements(demo$delay) eq 0 then demo$delay = 1.0 ;wait between statements

if n_elements(demo$file) eq 0 then begin ;Define the default script
	demo$file = filepath('testdemo.demo',subdirectory='lib')
	qq = findfile(demo$file, count=i)
	if i eq 0 then begin	;Cant find script.
		print,"Can't find the demo script ",demo$file
		read,'Enter script file path name: ',demo$file
		endif
	endif

if n_elements(demo$rept) eq 0 then demo$rept = 1	;Def Repetition count

if n_elements(demo$color) eq 0 then begin	;defining config?
	demo$imagedir = filepath('',subdir=['examples', 'data'])
	if n_elements(findfile(demo$imagedir + '*.dat')) le 2 then begin
		print,'Cant find images on: ',demo$imagedir
		read,'Enter directory containing images: ', demo$imagedir
		endif
	case !version.os of
		'vms':
		'Win32':
		'MacOS':
		else: demo$imagedir=demo$imagedir+'/'
	endcase
	if !d.name eq 'SUN' then window,col=240	;don't use all colors
	if !d.name eq 'X' then window
	demo$color = 1		;always do images
endif				;config

on_ioerror, io_err	;Error branch
get_lun, demo$lun	;get a unit for program file
t0 = systime(1)		;Beginning time
wait_time = 0		;Time spent waiting


for demo$irept = 1L,demo$rept do begin	;main loop
	demo$done = 0			;set to quit
	openr,demo$lun,demo$file,err=i	;open program file
	if i ne 0 then begin		;Cant find file
file_err:	print," "
		print,"Can't find file ",demo$file," in current directory."
		print,"You should 'cd' to the directory containing this file and then run idl."
		print," Which is usually ",$
                        filepath('', subdir='lib')
		stop
		endif
	while not (eof(demo$lun) or demo$done) do begin	;statement loop
		readf,demo$lun,demo$line	;read statement
			;print comments without delay
		demo$char = strmid(demo$line,0,1) ;get 1st char
		case demo$char of
';':		 print,demo$line	;just print comments
'@':		 begin			;open new file
		  close,demo$lun
		  demo$file = strmid(demo$line,1,100) ;New file name
		  ofile = demo$file	;orig name
		  junk = findfile(demo$file,count=i)
			;Assume in library if not found
		  if i eq 0 then demo$file = filepath(demo$file, subdir='lib')
		  junk = findfile(demo$file,count=i)
		  if i eq 0 then begin
			print,"Cant find script file ",ofile
			read,"Enter pathname of script file ",demo$file
			endif
		  openr,demo$lun,demo$file,err=i
		  if i ne 0 then goto, file_err
		  endcase
else:		 begin		;execute statement
		  print, demo$line
		  demo$istat = execute(demo$line) ;execute it
		  wait, demo$delay	;allow it to sink in
		  wait_time = wait_time + 1
		  endcase
		endcase			
		endwhile		;eof
	close, demo$lun			;done with file
endfor			;execute loop

demo$msg = 'Done.'
t0 = fix(systime(1) - t0)	;Total time
wait_time = fix(wait_time * demo$delay)
print,'Times: Elapsed =',t0,', Waiting =',wait_time,', Executing =',$
	t0-wait_time
io_err:	stop, demo$msg
end
; $Id: test_hp.pro,v 1.2 1995/02/02 22:34:02 billo Exp $

;+
; NAME:		TEST_HP
; PURPOSE:	Generate HP-GL output to test features of the driver.
; CATEGORY:	Graphics Drivers.
; CALLING SEQUENCE:
;	TEST_HP
; INPUTS:
;	None.
; KEYWORD PARAMETERS:
;	EVASDROP - If this keyword *and* SMART are present, the output
;		is sent directly to the terminal with an evasdrop configuration
;		assummed.
;	SMART - If this keyword is present, it is assummed that the
;		plotter has a sheet feeder and is able to do
;		polygon filling. The HP7550A is an example of such
;		a plotter.
; OUTPUTS:
;	If the SMART keyword is present, a file named hpdemo.1 is created
;	containing 4 pages of plotter output. If SMART and EVASDROP are
;	present, the output goes to the terminal. Otherwise, three files
;	named hpdemo.1, hpdemo.2, and hpdemo.3 are created containing
;	one page of output each.
; RESTRICTIONS:
;	Expects the plotter to have 6 pens.
; SIDE EFFECTS:
;	Output file(s) are created.
; MODIFICATION HISTORY:
;	AB, July, 1989.
;-


pro hp_label_page
; Put a label at (0,0) identifying the page.

  common HPDEV,CURPAGE,SMART,EVASDROP

  on_error,2                    ;Return to caller if an error occurs
  if (smart) then s = 'HP7550A' else s = 'HP7475'
  xyouts, /norm, 0, -.04, 'HP-GL Demo (' + s + '). Page: ' + $
	strcompress(curpage,/remove_all)

end



pro hp_erase
; Some plotters have a sheet feeder, others can be put offline,
; and still others (e.g. HP7475) can only handle a page at a time.
; In order to accomodate the least common denominator, this routine
; is called to set up the next page. It closes the current file
; and opens a new one.

  common HPDEV,CURPAGE,SMART,EVASDROP

  on_error,2                    ;Return to caller if an error occurs
  curpage = curpage + 1

  if (EVASDROP or (SMART and (curpage ne 1))) then erase else begin
    DEVICE,/CLOSE
    DEVICE,filename='hpdemo.' + strcompress(curpage,/remove_all)
  endelse

end



pro hp_polyfill, title		; Polygon filling exercise
;	title - Main title for plot

on_error,2                       ;Return to caller if an error occurs
hp_erase
device,/landscape
plot,[0.0, 1.2],[0.0, 1.2],/nodata, title = title
for i = 0.0, 1.1, .2 do oplot, [0, 1.2 - i], [i, 1.2]
for i = 0.2, 1.1, .2 do oplot, [i, 1.2], [0, 1.2 - i]

; Determine the polygon regions
pregion_x = fltarr(5,12)
pregion_y = fltarr(5,12)
pregionlimit = intarr(12) + 4
pregionlimit(0) = 3
pregionlimit(11) = 3
; zeroth
pregion_x(0:3, 0) = [0.0, 0.2, 0.0, 0.0]
pregion_y(0:3, 0) = [1.0, 1.2, 1.2, 1.0]
; 11th
pregion_x(0:3, 11) = [1.0, 1.2, 1.2, 1.0]
pregion_y(0:3, 11) = [0.0, 0.0, 0.2, 0.0]
; 2 - 6
n = 1
for i = 0.2, 1.1, 0.2 do begin
  pregion_x(0:4, n) = [0., i + .2, i, 0., 0.]
  pregion_y(0:4, n) = [1.0-i, 1.2, 1.2, 1.2-i, 1.0-i]
  n = n + 1
endfor
; 7 - 11
for i = 0.2, 1.1, 0.2 do begin
  pregion_x(0:4, n) = [i, 1.2, 1.2, i-.2, i]
  pregion_y(0:4, n) = [0., 1.2-i, 1.4-i, 0., 0.]
  n = n + 1
endfor


; This vector indicates solid vs. line fill polyfilling
fill = intarr(12) + 1
fill(10:11) = 0

; The line attrbiutes if line filling
orient = [ 0.0, 45.0, 90.0, 0.0, 0.0, 45.0, 90.0, 0.0, 22.5, 45.0, 0.0, 0.0 ]
cross = fltarr(12)
cross(7) = [90.0, 112.5, 135.0]
spacing = fltarr(12) + 0.25
spacing(10:11) = 0.0
lstyle = [ 0, 0, 0, 1, 4, 4, 4, 0, 0, 0, 0, 0 ]
color = [2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3 ]

; Finally, draw the basic styles
for i = 0, 9 do begin
  polyfill, pregion_x(0:pregionlimit(i),i), pregion_y(0:pregionlimit(i),i), $
	    line_fill = fill(i), orient=orient(i), spacing=spacing(i), $
	    linestyle = lstyle(i), color=color(i)
  if (cross(i) ne 0) then begin
    polyfill, pregion_x(0:pregionlimit(i),i), pregion_y(0:pregionlimit(i),i), $
	      line_fill = fill(i), orient=cross(i), spacing=spacing(i), $
	      linestyle = lstyle(i), color=color(i)
  endif
endfor
for i = 10,11 do begin
  polyfill, pregion_x(0:pregionlimit(i),i), pregion_y(0:pregionlimit(i),i), $
	color=color(i)
endfor

hp_label_page
end


pro hp_lines_and_color
; Line styles and color exercise
on_error,2                    ;Return to caller if an error occurs
hp_erase
device,/landscape
a = findgen(100) - 10
plot, sin(a/5)/exp(a/50),/nodata,title='HP-GL Linestyle And Color Test'
for i = 0, 5 do begin
  a = a + 10
  c = i + 1
  y = .4 - .025 * i
  xyouts, /norm, .6, y, strcompress(string(i),/remove_all), color = c
  plots, /norm, [.62, .9], [y, y], color = c, linestyle = i
  oplot, sin(a/5)/exp(a/50), color = c, linestyle=i
endfor
hp_label_page
end


pro hp_hwtext		; Hardware Text exercise
on_error,2              ;Return to caller if an error occurs
device,/portrait
hp_erase
!p.font=0
xyouts,/norm,.1,.5,'Hardware Text Demonstration',align=.5,orien=90, $
	color=5, size=2.0
plots,/norm,[.05,.05, .125,.125, .05],[0, 1, 1, 0, 0],color=5

plots,/norm,[.5,.5],[0,1]
xyouts,/norm,.5,.7, 'Right Justified Text',align=1.0
xyouts,/norm,.5,.8, 'Centered Text',align=0.5
xyouts,/norm,.2,.3, '2.5 times normal size',size=2.5,orien=30
for i = 1, 4 do begin
  angle = i * 45
  str = '  ' + strcompress(string(angle),/remove_all) + ' degrees rotation'
  xyouts,/norm,.75, .25, str, color=i, orien=angle
  angle = angle + 180
  str = '  ' + strcompress(string(angle),/remove_all) + ' degrees rotation'
  xyouts,/norm,.75, .25, str, color=i, orien=angle
endfor
xyouts,/norm,.5,.9, 'Left Justified Text',align=0.0
!p.font=-1
hp_label_page
end


pro TEST_HP,SMART=KW_SMART,EVASDROP=KW_EVASDROP

common HPDEV,CURPAGE,SMART,EVASDROP
on_error,2                      ;Return to caller if an error occurs
CURPAGE = 0
SMART = (n_elements(KW_SMART) ne 0)
EVASDROP = (n_elements(KW_EVASDROP) ne 0) and SMART

current_d = !D.NAME		; Remember current device
set_plot,'hp'			; Switch to HP-GL
if (SMART) then DEVICE,/EJECT
if (EVASDROP) then DEVICE,/PLOTTER,file='/dev/tty'

hp_lines_and_color
hp_hwtext
hp_polyfill, 'Fill Patterns (Software)'
if (smart) then begin
  DEVICE,/POLYFILL
  hp_polyfill, 'Fill Patterns (Hardware)'
endif

set_plot, current_d		; Return to original device
end



; $Id: test_lj.pro,v 1.2 1995/02/02 22:34:31 billo Exp $

pro lj_loadct,sixteen=sixteen,eight=eight,four=four
;+
;
;   Procedure to load a group of 16, 8, or 4 (depending on keyword)
;	colors for the LJ-250 .  If 8 or fewer colors are to be defined, it is
;	assumed that 180 dpi resolution mode will be accessed.  In this case,
;	selection is from a pre-defined set of 8 colors. For 16 colors, any
;	combination of the 256 available LJ-250 colors may be selected.
;	The group chosen here is an attempt to select a table which uses
;	a variety of colors, while maintaining some gradation between color
;	intensities.
;
;-
if keyword_set(sixteen) then begin   ; 16 color specification is controllable
   ; [black,med_gray,lt_gray,lt_blue,royal_blue,blue,lavendar,
   ;  aqua,dark_green,green,lt_green,red,orange,yellow,lt_yellow,white]
   r=2.55*[4,15,43,38,2,5,20,2,4,12,37,53,72,89,89,90]
   g=2.55*[4,16,43,58,22,5,5,24,9,38,58,8,41,83,88,88]
   b=2.55*[8,18,45,78,64,31,29,41,11,18,49,14,13,13,54,85]
endif else if keyword_set(eight) then begin   ; 8 color selection is fixed
   ; [black,blue,yellow,magenta,cyan,red,green,white] ; Keep highest white
   r=[10,10,227,135,5,135,8,229]
   g=[10,10,212,13,56,20,66,224]
   b=[15,74,33,64,163,36,56,217]
endif else if keyword_set(four) then begin  ; Keep highest (background) white
   ; [black,blue,yellow,white]
   r=[10,10,227,229]
   g=[10,10,212,224]
   b=[15,74,33,217]
endif else print,'Unable to load lj color table; keyword expected.'
tvlct,r,g,b   ; Just loads the first 8 or 16 values, the rest are unchanged
return
end






pro lj_plot_test
;+
;
;   Procedure to test the basic plotting capabilities of the LJ-250 driver,
;     including color selection.
;
;-
olddevice=!d.name
set_plot,'lj'
device,depth=3,/land,xsize=8,ysize=6,/inches,file='lj_plot_test.lj'
old_pmulti=!p.multi
!p.multi=[4,2,2,0,0]
x=cos(6*(findgen(60)+1)/!radeg)
y=sin(6*(findgen(60)+1)/!radeg)
lj_loadct,/eight
plot,x,xtitle='!8Complex Italic',ytitle='!5Duplex Roman', $
  title='!12Dashed, Diamonds, Blue fill!3',linestyle=2,xrange=[0,60],xsty=1
oplot,y,linestyle=0,psym=-4  ; diamonds connected by solid line
index=[indgen(60),reverse(indgen(60))]
fillpts=[x,reverse(y)]
polyfill,index,fillpts,color=1   ; Should fill with blue
;polyfill,index,fillpts,spacing=0.8,orientation=135   ;Finish crosshatch
;
v=dist(100)
contour,v,levels=[10,20,30,40,50],c_labels=[1,1,1,1,1], $
  c_annotation=['!3Ten','!5Twenty','!6Thirty','!8Forty','!12Fifty!3'], $
  color=3,title='Five levels, Magenta'
;
v=dist(20)
surface,v,title='Simple Surface (no color)'
;
x=[0,0,4,4,0]
y=[0,2,2,0,0]
plot,x,y,/nodata,title='Test of PLOTS, red interior channel'
f=0.25
for i=1,4 do $
 plots,[0+i*f,0+i*f,4-i*f,4-i*f,0+i*f],[0+i*f,2-i*f,2-i*f,0+i*f,0+i*f],linest=i
xcoord=[0.1,3.9,3.9,0.1,0.1,0.2,3.8,3.8,0.2,0.2]
ycoord=[0.1,0.1,1.9,1.9,0.1,0.2,0.2,1.8,1.8,0.2]
polyfill,xcoord,ycoord,color=5  ; fill interior box with red
xyouts,0,0,'!6Unclipped, enlarged line at 45 degrees!3',/noclip, $
 size=1.6,orientation=45
;
!p.multi=old_pmulti
device,/close
set_plot,olddevice
return
end





pro lj_line_test
;+
;
;   Procedure to test the monochrome linestyle capability of the IDL 
;     LJ-250 driver.
;
;-
olddevice=!d.name
set_plot,'lj'
device,/land,depth=1,xsize=8,ysize=6,/inches,file='lj_line_test.lj'
plot,[0,1],[1,1],xstyle=1,xrange=[-0.2,1.2],ystyle=1,yrange=[0,2],/nodata, $
  xticks=14,xticklen=0.04,xtitle='14 Tick Intervals', $
  title='!8Test of Linestyles (Thick Lines)',ytitle='!8Avail. Styles!3'
for i=0,5 do begin
   oplot,[0,1],[0.1+(0.3*i),0.1+(0.3*i)],linestyle=i,thick=5.0
   xyouts,0.2,(0.2+(0.3*i)), $
    '!8Linestyle: '+string(i,'(i1)')
endfor
device,/close
set_plot,olddevice
return
end






pro lj_image_test
;+
;
;   Procedure to generate a series of TV images on a page, for an LJ-250 driver
;     test.  Monochrome (depth=1) is used, so that the dithering may be tested.
;
;-
olddevice=!d.name
set_plot,'lj'
v = bytscl(dist(600))
v=255-v*(v lt 180)
v(300,*)=0	;Dark line
v(*,300)=0	;Crossing dark line
device,resol=180,/land,xsize=10*180,ysize=6*180,xoffset=90,yoffset=180, $
       /pixels,/floyd,file='lj_image_test.lj',depth=1
tv,v,0,180   ; Move up 1 inch to allow room for label below
xyouts,200,90,/device,'!6Floyd'
device,/ordered
tv,v,690,180  ; Should be 1/2 inch gap between images
xyouts,890,90,/device,'Ordered'  ; Should continue to use !6 font
xyouts,640,180,/device,orientation=90,'1/2 inch gap here, 90 deg. rotation'
device,threshold=100              ; Should create small black swaths
;tv,v,1380,180  ; NOTE: this doesn't work because monochrome, & outside area
tv,v(0:399,*),1380,180   ;Deliberately avoid last 200 pixels to fit plot area
xyouts,(1580./1800.),(90./1080.),/normal,'!6Threshold!3'
xyouts,1330,780,/device,orientation=270,'270 deg. rot., last inch truncated'
device,/close
set_plot,olddevice
return
end





pro lj_resolution_test
;+
;
;   Procedure to test landscape and portrait graphics using both 90 and 180 dpi
;      LJ-250 resolutions.  A total of four output files will be generated.
;
;-
olddevice=!d.name
set_plot,'lj'
;
device,depth=4,resol=90,/land,xsize=20,ysize=12.5,xoffset=2.5,yoffset=2.5, $
  file='lj_90_land_cm.lj'
lj_loadct,/sixteen    ; Load first 16 indices in color table with known colors
surface,dist(20),title='!6land, 90res, 20x12.5cm, 2.5x2.5cm off, color Red!3',$
   color=11
device,/close
;
device,depth=4,resol=90,/port,xsize=6,ysize=4,xoffset=1,yoffset=1,/inches, $
  file='lj_90_port_inches.lj'
lj_loadct,/sixteen    ; Load first 16 indices in color table with known colors
surface,dist(20),title='!6port, 90res, 6x4in, 1x1 off, color Lt. Gray!3', $
   color=2
device,/close
;
device,depth=3,resol=180,/land,xsize=6,ysize=6,xoffset=2.0,yoffset=2.0, $
  /inches,file='lj_180_land_inches.lj'
lj_loadct,/eight    ; Load first 8 indices in color table with known colors
surface,dist(20),title='!6land, 180res, 6x6in, 2x2 off, color Cyan!3', $
   color=4
device,/close
;
device,depth=3,resol=180,/port,xsize=1080,ysize=720,xoffset=180,yoffset=360, $
  /pixels,file='lj_180_port_pixels.lj'
lj_loadct,/eight    ; Load first 8 indices in color table with known colors
surface,dist(20),title='!6port, 180res, 1080x720, 180x360 off, color Green!3',$
   color=6
device,/close
;
set_plot,olddevice
return
end




pro lj_depth_test
;+
;
;    Procedure to create two disk files illustrating different depth
;	(bit plane) renditions available on the LJ-250 .
;
;-
olddevice=!d.name
set_plot,'lj'
image=dist(360)
;
device,/port,resol=180,depth=3,xsize=3,ysize=3,/inches, $
   file='lj_depth123_test.lj'
lj_loadct,/eight   ; load THE 8 colors for use in 180 dpi mode
tv,bytscl(image,top=7),0,90
xyouts,0,40,'Depth 3, 180 dpi, Portrait',/device
;
device,/land,depth=2,resolution=90,xsize=5,ysize=5,/inches
lj_loadct,/four   ; load 4 colors for use in 180 dpi mode, 2 bit planes
tv,bytscl(image,top=3),180,90   ; Should cleanly truncate last 1 inch on right
xyouts,270,50,'Depth 2, 90 dpi, Land, last inch truncated',/device
xyouts,100,90,orient=90,'Right inch of image & text should be clipped',/device
;
device,/port,depth=1,resolution=180,xsize=3,ysize=3,/inches
tv,image,90,90
xyouts,90,40,'Depth 1, 180 dpi, Portrait, Mono',/device
device,/close
;
device,/land,resol=90,depth=4,file='lj_depth4_test.lj'
lj_loadct,/sixteen   ; Load 16 colors for use at 90 dpi resolution
image=bytscl(image,top=15)  ; Set image range to match 16 selected colors
for i=0b,15 do image(22*i,0)=bytarr(22,22)+i   ; Place color bar at bottom
tv,image,0,90
xyouts,90,45,'Depth 4, 90 dpi, Land, 16 color bar',/device
device,/close
set_plot,olddevice
return
end





pro lj_show3_test
;+
;
;   Procedure to create an output file for use on the LJ-250, which will
;     use the library procedure SHOW3.
;
;-
olddevice=!d.name
set_plot,'lj'
device,/land,depth=3,resolution=180,filename='lj_show3_test.lj'
ljlct   ; Test this routine to load the default palette
show3,dist(16)
device,/close
set_plot,olddevice
return
end






pro test_lj
;+
; NAME:
;	test_lj
; PURPOSE:
;	To exercise and demonstrate various aspects of the IDL driver for
;	   the Digital Equipment Corporation LJ-250 color printer.
; CATEGORY:
;	Graphics Drivers.
; CALLING SEQUENCE:
;	test_lj - Calls all test procedures, which may also be individually
;		   called:
;	lj_plot_test       - plot, contour, surface, plots, and vector fonts
;	lj_line_test       - test of linestyles
;	lj_image_test      - raster image output, for various dithering options
;	lj_resolution_test - test the two available resolutions (90 and 180dpi)
;	lj_depth_test      - test different depth (bit plane) renditions
;	lj_show3_test      - test the output using the SHOW3 procedure
; INPUTS:
;	None
; OPTIONAL INPUT PARAMETERS:
;	None
; KEYWORD PARAMETERS:
;	None
; OUTPUTS:
;	Creates LJ-250 compatible disk files: lj_plot_test.lj, lj_line_test.lj,
;          lj_image_test.lj, lj_90*.lj, lj_180*.lj, lj_depth123_test.lj,
;	   lj_depth4_test.lj, and lj_show3_test.lj .
;	   These files are not automatically submitted for printing; neither
;	   are they deleted automatically.
;	To print the .lj files properly on a VMS system, it is recommended
;	   that the /PASSALL qualifier be used with the PRINT command, to
;	   pass all file information directly to the lj printer.
; OPTIONAL OUTPUT PARAMETERS:
;	None
; COMMON BLOCKS:
;	None
; SIDE EFFECTS:
;	Many .lj files will be created and left in the default directory.
; RESTRICTIONS:
;	Designed for IDL Version 2; not compatible with VMS IDL Version 1.
; PROCEDURE:
;	The called routines try different permutations of the allowable
;	   keywords to the DEVICE procedure for the LJ-250.  Vector plotting,
;	   contour, line drawing, and surface plots are generated, as well 
;	   as a series of images which test all dithering methods.
;	   The two resolutions of the LJ-250 are tested, and specific color
;	   maps are used and tested.
; MODIFICATION HISTORY:
;	Written, August 1990, TJA (derived from demo_pcl)
;-
lj_plot_test
print,'File lj_plot_test.lj has been completed.'
lj_line_test
print,'File lj_line_test.lj has been completed.'
lj_image_test
print,'File lj_image_test.lj has been completed.'
lj_resolution_test
print,'Files lj_90*.lj, and lj_180*.lj have been completed.'
lj_depth_test
print,'Files lj_depth123_test.lj, and lj_depth4_test.lj have been completed.'
lj_show3_test
print,'File lj_show3_test.lj has been completed.'
print,' '
print,'*** All Finished ***'
return
end
; $Id: test_pcl.pro,v 1.2 1995/02/02 22:33:22 billo Exp $

pro pcl_plot_test
;+
;
;   Procedure to test the basic plotting capabilities of the pcl driver
;
;-
olddevice=!d.name
set_plot,'pcl'
device,/land,xsize=8,ysize=6,/inches,file='pcl_plot_test.pcl'
old_pmulti=!p.multi
!p.multi=[4,2,2,0,0]
x=cos(6*(findgen(60)+1)/!radeg)
y=sin(6*(findgen(60)+1)/!radeg)
plot,x,xtitle='!8Complex Italic',ytitle='!5Duplex Roman', $
  title='!12Dashed, Dotted, Diamonds!3',linestyle=2,xrange=[0,60],xsty=1
oplot,y,linestyle=0,psym=-4  ; diamonds connected by solid line
index=[indgen(60),reverse(indgen(60))]
fillpts=[x,reverse(y)]
polyfill,index,fillpts,spacing=0.8,orientation=45
polyfill,index,fillpts,spacing=0.8,orientation=135   ;Finish crosshatch
;
v=dist(100)
contour,v,levels=[10,20,30,40,50],c_labels=[1,1,1,1,1], $
  c_annotation=['!3Ten','!5Twenty','!6Thirty','!8Forty','!12Fifty!3']
;
v=dist(20)
surface,v
;
x=[0,0,4,4,0]
y=[0,2,2,0,0]
plot,x,y,/nodata,title='Test of PLOTS'
f=0.25
for i=1,4 do $
 plots,[0+i*f,0+i*f,4-i*f,4-i*f,0+i*f],[0+i*f,2-i*f,2-i*f,0+i*f,0+i*f],linest=i
xyouts,0,0,'!6Unclipped, enlarged line at 45 degrees!3',/noclip, $
 size=1.6,orientation=45
;
!p.multi=old_pmulti
device,/close
set_plot,olddevice
return
end





pro pcl_line_test
;+
;
;   Procedure to test the linestyle capability of the IDL pcl driver
;
;-
olddevice=!d.name
set_plot,'pcl'
device,/land,xsize=8,ysize=6,/inches,file='pcl_line_test.pcl'
plot,[0,1],[1,1],xstyle=1,xrange=[-0.2,1.2],ystyle=1,yrange=[0,2],/nodata, $
  xticks=14,xticklen=0.04,xtitle='14 Tick Intervals', $
  title='!8Test of Linestyles (Thick Lines)',ytitle='!8Avail. Styles!3'
for i=0,5 do begin
   oplot,[0,1],[0.1+(0.3*i),0.1+(0.3*i)],linestyle=i,thick=2.0
   xyouts,0.2,(0.2+(0.3*i)),'!8Linestyle: '+string(i,'(i1)')+'!3'
endfor
device,/close
set_plot,olddevice
return
end






pro pcl_image_test
;+
;
;   Procedure to generate a series of TV images on a page, for a pcl driver
;     test
;
;-
olddevice=!d.name
set_plot,'pcl'
v = bytscl(dist(900))
v=255-v*(v lt 115)
v(450,*)=0	;Dark line
v(*,450)=0	;Crossing dark line
device,resol=300,/land,xsize=2700,ysize=1000,xoffset=150,yoffset=150,/pixels, $
       /floyd,file='pcl_image_test.pcl'
tv,v,0
xyouts,300,920,/device,'!6Floyd'
device,/ordered
tv,v,1
xyouts,1200,920,/device,'Ordered'  ; Should continue to use !6 font
device,threshold=100               ; Should create small black swaths
tv,v,2
xyouts,(2100./2700.),(920./1000.),/normal,'!6Threshold!3'
device,/close
set_plot,olddevice
return
end





pro pcl_optimize_test
;+
;
;   Procedure to test landscape and portrait graphics using all three
;      optimization methods.  A total of six output files will be
;      generated.
;
;   Note: All three optimization levels (0,1,2) are used; since not all
;      devices will support all levels, garbage could result.
;
;-
olddevice=!d.name
set_plot,'pcl'
;
device,resol=75,/land,xsize=20,ysize=12.5,xoffset=2.5,yoffset=2.5, $
  optimize=2,file='pcl_opt2_land.pcl'
surface,dist(20),title='!6Opt=2, land, 75res, 20x12.5cm, 2.5x2.5cm off!3'
device,/close
;
device,resol=75,/land,xsize=450,ysize=300,xoffset=150,yoffset=150,/pixels, $
  optimize=1,file='pcl_opt1_land.pcl'
surface,dist(20),title='!6Opt=1, land, 75res, 450x300, 150x150 off!3'
device,/close
;
device,resol=100,/land,xsize=6,ysize=6,xoffset=2.0,yoffset=2.0,/inches, $
  optimize=0,file='pcl_opt0_land.pcl'
surface,dist(20),title='!6Opt=0, land, 100res, 6x6, 2x2 off!3'
device,/close
;
device,resol=150,/port,xsize=900,ysize=600,xoffset=150,yoffset=300,/pixels, $
  optimize=2,file='pcl_opt2_port.pcl'
surface,dist(20),title='!6Opt=2, port, 150res, 900x600, 150x300 off!3'
device,/close
;
device,resol=100,/port,xsize=4,ysize=6,xoffset=2.0,yoffset=2.0,/inches, $
  optimize=1,file='pcl_opt1_port.pcl'
surface,dist(20),title='!6Opt=1, port, 100res, 4x6, 2x2 off!3'
device,/close
;
device,resol=300,/port,xsize=6,ysize=6,xoffset=1.0,yoffset=1.0,/inches, $
  optimize=0,file='pcl_opt0_port.pcl'
surface,dist(20),title='!6Opt=0, port, 300res, 6x6, 1x1 off!3'
device,/close
;
set_plot,olddevice
return
end




pro test_pcl
;+
; NAME:
;	test_pcl
; PURPOSE:
;	To exercise and demonstrate various aspects of the HP PCL (Printer
;	Command Language) IDL driver.
; CATEGORY:
;	Graphics Drivers.
; CALLING SEQUENCE:
;	test_pcl - Calls all test procedures, which may also be individually
;		   called:
;	pcl_plot_test     - plot, contour, surface, plots, and vector fonts
;	pcl_line_test     - test of linestyles
;	pcl_image_test    - raster image output, with various dithering options
;	pcl_optimize_test - test file compression (optimization) methods
; INPUTS:
;	None
; OPTIONAL INPUT PARAMETERS:
;	None
; KEYWORD PARAMETERS:
;	None
; OUTPUTS:
;	Creates PCL disk files: pcl_plot_test.pcl, pcl_line_test.pcl,
;          pcl_image_test.pcl, pcl_opt*_land.pcl, and pcl_opt*_port.pcl.
;	   These files are not automatically submitted for printing; neither
;	   are they deleted automatically.
;	To print the .pcl files properly on a VMS system, it is recommended
;	   that the /PASSALL qualifier be used with the PRINT command, to
;	   pass all file information directly to the pcl printer.
; OPTIONAL OUTPUT PARAMETERS:
;	None
; COMMON BLOCKS:
;	None
; SIDE EFFECTS:
;	Many .pcl files will be created and left in the default directory.
; RESTRICTIONS:
;	Designed for IDL Version 2; not compatible with VMS IDL Version 1.
;
;	Procedure pcl_optimize_test uses all three (0,1,2) optimization
;	   levels; since some devices do not support all of these levels,
;	   garbage may result.  Specifically, the HP LaserJet II does
;	   not support optimization level 1; optimization 2 was primarily
;	   designed for it.  The HP DeskJet Plus supports all three
;	   optimizations.
; PROCEDURE:
;	The called routines try different permutations of the allowable
;	   keywords to the DEVICE procedure for PCL.  Vector plotting, contour,
;	   line drawing, and surface plots are generated, as well as a series
;	   of gray-scale images which test all dithering methods.  File
;	   optimization options are also tested.
; MODIFICATION HISTORY:
;	Written, June 1990, TJA
;-
pcl_plot_test
print,'File pcl_plot_test.pcl has been completed.'
pcl_line_test
print,'File pcl_line_test.pcl has been completed.'
pcl_image_test
print,'File pcl_image_test.pcl has been completed.'
pcl_optimize_test
print,'Files pcl_opt*_land.pcl, and pcl_opt*_port.pcl have been completed.'
print,' '
print,'*** All Finished ***'
return
end
; $Id: test_true.pro,v 1.1 1993/04/02 18:38:01 idl Exp $

;
;	Procedure to test IDL true color operation
;
function col,r,g,b	;Return the color index, given R, G, and B
return,r + 256L*(g + 256L*b)
end

pro test_true

Print, 'Demonstration of True Color / IDL'
Read,'Enter 1 for retained windows, 0 for non-retained: ',retain
window,xs=512,ys=800,retain=retain	;Make a window

print,'Ramps'
v = [0,0,0]
for ic=0,2 do begin
  for iy=0,255 do begin	;Fill with vectors of 3 colors
	v = intarr(3)
	v(ic) = iy
	y = ic*256 + iy
	plots,[0,511],[y,y],/dev,col=col(v(0),v(1),v(2))
	endfor
   empty
endfor

; Make an image and output to Channels 0 thru 3.  Channel 0 is all channels.
; Then, read it back and compare.
print,'Output an image to all channels, then r,g,b'
a=bytscl(dist(200))
for i=0,3 do begin
	tv,a,i*100,i*100,channel=i	;Write it
	empty
	b = tvrd(i*100,i*100,200,200,channel=i) ;Read it
	if total(abs(a-b)) ne 0 then $
	  print, "Read Compare Error, Channel ",i
	endfor

Print,'Color Table Manipulations'
for i=0,15 do begin loadct,i,/silent & wait,0.5  & end
r = indgen(256)
s = [1,1,1]
for j=0,2 do begin
	for i=0,256,2 do begin
	tvlct,shift(r,i*s(0)),shift(r,i*s(1)),shift(r,i*s(2))
	wait,.01
	endfor
  s(j) = -1
endfor
loadct,0,/silent

print,'Reading image'
close,1

fname = filepath('p077h3b.equ',subdir='images') ;the demo true color image 
qq = findfile(fname,count = i)
if i eq 0 then begin
	print,'Cant find true color image file ',fname
	print,'Skipping this part of the demo.'
	goto, no_file
	endif
openr,1, fname
a=bytarr(500,500,4)
readu,1,a
close,1

print,'Displaying Image'
erase
tv,a,true=3	;Output 1st three images of A into R,G,B
wait,1
tv,a(*,*,3),channel=2	;Output Fourth into Green channel

no_file: 
print,'Computing Hue-Saturation Image'
siz = 150
x = indgen(siz) # replicate(1,siz) - siz/2.
y = replicate(1,siz) # indgen(siz) - siz/2.
r = sqrt(x^2 + y^2) / (siz/2.) < 1 ;From 0 to 1.
hue = atan(y,x) * (180./!pi)
color_convert,hue, r, replicate(1.,siz,siz), r,g,b,/hsv_rgb

print,'Displaying Hue-Saturation Image'
tv,r,0,channel=1
tv,g,0,channel=2
tv,b,0,channel=3

print,'Done'
end
;
; $Id: text_alloc.pro,v 1.8 1995/01/20 19:41:01 tonyh Exp $
;
;  WidText
;   Widget Text class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  TEXT_Icon
;       Return the text toolbar icon
;
FUNCTION TEXT_Icon
  RETURN, [ $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 128b, 51b ], $
    [ 12b, 14b, 3b, 49b ], $
    [ 12b, 31b, 3b, 49b ], $
    [ 140b, 49b, 3b, 49b ], $
    [ 140b, 49b, 3b, 49b ], $
    [ 140b, 49b, 3b, 49b ], $
    [ 140b, 49b, 59b, 49b ], $
    [ 140b, 63b, 127b, 49b ], $
    [ 140b, 63b, 103b, 49b ], $
    [ 140b, 49b, 99b, 49b ], $
    [ 140b, 49b, 103b, 49b ], $
    [ 140b, 49b, 127b, 49b ], $
    [ 140b, 49b, 59b, 49b ], $
    [ 12b, 0b, 0b, 49b ], $
    [ 12b, 0b, 128b, 51b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 12b, 0b, 0b, 48b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 252b, 255b, 255b, 63b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ], $
    [ 0b, 0b, 0b, 0b ]  $
  ]
END

;
;  TEXT_Copy
;   Copy a text.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO TEXT_Copy, Ptr, Copy
    GenCopy, Ptr, Copy, /HASVALUE
END


;
;  TEXT_Destroy
;   Release resources for the given text widget.
;
PRO TEXT_Destroy, Ptr
    GenDestroy, Ptr, /HASVALUE
END


;
;  TEXT_Event
;   Event handling routine for text dialog
;
PRO TEXT_Event, Event

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'LITERAL':      BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 0
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=0
        END
    'CODEBASED':    BEGIN                   ; UNIMPLEMENTED (IDL v. Literal)
        Obj.ValueType       = 1
        WIDGET_CONTROL, Binfo.EditId, SENSITIVE=1
        END

    'MAINTEXT': WIDGET_CONTROL, Obj.Value1, SET_UVALUE=Event.Value
    'VALUETEXT':Obj.Value2      = Event.Value   ; UNIMPLEMENTED

    'FONT':     Obj.Font        = Event.Value
    'NAME':     Obj.Name        = Event.Value   ; Other
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'XSIZE':    Obj.XSize       = Event.Value   ; XY Stuff
    'YSIZE':    Obj.YSize       = Event.Value
    'XOFFSET':  Obj.XOffset     = Event.Value
    'YOFFSET':  Obj.YOffset     = Event.Value

    'ALLEV':    Obj.AllEvent    = 1 - Obj.AllEvent
    'EDIT':     Obj.TextEdit    = 1 - Obj.TextEdit
    'NO_NL':    Obj.TextNoNL    = 1 - Obj.TextNoNL
    'SCROLLS':  Obj.TextScrolls = 1 - Obj.TextScrolls

    'XFONT':    DoXFont, Obj, Binfo.Foci(1)

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  TEXT_Build
;   Create a dialog box a text object.  If ptr is nil then
;   create the object as well.
;
PRO TEXT_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    TEXT_Alloc, ParPtr, Ptr                 ; Allocate object if necessary
    MgrName = 'WE_TEXT' + STRTRIM(Ptr, 2)   ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    IF SmallScreen(0) NE 0 THEN BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg, $
                        X_SCROLL_SIZE=SmallScreen(0), $
                        Y_SCROLL_SIZE=SmallScreen(1) )
    ENDIF ELSE BEGIN
        Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    ENDELSE
    Foci    = LONARR(8)

    Base1   = WIDGET_BASE(Base, /COLUMN, /FRAME)
    ; Lab       = WIDGET_LABEL(Base1, VALUE="Basic Information")
    BuildEdit, Base1, Obj, _EditId
    Base2   = WIDGET_BASE(Base1,/ROW)
    Foci(0) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50,/STR)
    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
        XFontBtn    = WIDGET_BUTTON(Base2, VALUE="XFont", UVALUE="XFONT")

    Base2   = WIDGET_BASE(Base1, COLUMN=3, /NONEXCLUSIVE)
    Button  = WIDGET_BUTTON(Base2, VALUE='Text Editable', UVALUE='EDIT')
    IF Obj.TextEdit THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='No Auto-Newline', UVALUE='NO_NL')
    IF Obj.TextNoNL THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Add Scrollbars', UVALUE='SCROLLS')
    IF Obj.TextScrolls THEN WIDGET_CONTROL, Button, /SET_BUTTON
    Button  = WIDGET_BUTTON(Base2, VALUE='Process All Events',UVALUE='ALLEV')
    IF Obj.AllEvent THEN WIDGET_CONTROL, Button, /SET_BUTTON

    BuildOther, Base1, Obj, Foci, 1, /FRAME

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Text Appearance Controls")
    BuildXY, Base1, Obj, Foci, 4, /SIZE, /OFFSET
    BuildOkCancel, Base, Obj

    DlgInfo     = {             $
        Foci:       Foci,       $
        EditId:     _EditId,    $
        ObjPtr:     Ptr         $
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='TEXT_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  TEXT_Save
;   Save text information to a file.
;   Store value as well: If value is nil, make up a value.
;
;   FORMAT:
;       <text object>
;       <number of elements in value>
;       <value>
;
PRO TEXT_Save, Unit, Ptr
    GenWrite, Unit, Ptr, DEFAULT=''
END


;
;  TEXT_Restore
;   Read in a text object from a file
;
PRO TEXT_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "TEXT", 1
END


;
;  TEXT_Generate
;   Create a text object for previewing
;
PRO TEXT_Generate, Base, Ptr
  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    GetValue, Obj, Names, ""        ; Get Value (or use default)

    ;   Generate command string

    Cmd = 'Id = WIDGET_TEXT(Base,VALUE=Names'
    IF Obj.TextEdit THEN Cmd = Cmd + ',/EDITABLE'
    SAddCmd, Cmd, Obj.Font, 'FONT'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IF Obj.TextNoNL THEN Cmd = Cmd + ',/NO_NEWLINE'
    IF Obj.TextScrolls THEN Cmd = Cmd + ',/SCROLL'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'

    ;   Automatically make text big enough if the user
    ;   doesn't specify Ysize
    IF Obj.YSize EQ 0 THEN BEGIN
        Cmd = Cmd + ',YSIZE='+STRTRIM(N_ELEMENTS(Names),2)
    ENDIF

    Obj2Ptr, Obj, Ptr

    ; Create text widget by executing the command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create text ' + VarName(Ptr)
    ENDIF
END


;
;  TEXT_GenWid
;   Create IDL code for creating a text widget
;
PRO TEXT_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)                ; Get variable name of object
    Ptr2Obj, Ptr, Obj                   ; Get object info

    TextName    = 'TextVal' + STRTRIM(Ptr,2)    ; Create value name
    SaveStr, Unit, Ptr, Obj, TextName, ""       ; Generate value code

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_TEXT( ",A,",VALUE=",A)', $
        Name, Parent, TextName, /NO_EOL
    IF Obj.AllEvent THEN ISaveCmd, Unit, 1, "ALL_EVENTS"
    ISaveCmd, Unit, Obj.TextEdit, "EDITABLE"
    SSaveCmd, Unit, Obj.Font, "FONT"
    ISaveCmd, Unit, Obj.FrameSize, "FRAME"
    ISaveCmd, Unit, Obj.TextNoNL, "NO_NEWLINE"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    ISaveCmd, Unit, Obj.XOffset, "XOFFSET"
    ISaveCmd, Unit, Obj.XSize, "XSIZE"
    ISaveCmd, Unit, Obj.YOffset, "YOFFSET"
    ISaveCmd, Unit, Obj.YSize, "YSIZE"

    ;   Automatically make text big enough if the user
    ;   doesn't specify Ysize

    IF Obj.YSize EQ 0 THEN BEGIN
        GetValue, Obj, Names, ""
        ISaveCmd, Unit, N_ELEMENTS(Names), "YSIZE"
    ENDIF

    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END


;
;  TEXT_Alloc
;       Allocate a text object.  Don't allocate if ptr is non-nil
;
PRO TEXT_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr     = WIDGET_BASE(GROUP=TopDlg)    ; Make a pointer
    ValueId = WIDGET_BASE(GROUP=TopDlg)    ; Make a pointer for the value too

    ;   Make a Text object

    Obj     = {                 $
        WE_TEXT,                $
        Type:           'TEXT',$
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Save Dialog ID (need for Cut consistency)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; Title or object name
        FrameSize:      0,      $
        Font:           '',     $
        UValue:         '',     $
        Value1:         ValueId,$
        Value2:         '',     $ ; UNIMPLEMENTED and unused
        ValueType:      0,      $ ; UNIMPLEMENTED and unused
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        AllEvent:       0,      $ ; ALL_EVENT flag
        TextEdit:       1,      $ ; Set if can edit text (default TRUE)
        TextNoNL:       0,      $ ; Suppress auto Newline?
        TextScrolls:    0       $ ; Widget has scroll bars?
    }
    Obj2Ptr, Obj, Ptr                       ; Store object in pointer
END
; $Id: threed.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO 	THREED,A,SP, Title = title, Xtitle = Xtitle, Ytitle=Ytitle
;
;+
; NAME:
;	THREED
;
; PURPOSE:
;	Plot a 2D array as a pseudo 3D plot.
;
; CATEGORY:
;	J7 Plotting, graphics, multi-dimensional.
;
; CALLING SEQUENCE:
;	THREED, A [, Sp]
;
; INPUTS:
;	A:	The two-dimensional array to plot.
;
; OPTIONAL INPUT PARAMETERS:
;	Sp:	Spacing between plot lines.  If sp is omitted, the spacing 
;		is set to: 
;			(MAX(A)-MIN(A))/ROWS
;		If Sp is negative, hidden lines are not removed.
;
; KEYWORDS:
;	TITLE:	The main plot title.
;
;	XTITLE:	The X axis title.
;
;	YTITLE:	The Y axis title.
;
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A plot is produced on the currently selected graphics device.
;
; RESTRICTIONS:
;	Orientation of data is fixed.
;	Use the built-in procedure SURFACE for a more comprehensive surface 
;	plotting routine.
;
; PROCEDURE:
;	Straightforward.
;	A vector is maintained of the previous maximum plotted Y.
;	The PLOT and OPLOT procedures are used.
;
; MODIFICATION HISTORY:
;	VERSION 1.2, CREATED BY D. LINDLER, AUGUST 5,1980
;	VERSION 1.3, CREATED BY I. DEAN AHMAD, JANUARY 28, 1981
;	MODIFIED FOR VAX, DMS, SEPT, 1982.
;	Modified for Unix, DMS, 2/15/88.
;-
;
ON_ERROR,2		;RETURN TO CALLER IF ERROR
;
; DETERMINE SIZE OF A
;
IDEM=SIZE(A) & M=IDEM(1) & N=IDEM(2)
IF N_ELEMENTS(A) NE N*M THEN message, 'Sorry, not two dimensional.'
;
IF N_PARAMS(0) EQ 1 THEN SP = (MAX(A)-MIN(A))/FLOAT(N) ;FAKE SPACING
;
; DEFINE ARRAYS FOR THE X AND Y AXIS
;
X=INDGEN(M)
;
; DETERMINE PLOT SCALE
;
ADD = A+(INDGEN(M,N)/M)*ABS(SP) ;ARRAY + INCREMENT
YMAX=MAX(ADD)
YMIN=MIN(ADD)
!C=0		;DISABLE CURSOR
;
; DETERMINE IF HIDDEN LINES SHOULD BE PLOTTED
;
OLDY=ADD(*,0)
		;PLOT THE SCALE AND THE FIRST LINE
if n_elements(title) eq 0 then title = ''
if n_elements(xtitle) eq 0 then xtitle = ''
if n_elements(ytitle) eq 0 then ytitle = ''

PLOT,X,OLDY,xrange=[0.,m],yrange=[ymin,ymax], title=title, xtitle=xtitle,$
	ytitle=ytitle
;
  FOR I=1,N-1 DO BEGIN           ;LOOP TO PLOT EACH LINE
  Y=ADD(*,I)			;GET ROW
  IF SP GE 0. THEN Y=Y>OLDY     ; REMOVE HIDDEN LINES
  OPLOT,X,Y                    ;PLOT IT
  OLDY=Y
  END  ; FOR LOOP
RETURN
END  ;  THREED

; $Id: tiff_dump.pro,v 1.3 1995/02/02 18:31:47 dave Exp $

; Copyright (c) 1991-1993. Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;
function tiff_long,a,i,len=len	;return longword(s) from array a(i)
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs

   if n_elements(len) le 0 then len = 1
   if len gt 1 then result = long(a,i,len) $
   else result = long(a,i)
   if order then byteorder, result, /lswap
   return, result
end


function tiff_rational,a,i, len = len  	; return rational from array a(i)
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs

if n_elements(len) le 0 then len = 1
tmp = tiff_long(a, i, len = 2 * len)	;1st, cvt to longwords
if len gt 1 then begin
	subs = lindgen(len)
	rslt = float(tmp(subs*2)) / tmp(subs*2+1)
endif else rslt = float(tmp(0)) / tmp(1)
return, rslt
end

function tiff_int,a,i, len=len	;return unsigned long int from TIFF short int
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs
if n_elements(len) le 0 then len = 1
if len gt 1 then begin	;Array?
	result = fix(a,i,len)
	if order then byteorder, result, /sswap
	result = long(result)
	if min(result) lt 0 then begin	;Convert to unsigned from signed 16bit
	  negs = where(result lt 0)
	  result(negs) = 65535L + result(negs)
	  endif
endif else begin	;Scalar
	result = fix(a,i)
	if order then byteorder, result, /sswap
	if result lt 0 then result = 65535L + result
endelse
return, result
end


function tiff_byte, a,i,len=len	;return bytes from array a(i)
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs

   if n_elements(len) le 0 then len = 1
   if len gt 1 then result = a(i:i+len-1) $
   else result = a(i)
   return, result
end



pro tiff_basic		;Just load the stuff....
a=1
end

pro tiff_dump_field, index, lun	;Return contents of field index
common tiff_com, order, ifd, count

on_error,2                      ;Return to caller if an error occurs
TypeLen = [0, 1, 1, 2, 4, 8] ;lengths of tiff types, 0 is null type for indexin
TypeName = [ 'Undefined', 'Byte', 'Ascii', 'Short', 'Long', 'Rational' ]
TagIndex = [258,320, 301, 259,291,290,257,256,254,262,284,$
	317,296,278,277,279,273,282,283,315,306,316,270,271,272,305,274,255]
TagName = ['BitsPerSample', 'ColorMap', 'ColorResponseCurves','Compression',$
	'GrayResponseCurve','GrayResponseUnit','ImageLength','ImageWidth', $
	'NewSubfileType','PhotometricInterpretation','PlanarConfiguration',$
	'Predictor','ResolutionUnit','RowsPerStrip','SamplesPerPixel',$
	'StripByteCounts','StripOffsets','XResol','Yresol',$
	'Artist','DateTime','HostComputer','ImageDescription','Make','Model',$
	'Software','Orientation','SubfileType' ]

ent = ifd(index * 12: index * 12 + 11)  ;Extract the ifd
tag = tiff_int(ent, 0)
typ = tiff_int(ent, 2)
tname = TypeName(typ)
cnt = tiff_long(ent, 4)
if tag ge 32768L then begin		;Private tag?
  tag = 65536L + tag		;Unsigned long
  name = '<PrivateTag>'
endif else begin
  i = where(tag eq TagIndex, j)	;Look up name...
  if j gt 0 then name = TagName(i(0)) else name = '<NoName>'
  if (typ le 0) or (typ gt 5) then $
	message,'Illegal type code, ifd = '+string(index)
endelse

print,'*** ',name, ', tag = ', tag, ', ', tname, ', Count = ',cnt

nbytes = cnt * TypeLen(typ)
IF (nbytes GT 4) THEN BEGIN 	;value size > 4 bytes ?
        offset = tiff_long(ent, 8)	;field has offset to value location
        Point_Lun, lun, offset
        val = BytArr(nbytes) 	;buffer will hold value(s)
        Readu, lun, val
        CASE typ OF		;Ignore bytes, as there is nothing to do
	   1: i = 0		;Dummy
           2: val = String(val)		;tiff ascii type
           3: val = tiff_int(val,0, len = cnt)
	   4: val = tiff_long(val,0, len = cnt)
           5: val = tiff_rational(val,0, len = cnt)
	ENDCASE
	print, val(0: (cnt-1) < 15)
ENDIF ELSE BEGIN			;Scalar
        CASE typ OF
	   1: val = ent(8)
  	   2: val = string(ent(8:8+(cnt>1)-1))
	   3: val = tiff_int(ent,8)
	   4: val = tiff_long(ent,8)
        ENDCASE
	print,'  ', val
     ENDELSE
end


pro tiff_dump, file
;+
; NAME:
;	TIFF_DUMP
;
; PURPOSE:
;	Dump the Image File Directories of a TIFF File.  This procedure is
;	used mainly for debugging.
;
; CATEGORY:
;	Input/output.
;
; CALLING SEQUENCE:
;	TIFF_DUMP, Filename
;
; INPUTS:
;    Filename:	string containing the name of file to read.
;		The default extension is ".TIF".
;
; OUTPUTS:
;	All output is to the terminal.  Each TIFF Image File Directory
;	entry is printed.
;
; COMMON BLOCKS:
;	TIFF_COM.  Only for internal use.
;
; SIDE EFFECTS:
;	A file is read.
;
; RESTRICTIONS:
;	Not all of the tags have names encoded.
;	In particular, Facsimile, Document Storage and Retrieval,
;	and most no-longer recommended fields are not encoded.
;
; PROCEDURE:
;	The TIFF file Header and the IFD (Image File Directory) are read
;	and listed.
;
; MODIFICATION HISTORY:
;	DMS, Apr, 1991.  Extracted from TIFF_READ.
;	DMS, Dec, 1994.	 Added private tags
;
;-

common tiff_com, order, ifd, count

;on_error,2                      ;Return to caller if an error occurs

openr,lun,file, error = i, /GET_LUN, /BLOCK

if i lt 0 then begin ;OK?
	if lun gt 0 then free_lun,lun
	lun = -1
	message, 'Error opening ' + file
	endif

hdr = bytarr(8)			;Read the header
readu, lun, hdr

typ = string(hdr(0:1))		;Either MM or II
if (typ ne 'MM') and (typ ne 'II') then begin
	print,'TIFF_READ: File is not a Tiff file: ', file
	return
	endif
order = typ eq 'MM'  		;1 if Motorola 0 if Intel (LSB first or vax)
endian = byte(1,0,2)		;What endian is this?
endian = endian(0) eq 0		;1 for big endian, 0 for little
order = order xor endian	;1 to swap...

print,'Tiff File: byte order=',typ, ',  Version = ', tiff_int(hdr,2)

offs = tiff_long(hdr, 4)	;Offset to IFD

point_lun, lun, offs		;Read it

a = bytarr(2)			;Entry count array
readu, lun, a
count = tiff_int(a,0)		;count of entries
print,count, ' directory entries'
ifd = bytarr(count * 12)	;Array for IFD's
readu,lun, ifd			;read it

old_tag = 0			;Prev tag...
for i=0,count-1 do begin	;Print each directory entry
	tag = tiff_int(ifd, i*12)
	if tag lt old_tag then $
		print,'Error in TIFF file, Directory entries out of order ****'
	old_tag = tag
	tiff_dump_field, i, lun
	endfor	

free_lun, lun
lun = -1
end
; $Id: tiff_read.pro,v 1.5 1995/03/14 14:05:39 mattr Exp $

; Copyright (c) 1991-1993. Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	TIFF_READ
;
; PURPOSE:
;	Read 8-bit or 24-bit images in TIFF format.
;
; CATEGORY:
;	Input/output.
;
; CALLING SEQUENCE:
;   Result = TIFF_READ(Filename [,R, G, B], ORDER = order, PLANARCONFIG = pc)
;
; INPUTS:
;    Filename:	A string containing the name of file to read.
;		The default extension is ".TIF".
;
; OUTPUTS:
;	TIFF_READ returns a byte array containing the image data.  The 
;	dimensions of the result are the same as defined in the TIFF 
;	file: (Columns, Rows).
;
;	For TIFF images that are RGB interleaved by pixel, the output 
;	dimensions are (3, Cols, Rows).
;
;	For TIFF images that are RGB interleaved by image, on output
;	Planarconfig is set to 2, and the result is the integer value
;	zero.   In this case, three separate images are returned in
;	the R, G, and B output parameters.
;
; OPTIONAL OUTPUTS:
;     R, G, B:	Variables to hold the Red, Green, and Blue color vectors
;		extracted from TIFF Class P, Palette Color images.
;	For TIFF images that are RGB interleaved by image (Planarconfig
;	returned as 2) the R, G, and B variables each hold an image
;	with the dimensions (Columns, Rows).
;
; KEYWORDS:
;	The following keywords are used for output parameters only:
;
;	ORDER:	The order parameter from the TIFF File.  This parameter is
;		returned as 0 for images written bottom to top, and 1 for
;		images written top to bottom.  If the Orientation parameter 
;		does not appear in the TIFF file, an order of 1 is returned.
;
; PLANARCONFIG:	This parameter is returned as 1 for TIFF files that are
;		GrayScale, Palette, or RGB color interleaved by pixel.  
;		This parameter is returned as 2 for RGB color TIFF files 
;		interleaved by image.
;
; COMMON BLOCKS:
;	TIFF_COM.  Only for internal use.
;
; SIDE EFFECTS:
;	A file is read.
;
; RESTRICTIONS:
;	Handles TIFF classes G, P, and R.  One image per file.
;
; EXAMPLE:
;	Read the file "my.tiff" in the current directory into the variable
;	IMAGE, and save the color tables in the variables, R, G, and B by
;	entering:
;
;		IMAGE = TIFF_READ("my.tiff", R, G, B)
;
;	To view the image, load the new color table and display the image by
;	entering:
;
;		TVLCT, R, G, B
;		TV, IMAGE 
;
;
; MODIFICATION HISTORY:
;	DMS, Written for VMS in 1985.
;	DMS, April, 1991.  Rewrote and added class R and P images.
;	DMS, Jan, 1992.  Fixed bug for images without a RowsPerStrip field.
;       DJC, Nov, 1993.  Fixed doc header.
;	DMS, Dec, 1994.	 Fixed bug with private tags.
;	MWR, Mar, 1995.  Fixed bug when opening non-existent file.
;-

function tiff_long,a,i,len=len	;return longword(s) from array a(i)
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs

   if n_elements(len) le 0 then len = 1
   if len gt 1 then result = long(a,i,len) $
   else result = long(a,i)
   if order then byteorder, result, /lswap
   return, result
end


function tiff_rational,a,i, len = len  	; return rational from array a(i)
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs

if n_elements(len) le 0 then len = 1
tmp = tiff_long(a, i, len = 2 * len)	;1st, cvt to longwords
if len gt 1 then begin
	subs = lindgen(len)
	rslt = float(tmp(subs*2)) / tmp(subs*2+1)
endif else rslt = float(tmp(0)) / tmp(1)
return, rslt
end

function tiff_int,a,i, len=len	;return unsigned long int from TIFF short int
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs
if n_elements(len) le 0 then len = 1
if len gt 1 then begin	;Array?
	result = fix(a,i,len)
	if order then byteorder, result, /sswap
	result = long(result)
	if min(result) lt 0 then begin	;Convert to unsigned from signed 16bit
	  negs = where(result lt 0)
	  result(negs) = 65535L + result(negs)
	  endif
endif else begin	;Scalar
	result = fix(a,i)
	if order then byteorder, result, /sswap
	if result lt 0 then result = 65535L + result
endelse
return, result
end

function tiff_byte, a,i,len=len	;return bytes from array a(i)
common tiff_com, order, ifd, count

on_error,2              ;Return to caller if an error occurs

   if n_elements(len) le 0 then len = 1
   if len gt 1 then result = a(i:i+len-1) $
   else result = a(i)
   return, result
end

function tiff_read_field, index, tag, lun  ;Return contents of field index
; On output, tag = tiff tag index.
;
common tiff_com, order, ifd, count


on_error,2                      ;Return to caller if an error occurs
TypeLen = [0, 1, 1, 2, 4, 8] ;lengths of tiff types, 0 is null type for indexin

ent = ifd(index * 12: index * 12 + 11)  ;Extract the ifd
tag = tiff_int(ent, 0)		;Tiff tag index
typ = tiff_int(ent, 2)		;Tiff data type
cnt = tiff_long(ent, 4)		;# of elements
nbytes = cnt * TypeLen(typ)	;Size of tag field
IF (nbytes GT 4) THEN BEGIN 	;value size > 4 bytes ?
        offset = tiff_long(ent, 8)	;field has offset to value location
        Point_Lun, lun, offset
        val = BytArr(nbytes) 	;buffer will hold value(s)
        Readu, lun, val
        CASE typ OF		;Ignore bytes, as there is nothing to do
	   1: i = 0		;Dummy
           2: val = String(val)		;tiff ascii type
           3: val = tiff_int(val,0, len = cnt)
	   4: val = tiff_long(val,0, len = cnt)
           5: val = tiff_rational(val,0, len = cnt)
	ENDCASE
ENDIF ELSE BEGIN			;Scalar...
        CASE typ OF
	   1: val = ent(8)
  	   2: val = string(ent(8:8+(cnt>1)-1))
	   3: val = tiff_int(ent,8)
	   4: val = tiff_long(ent,8)
        ENDCASE
     ENDELSE
return, val
end




function tiff_read, file, r, g, b, order = ord, PlanarConfig = PC
common tiff_com, order, ifd, count


on_error,2                      ;Return to caller if an error occurs

openr,lun,file, error = i, /GET_LUN, /BLOCK
if i lt 0 then begin ;OK?
	if keyword_set(lun) then free_lun,lun
	lun = -1
	message, 'Unable to open file: ' + file
	endif

hdr = bytarr(8)			;Read the header
readu, lun, hdr

typ = string(hdr(0:1))		;Either MM or II
if (typ ne 'MM') and (typ ne 'II') then begin
	message,'TIFF_READ: File is not a Tiff file: ' + string(file)
	return,0
	endif
order = typ eq 'MM'  		;1 if Motorola 0 if Intel (LSB first or vax)
endian = byte(1,0,2)		;What endian is this?
endian = endian(0) eq 0		;1 for big endian, 0 for little
order = order xor endian	;1 to swap...

; print,'Tiff File: byte order=',typ, ',  Version = ', tiff_int(hdr,2)

offs = tiff_long(hdr, 4)	;Offset to IFD

point_lun, lun, offs		;Read it

a = bytarr(2)			;Entry count array
readu, lun, a
count = tiff_int(a,0)		;count of entries
; print,count, ' directory entries'
ifd = bytarr(count * 12)	;Array for IFD's
readu, lun, ifd			;read it

;	Insert default values:
compression = 1
bits_sample = 1
ord = 1
samples_pixel = 1L
pc = 1
photo = 1
rows_strip = 'fffffff'xl	;Essentially infinity

for i=0,count-1 do begin	;Print each directory entry
	value = tiff_read_field(i, tag, lun)  ;Get each parameter
	case tag of		;Decode the tag fields, other tags could be added
256:	width = value
257:	length = value
258:	bits_sample = value
259:	compression = value
262:	Photo = value
273:	StripOff = value
274:	Ord = value
277:	samples_pixel = long(value)
278:	Rows_strip = value
279:	Strip_bytes = value
284:	PC = value
320:	ColorMap = value
else:   value = 0		;Throw it away
	endcase
endfor	

;	Do a cursory amount of checking:
	if bits_sample(0) ne 8 then $
		message,'TIFF_READ: bits_sample must be 8'
	if compression ne 1 then $
		message,'TIFF_READ: Images must be un-compressed'
;	if photo ge 4 then $
;		message,'TIFF_READ: Photometric Interpretation must be 0 to 3.'
	if (pc eq 2) and (samples_pixel ne 3) then $
		message,'TIFF_READ: RGB data must have 3 SamplesPerPlane'
	
nbytes = width * long(length)
strips_image = (length + rows_strip -1) / rows_strip


if pc eq 1 then begin	;Planar Config...., simple
	if samples_pixel eq 1 then image = bytarr(width, length, /nozero) $
	else image = bytarr(samples_pixel, width, length, /nozero)
	if strips_image eq 1 then begin	;Quick way?
		point_lun, lun, stripoff(0)   ;1st image data
		readu, lun, image 	;Yes....
	endif else begin		;1 strip at a time....
		tmp = 0b
		for i=0L, strips_image-1 do begin
			point_lun, lun, stripoff(i)
			if n_elements(tmp) ne Strip_bytes(i) Then $
			    tmp = bytarr(Strip_bytes(i), /nozero)
			readu, lun, tmp
			image(samples_pixel * width * i * rows_strip) = tmp
			endfor
	endelse
	if n_elements(ColorMap) gt 0 then begin	;Color map present?
	   if n_elements(ColorMap) eq 768 then begin
		r = ishft(ColorMap(0:255), -8) ;Remove and scale
		g = ishft(ColorMap(256:511), -8)
		b = ishft(ColorMap(512:767), -8)
	    endif else message,'TIFF_READ: color map has wrong # of elements'
	endif
endif else begin			;PC = 2, = interleaved by image
	l = 0
	tmp = 0b
	for band = 0,2 do begin		;Read each image
		image = bytarr(width, length, /nozero)
		for i=0L, strips_image-1 do begin
			point_lun, lun, stripoff(l)
			if n_elements(tmp) ne Strip_bytes(l) then $
			  tmp = bytarr(strip_bytes(l), /nozero)
			readu, lun, tmp
			image(width * i * rows_strip) = tmp
			l = l + 1
			endfor		;Each strip
		case band of
		0: r = image
		1: g = image
		2: b = image
		endcase
		image = 0
	endfor				;Each band
endelse					;PC = 2
	
free_lun, lun
return, image
end
; $Id: tiff_write.pro,v 1.6 1995/02/02 18:31:47 dave Exp $

; Copyright (c) 1991-1993. Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	TIFF_WRITE
;
; PURPOSE:
;	Write 8-bit or 24-bit images in TIFF format.
;
; CATEGORY:
;	Input/output.
;
; CALLING SEQUENCE:
;	TIFF_WRITE, Filename, Array [, Orientation], $
;		    [RED = R, GREEN = G, BLUE = B, PLANARCONFIG = pc, $
;		    XRESOL = xresol, YRESOL = yresol]
;
; INPUTS:
;     Filename:	A string containing the name of file to create. 
;
;	Array:	The image data to be written.  If not already a byte array,
;		it is made a byte array.  Array may be either an
;		(n, m) array for Grayscale or Palette classes, or
;		a (3, n, m) array for RGB full color, interleaved
;		by image.  If the PLANARCONFIG keyword (see below) is set
;		to 2 then the Array parameter is ignored (and may be
;		omitted). See PROCEDURE below for more information on
;		TIFF classes. 
;
; OPTIONAL INPUT PARAMETERS:
; Orientation:	This parameter should be 0 if the image is stored from bottom 
;		to top (the default).  For images stored from top to bottom, 
;		this parameter should be 1.  
;
;		WARNING:  Not all TIFF readers are capable of reversing the 
;		scan line order.  If in doubt, first convert the image
;		to top to bottom order (use the IDL REVERSE() function), and 
;		set Orientation to 1.
;
; OPTIONAL KEYWORD PARAMETERS:
; RED, GREEN, BLUE:
;		The color table vectors, scaled from 0 to 255 in the case of 
;		a Class P, Palette color image.  If, PlanarConfig is 2, these 
;		parameters must contain the 3 color component image parameters.
;
; PLANARCONFIG:	Set this parameter to 2 if writing an RGB image that is 
;		contained in three separate images (color planes), specified
;		in the RED, GREEN, and BLUE parameters.  Otherwise, omit
;		this parameter (or set it to 1).
;
;	XRESOL:	The horizontal resolution, in pixels per inch.  The default
;		is 100.
; 
;	YRESOL:	The vertical resolution, in pixels per inch.  The default
;		is 100.
;
; OUTPUTS:
;	No explicit inputs.
;
; COMMON BLOCKS:
;	TIFF_COM.  Only for internal use.
;
; SIDE EFFECTS:
;	A file is created and written.
;
; RESTRICTIONS:
;	This procedure writes images in a single strip, or 3 strips when 
;	PLANARCONFIG is set to 2.  This procedure may cause readers with 
;	memory limitations problems.
;
; PROCEDURE/EXAMPLES:
;	Four types of TIFF files can be written:
;
;	TIFF Class G, Grayscale.  Array contains the 8-bit image array.
;	A value of 0 is black, 255 is white.  The Red, Green, and Blue
;	keywords are omitted.  Example:
;		TIFF_WRITE, 'a.tiff', Array
;
;	TIFF Class P, Palette Color.  Array contains the 8-bit image array.  
;	The keyword parameters RED, GREEN, and BLUE contain the color tables, 
;	which can have up to 256 elements, scaled from 0 to 255.  Example:
;		TIFF_WRITE, 'a.tiff', Array, RED = r, GREEN = g, BLUE = b
;
;	TIFF Class R, RGB Full Color, color interleaved by pixel.
;	Array contains the byte data, and is dimensioned (3, cols, rows).
;	Example:
;		TIFF_WRITE, 'a.tiff', Array
;
;	TIFF Class R, RGB Full Color, color interleaved by image.
;	Input is three separate images, provided in the keyword
;	parameters RED, GREEN, and BLUE.  The input parameter "Array"
;	is ignored.  The keyword PLANARCONFIG must be set to 2 in this case.
;	Example:
;		TIFF_WRITE, 'a.tiff', RED = r, GREEN = g, BLUE = b, PLAN = 2
;
; MODIFICATION HISTORY:
;	DMS, Written for VMS in 1985.
;
;	DMS, April, 1991.  Rewrote and added class R and P images.
;	DJC, Nov, 1993.  Fixed doc header.
;-
pro tiff_add_tag, lun, tag, value  ;Add a tag to the Image File Directory (IFD)
common tiff_com, order, ifd, count

s = size(value)		;Determine type from parameter
typ = s(s(0)+1)		;IDL type code
tiff_typ = ([ 0, 1, 3, 4, 5, 0, 0, 2])(typ)  ;Tiff types vs IDL
TypeLen = ([0, 1, 1, 2, 4, 8])(tiff_typ)

n = s(s(0)+2)		; # of elements
offset = count * 12 + 2	; Offset into ifd
ifd(offset) =   byte(fix(tag),0,2)	;integer tag
ifd(offset+2) = byte(tiff_typ, 0, 2)	;data type
ifd(offset+4) = byte(n,0,4)		;count
nbytes = n * TypeLen

if nbytes le 4 then begin	;Simple case
	ifd(offset+8) = byte(value,0,nbytes)
endif else begin		;Array, written to file
	point_lun, -lun, pos   ;Get file posit
	ifd(offset+8) = byte(pos, 0, 4)  ;Set IFD ^ pointer
	if typ ne 4 then writeu, lun, value $	;Write the data
	else begin		;Write floating
		s = lonarr(n * 2)
		s(indgen(n)*2) = value * 10000.  ;Arbritrary scale of 10000
		s(indgen(n)*2+1) = 10000
		writeu,lun, s
	endelse
endelse
count = count + 1
end


pro tiff_write, filename, array, orientation, $
	Red=red, Green=green, Blue=blue, PlanarConfig = PlanarConfig, $
	Xresol = Xresol, Yresol = Yresol
common tiff_com, order, ifd, count

on_error,2                      ;Return to caller if an error occurs

if n_elements(array) gt 0 then array = byte(array) ;Make sure it's byte
s = size(array)
if n_elements(PlanarConfig) le 0 then PlanarConfig = 1

color = 0			;True if palette color with tables

if s(0) eq 3 then begin		;True color image?
	photo = 2
	if s(1) ne 3 then message,'For true-color, image must be (3,n,m)'
	cols = s(2)
	rows = s(3)
	samples = 3		;3 samples / pixel
endif else if PlanarConfig eq 2 then begin   ;RGB with separate sample planes
	photo = 2
	s = size(red)		;Take image param from r,g,b
	if s(0) ne 2 then message, 'Parameter must be 2D'
	cols = s(1)
	rows = s(2)
	samples = 3
	if (n_elements(red) ne n_elements(green)) or $
	    (n_elements(red) ne n_elements(blue)) then $
		message,'Image components must have same size'
endif else begin		;Assume must be palette
	if s(0) ne 2 then message, 'Parameter must be 2D'
	cols = s(1)
	rows = s(2)
	samples = 1
	if (n_elements(red) ne n_elements(green)) or $
	    (n_elements(red) ne n_elements(blue)) then $
			message,'Color tables must have same size'
	color = N_elements(red) GT 0
	if color then photo = 3 else photo = 1
endelse

if n_elements(orientation) eq 0 then orientation = 0

if (!version.os EQ 'MacOS') then begin
openw, lun, filename, /BLOCK, /GET_LUN, MACTYPE = "TIFF"
endif else begin
openw, lun, filename, /BLOCK, /GET_LUN
endelse
header = bytarr(8)		;The Tiff header

tst = byte(1,0,2)		;Which endian???
if tst(0) eq 1 then header(0) = byte("II") $	;Intel order
   else header(0) = byte("MM")	;Motorola order

header(2) = byte(42,0,2)	;Version = 42

writeu, lun, header

ifd = bytarr(512)		;Image file directory
count = 0			;# of tags

tiff_add_tag, lun, 254, 0L		;New Subfile type
tiff_add_tag, lun, 256, long(cols)	;Image width
tiff_add_tag, lun, 257, long(rows)	;Image height

tiff_add_tag, lun, 258, replicate(8,samples)  ;bit/sample
tiff_add_tag, lun, 259, 1		;No compression
tiff_add_tag, lun, 262, photo	;Photometric Interpretation
nbytes = rows * cols		;Bytes / plane

; Write image data......
point_lun, -lun, faddr		;Get current file position
if PlanarConfig eq 2 then begin ; write R,G,B in separate planes
	tiff_add_tag, lun, 273, faddr + [0,1,2] * nbytes + 12  ;Strip offsets
	writeu,lun, byte(red)
	writeu,lun, byte(green)
	writeu,lun, byte(blue)
endif else begin		;Write image as one chunk
	tiff_add_tag, lun,273, faddr  ;Strip offset
	writeu, lun, byte(array)
endelse

tiff_add_tag, lun, 274, fix(4 - 3 * (orientation and 1)) ;Orientation  
tiff_add_tag, lun, 277, samples	;Samples / pixel
tiff_add_tag, lun, 278, rows		;Rows / strip

if PlanarConfig eq 2 then  t = replicate(nbytes, samples) $ ;Strip byte cnts
else t = samples * nbytes
tiff_add_tag, lun, 279,  t  ;Strip byte counts 

if n_elements(xresol) le 0 then xresol = 100.
if n_elements(yresol) le 0 then yresol = 100.
tiff_add_tag, lun, 282, float(xresol)		;Xresolution
tiff_add_tag, lun, 283, float(yresol)		;... and Yresolution
tiff_add_tag, lun, 284, PlanarConfig ;PlanarConfig

IF (photo EQ 3) THEN BEGIN	;Add colormap?
	rgb_array = intarr(768)	;Make the color maps
	rgb_array(0) = ishft(fix(red),8)  ;Scale up to 65K max
	rgb_array(256) = ishft(fix(green), 8)
	rgb_array(512) = ishft(fix(blue),8)
	tiff_add_tag, lun, 320, rgb_array
	ENDIF


point_lun, -lun, faddr		;Write IFD at and, get addr
ifd(0) = byte(count,0,2)	;Insert count
writeu, lun, ifd(0: count*12+5) ;Write IFD followed by 4 zero bytes

point_lun, lun, 0		;Rewind to header
header(4) = byte(faddr,0,4)	;Write ifd offset
writeu, lun, header		;And save it

free_lun,lun			;Done
end
		

; $Id: time_test.pro,v 1.5 1995/01/28 20:52:41 dave Exp $

;	Time test procedure.. Print values of commonly used timings.
pro timer, name	;Print timing information, name = descriptive
;	string for message.

common timer_common, time, lunno, total_time, geom_time, ntest

t = systime(1)		;Get current time.
ntest = ntest + 1
tt = t - time
total_time = total_time + tt
geom_time = geom_time + alog(tt)
printf, lunno, ntest, float(tt), ' ',name
time = t
end

pro init_time,file	;Initialize timer, file = optional param
;	containing name of file to write info to
common timer_common, time, lunno, total_time, geom_time, ntest

on_error,2              ;Return to caller if an error occurs
total_time = 0.
geom_time = 0.
ntest = 0
if n_params(0) ge 1 then begin
	get_lun, lunno	;Get a lun
	openw,lunno,file
  end else lunno = -1	;Set to stdout
time = systime(1)
return
end



pro time_compare, file1, file2, outfile	;Compare results of two time tests...
; File1 = file name containing output of first time test.
; File2 = file name containing output of 2nd time test.
; Outfile = filename for output. If omitted, only output to log window.
; A report is printed..
;
openr,lun1, /get, file1
openr,lun2, /get, file2
nmax = 100			;Max number of tests.
t1 = fltarr(nmax)
t2 = fltarr(nmax)
names = strarr(nmax)
for i=0, nmax-1 do begin	;Read times
    a1 = '' & a2 = ''
    readf, lun1, a1
    readf, lun2, a2
    if strpos(a1, 'Total Time') ge 0 then goto, done_reading
    a1 = strcompress(a1)
    j = strpos(a1, ' ', 1)
    t1(i) = float(strmid(a1, j+1, 100))
    j = strpos(a1, ' ', j+1)
    names(i) = strmid(a1, j+1, 100)
    a1 = strcompress(a2)	;2nd time
    j = strpos(a1, ' ', 1)
    t2(i) = float(strmid(a1, j+1, 100))
    endfor

done_reading: free_lun, lun1, lun2
t1 = t1(0:i)
t2 = t2(0:i)
names = names(0:i)
t1(i) = total(t1)
t2(i) = total(t2)
r = t1/t2
names(i) = 'Total Time'
luns = -1
if n_elements(outfile) gt 0 then begin
    openw, lun, /get, outfile
    luns = [luns, lun]
    endif
for file = 0, n_elements(luns)-1 do begin 
  printf, luns(file) , strmid(file1, 0, 7), ' ', strmid(file2,0,7), '   Ratio'
  for j=0,i do printf, luns(file), $
		format='(3(f7.2, 1x), a)', t1(j), t2(j), r(j), $
		strmid(names(j), 0, 48)
  endfor
if n_elements(outfile) gt 0 then free_lun, lun
end





pro reset,dummy	;Reset timer, used to ignore set up times...
; No-op this procedure to include setup times mainly comprise
; the time required to allocate arrays and to set them to
; a given value.

common timer_common, time, lunno, total_time, geom_time, ntest

time = systime(1)
return
end

pro dummy,dummy
return
end



pro graphics_times2, filename
; Time common graphics operations in the same manner as time_test  (REVISED)

common timer_common, time, lunno, total_time, geom_time, ntest

on_error,2                      ;Return to caller if an error occurs
if (!d.x_size ne 640) or (!d.y_size ne 512) then $
	window, xs=640, ys=512	;Use the same size window for fairness.
if n_params() gt 0 then init_time,filename else init_time

for i=1,10 do begin
	plot,[0,1]+i
	empty
	endfor
timer,'Simple plot, 10 times'

n = 1000
x = randomu(seed, n) * (2 * !pi)
y = fix((sin(x)+1) * (0.5 * !d.y_vsize))
x = fix((cos(x)+1) * (0.5 * !d.x_vsize))
for i=1,20 do begin
	erase
	empty
	plots,x,y,/dev
	empty
	endfor
timer,strtrim(n,2) + ' vectors x 100'
 
n = 50
plot,[-1,1],[-1,1]

for i=3,n do begin
	x = findgen(i) * ( 2 * !pi / i)
	erase
	polyfill,sin(x),cos(x)
	for j=1,i do begin
	    xx = randomu(seed, 3)
	    yy = randomu(seed, 3)
	    polyfill, xx, yy, /norm, color = !d.n_colors/2
	    endfor
	empty
	endfor
timer,'Polygon filling'

n = 512
a = findgen(n) * (8 * !pi / n)
c = bytscl(sin(a) # cos(a), top = !d.n_colors-1)
d = not c
erase
reset
for i=1,5 do begin
	tv,c
	empty
	tv,d
	empty
	endfor
timer,'Display 512 x 512 image, 10 times'
;for i=1,10 do begin
;	c = 0
;	c = tvrd(0,0,512,512)
;	endfor
;timer,'Read back 512 by 512 image, 10 times'

printf,lunno, float(total_time),'=Total Time, ', $
	exp(geom_time / ntest), '=Geometric mean,',ntest,' tests.'
if lunno gt 0 then free_lun,lunno
end

pro time_test2, filename		;Time_test revised....
common timer_common, time, lunno, total_time, geom_time, ntest

on_error,2                      ;Return to caller if an error occurs
if n_params() gt 0 then init_time,filename else init_time

;	Empty for loop
nrep = 2000000
for i=1L, nrep do begin & end

timer,'Empty For loop,' + string(nrep)+ ' times'

for i=1L,100000 do dummy, i
timer,'Call empty procedure (1 param) 100,000 times'

;	Add 100000 scalar ints:...
for i=0L,99999 do a=i+1
timer,'Add 100,000 integer scalars and store'

;	Scalar arithmetic loop:
for i=0L,25000 do begin
	a = i + i -2
	b = a / 2 + 1
	if b ne i then print,'You screwed up',i,a,b
	endfor
timer,'25,000 scalar loops each of 5 ops, 2 =, 1 if)'

a=replicate(2b,512,512)
reset
for i=1,10 do b=a*2b
timer,'Mult 512 by 512 byte by constant and store, 10 times'
for i=1,100 do c = shift(b,10,10)
timer,'Shift 512 by 512 byte and store, 100 times'
for i=1,50 do b=a+3b
timer,'Add constant to 512 x 512 byte array and store, 50 times'
for i=1,30 do b=a+b
timer,'Add two 512 by 512 byte images and store, 30 times'

a = float(a)
reset
for i=1,30 do b=a*2b
timer,'Mult 512 by 512 floating by constant and store, 30 times'
for i=1,30 do c = shift(b,10,10)	
timer,'Add constant to 512 x 512 floating and store, 30 times'
for i=1,30 do b=a+b
timer,'Add two 512 by 512 floating images and store, 30 times'

reset
for i=1,10 do a=randomu(qqq, 150, 150)	;Random number matrix
timer, 'Generate 225000 random numbers'

reset
b = invert(a)
timer,'Invert a 150 by 150 random matrix'

reset
nr_ludcmp, a, index
timer, 'LU Decomposition of a 150 by 150 random matrix'

a=bindgen(256,256) & b=a
reset
for i=0,255 do for j=0,255 do b(j,i)=a(i,j)
timer,'Transpose 256 x 256 byte, FOR loops'
for i=0,255 do begin
	b(0,i) = transpose(a(i,*))
	end
timer,'Transpose 256 x 256 byte, row and column ops'
b=transpose(a)
timer,'Transpose 256 x 256 byte, transpose function'

a=findgen(100000)+1
c=a
b = a
reset
for i=0L,n_elements(a)-1 do b(i) = alog(a(i))
timer,'Log of 100,000 numbers, FOR loop'
b = alog(a)
timer,'Log of 100,000 numbers, vector ops'

n = 2L^17
a = findgen(n)
reset
b = fft(a,1)
b = fft(b,-1)
timer,string(n) + ' point forward plus inverse FFT'

a=bytarr(512,512)
a(200:250,200:250)=10b
reset
for i=1,10 do b=smooth(a,5)
timer,'Smooth 512 by 512 byte array, 5x5 boxcar, 10 times'

a=float(a)
reset
for i=1,2 do b=smooth(a,5)
timer,'Smooth 512 by 512 floating array, 5x5 boxcar, 2 times'

a=bindgen(512,512)
aa =assoc(1,a)
reset
nrecs = 20
openw,1,'test.dat',512, initial = 512L*nrecs	;Must be changed for vax
for i=0,nrecs-1 do aa(i) = a
for i=0,nrecs-1 do a=aa(i)
timer,'Write and read 512 by 512 byte array x '+strtrim(nrecs,2)
close,1

printf,lunno, float(total_time),'=Total Time, ', $
	exp(geom_time / ntest), '=Geometric mean,',ntest,' tests.'
;  Remove the data file
openw,2,'test.dat',/DELETE
close,2
if lunno gt 0 then free_lun,lunno
end

pro graphics_times, filename
; Time common graphics operations in the same manner as time_test

common timer_common, time, lunno, total_time, geom_time, ntest

on_error,2                      ;Return to caller if an error occurs
if (!d.x_size ne 640) or (!d.y_size ne 512) then $
	window, xs=640, ys=512	;Use the same size window for fairness.
if n_params() gt 0 then init_time,filename else init_time

for i=1,10 do begin
	plot,[0,1]+i
	empty
	endfor
timer,'Simple plot, 10 times'

n = 1000
x = randomu(seed, n) * (2 * !pi)
y = fix((sin(x)+1) * (0.5 * !d.y_vsize))
x = fix((cos(x)+1) * (0.5 * !d.x_vsize))
for i=1,5 do begin
	erase
	empty
	plots,x,y,/dev
	empty
	endfor
timer,'vectors'
 
n = 24
plot,[-1,1],[-1,1]

for i=3,n do begin
	x = findgen(i) * ( 2 * !pi / i)
	erase
	polyfill,sin(x),cos(x)
	empty
	endfor
timer,'Polygon filling'

n = 512
a = findgen(n) * (8 * !pi / n)
c = bytscl(sin(a) # cos(a), top = !d.n_colors-1)
d = not c
erase
reset
for i=1,5 do begin
	tv,c
	empty
	tv,d
	empty
	endfor
timer,'Display 512 x 512 image, 10 times'
;for i=1,10 do begin
;	c = 0
;	c = tvrd(0,0,512,512)
;	endfor
;timer,'Read back 512 by 512 image, 10 times'

printf,lunno, float(total_time),'=Total Time, ', $
	exp(geom_time / ntest), '=Geometric mean,',ntest,' tests.'
if lunno gt 0 then free_lun,lunno
end



pro time_test, filename		;Run some time tests.
; filename = name of listing file or null for terminal output.
;
;+
; NAME:
;	TIME_TEST
;
; PURPOSE:
;	General purpose IDL benchmark program that performs
;	approximately 20 common operations and prints the time
;	required.
;
; CATEGORY:
;	Miscellaneous.
;
; CALLING SEQUENCE:
;	TIME_TEST [, Filename]
;
; OPTIONAL INPUTS:
;    Filename:	The string containing the name of output file for the 
;		results of the time test.
;
; OUTPUTS:
;	No explicit outputs.  Results of the test are printed to the screen 
;	or to a file.
;
; OPTIONAL OUTPUT PARAMETERS:
;	None.
;
; COMMON BLOCKS:
;	TIMER_COMMON
;
; SIDE EFFECTS:
;	Many operations are performed.  Files are written, etc.
;
; RESTRICTIONS:
;	Could be more complete, and could segregate integer, floating
;	point and file system IO times into separate figures.
;
; PROCEDURE:
;	Straightforward.
;	See also the procedure GRAPHICS_TEST, in this file, which
;	times a few of the common graphics operations.
;
;	We make no claim that these times are a fair or accurate
;	measure of computer performance.  In particular, different
;	versions of IDL were used.
;
;	Graphics performance varies greatly, depending largely on the
;	window system, or lack of thereof.
;	
;	Typical times obtained to date include:
; 	 (where	Comp.     = computational tests
; 		Graphics  = graphics tests
;		Geo. Avg. = geometric average)
;
; Machine / OS / Memory            Comp.   Geo. Avg.   Graphics Geo. Avg.
;
; MicroVAX II, VMS 5.1, 16MB        637     14.4        39.9    6.57
; MicroVAX II, Ultrix 3.0, 16MB     616     13.9        58.1    8.27
; Sun 3/110, SunOS 4.0, 12MB        391      8.19       32.0    7.81
; Sun 3/80, 12MB, 24 bit color      282      6.03       89.3   21.7
; PC 386 25MHz, 80387, MSDOS, 4MB   276      6.9        29.5    5.94
; Mips R2030, RISC/os 4.1, 8MB      246      3.67       14.6    2.62
; VAXStation 3100, VMS 5.1, 16MB    235      5.13       24.3    3.71
; HP 9000, Model 375, ?? ??         163      4.14       20.8    3.37
; DecStation 3100, UWS 2.1, 16MB    150      4.00       17.6    3.23
; 486 33mhz Clone, MS Windows, 8MB   70      1.81       12.9    3.00
; Sun 4/65, SunOS 4.1, 16MB          66      1.81        7.0    1.64
; Silicon Graphics 4D/25, ??         51      1.38       19.4    2.44
; Sun 4/50 IPX, 16MB		     40	     1.03	 7.7	0.80
; IBM 6000 Model 325 24MB            40      0.87        5.8    1.21
; HP 9000 / 720 48 MB                20      0.52        5.0    0.70
; SGI Indigo XS4000, 32MB	     20      0.46	 2.1    0.44
; SGI Indigo2, 150Mhz, 32MB	     16	     0.32        2.4    0.51
; DEC Alpha 3000/500, 224MB	     13      0.30        2.3    0.43
;
;
; MODIFICATION HISTORY:
;	DMS, 1986.
;
;	DMS, Revised July 1990,  Increased the size of arrays and the number
;		of repetitions to make most of the tests take longer.
;		This is to eliminate the effect of clock granularity
;		and to acknowledge that machines are becoming faster.
;		Many of the tests were made longer by a factor of 10.
;		
;-

common timer_common, time, lunno, total_time, geom_time, ntest

on_error,2                      ;Return to caller if an error occurs

do_floating = 1	;Do floating point array tests


if n_params() gt 0 then init_time,filename else init_time

;	Empty for loop
for i=0L, 999999l do begin & end

timer,'Empty For loop, 1 million times'

for i=1L,100000 do dummy, i
timer,'Call empty procedure (1 param) 100,000 times'

;	Add 100000 scalar ints:...
for i=0L,99999 do a=i+1
timer,'Add 100,000 integer scalars and store'

;	Scalar arithmetic loop:
for i=0L,25000 do begin
	a = i + i -2
	b = a / 2 + 1
	if b ne i then print,'You screwed up',i,a,b
	endfor
timer,'25,000 scalar loops each of 5 ops, 2 =, 1 if)'

a=replicate(2b,512,512)
reset
for i=1,10 do b=a*2b
timer,'Mult 512 by 512 byte by constant and store, 10 times'
for i=1,10 do c = shift(b,10,10)
timer,'Shift 512 by 512 byte and store, 10 times'
for i=1,10 do b=a+3b
timer,'Add constant to 512 x 512 byte array and store, 10 times'
for i=1,10 do b=a+b
timer,'Add two 512 by 512 byte images and store, 10 times'

if do_floating then begin
	a = float(a)
	reset
	for i=1,10 do b=a*2b
	timer,'Mult 512 by 512 floating by constant and store, 10 times'
	for i=1,10 do c = shift(b,10,10)	
	timer,'Add constant to 512 x 512 floating and store, 10 times'
	for i=1,10 do b=a+b
	timer,'Add two 512 by 512 floating images and store, 10 times'
	endif


a=randomu(qqq,100,100)	;Random number matrix
reset
b = invert(a)
timer,'Invert a 100 by 100 random matrix'

a=bindgen(256,256) & b=a
reset
for i=0,255 do for j=0,255 do b(j,i)=a(i,j)
timer,'Transpose 256 x 256 byte, FOR loops'
for i=0,255 do begin
	b(0,i) = transpose(a(i,*))
	end
timer,'Transpose 256 x 256 byte, row and column ops'
b=transpose(a)
timer,'Transpose 256 x 256 byte, transpose function'

a=findgen(100000)+1
c=a
b = a
reset
for i=0L,n_elements(a)-1 do b(i) = alog(a(i))
timer,'Log of 100,000 numbers, FOR loop'
b = alog(a)
timer,'Log of 100,000 numbers, vector ops'

for i=0L,n_elements(a)-1 do c(i)=a(i)+b(i)
timer,'Add two 100000 element floating vectors, FOR loop'

c=a+b
timer,'Add two 100000 element floating vectors, vector op'

a = findgen(65536L)
reset
b=fft(a,1)
timer,'65536 point real to complex FFT'

a=bytarr(512,512)
a(200:250,200:250)=10b
reset
b=smooth(a,5)
timer,'Smooth 512 by 512 byte array, 5x5 boxcar'

a=float(a)
reset
b=smooth(a,5)
timer,'Smooth 512 by 512 floating array, 5x5 boxcar'

a=bindgen(512,512)
aa =assoc(1,a)
reset
openw,1,'test.dat',512, initial = 5120	;Must be changed for vax
for i=1,10 do aa(0) = a
for i=1,10 do a=aa(0)
timer,'Write and read 10 512 by 512 byte arrays'
close,1

printf,lunno, float(total_time),'=Total Time, ', $
	exp(geom_time / ntest), '=Geometric mean,',ntest,' tests.'
;  Remove the data file
openw,2,'test.dat',/DELETE
close,2
if lunno gt 0 then free_lun,lunno
end
;$Id: tm_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       TM_TEST
;
; PURPOSE:
;       This function computes the Student's t-statistic and the probability
;       that two vectors of sampled data have significantly different means. 
;       The default assumption is that the data is drawn from populations with
;       the same true variance. This type of test is often refered to as the 
;       T-means Test.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = TM_TEST(X, Y)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double.
;
;       Y:    An m-element vector of type integer, float or double.
;             If the PAIRED keyword is set, X and Y must have the same
;             number of elements.
;
; KEYWORD PARAMETERS:
;       PAIRED:   If set to a non-zero value, X and Y are assumed to be 
;                 paired samples and must have the same number of elements.
;
;       UNEQUAL:  If set to a non-zero value, X and Y are assumed to be from
;                 populations with unequal variances.
;
; EXAMPLE
;       Define two n-element vectors of tabulated data.
;         X = [257, 208, 296, 324, 240, 246, 267, 311, 324, 323, 263, 305, $
;               270, 260, 251, 275, 288, 242, 304, 267]
;         Y = [201, 56, 185, 221, 165, 161, 182, 239, 278, 243, 197, 271, $
;               214, 216, 175, 192, 208, 150, 281, 196]
;       Compute the Student's t-statistic and its significance assuming that 
;       X and Y belong to populations with the same true variance.
;       The result should be the two-element vector [5.5283890, 2.5245510e-06],
;       indicating that X and Y have significantly different means.
;         result = tm_test(X, Y)
;       
; PROCEDURE:
;       TM_TEST computes the t-statistic of X and Y as the ratio;
;       (difference of sample means) / (standard error of differences) and 
;       its significance (the probability that |t| could be at least as large
;       large as the computed statistic). X and Y may be of different lengths.
;       The result is a two-element vector containing the t-statistic and its
;       significance. The significance is a value in the interval [0.0, 1.0]; 
;       a small value (0.05 or 0.01) indicates that X and Y have significantly
;       different means. 
;
; REFERENCE:
;       Numerical Recipes, The Art of Scientific Computing (Second Edition)
;       Cambridge University Press
;       ISBN 0-521-43108-5
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, Aug 1994
;                    TM_TEST is based on the routines: ttest.c, tutest.c and
;                    tptest.c described in section 14.2 of Numerical Recipes, 
;                    The Art of Scientific Computing (Second Edition), and is 
;                    used by permission.
;-

function betacf, a, b, x
  on_error, 2
  eps   = 3.0e-7
  fpmin = 1.0e-30
  maxit = 100
  qab = a + b
  qap = a + 1.0
  qam = a - 1.0
    c = 1.0
    d = 1.0 - qab * x / qap
  if(abs(d) lt fpmin) then d = fpmin
  d = 1.0 / d
  h = d
  for m = 1, maxit do begin
    m2 = 2 * m
    aa = m * (b - m) * x / ((qam + m2) * (a + m2))
     d = 1.0 + aa*d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     h = h * d * c
     aa = -(a + m) *(qab + m) * x/((a + m2) * (qap + m2))
     d = 1.0 + aa * d
     if(abs(d) lt fpmin) then d = fpmin
     c = 1.0 + aa / c
     if(abs(c) lt fpmin) then c = fpmin
     d = 1.0 / d
     del = d * c
     h = h * del
     if(abs(del - 1.0) lt eps) then return, h
  endfor
  message, 'Failed to converge within given parameters.'
end

function gammln, xx
  coff = [76.18009172947146d0,   -86.50532032941677d0,  $
          24.01409824083091d0,    -1.231739572450155d0, $
           0.1208650973866179d-2, -0.5395239384953d-5]
  stp = 2.5066282746310005d0
  x = xx
  y = x
  tmp = x + 5.5d0
  tmp = (x + 0.5d0) * alog(tmp) - tmp
  ser = 1.000000000190015d0
  for j = 0, n_elements(coff)-1 do begin
    y = y + 1.d0
    ser = ser + coff(j) / y
  endfor
  return, tmp + alog(stp * ser / x)
end

function ibeta, a, b, x
  on_error, 2
  if (x lt 0 or x gt 1) then message, $
    'x must be in the interval [0, 1].'
  if (x eq 0  or x eq 1) then bt = 0.0 $
  else $
    bt = exp(gammln(a + b) - gammln(a) - gammln(b) + $
             a * alog(x) + b * alog(1.0 - x))
  if(x lt (a + 1.0)/(a + b + 2.0)) then return, $
    bt * betacf(a, b, x) / a $
  else return, 1.0 - bt * betacf(b, a, 1.0-x) / b
end

function tm_test, x0, x1, paired = paired, unequal = unequal

  on_error, 2

  if keyword_set(paired) ne 0 and keyword_set(unequal) ne 0 then $
    message, 'Paired and Unequal keywords cannot be set simultaneously.'

  nx0 = n_elements(x0)
  nx1 = n_elements(x1)

  if nx0 le 1 or nx1 le 1 then $
    message, 'x0 and x1 must be vectors of length greater than one.'

  type = size(x0)

  if keyword_set(paired) ne 0 then begin
    ;x0 and x1 are paired samples with corrected covariance.
    if nx0 ne nx1 then message, $
      'Paired keyword requires vectors of equal size.'
    mv0 = moment(x0)
    mv1 = moment(x1)
    cov = total((x0 - mv0(0)) * (x1 - mv1(0)))
    df = nx0 - 1
    cov = cov / df
    sd = sqrt((mv0(1) + mv1(1) - 2.0 * cov) / nx0)
    t = (mv0(0) - mv1(0)) / sd
    prob = ibeta(0.5*df, 0.5, df/(df+t^2))
    if type(2) eq 4 then return, float([t, prob]) $
    else return, [t, prob]
  endif else if keyword_set(unequal) ne 0 then begin
    ;x0 and x1 are assumed to have different population variances.
    mv0 = moment(x0)
    mv1 = moment(x1)
    t = (mv0(0) - mv1(0)) / sqrt(mv0(1)/nx0 + mv1(1)/nx1)
    df = (mv0(1)/nx0 + mv1(1)/nx1)^2 / $
         ((mv0(1)/nx0)^2/(nx0 - 1.0) + (mv1(1)/nx1)^2/(nx1 - 1.0))
    prob = ibeta(0.5*df, 0.5, df/(df+t^2))
    if type(2) ne 5 then return, float([t, prob]) $
    else return, [t, prob]
  endif else begin
    ;x0 and x1 are assumed to have the same population variance. 
    mv0 = moment(x0)
    mv1 = moment(x1)
    df = nx0 + nx1 - 2
    var = ((nx0 - 1)*mv0(1) + (nx1 - 1)*mv1(1)) / df 
    t = (mv0(0) - mv1(0)) / sqrt(var*(1.0/nx0 + 1.0/nx1))
    prob = ibeta(0.5*df, 0.5, df/(df+t^2))
    if type(2) ne 5 then return, float([t, prob]) $
    else return, [t, prob]
  endelse

end
;$Id: t_pdf.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       T_PDF
;
; PURPOSE:
;       This function computes the probabilty (p) such that:
;                   Probability(X <= v) = p
;       where X is a random variable from the Student's t distribution
;       with (df) degrees of freedom.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = T_pdf(V, DF)
;
; INPUTS:
;       V:    A scalar of type integer, float or double that specifies
;             the cutoff value.
;
;      DF:    A positive scalar of type integer, float or double that
;             specifies the degrees of freedom of the Student's t 
;             distribution.
;
; EXAMPLE:
;       Compute the probability that a random variable X, from the 
;       Student's t distribution with (df = 15) degrees of freedom,
;       is less than or equal to 0.691. The result should be 0.749940
;         result = t_pdf(0.691, 15)
;
; REFERENCE:
;       APPLIED STATISTICS (third edition)
;       J. Neter, W. Wasserman, G.A. Whitmore
;       ISBN 0-205-10328-6
;
; MODIFICATION HISTORY:
;       Modified by:  GGS, RSI, July 1994
;                     Minor changes to code. New documentation header.
;-

function t_pdf , v, df

  on_error, 2  ;Return to caller if error occurs.

  if df le 0 then message, $
    'Degrees of freedom must be positive.'

  return, 1.0 - 0.5 * ibeta_pdf(df/(df + v^2), df/2.0, 0.5) 
end 

;
; $Id: tplt_alloc.pro,v 1.6 1995/01/20 19:41:01 tonyh Exp $
;
;  WidTemplate
;   Sample Class definition file
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  TPLT_Icon
;
FUNCTION TPLT_Icon
  ;  One should either return 0 (indicates no toolbar icon)
  ;  or a BYTARR(4,32) which will be added to the toolbar.

  RETURN, 0
END

;
;  TPLT_Copy
;   Copy a tmplt.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO TPLT_Copy, Ptr, Copy
    GenCopy, Ptr, Copy
END


;
;  TPLT_Destroy
;   Release resources for the given tmplt
;
PRO TPLT_Destroy, Ptr
    GenDestroy, Ptr
END


;
;  TPLT_Event
;   Event handling routine for a tmplt dialog.   Shares common code
;   (c.f. widbuild.pro)
;
PRO TPLT_Event, Event
    MISC_Event, Event, 1    ; constant is Font Offset in Foci (see TPLT_Build)
END


;
;  TPLT_Build
;   Create a dialog box a tmplt object.  If ptr is nil then
;   create the object as well.
;
PRO TPLT_Build, Ptr, ParPtr

  COMMON WidEd_Comm

    TPLT_Alloc, ParPtr, Ptr               ; Allocate object if necessary
    MgrName = 'WE_TPLT' + STRTRIM(Ptr, 2) ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN    ; See if it already exists

    Title   = GetId(Ptr) + '(Child of ' + GetId(ParPtr) + ')'
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    Base    = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)

;****************OBJECT SPECIFIC CODE TO BUILD DIALOG BOX**************
;   Foci    = LONARR(6)
;   Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
;   Lab     = WIDGET_LABEL(Base1, VALUE="Basic Information")
;   Foci(0) = Field(Base1, "Tmplt Text:", Obj.Value, 'VALUE', SIZE=50, /STRING)
;    Base2   = WIDGET_BASE(Base1,/ROW)

;***************See TPLT_Event for use of the Font Index***************
;    Foci(1) = Field(Base2, "Font:", Obj.Font, 'FONT', SIZE=50, /STRING)
;    IF !Version.OS NE 'Win32' AND !Version.OS NE 'MacOS' THEN $
;       XFontBtn    = WIDGET_TPLT(Base2, VALUE="XFont", UVALUE="XFONT")
;
;   Base1   = WIDGET_BASE(Base, /FRAME)
;   BuildOther, Base, Obj, Foci, 2, /FRAME
;   Lab     = WIDGET_LABEL(Base1, VALUE="Tmplt Appearance Controls")
;   BuildXY, Base1, Obj, Foci, 3, /SIZE, /OFFSET
;   BuildOkCancel, Base, Obj

;****************DECLARE DIALOG INFORMATION**********************
    DlgInfo     = { $
        Foci:       Foci, $     ; Required
        ObjPtr:     Ptr, $      ; Required
        SpecialData: 0b $       ; Data for Dialog Box (widget ids, etc.)
    }
    Obj.Dialog  = Base
    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER='TPLT_Event', CLEANUP='MISC_Kill'
    Obj2Ptr, Obj, Ptr
END


;
;  TPLT_Save
;   Save tmplt information to a file.
;   This is a simple object to save.
;
PRO TPLT_Save, Unit, Ptr
    GenWrite, Unit, Ptr
END


;
;  TPLT_Restore
;   Read in a tmplt object from a file
;
PRO TPLT_Restore, Unit, Parent, Ptr
    MISC_Restore, Unit, Parent, Ptr, "TPLT", 0
END


;
;  TPLT_Generate
;   Create a tmplt object for previewing
;
PRO TPLT_Generate, Base, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Build a command string

    Cmd = 'Id = WIDGET_TPLT(Base'
    SAddCmd, Cmd, Obj.TemplateStringData, 'STRING_KEYWORD'
    IAddCmd, Cmd, Obj.TemplateIntData, 'ANOTHER_KEYWORD'
    SAddCmd, Cmd, Obj.TemplateFont, 'FONT'

    ; Create tmplt by executing the command string we just built

    Obj2Ptr, Obj, Ptr

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        MESSAGE,'Could not create Tmplt ' + VarName(Ptr)
    ENDIF
END


;
;  TPLT_GenWid
;   Create IDL code for creating a TPLT
;
PRO TPLT_GenWid, Unit, Ptr, Parent

    Name    = VarId(Ptr)            ; Get name for tmplt
    Ptr2Obj, Ptr, Obj               ; Get object information

    XPRINTF, Unit, FORMAT='("  ",A," = CW_TPLT( ",A )', /NO_EOL, $
        Name, Parent
    SSaveCmd, Unit, Obj.TemplateFont, "FONT"
    SSaveCmd, Unit, Obj.TemplateStringData, "STRING_KEYWORD"
    ISaveCmd, Unit, Obj.TemplateIntData, "ANOTHER_KEYWORD"
    SSaveCmd, Unit, UValue(Obj, Ptr), "UVALUE"
    XPRINTF, Unit, ')'

    Obj2Ptr, Obj, Ptr
END

;  Alloc function must be last function in file

;
;  TPLT_Alloc
;       Allocate a <THING> object.
;
PRO TPLT_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    IF KEYWORD_SET(Ptr) NE 0 THEN RETURN    ; if(ptr != NULL) return;

    Ptr = WIDGET_BASE(GROUP=TopDlg)         ; Make a pointer

    ;   Make a Tmplt object

    Obj = {                     $
        WE_TPLT,               $ ; Nice but not required
        Type:           'TPLT',$ ; Set to function prefix
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        Dialog:         0L,     $ ; Ptr to Control Panel (Base widget ID)
        Next:           0L,     $ ; index of next child/free/top
        Name:           '',     $ ; object name
        UValue:         '',     $ ; Required.
        TemplateStringData: '', $ ; Per class information <Sample>
        TemplateIntData: 0,     $ ; Per class information <Sample>
        TemplateFont:   ''      $ ; Per class information <Font Sample>
    }

    Obj2Ptr, Obj, Ptr
END
; $Id: tri_surf.pro,v 1.1 1993/10/08 15:37:53 dave Exp $

FUNCTION TRI_SURF, z, x, y, REGULAR = regular, XGRID=xgrid, $
	XVALUES = xvalues, YGRID = ygrid, YVALUES = yvalues, $
	GS = gs, BOUNDS = bounds, NX = nx0, NY = ny0, $
	MISSING = missing, EXTRAPOLATE = extrapolate
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	TRI_SURF
;
; PURPOSE:
;	This function Interpolates a regularly or irregularly gridded
;	set of points with a smooth quintic surface.
;
; CATEGORY:
;	Mathematical functions, Interpolation, Surface Fitting
;
; CALLING SEQUENCE:
;	Result = TRI_SURF(Z [, X, Y])
;
; INPUTS: 
;	X, Y, Z:  arrays containing the X, Y, and Z coordinates of the 
;		  data points on the surface. Points need not be 
;		  regularly gridded. For regularly gridded input data, 
;		  X and Y are not used: the grid spacing is specified 
;		  via the XGRID and YGRID (or XVALUES and YVALUES) 
;		  keywords, and Z must be a two dimensional array. 
;		  For irregular grids, all three parameters must be
;		  present and have the same number of elements. 
;
; KEYWORD PARAMETERS:
;  Input grid description:
;	REGULAR:  if set, the Z parameter is a two dimensional array 
;		  of dimensions (N,M), containing measurements over a 
;		  regular grid. If any of XGRID, YGRID, XVALUES, YVALUES 
;		  are specified, REGULAR is implied. REGULAR is also 
;		  implied if there is only one parameter, Z. If REGULAR is 
;		  set, and no grid (_VALUE or _GRID) specifications are 
;		  present, the respective grid is set to (0, 1, 2, ...). 
;	XGRID:    contains a two element array, [xstart, xspacing], 
;		  defining the input grid in the X direction. Do not
;		  specify both XGRID and XVALUES. 
;	XVALUES:  if present, XVALUES(i) contains the X location 
;		  of Z(i,j). XVALUES must be dimensioned with N elements. 
;	YGRID:    contains a two element array, [ystart, yspacing], 
;		  defining the input grid in the Y direction. Do not
;		  specify both YGRID and YVALUES. 
;	YVALUES:  if present, YVALUES(i) contains the Y location 
;		  of Z(i,j). YVALUES must be dimensioned with N elements. 
;
;  Output grid description:
;	GS:	  If present, GS must be a two-element vector [XS, YS],
;		  where XS is the horizontal spacing between grid points
;		  and YS is the vertical spacing. The default is based on
;		  the extents of X and Y. If the grid starts at X value
;		  Xmin and ends at Xmax, then the default horizontal
;		  spacing is (Xmax - Xmin)/(NX-1). YS is computed in the
;		  same way. The default grid size, if neither NX or NY
;		  are specified, is 26 by 26. 
;	BOUNDS:   If present, BOUNDS must be a four element array containing
;		  the grid limits in X and Y of the output grid:
;		  [Xmin, Ymin, Xmax, Ymax]. If not specified, the grid
;		  limits are set to the extent of X and Y. 
;	NX:       The output grid size in the X direction. NX need not
;	  	  be specified if the size can be inferred from GS and
;		  BOUNDS. The default value is 26.
;	NY:       The output grid size in the Y direction. See NX. 
;
;  Others:
;       EXTRAPOLATE: If set, extrapolate the surface to points outside
;		the convex hull of input points.  Has no effect if
;		input points are regularly gridded.
;	MISSING: If set, points outside the convex hull of input points
;		are set to this value.  Default is 0.  Has no effect
;		if input points are regularly gridded.
;
; OUTPUTS:
;	This function returns a two-dimensional floating point array
; 	containing the interpolated surface, sampled at the grid points.
;
; RESTRICTIONS:
;	The output grid must enclose convex hull of the input points.
; PROCEDURE:
;	This routine is similar to MIN_CURVE_SURF but the surface
;	fitted is a smooth surface, not a minimum curvature surface.  This
;	routine has the advantage of being much more efficient
;	for larger numbers of points.
;
;	The built-in IDL routines TRIANGULATE and TRIGRID(/QUINTIC) are
;	used.
;
; EXAMPLES:
; Example 1: Irregularly gridded cases
;	Make a random set of points that lie on a gaussian:
;	  n = 15				;# random points
;	  x = RANDOMU(seed, n)
;	  y = RANDOMU(seed, n)
;	  z = exp(-2 * ((x-.5)^2 + (y-.5)^2)) 	 ;The gaussian
;
; 	get a 26 by 26 grid over the rectangle bounding x and y:
;	  r = TRI_SURF(z, x, y)	;Get the surface.
;
; 	Or: get a surface over the unit square, with spacing of 0.05:
;	  r = TRI_SURF(z, x, y, GS=[0.05, 0.05], BOUNDS=[0,0,1,1])
;
; 	Or: get a 10 by 10 surface over the rectangle bounding x and y:
;	  r = TRI_SURF(z, x, y, NX=10, NY=10)
;
; Example 2: Regularly gridded cases
;	Make some random data
;	  z = randomu(seed, 5, 6)
;
;	interpolate to a 26 x 26 grid:
;	  CONTOUR, TRI_SURF(z, /REGULAR)
;
; MODIFICATION HISTORY:
;	DMS, RSI, October, 1993.  Written.
;-


ON_ERROR, 2
s = size(z)		;Assume 2D
nx = s(1)
ny = s(2)

reg = keyword_set(regular) or (n_params() eq 1)

if n_elements(xgrid) eq 2 then begin
	x = findgen(nx) * xgrid(1) + xgrid(0)
	reg = 1
endif else if n_elements(xvalues) gt 0 then begin
	if n_elements(xvalues) ne nx then $
		message,'Xvalues must have '+string(nx)+' elements.'
	x = xvalues
	reg = 1
endif

if n_elements(ygrid) eq 2 then begin
	y = findgen(ny) * ygrid(1) + ygrid(0)
	reg = 1
endif else if n_elements(yvalues) gt 0 then begin
	if n_elements(yvalues) ne ny then $
		message,'Yvalues must have '+string(ny)+' elements.'
	y = yvalues
	reg = 1
endif

if reg then begin
	if s(0) ne 2 then message,'Z array must be 2D for regular grids'
	if n_elements(x) ne nx then x = findgen(nx)
	if n_elements(y) ne ny then y = findgen(ny)
	x = x # replicate(1., ny)	;Expand to full arrays.
	y = replicate(1.,nx) # y
	endif

n = n_elements(x)
if n ne n_elements(y) or n ne n_elements(z) then $
	message,'x, y, and z must have same number of elements.'

if n_elements(bounds) lt 4 then begin	;Bounds specified?
	xmin = min(x, max = xmax)
	ymin = min(y, max = ymax)
	bounds = [xmin, ymin, xmax, ymax]
	endif

TRIANGULATE, x, y, tr, b

if n_elements(gs) lt 2 then begin	;GS specified?  No.
    if n_elements(nx0) le 0 then nx = 26 else nx = nx0 ;Defaults for nx and ny
    if n_elements(ny0) le 0 then ny = 26 else ny = ny0
    gs = [(bounds(2)-bounds(0))/(nx-1.), $
	   (bounds(3)-bounds(1))/(ny-1.)]
  endif else begin			;GS is specified?
    if n_elements(nx0) le 0 then $
	nx = ceil((bounds(2)-bounds(0))/gs(0)) + 1 $
    else nx = nx0
    if n_elements(ny0) le 0 then $
	ny = ceil((bounds(3)-bounds(1))/gs(1)) + 1 $
    else ny = ny0
  endelse


if N_ELEMENTS(missing) le 0 then missing = 0

if KEYWORD_SET(extrapolate) then $
    return, TRIGRID(x,y,z, tr, /QUINTIC, gs, bounds, $
		    MISSING=missing, EXTRAPOLATE=b)

return, TRIGRID(x,y,z, tr, /QUINTIC, gs, bounds, MISSING=missing)
end
;$Id: ts_coef.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       TS_COEF
;
; PURPOSE:
;       This function computes the coefficients used in a Pth order
;       autoregressive time-series forecasting model. The result is
;       a P-element vector whose type is identical to X.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = TS_COEF(X, P)
;
; INPUTS:
;       X:    An n-element vector of type float or double containing time-
;             series samples.
;
;       P:    A scalar of type integer or long integer that specifies the
;             number of coefficients to be computed.
;
; KEYWORD PARAMETERS:
;     MSE:    Use this keyword to specify a named variable which returns the 
;             mean square error of the Pth order autoregressive model.
;
; EXAMPLE:
;       Define an n-element vector of time-series samples.
;         x = [6.63, 6.59, 6.46, 6.49, 6.45, 6.41, 6.38, 6.26, 6.09, 5.99, $
;              5.92, 5.93, 5.83, 5.82, 5.95, 5.91, 5.81, 5.64, 5.51, 5.31, $
;              5.36, 5.17, 5.07, 4.97, 5.00, 5.01, 4.85, 4.79, 4.73, 4.76]
;
;       Compute the coefficients of a 5th order autoregressive model.
;         result = TS_COEF(x, 5)
;
;       The result should be:
;         [1.30168, -0.111783, -0.224527. 0.267629, -0.233363]
;
; REFERENCE:
;       The Analysis of Time Series, An Introduction (Fourth Edition)
;       Chapman and Hall
;       ISBN 0-412-31820-2
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, November 1994
;-

function ts_coef, x, p, mse = mse, reflect = reflect

  ;Compute the coefficients of the Pth order autoregressive model
  ;used in time-series forecasting.
  ;AR_COEF = AR_COEF(0, 1, ... , p-1) 

  nx = n_elements(x)

  mse = total(x^2) / nx
  
  sx = size(x)
  ;if sx(2) eq 5 then ar_coef = dblarr(p) $
  ;else ar_coef = fltarr(p)
  ar_coef = dblarr(p)

  ;Do all intermediate calculations in double-precision.
  str1 = [0.0d, x(0:nx-2), 0.0]
  str2 = [0.0d, x(1:nx-1), 0.0]
  str3 = dblarr(nx+1)

  for k = 1, p do begin
    ar_coef(k-1) = 2.0 * total(str1(1:nx-k) * str2(1:nx-k)) / $
                     total(str1(1:nx-k)^2 + str2(1:nx-k)^2)
    mse = mse * (1.0 - ar_coef(k-1)^2)
    for i = 1, k-1 do $
      ar_coef(i-1) = str3(i) - ar_coef(k-1) * str3(k-i)

    ;if k = p then skip the remaining computations.
    if k eq p then goto, return_ar_coef

    str3(1:k) = ar_coef(0:k-1)
    for j = 1, nx-k-1 do begin
      str1(j) = str1(j) - str3(k) * str2(j)
      str2(j) = str2(j+1) - str3(k) * str1(j+1)
    endfor
  endfor

  return_ar_coef:
  ;if keyword_set(reflect) ne 0 then $     ;Reflect the coefficients
  ;  return, reflect(ar_coef) $            ;for stability.
  ;else return, ar_coef
  ;;Note: The REFLECT keyword implements a reflection algorithm to
  ;;      stabilize the coefficients that lie outside the complex
  ;;      unit circle. This algorithm may be included in the future.
 
  if sx(2) eq 5 then return, ar_coef $
  else return, float(ar_coef)

end
;$Id: ts_diff.pro,v 1.1 1994/12/02 21:24:28 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       TS_DIFF
;
; PURPOSE:
;       This function recursively computes the forward differences, of an 
;       N-element time-series, K times. The result is an N-element differenced 
;       time-series with its last K elements as zeros. 
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = TS_Diff(X, K)
;
; INPUTS:
;       X:    An n-element vector of type integer, float or double containing
;             time-series samples.
;
;       K:    A positive scalar of type integer or long integer in the 
;             interval [1, N_ELEMENTS(X) - 1], that specifies the number of 
;             times X is differenced.
;
; EXAMPLE:
;       Define an n-element vector of time-series samples.
;         x = [389, 345, 303, 362, 412, 356, 325, 375, $
;              410, 350, 310, 388, 399, 362, 325, 382, $
;              399, 382, 318, 385, 437, 357, 310, 391]
;
;       Compute the second forward differences of X.
;         result = TS_DIFF(x, 2)
;
;       The result should be:
;         [ 2, 101,   -9,  -106, 25,  81, -15, -95, $
;          20, 118,  -67,   -48,  0,  94, -40, -34, $
;         -47, 131,  -15,  -132, 33, 128,   0,   0]
;
; REFERENCE:
;       The Analysis of Time Series (Fourth Edition)
;       C. Chatfield
;       ISBN 0-412-31820-2
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, December 1994
;-

function ts_diff, x, k

  on_error, 2

  nx = n_elements(x)
  if k gt nx - 1 then $
    message, 'Order of differencing cannot exceed N_ELEMENTS(X) - 1.'

  tsx = [0, x]

  if k gt 0 then begin
    for l = 1, k do begin ;Recursively compute differences.
      ;j = [1, 2, 3, ..., nx-1]
      ;tsx(j) = tsx(j) - tsx(j+1)
      j = lindgen(nx-1L)+1L
      tsx(j) = tsx(j) - tsx(j+1L)
      tsx(nx) = 0
      nx = nx - 1L
    endfor
  ;;endif else if k lt 0 then begin  ;Backward difference operator.
  ;;  for l = 1, abs(k) do begin     ;  ts_diff(x, 1) = -ts_diff(x, -1)
  ;;    a = tsx(1)                   ;  ts_diff(x, k) =  ts_diff(x, -k)
  ;;    for j = 2, nx do begin       ;    for k >= 2
  ;;      b = tsx(j)
  ;;      tsx(j-1) = tsx(j) - a
  ;;      a = b
  ;;    endfor
  ;;    tsx(nx) = 0.0
  ;;    nx = nx - 1L
  ;;  endfor
  ;;endif else $
  endif else $
    message, 'Order of differencing must be greater than zero.'

  return, tsx(1:*)

end
;$Id: ts_fcast.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       TS_FCAST
;
; PURPOSE:
;       This function computes future values of a stationary time-series 
;       using a Pth order autoregressive model. The result is an
;       N_FUTURE-element vector whose type is identical to X.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = TS_FCAST(X, P, N_FUTURE)
;
; INPUTS:
;       X:    An n-element vector of type float or double containing time-
;             series samples.
;
;       P:    A scalar of type integer or long integer that specifies the
;             number of past time-series values to be used in the forecast. 
;             In general, a larger number of values results in a more accurate
;             forecast.
;
;N_FUTURE:    A scalar of type integer or long integer that specifies the
;             number of future values to be computed.
;
; EXAMPLE:
;       Define an n-element vector of time-series samples.
;         x = [6.63, 6.59, 6.46, 6.49, 6.45, 6.41, 6.38, 6.26, 6.09, 5.99, $
;              5.92, 5.93, 5.83, 5.82, 5.95, 5.91, 5.81, 5.64, 5.51, 5.31, $
;              5.36, 5.17, 5.07, 4.97, 5.00, 5.01, 4.85, 4.79, 4.73, 4.76]
;
;       Compute five future values of the time-series using a 10th order
;       autoregressive model.
;         result = ts_fcast(x, 10, 5)
;
;       The result should be:
;         [4.65870, 4.58380, 4.50030, 4.48828, 4.46971] 
;
; REFERENCE:
;       The Analysis of Time Series, An Introduction (Fourth Edition)
;       Chapman and Hall
;       ISBN 0-412-31820-2
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, November 1994
;-

function ts_fcast, x, p, n_future, reflect = reflect

  ;This function uses the last P elements of the time-series
  ;[x0, x1, ... , xn-1] to compute the forecast. More coefficients 
  ;correspond to more past time-series data used to make the forecast.

  on_error, 2

  n_future = n_future + 0L

  if n_future le 0 then $
    message, 'n_future must be a scalar greater than 0.'

  nx = n_elements(x)
  sx = size(x)
 
  if p lt 2 or p gt nx-1 then $
    message, 'p must be a scalar in the interval: [2, n_elements(x)-1].'

  ;The last p elements of the time-series.
  data = reverse(x(nx-p:nx-1))

  if sx(2) eq 5 then fcast = dblarr(n_future) $
  else fcast = fltarr(n_future)

  ;Compute coefficients.
  if keyword_set(reflect) eq 0 then $
    ar_coef = ts_coef(x, p) $
  else ar_coef = ts_coef(x, p, /reflect)
  ;Note: The REFLECT keyword implements a reflection algorithm to 
  ;      stabilize the coefficients that lie outside the complex 
  ;      unit circle. This algorithm may be included in the future.

  ;n_elements(ar_coef) must equal p.

  for j = 0, n_future-1 do begin
    yn = total(data * ar_coef)
    ;data = [yn, data(0:n_future-2)]
    data = [yn, data(0:p-2)]
    fcast(j) = yn
  endfor

  return, fcast

end


; $Id: uniq.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

;+
; NAME:
;	UNIQ
;
; PURPOSE:
;	Return the subscripts of the unique elements in an array.
;
;	Note that repeated elements must be adjacent in order to be
;	found.  This routine is intended to be used with the SORT
;	function.  See the discussion of the IDX argument below.
;
;	This command is inspired by the Unix uniq(1) command.
;
; CATEGORY:
;	Array manipulation.
;
; CALLING SEQUENCE:
;	UNIQ(Array [, Idx])
;
; INPUTS:
;	Array:	The array to be scanned.  The type and number of dimensions
;		of the array are not important.  The array must be sorted
;		into monotonic order unless the optional parameter Idx is 
;		supplied.
;
; OPTIONAL INPUT PARAMETERS:
;	IDX:	This optional parameter is an array of indices into Array
;		that order the elements into monotonic order.
;		That is, the expression:
;
;			Array(Idx)
;
;		yields an array in which the elements of Array are
;		rearranged into monotonic order.  If the array is not
;		already in monotonic order, use the command:
;
;			UNIQ(Array, SORT(Array))
;
;		The expression below finds the unique elements of an unsorted
;		array:
;
;			Array(UNIQ(Array, SORT(Array)))
;
; OUTPUTS:
;	An array of indicies into ARRAY is returned.  The expression:
;
;		ARRAY(UNIQ(ARRAY))
;
;	will be a copy of the sorted Array with duplicate adjacent
;	elements removed.
;
; COMMON BLOCKS:
;	None.
;
; MODIFICATION HISTORY:
;	29 July 1992, ACY - Corrected for case of all elements the same.
;
;-
;

function UNIQ, ARRAY, IDX

; Check the arguments.
  s = size(ARRAY)
  if (s(0) eq 0) then message, 'ARRAY must be an array.'
  if n_params() ge 2 then begin		;IDX supplied?
     q = array(idx)
     indices = where(q ne shift(q,-1), count)
     if (count GT 0) then return, idx(indices) $
     else return, n_elements(q)-1
  endif else begin
     indices = where(array ne shift(array, -1), count)
     if (count GT 0) then return, indices $
     else return, n_elements(ARRAY)-1
  endelse
end
; $Id: velovect.pro,v 1.8 1995/06/09 21:01:26 dave Exp $
PRO VELOVECT,U,V,X,Y, Missing = Missing, Length = length, Dots = dots,  $
        Color=color, _EXTRA = extra
;
;+ 
; NAME:
;	VELOVECT
;
; PURPOSE:
;	Produce a two-dimensional velocity field plot.
;
;	A directed arrow is drawn at each point showing the direction and 
;	magnitude of the field.
;               
; CATEGORY:
;	Plotting, two-dimensional.
;
; CALLING SEQUENCE:
;	VELOVECT, U, V [, X, Y]
;
; INPUTS:
;	U:	The X component of the two-dimensional field.  
;		U must be a two-dimensional array.
;
;	V:	The Y component of the two dimensional field.  Y must have
;		the same dimensions as X.  The vector at point (i,j) has a 
;		magnitude of:
;
;			(U(i,j)^2 + V(i,j)^2)^0.5
;
;		and a direction of:
;
;			ATAN2(V(i,j),U(i,j)).
;
; OPTIONAL INPUT PARAMETERS:
; 	X:	Optional abcissae values.  X must be a vector with a length 
;		equal to the first dimension of U and V.
;
;	Y:	Optional ordinate values.  Y must be a vector with a length
;		equal to the first dimension of U and V.
;
; KEYWORD INPUT PARAMETERS:
;      MISSING:	Missing data value.  Vectors with a LENGTH greater
;		than MISSING are ignored.
;
;	LENGTH:	Length factor.  The default of 1.0 makes the longest (U,V)
;		vector the length of a cell.
;
;	DOTS:	Set this keyword to 1 to place a dot at each missing point. 
;		Set this keyword to 0 or omit it to draw nothing for missing
;		points.  Has effect only if MISSING is specified.
;
;	COLOR:	The color index used for the plot.
;
;	Note:   All other keywords are passed directly to the PLOT procedure
;		and may be used to set option such as TITLE, POSITION, 
;		NOERASE, etc.
; OUTPUTS:
;	None.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Plotting on the selected device is performed.  System
;	variables concerning plotting are changed.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Straightforward.  Unrecognized keywords are passed to the PLOT
;	procedure.  
;
; MODIFICATION HISTORY:
;	DMS, RSI, Oct., 1983.
;	For Sun, DMS, RSI, April, 1989.
;	Added TITLE, Oct, 1990.
;	Added POSITION, NOERASE, COLOR, Feb 91, RES.
;	August, 1993.  Vince Patrick, Adv. Visualization Lab, U. of Maryland,
;		fixed errors in math.
;	August, 1993. DMS, Added _EXTRA keyword inheritance.
;	January, 1994, KDB. Fixed integer math which produced 0 and caused
;		            divide by zero errors.
;	December, 1994, MWR. Added _EXTRA inheritance for PLOTS and OPLOT.
;	June, 1995, MWR. Removed _EXTRA inheritance for PLOTS and changed
;			 OPLOT to PLOTS.
;-
;
        on_error,2                      ;Return to caller if an error occurs
        s = size(u)
        t = size(v)
        if s(0) ne 2 then begin 
baduv:   message, 'U and V parameters must be 2D and same size.'
                endif
        if total(abs(s(0:2)-t(0:2))) ne 0 then goto,baduv
;
        if n_params(0) lt 3 then x = findgen(s(1)) else $
                if n_elements(x) ne s(1) then begin
badxy:                  message, 'X and Y arrays have incorrect size.'
                        endif
        if n_params(1) lt 4 then y = findgen(s(2)) else $
                if n_elements(y) ne s(2) then goto,badxy
;
        if n_elements(missing) le 0 then missing = 1.0e30
        if n_elements(length) le 0 then length = 1.0

        mag = sqrt(u^2.+v^2.)             ;magnitude.
                ;Subscripts of good elements
        nbad = 0                        ;# of missing points
        if n_elements(missing) gt 0 then begin
                good = where(mag lt missing) 
                if keyword_set(dots) then bad = where(mag ge missing, nbad)
        endif else begin
                good = lindgen(n_elements(mag))
        endelse

        ugood = u(good)
        vgood = v(good)
        x0 = min(x)                     ;get scaling
        x1 = max(x)
        y0 = min(y)
        y1 = max(y)
	x_step=float(x1-x0)/float(s(1))   ; Convert to float. Integer math
	y_step=float(y1-y0)/float(s(2))   ; could result in divide by 0

	maxmag=max([max(abs(ugood/x_step)),max(abs(vgood/y_step))])
	sina = length * (ugood/maxmag)
	cosa = length * (vgood/maxmag)
;
        if n_elements(title) le 0 then title = ''
        ;--------------  plot to get axes  ---------------
        if n_elements(color) eq 0 then color = !p.color
        x_b0=x0-x_step
	x_b1=x1+x_step
	y_b0=y0-y_step
	y_b1=y1+y_step
        if n_elements(position) eq 0 then begin
          plot,[x_b0,x_b1],[y_b1,y_b0],/nodata,/xst,/yst, $
            color=color, _EXTRA = extra
        endif else begin
          plot,[x_b0,x_b1],[y_b1,y_b0],/nodata,/xst,/yst, $
            color=color, _EXTRA = extra
        endelse
;
        r = .3                          ;len of arrow head
        angle = 22.5 * !dtor            ;Angle of arrowhead
        st = r * sin(angle)             ;sin 22.5 degs * length of head
        ct = r * cos(angle)
;
        for i=0,n_elements(good)-1 do begin     ;Each point
                x0 = x(good(i) mod s(1))        ;get coords of start & end
                dx = sina(i)
                x1 = x0 + dx
                y0 = y(good(i) / s(1))
                dy = cosa(i)
                y1 = y0 + dy
		xd=x_step
		yd=y_step
                plots,[x0,x1,x1-(ct*dx/xd-st*dy/yd)*xd, $
			x1,x1-(ct*dx/xd+st*dy/yd)*xd], $
                      [y0,y1,y1-(ct*dy/yd+st*dx/xd)*yd, $
			y1,y1-(ct*dy/yd-st*dx/xd)*yd], $
                      color=color
                endfor
        if nbad gt 0 then $             ;Dots for missing?
                PLOTS, x(bad mod s(1)), y(bad / s(1)), psym=3, color=color
end
; $Id: vel.pro,v 1.2 1994/07/12 21:30:58 kirk Exp $

function vel_mybi,a,x,y
on_error,2                      ;Return to caller if an error occurs
sizea=size(a)
nx=sizea(1)
i=long(x)+nx*long(y)
q=y-long(y)
p=x-long(x)
q1 = 1.-q
p1 = 1.-p

; Weighting factors were wrong for a(i+1) & a(i+nx), switched them.

aint=p1*q1*a(i) + p*q1*a(i+1) + q*p1*a(i+nx) + p*q*a(i+nx+1)
return,aint
end

PRO ARRHEAD,X

ON_ERROR,2                      ;Return to caller if an error occurs
theta = 30 * !radeg
TANT = TAN(THETA)
NP=3.0
SCAL=8.

SX=SIZE(X)
N=SX(2)


BIGL=SQRT((X(*,N-4,0)-X(*,N-5,0))^2+(X(*,N-4,1)-X(*,N-5,1))^2)
wbigl=where(BIGL ne 0.0)
wnbigl=where(bigl eq 0.0, count)
LL  = SCAL*TANT*BIGL(wbigl)/NP

DX = LL*(X(wbigl,N-4,1)-X(wbigl,N-5,1))/BIGL(wbigl)
DY = LL*(X(wbigl,N-4,0)-X(wbigl,N-5,0))/BIGL(wbigl)

XM = X(wbigl,N-4,0)-(SCAL-1)*(X(wbigl,N-4,0)-X(wbigl,N-5,0))/NP
YM = X(wbigl,N-4,1)-(SCAL-1)*(X(wbigl,N-4,1)-X(wbigl,N-5,1))/NP

X(wbigl,N-3,0) = XM-DX
X(wbigl,N-2,0) = X(wbigl,N-4,0)
X(wbigl,N-1,0) = XM+DX

X(wbigl,N-3,1) = YM+DY
X(wbigl,N-2,1) = X(wbigl,N-4,1)
X(wbigl,N-1,1) = YM-DY

if count ge 1 then begin  ;No head for 0 length
	X(wnbigl,N-3,0) = x(wnbigl,n-4,0)
	X(wnbigl,N-2,0) = X(wnbigl,n-4,0)
	X(wnbigl,N-1,0) = X(wnbigl,n-4,0)
	
	X(wnbigl,N-3,1) = X(wnbigl,N-4,1)
	X(wnbigl,N-2,1) = X(wnbigl,N-4,1)
	X(wnbigl,N-1,1) = X(wnbigl,N-4,1)
	endif

return
END

function arrows,u,v,n,length,nsteps=nsteps
on_error,2                      ;Return to caller if an error occurs
su=size(u)
nx=su(1)
ny=su(2)

lmax=sqrt(max(u^2+v^2))		;Max vector length
lth=1.*length/lmax/nsteps
xt=randomu(seed,n)		;Starting position
yt=randomu(seed,n)
x=fltarr(n,nsteps+3,2)
x(0,0,0)=xt
x(0,0,1)=yt
for i=1,nsteps-1 do begin
 xt(0)=(nx-1)*x(*,i-1,0)
 yt(0)=(ny-1)*x(*,i-1,1)
 ut=vel_mybi(u,xt,yt)
 vt=vel_mybi(v,xt,yt)
 x(0,i,0)=x(*,i-1,0)+ut*lth
 x(0,i,1)=x(*,i-1,1)+vt*lth
end
ARRHEAD,X
return,x<1.0>0.0
end



PRO VEL,U,W,LENGTH=length,XMAX=xmax, nvecs = nvecs, nsteps = nsteps, $
	title = title
;+
; NAME:
;	VEL
;
; PURPOSE:
;	Draw a velocity (flow) field with arrows following the field 
;	proportional in length to the field strength.  Arrows are composed 
;	of a number of small segments that follow the streamlines.
;
; CATEGORY:
;	Graphics, two-dimensional.
;
; CALLING SEQUENCE:
;	VEL, U, V
;
; INPUTS:
;	U:	The X component at each point of the vector field.  This 
;		parameter must be a 2D array.
;
;	V:	The Y component at each point of the vector field.  This 
;		parameter must have the same dimensions as U.
;
; KEYWORD PARAMETERS:
;	NVECS:	The number of vectors (arrows) to draw.  If this keyword is
;		omitted, 200 vectors are drawn.
;
;	XMAX:	X axis size as a fraction of Y axis size.  The default is 1.0.
;		This argument is ignored when !p.multi is set.
;
;	LENGTH:	The length of each arrow line segment expressed as a fraction 
;		of the longest vector divided by the number of steps.  The 
;		default is 0.1.
;
;	NSTEPS:	The number of shoots or line segments for each arrow.  The
;		default is 10.
;
;	TITLE:	A string containing the title for the plot.
;	
; OUTPUTS:
;	No explicit outputs.  A velocity field graph is drawn on the current
;	graphics device.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A plot is drawn on the current graphics device.
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
;	NVECS random points within the (u,v) arrays are selected.
;	For each "shot" the field (as bilinearly interpolated) at each
;	point is followed using a vector of LENGTH length, tracing
;	a line with NSTEPS segments.  An arrow head is drawn at the end.
;
; MODIFICATION HISTORY:
;	12/2/92	- modified to handle !p.multi (jiy-RSI)
;	Neal Hurlburt, April, 1988.
;       7/12/94 HJM - Fixed error in weighting factors in function
;                     vel_mybi() which produced incorrect velocity vectors.
;
;-

on_error,2                      ;Return to caller if an error occurs
if n_elements(Nvecs) le 0 then nvecs=200
if n_elements(nsteps) le 0 then nsteps = 10
if n_elements(length) le 0 then length=.1
if n_elements(title) le 0 then title='Velocity Field'
X=ARROWS(U,W,Nvecs,LENGTH, nsteps = nsteps)

if (!p.multi(1) eq 0 and !p.multi(1) eq 0) then begin
   if (n_elements(xmax) eq 0) then xmax = 1.0
   IF XMAX GT 1. THEN position=[0.20,(0.5-0.30/XMAX),0.90,(0.5+0.40/XMAX)]$
      else position=[(0.5-0.30*XMAX),0.20,(0.5+0.40*XMAX),0.90]
   plot,[0,1,1,0,0],[0,0,1,1,0],title=title,pos=position
endif else begin
   plot,[0,1,1,0,0],[0,0,1,1,0],title=title
endelse

FOR I=0,Nvecs-1 DO PLOTS,X(I,*,0),X(I,*,1)
RETURN
end
; $Id: vert_t3d.pro,v 1.1 1994/04/05 17:22:10 dan Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       VERT_T3D
;
; PURPOSE:
;       This function tranforms 3-D points by a 4x4 transformation matrix.
;       The 3-D points are typically an array of polygon vertices that were
;       generated by SHADE_VOLUME or MESH_OBJ.
;
; CATEGORY:
;       Graphics.
;
; CALLING SEQUENCE:
;       result = VERT_T3D(vertex_list)
;
; INPUTS:
;       Vertex_List:
;               A vector of the form [x, y, z], or a (3, n) array of 3-D
;               coordinates to transform.
;
; KEYWORD PARAMETERS:
;
;       Matrix:
;               The 4x4 transformation matrix to use. The default is to use
;               the system viewing matrix (!P.T). (See the "T3D" procedure). 
;
;       No_Copy:
;               Normally, a COPY of Vertex_List is transformed and the
;               original vertex_list is preserved. If No_Copy is set, however,
;               then the original Vertex_List will be undefined AFTER the call
;               to VERT_T3D. Using the No_Copy mode will require less memory.
;
;       No_Divide:
;               Normally, when a [x, y, z, 1] vector is transformed by a 4x4
;               matrix, the final homogeneous coordinates are obtained by
;               dividing the x, y, and z components of the result vector by
;               the fourth element in the result vector. Setting the No_Divide
;               keyword will prevent VERT_T3D from performing this division.
;               In some cases (usually when a perspective transformation is
;               involved) the fourth element in the result vector can be very
;               close to (or equal to) zero.
;
;       Save_Divide:
;               Set this keyword to a named variable to receive the fourth
;               element of the transformed vector(s). If Vertex_List is a
;               vector then Save_Divide is a scalar. If Vertex_List is a
;               (3, n) array then Save_Divide is an array of n elements.
;               This keyword only has effect when the No_Divide keyword is set.
;
; OUTPUTS:
;       This function returns the transformed coordinate(s). The returned
;       array has the same size and dimensions as Vertex_List.
;
; PROCEDURE:
;       Before performing the transformation, the (3, n) Vertex_List is padded
;       to produce a (4, n) array with 1's in the last column. After the
;       transformation, the first three columns of the array are divided by
;       the fourth column (unless the No_Divide keyword is set). The fourth
;       column is then stripped off (or saved in the Save_Divide keyword)
;       before returning.
;
; EXAMPLE:
;       Transform four points representing a square in the x-y plane by first
;       translating +2.0 in the positive X direction, and then rotating 60.0
;       degrees about the Y axis.
;
;               points = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], $
;                         [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]
;               T3d, /Reset
;               T3d, Translate=[2.0, 0.0, 0.0]
;               T3d, Rotate=[0.0, 60.0, 0.0]
;               points = VERT_T3D(points)
;
; MODIFICATION HISTORY:
;       Written by:     Daniel Carr, Thu Mar 31 15:58:07 MST 1994
;-

FUNCTION VERT_T3D, vertex_list, Matrix=matrix, No_Copy=no_copy, $
                   No_Divide=no_divide, Save_Divide=save_divide

sz_vertex = Size(vertex_list)
n_verts = sz_vertex(2)

IF (N_Elements(matrix) LE 0L) THEN matrix = !P.T

IF (Keyword_Set(no_copy)) THEN BEGIN
   ret_list = Transpose( $
      Transpose([Temporary(vertex_list), Replicate(1.0, 1L, n_verts)]) # matrix)
ENDIF ELSE BEGIN
   ret_list = $
      Transpose(Transpose([vertex_list, Replicate(1.0, 1L, n_verts)]) # matrix)
ENDELSE

IF (Keyword_Set(no_divide)) THEN BEGIN
   save_divide = ret_list(3, *)
   RETURN, [ret_list(0, *), ret_list(1, *), ret_list(2, *)]
ENDIF ELSE $
   RETURN, [(ret_list(0, *) / ret_list(3, *)), $
            (ret_list(1, *) / ret_list(3, *)), $
            (ret_list(2, *) / ret_list(3, *))]
END
; $Id: voronoi.pro,v 1.5 1995/03/01 23:59:02 dave Exp $

function isright, x0, y0, x1, y1, x2, y2 
; return 1 if Pnt0 is to right of Pnt1-> Pnt2
; return 0 if it is on the line.
; return -1 if Pnt0 is to the left of Pnt1 -> Pnt2

z = (x0-x1) * (y2-y1) - (y0-y1) * (x2-x1)
if z gt 0.0 then return, 1
if z lt 0.0 then return, -1
return, 0
end


PRO voronoi_get_intersect, rect, x0, y0, dx, dy, xi, yi, nedge
;  Return the closest intersection of the line thru (x0, y0), with
;	slope (dx / dy), and the rectangle rect.  The intersection must
;	be in the "positive" direction.
;	Set (xi, yi) to the intersection point, and 
;	nedge to the edge index.  Edge 0 is the bottom, going CCW.
;
nedge = -1
tmin = 0.

if dy ne 0.0 then begin
    t = (rect(1) - y0) / dy	;Bottom = edge 0?
    if t ge 0.0 then begin
	tmin = t
	nedge = 0
	yi = rect(1)		;Intersection with bottom
	xi = x0 + t * dx
	endif
    t = (rect(3) - y0) / dy	;Top edge = 2
    if t ge 0.0 then $
      if (nedge lt 0) or (t lt tmin) then begin
	tmin = t
	nedge = 2
	yi = rect(3)
	xi = x0 + t * dx
	endif
endif				;dy ne 0

if dx ne 0.0 then begin		;Check sides?
    t = (rect(0) - x0) / dx	;Left edge = 3
    if t ge 0.0 then $
       if (nedge lt 0) or (t lt tmin) then begin
	tmin = t
	nedge = 3
	xi = rect(0)
	yi = y0 + t * dy
	endif
    t = (rect(2) - x0) / dx	;Right edge = 1
    if t ge 0.0 then $
       if (nedge lt 0) or (t lt tmin) then begin
	tmin = t
	nedge = 1
	xi = rect(2)
	yi = y0 + t * dy
	endif
endif				;Dx ne 0
end




pro VORONOI_SHOW, n		;Illustrate using and drawing Voronoi polygons
; This procedure generates N random points (default = 12).
;	and then draws the voronoi polygons, with the points and
;	delaunay triangulation overlaid.

if n_elements(n) le 0 then n = 12	;Make the random points
seed = 1211567L
x = randomu(seed, n)
y = randomu(seed, n)

triangulate, x, y, tr, CONN=c		;Triangulate them
plot,x,y,/psym, xrange=[-.5,1.5], yrange=[-.5,1.5]
tek_color				;Discrete color tables.
range = 0				;Init bounding rectangle

for i=0, n-1 do begin		;Each VORONOI region for each point
	voronoi, x, y, i, c, xp, yp, range	  ;Get the ith polygon
	xp = xp > (-10) < 10		;Clip to reasonable space
	yp = yp > (-10) < 10
	polyfill, xp, yp, color = (i mod 13) + 2	;Show it
	endfor

oplot,x,y,/psym, color=1		;Show points & triangulation
for i=0, n_elements(tr)/3-1 do begin	;The triangles
	t = [tr(*,i),tr(0,i)]		;Subscripts of triangle & back to 0
	plots,x(t), y(t)
	endfor
end



PRO voronoi, x, y, i0, c, xp, yp, rect
; Copyright (c) 1992, Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	VORONOI
;
; PURPOSE:
;	This procedure computes the Voronoi polygon of a point within
;	an irregular grid of points, given the Delaunay triangulation.
;	The Voronoi polygon of a point contains the region closer to
;	that point than to any other point.
;
; CATEGORY:
;	Gridding.
;
; CALLING SEQUENCE:
;	VORONOI, X, Y, I0, C, Xp, Yp, Rect
;
; INPUTS:
;	X:	An array containing the X locations of the points.
;	Y:	An array containing the Y locations of the points.
;	I0:	Index of the point of which to obtain the Voronoi polygon.
;	C:	A connectivity list from the Delaunay triangulation.
;		This list is produced with the CONNECTIVITY keyword
;		of the TRIANGULATE procedure.
;	Rect	the bounding rectangle:  [Xmin, Ymin, Xmax, Ymax].
;		Because the Voronoi polygon (VP) for points on the convex hull
;		extends to infinity, a clipping rectangle must be supplied to
;		close the polygon.  This rectangle has no effect on the VP of
;		interior points.  If this rectangle does not enclose all the
;		Voronoi vertices, the results will be incorrect.  If this
;		parameter, which must be a named variable, is undefined or
;		set to a scalar value, it will be calculated.
;
; OUTPUTS:
;	Xp, Yp:	The vertices of voroni polygon, VP.
;
; RESTRICTIONS:
;	The polygons only cover the convex hull of the set of points.
;
; PROCEDURE:
;	For interior points, the polygon is constructed by connecting
;	the midpoints of the lines connecting the point with its Delaunay
;	neighbors. Polygons are traversed in a counterclockwise direction.
;
;	For exterior points, the set described by the midpoints of the
;	connecting lines, plus the circumcenters of the two triangles
;	that connect the point to the two adjacent exterior points.
;
; EXAMPLE:
;	See the example procedure, VORONOI_SHOW, contained in this file.
;	To illustrate Voronoi polygons, after compiling this file (voronoi):
;		VORONOI_SHOW, Npoints  (try anywhere from 3 to 1000, default=12)
;
;	To draw the voroni polygons of each point of an irregular 
;	grid:
;	  x = randomu(seed, n)			 ;Random grid of N points
;	  y = randomu(seed, n)
;	  triangulate, x, y, tr, CONN=c			  ;Triangulate it
;	  rect = 0
;	  for i=0, n-1 do begin
;		voronoi, x, y, i, c, xp, yp, rect	  ;Get the ith polygon
;		polyfill, xp, yp, color = (i mod 10) + 2  ;Draw it
;		endfor
;
; MODIFICATION HISTORY:
;	DMS, RSI.	Dec, 1992. Original version.
;	DMS, RSI	Feb, 1995. Added bounding rectangle which simplified
;				   logic and better illustrated VPs for points
;				   on the convex hull.
;-
COMMON VORONOI_COMMON, first	;Only print warning once.

if n_params() lt 7 and n_elements(first) le 0 and !quiet eq 0 then begin
  Message, /INFO, 'New revision. For more efficient use, supply the Rect parameter'
  first = 1
  endif

p = c(c(i0):c(i0+1)-1)  	;Verts of polygon
np = n_elements(p)
xp = fltarr(np, /NOZERO)
yp = fltarr(np, /NOZERO)
ext = i0 eq p(0)		;True if exterior point

; Each vertex is simply the circumcenter of a Delaunay triangle
; 		containing the point in question.
for i=0, np-1 do begin		;Traverse adjacency list for point i0.
    m = p(i)
    j = p((i + 1) mod np)	;Successor
    cir_3pnt, x([m,j,i0]), y([m,j,i0]), r, x0, y0
    xp(i) = x0
    yp(i) = y0
    endfor

if ext eq 0 then return	;If interior point, we're all done....

;	*** Point is on the Convex Hull ****
if n_elements(rect) ne 4 then begin  ;Initialize bounding rect?
    i1 = i0			;Follow boundary CCW
    xmin = min(x, max=xmax)
    ymin = min(y, max=ymax)
    xr = (xmax-xmin)*.05	;Fudge factor of 5%
    yr = (ymax-ymin)*.05
    rect = [xmin-xr, ymin-yr, xmax+xr, ymax+yr]  ;Initial bound box
    repeat begin		;Get circumctr of each boundary triangle
	k = c(i1)
	m = c(k+1)
	j = c(k+2)
	cir_3pnt, x([m,j,i1]), y([m,j,i1]), r, x0, y0
	rect(0) = rect(0) < x0
	rect(2) = rect(2) > x0
	rect(1) = rect(1) < y0
	rect(3) = rect(3) > y0	;Keep extremes
	i1 = m			;Next boundary point
	endrep until i1 eq i0
    endif
    
;	Now get intersections of perpendicular  bisectors of the two edges
;	on the convex hull, with vertex point i0, with the bounding rectangle.
;
j = p(1)
voronoi_get_intersect, rect, xp(1), yp(1), y(j)-y(i0), x(i0)-x(j), x0, y0, edge0
xp(0) = x0
yp(0) = y0
j = p(np - 1)
voronoi_get_intersect, rect, xp(np-2), yp(np-2), y(i0)-y(j), x(j)-x(i0), $
	x0, y0, edge1
xp(np-1) = x0
yp(np-1) = y0

if (edge0 < edge1) lt 0 then begin   ;Either out of bounds?
    MESSAGE, /INFO, 'Bounding rectangle does not enclose Voronoi polygon'
    xp(0) = xp(1)		;Fudge polygon, its wrong anyway...
    yp(0) = yp(1)
    xp(np-1) = xp(np-2)
    yp(np-1) = yp(np-2)
    return
endif

while edge1 ne edge0 do begin		;Add corner(s) of bound rect if necess.
    edge1 = (edge1 + 1) mod 4		;Go CCW
    xp = [xp, rect(([0,2,2,0])(edge1))]
    yp = [yp, rect(([1,1,3,3])(edge1))]
    endwhile
return
end
; $Id: warp_tri.pro,v 1.3 1994/02/28 16:16:57 dave Exp $

function warp_tri, xo, yo, xi, yi, im_in, OUTPUT_SIZE = output_size, $
	QUINTIC = quintic, EXTRAPOLATE = extra
; xo, yo = coordinates of tie points in output image.
; xi, yi = coordinates of tie points in im_in.
;+
; NAME:
;	WARP_TRI
;
; PURPOSE:
;	This function warps images using control (tie) points.
;
; CATEGORY:
;	Image processing, geometric transformation.
;
; CALLING SEQUENCE:
;	Result = WARP_TRI(Xo, Yo, Xi, Yi, Im_in)
;
; INPUTS:
;	Xo, Yo:	     Vectors containing the locations of the tie points
;		     in the output image.
;	Xi, Yi:	     Vectors containing the location of the tie points
;		     in the input image (Im_in). Xi, Yi must be the same
;		     length as Xo, Y0.
;	Im_in:	     The image to be warped. May be any type of data.
;
; KEYWORD PARAMETERS:
;	OUTPUT_SIZE: A 2-element vector containing the size of the
;		     output image. If omitted, the output image is the
;		     same size as Im_in.
;	QUINTIC:     Set this keyword to use smooth quintic interpolation.
;		     Quintic interpolation is slower but the
;		     derivatives are continuous across triangles,
;		     giving a more pleasing result than the default
;		     linear interpolation. 
;	EXTRAPOLATE: Set to true to extrapolate outside the convex
;		     hull of the tie points. Setting this keyword implies
;		     the use of QUINTIC interpolation.
;
; OUTPUTS:
;	This function returns an image array with the specified
;	geometric correction applied. Points at locations (Xi, Yi)
;	are shifted to (Xo, Yo).
;
; PROCEDURE:
;	The irregular grid defined by (Xo, Yo) is triangulated
;	using TRIANGULATE. Then the surfaces defined by (Xo, Yo, Xi)
;	and (Xo, Yo, Yi) are interpolated using TRIGRID to get
;	the locations in the input image of each pixel in the output
;	image. Finally, INTERPOLATE is called to obtain the result.
;	Linear interpolation is used by default.  Smooth quintic
;	interpolation is used if the QUINTIC keyword is set.
;
; MODIFICATION HISTORY:
;	DMS, Jan, 1992.
;	DMS, Jul, 1992, added quintic interpolation.
;-

s = SIZE(im_in)
if s(0) ne 2 then MESSAGE, 'Warp_tri - Im_in param must be 2D'

TRIANGULATE, xo, yo, tr, bounds

if n_elements(output_size) ge 2 then begin
	nx = output_size(0)
	ny = output_size(1)
endif else begin
	nx = s(1)
	ny = s(2)
endelse

gs = [1,1]				;Grid spacing
b = [0,0, nx-1, ny-1]			;Bounds

; This style is called early schizophrenic capitalization.

if KEYWORD_SET(extra) then $
	return, INTERPOLATE(im_in,  $
	  TRIGRID(xo,yo,xi,tr, gs, b, /QUINT, EXTRA = bounds), $
	  TRIGRID(xo,yo,yi,tr, gs, b, /QUINT, EXTRA = bounds))$
ELSE $
	return, INTERPOLATE(im_in, $
	  TRIGRID(xo,yo,xi,tr, gs, b, QUINT=KEYWORD_SET(quintic)), $
	  TRIGRID(xo,yo,yi,tr, gs, b, QUINT=KEYWORD_SET(quintic)))
end

; $Id: wf_draw.pro,v 1.2 1993/10/06 18:34:31 doug Exp $
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	WF_DRAW
;
; PURPOSE:
;	This procedure draws weather fronts of various types with
;	spline smoothing.
;
; CATEGORY:
;	Meterology.
;
; CALLING SEQUENCE:
;	WF_DRAW, X, Y
;
; INPUTS:
;  	X, Y:        Vectors of abcissae and ordinates defining the
;		     front to be drawn.
;
; KEYWORD PARAMETERS:
;  	COLD:	     A cold front. The default is a plain line with
;		     no annotations.
;  	WARM:	     A warm front.
;  	OCCLUDED:    An occluded front.
;  	STATIONARY:  A stationary front.
;  	CONVERGENCE: A convergence line.
;  	FRONT_TYPE:  Index of type of front to draw, COLD=1, WARM=2, etc.
;		     Not required if plain line is desired or if an
;		     explicit front type keyword is specified.
;  	THICK:	     Line thickness. The default = 1.0.
;  	INTERVAL:    The spline interpolation interval, in normalized
;		     units. The default = 0.01. Larger values give coarser
;		     approximations to curves, smaller values make more
;		     interpolted points.
;  	COLOR:       The color to use. The default = !P.COLOR.
;  	DEVICE:      If set, X and Y are in device coordinates.
;  	DATA:        If set, X and Y are in data coordinates.
;  	NORM:	     If set, X and Y are in normalized coordinates.
;		     This is the default.
;  	PSYM:	     If set, draw a marker (index = PSYM) on each actual
;		     (X, Y) data point.
;  	SYM_LEN:     The length and spacing factor for front symbols,
;		     in normalized units. The default = 0.15.
;  	SYM_HT:      The height of front symbols, in normalized units.
;		     The default = 0.02.
;
; OUTPUTS:
;	No explicit outputs.
;
; SIDE EFFECTS:
;	Draws objects on current graphics device.
;
; PROCEDURE:
;	Uses parametric spline interpolation to smooth the lines.
;	POLYFILL is used to make the annotations on the front lines.
;
; EXAMPLE:
;	Draw a front given 3 points:
;	  WF_DRAW, [40, 20, 40], [30, 40, 25], /DATA, /COLD
;
; MODIFICATION HISTORY:
;	DMS, RSI.   August, 1993.  Written.
;-


PRO SPLINE_INTERP, x, y, xp, yp, INTERVAL=interval, TORIG = t, TSPLINE=tt
; Interpolate the points X(i),Y(i) using cubic spline interpolation,
;	returning the result in xp, yp.
; Try to make the distance between the resulting points
; approximately equal to INTERVAL.


	;Basic interval, in normalized coords.
if N_ELEMENTS(interval) le 0 then interval = .01
n = n_elements(x)
t = sqrt((x-shift(x,1))^2 + (y-shift(y,1))^2)	;Parametric variable
t(0) = 0.0
r = ceil(t/interval)		;# of pnts for each interv
tt = fltarr(total(r)+1, /nozero)
j = 0L
for i=1, n-1 do begin		;Each interval
    k = long(r(i))		;# of points in this interval
    tt(j) = findgen(k)*(t(i)/k) + t(i-1)  ;Parameteric variable
    t(i) = t(i) + t(i-1)	;Cumulative t value
    j = j + k
    endfor
tt(j) = t(n-1)			;Last t.
xp = SPLINE(t,x,tt)		;Now use SPLINE function
yp = SPLINE(t,y,tt)
end



pro wf_draw, x, y, FRONT_TYPE = pat, COLD=cold, WARM=warm, $
	OCCLUDED=occluded, STATIONARY=stationary, $
	CONVERGENCE=CONVERGENCE, THICK=thick, INTERVAL=interval, $
	COLOR = c, DEVICE = device, DATA = data, NORMAL = normal, $
	PSYM = psym, SYM_LEN = slen, SYM_HT = sht
;

if n_elements(interval) le 0 then interval = 0.01	;Default norm interval
if n_elements(c) eq 0 then c = !p.color
if n_elements(thick) eq 0 then thick = 0.0

if n_elements(pat) le 0 then pat = 0	;Default pattern = none
if keyword_set(COLD) then pat = 1 else $
if keyword_set(warm) then pat = 2 else $
if keyword_set(occluded) then pat = 3 else $
if keyword_set(stationary) then pat = 4 else $
if keyword_set(convergence) then pat = 5

if keyword_set(data) then xp = convert_coord(x,y,/data, /to_norm) $
else if keyword_set(device) then xp = convert_coord(x,y,/device, /to_norm) $
else xp = convert_coord(x,y,/norm, /to_norm)

if n_elements(x) gt 2 then $	;Enough to interpolate?
	spline_interp, xp(0,*), xp(1,*), xs, ys, INTERVAL=interval $
else begin
	xs = xp(0,*)
	ys = xp(1,*)
endelse


;	Length of basic pattern in normalized units.
if n_elements(slen) le 0 then patlen = 0.15 else patlen = slen
;	Pattern height (distance from line)
if n_elements(sht) le 0 then sht = 0.02

PLOTS, xs, ys, thick=thick, COLOR = c, /NORM	;Draw basic line.

pxt = [0, .2, .4]	;Triangle pattern, occupies .4 of each pattern interval
pyt = [0, 1., 0.]
			;half-circle pattern
pxc = [ 0.00, 0.0666667, 0.133333, 0.200, 0.266667, 0.333333,  0.400] ;t
pyc = [ 0.0, 0.50,  0.866,  1.0, 0.866, 0.5, 0.]	;Approx sin(t)

case pat of
1:   BEGIN			;Cold = triangles
	px = pxt * patlen
	py = pyt * sht
	goto, draw_polys
    ENDCASE
2:   BEGIN			;Warm = half circles.
	px = pxc * patlen
	py = pyc * sht
	goto, draw_polys
    ENDCASE
3:   BEGIN			;occlud = alternate tris, circles, same side
	px = [pxt, pxc + 0.45] * patlen
	py = [pyt, pyc] * sht
	goto, draw_polys
    ENDCASE
4:   BEGIN			;stationary = alt circ, triangs, alt sides
	px = [pxt, pxc + 0.45] * patlen
	py = [pyt, -pyc] * sht
	goto, draw_polys
    ENDCASE
5:   BEGIN			;converg = hash marks
	px = [0., .2, .25, .4] * patlen
	py = [0,1,0,-1.] * sht
	patlen = patlen / 2.	;Half as long

draw_polys:
	dx = xs(1:*)-xs		;Dx(i) = x(i+1) - x(i)
	dy = ys(1:*)-ys		;Get derivatives
	dt = sqrt(dx^2 + dy^2)	;Distance between points
	dx = dx / dt
	dy = dy / dt
	nt = n_elements(dt)
	tt = fltarr(nt+1)	;Cumulative distance
	for i=1, nt do tt(i) = tt(i-1) + dt(i-1) ;cumulative t

	t = 0.0			;Pattern start
	l = 0L			;Subscript in dx,dy,dt.
	n = n_elements(px)
	n2 = 2 * n
	xp = fltarr(n2)		;Vertices of polygons
	yp = fltarr(n2)
	tend = tt(nt)

	while t lt tend do begin
	    tx = t + px		;Parameteric values
	    for i=0,n-1 do begin
		if tx(i) ge tend then begin
		    x0 = xs(nt)
		    y0 = ys(nt)
		    xp(i) = x0
		    yp(i) = y0
		endif else begin		    
		    while tt(l) lt tx(i) do l=l+1L  ;Straddle
		    l1 = l-1L > 0L		;tt(l1) < tx(i) <= tt(l)
		    p0 = (tx(i) - tt(l1))/dt(l1)	;Interpol fract
		    x0 = xs(l1) + p0 * (xs(l) - xs(l1))  ;Point on front line
		    y0 = ys(l1) + p0 * (ys(l) - ys(l1))
		    xp(i) = x0 - py(i) * dy(l1)   ;Rotate 90 for symbol pnt
		    yp(i) = y0 + py(i) * dx(l1)
		    endelse
		k = n2-i-1
		xp(k) = x0		;Baseline for return
		yp(k) = y0
		endfor
	    if pat eq 5 then begin	;Special case for convergence
		plots, xp(0:1), yp(0:1), color=c, thick=thick, /NORM
		plots, xp(2:3), yp(2:3), color=c, thick=thick, /NORM
	    endif $
	    else polyfill, xp, yp, color=c, /NORM  ;Otherwise fill polygon
	    t = t + patlen
	endwhile
    ENDCASE	    
else: q=0
endcase

if n_elements(psym) gt 0 then begin	;Mark data points?
    if n_elements(xp) gt 0 then PLOTS, xp, /NORM, PSYM=psym, COLOR=c $
	else PLOTS, x,y, /NORM, PSYM=psym, COLOR=c
    endif
end



pro test_wf_draw
map_set, limit = [25, -125, 50, -70], /grid, /usa
wf_draw, [ -120, -110, -100], [30, 50, 45], /COLD, /DATA, THICK=2
wf_draw, [ -80, -80, -75], [ 50, 40, 35], /WARM, /DATA, THICK=2
wf_draw, [ -80, -80, -75]-10., [ 50, 40, 35], /OCCLUDED, /DATA, THICK=2
wf_draw, [ -120, -105], [ 40,35], /STATION, /DATA, THICK=2
wf_draw, [ -100, -90, -90], [ 30,35,40], /CONVERG, /DATA, THICK=2

names = ['None','Cold', 'Warm', 'Occluded', 'Stationary', 'Convergent']
x = [.015, .30]
y = 0.04
dy = 0.05
ty = n_elements(names) * dy + y
polyfill, x([0,1,1,0]), [0, 0, ty, ty], /NORM, color=!p.background
for i=0, n_elements(names)-1 do begin
	wf_draw, x, y, /NORM, FRONT_TYPE=i, THICK=2
	xyouts, x(1)+0.015, y(0), names(i), /NORM, CHARS=1.5
	y = y + dy
	endfor
end
;
; $Id: widalloc.pro,v 1.7 1994/06/01 23:08:48 ali Exp $
;
;  WidAlloc
;   Widget Editor allocation related routines.
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;



;
;  Destroy
;   Generic function to cause an object to delete itself from memory.
;   This is assumed to be recursive (objects containing other objects
;   should destroy their children as well).
;
PRO Destroy, Ptr

    ;   An invalid pointer is considered to be already destroyed
    ;   Not much we could do anyway.
    IF WIDGET_INFO(Ptr, /VALID_ID) EQ 0 THEN RETURN

    ;   Figure out the class specific routine name and call it
    GetType, Ptr, Type
    CALL_PROCEDURE,Type+"_Destroy",Ptr
END


;
;  GenDestroy
;   Generic Object destruction routine.
;
PRO GenDestroy, Ptr, HASVALUE=HasValue
    Ptr2Obj, Ptr, Obj

    IF N_ELEMENTS(Obj) EQ 0 THEN RETURN

    IF KEYWORD_SET(HasValue) THEN $
        WIDGET_CONTROL, Obj.Value1, /DESTROY    ; Destroy value contents

    IF WIDGET_INFO(Obj.Dialog, /VALID) THEN $   ; Destroy dialog box
        WIDGET_CONTROL, Obj.Dialog, /DESTROY

    WIDGET_CONTROL, Ptr, /DESTROY               ; Release pointer memory
    ;   Object is in local variable and goes away as we return
END


;
;  GenCopy
;   Copy an object.  2 copy methods:
;
;   if( copy != NULL)       { *copy = *ptr; free(ptr); }
;   else                    { *(copy = malloc(...)) = *ptr; }
;
PRO GenCopy, Ptr, Copy, HASVALUE=HasValue
  COMMON WidEd_Comm

    IF KEYWORD_SET(Copy) THEN BEGIN     ; Copy is already allocated

        Ptr2Obj, Copy, ThrowAway        ; Release current copy contents

        IF KEYWORD_SET(HasValue) THEN $
            WIDGET_CONTROL, ThrowAway.Value1, /DESTROY  ; Destroy value too

        Ptr2Obj, Ptr, Obj               ; Remove object from original pointer
        Obj2Ptr, Obj, Copy              ; Store in copy pointer
        WIDGET_CONTROL, Ptr, /DESTROY   ; Release original pointer memory

    ENDIF ELSE BEGIN

        Ptr2Obj, Ptr, Obj, /COPY        ; Make a copy of ptr contents

        IF KEYWORD_SET(HasValue) THEN $
            Ptr2Obj, Obj.Value1, Value1, /COPY  ; Get copy of value1 contents

        Copy    = WIDGET_BASE(GROUP=TopDlg)     ; Make a new pointer

        IF KEYWORD_SET(HasValue) THEN BEGIN
            Obj.Value1  = WIDGET_BASE(GROUP=TopDlg) ; New ptr for value
            IF N_ELEMENTS(Value1) NE 0 THEN $
                Obj2Ptr, Value1, Obj.Value1     ; Save value
        ENDIF

        Obj.Id  = NewId()
        Obj2Ptr, Obj, Copy              ; Store copy into new pointer

    ENDELSE
END


;
;  Ptr2Obj
;   Pointers are really unrealized base widget objects and the
;   contents are their UVALUEs.  In general, copying structures is
;   an expensive operation so the default is to REMOVE the UVALUE
;   from the pointer.  This is much faster.  Note that is has the
;   side effect that the pointer is no longer valid (has no object
;   in it).
;
PRO Ptr2Obj, Ptr, Obj, COPY=Copy
    WIDGET_CONTROL, Ptr, GET_UVALUE=Obj, NO_COPY=(1 - KEYWORD_SET(Copy))
END


;
;  Obj2Ptr
;   The reverse of Ptr2Obj.  Place the given object (as a UVALUE) into
;   the given pointer (unrealized base widget).  Copy the value if
;   explicitly requested, otherwise the Object given us will no longer
;   contain a value upon return from this function.
;
PRO Obj2Ptr, Obj, Ptr, COPY=Copy
    WIDGET_CONTROL, Ptr, SET_UVALUE=Obj, NO_COPY=(1 - KEYWORD_SET(Copy))
END


;
;  NextPtr
;   Returned the contents of the .Next field of an object.  All objects
;   must have a .Next field.
;
FUNCTION NextPtr, Ptr
    Ptr2Obj, Ptr, Obj
    Next    = Obj.Next
    Obj2Ptr, Obj, Ptr
    RETURN, Next
END


;
;  AddChild
;       Add an object to a base object.
;
;   NO_UPDATE -- If set, DONT call the routine to update the Cut/Copy/Paste
;           dialog boxes.  Set when adding multiple objects (as in File Open)
;
;   NO_CANCEL -- If set the object is not added to the Active dialog
;           list.  This is done for base objects (Base Object Dialog boxes
;           have no CANCEL button) and should be done for any object class
;           which can not/should not be removed.
;
PRO AddChild, Parent, Child, NO_UPDATE=NoUpdate, NO_CANCEL=NoCancel

  COMMON WidEd_Comm

    ;   Set Parent Ptr in child
    SetTag, Child, "Parent", Parent

    ;   Get the Parent object structure
    Ptr2Obj, Parent, PObj

    ;   First Child ? Set parent child list.
    ;   Else last child in list now has a next child
    ;
    IF PObj.Children EQ 0 THEN PObj.Children    = Child $
    ELSE SetTag, PObj.LastChild, "Next", Child

    ;   Remember the last child
    PObj.LastChild  = Child

    Obj2Ptr, PObj, Parent       ; Restore structure into parent pointer

    ;   Add to active dialog list so we can delete it in the event
    ;   user CANCELs addition.
    IF KEYWORD_SET(NoCancel) EQ 0 THEN BEGIN
        NewDialogs  = [ NewDialogs, { WE_NEWOBJ, Parent, Child, 0L } ]
    ENDIF

    ;   Update Cut/Copy/Paste/Edit Dialog boxes
    IF KEYWORD_SET(NoUpDate) EQ 0 THEN UpdateEdit

    ;   Note that the object tree has been altered.
    Dirty   = 1
END


;
;  Cancel
;   Common routine to handle the 'CANCEL' button on dialog boxes.
;   This performs 2 separate actions depending upon what has happened
;   so far:
;
;   If the object has been added but never realized (no Rebuild) then
;   OldPtr is NULL and there is no state to revert the widget to.
;   Otherwise, we have a copy of the widgets previous state and we
;   restore it instead of deleting it.
;
;   Note: The object information has already been pulled out of the pointer
;   so we need both to be passed in.
;
PRO Cancel, Obj, Ptr

  COMMON WidEd_Comm    

    Type    = Obj.Type      ; Get the type
    Dialog  = Obj.Dialog    ; Get the Dialog Box widget Id.
    Obj2Ptr, Obj, Ptr       ; Stick Object back into pointer so that
                            ; other routines can access object via its ptr

    ;   See if this object can be cancelled. Should always be found.
    ;   In fact we display an error message if we don't

    Idx = WHERE(NewDialogs.ObjPtr EQ Ptr, Count)

    IF Count NE 1 THEN ErrorDialog, TopDlg, $
        "Internal Error: CANCEL'ed widget could not be found"

    ;   Do we have an previous version of this widget to revert to?

    Idx = Idx(0)
    IF NewDialogs(Idx).OldPtr NE 0L THEN BEGIN

        ;   Call class specific copy routine to revert object to
        ;   its previous state:  *ObjPtr = *OldPtr

        CALL_PROCEDURE, Type + "_Copy", NewDialogs(Idx).OldPtr, $
                    NewDialogs(Idx).ObjPtr
        WIDGET_CONTROL, Dialog, /DESTROY    ; Take down dialog box

    ENDIF ELSE BEGIN

        ;   This is more difficult.  Remove the object from its
        ;   parent's list of children

        ParPtr  = NewDialogs(Idx).ParPtr        ; Get Parent Object
        Ptr2Obj, ParPtr, ParObj

        ;   Is it the first child?
        IF ParObj.Children EQ Ptr THEN BEGIN
            ParObj.Children = NextPtr(Ptr)

            ;   Was it an only child?
            IF ParObj.LastChild EQ Ptr THEN ParObj.LastChild = ParObj.Children

        ENDIF ELSE BEGIN


            PrevPtr = ParObj.Children           ; Run down the list of children
            CurrPtr = NextPtr(PrevPtr)          ; until we find the child in
            NxtPtr  = NextPtr(Ptr)              ; question. Keep track of the
            WHILE CurrPtr NE Ptr DO BEGIN       ; previous child.
                PrevPtr = CurrPtr
                CurrPtr = NextPtr(CurrPtr)
            ENDWHILE

            ; Unlink the deleted child from the list of children
            ; If it was the last child of the parent object then set
            ; the LastChild field to the new last child.
            SetTag, PrevPtr, "Next", NxtPtr
            IF ParObj.LastChild EQ Ptr THEN ParObj.LastChild = PrevPtr

        ENDELSE

        Obj2Ptr, ParObj, ParPtr     ; Restore Parent pointer

        ;   The child has been removed from the object tree. Delete
        ;   the child.
        CALL_PROCEDURE, Type + "_Destroy", Ptr  ; Destroy Object
    ENDELSE

    ;   Now we have to remove the deleted object from the list
    ;   of objects with active dialog boxes.

    N   = N_ELEMENTS(NewDialogs)
    IF Idx(0) EQ N-1 THEN $                 ; Last active object?
        NewDialogs  = NewDialogs(0:N-2) $
    ELSE $
        NewDialogs  = [ NewDialogs(0:Idx-1), NewDialogs(Idx+1,*) ]
    UpdateEdit
END


;
;  Accept
;   The user has pressed the 'DONE' button or just closed the dialog
;   box via the window manager menu Close option.  Unfortunately these
;   look like 'DONE's and not 'CANCEL's. Thats what documentation is for.
;
;   Note: as with Cancel, the Object structure is already outside of
;       the pointer
;       Unlike Cancel, Base Objects also need to be handled (not that
;       this makes any difference here)
;
PRO Accept, Obj, Ptr
    Obj2Ptr, Obj, Ptr       ; Stick Object back into pointer
END

PRO WidAlloc
END
;
; $Id: widbuild.pro,v 1.9 1994/06/01 23:08:48 ali Exp $
;
;  WidBuild
;   Widget Editor common routines related to building dialog boxes. Mostly.
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;


;
;  MakeBaseObj
;       Create a base object of the given type.  All use the same structure
;   but are different object types (MAIN, DEP, BASE)
;
PRO MakeBaseObj, Parent, Obj, Type

    Obj = {                     $
        WE_BASE,                $
        Type:           Type,   $ ; Set Type
        Parent:         Parent, $ ; Pointer to parent
        Id:             NewId(),$ ; Permanent Id
        TB_Showing:     1,      $ ; Is Tool Bar Showing?
        Dialog:         0L,     $
        AttrDlg:        0L,     $
        Next:           0L,     $
        Name:           '',     $ ; Title or object name
        Children:       0L,     $ ; linked list of children
        LastChild:      0L,     $ ; Last child (makes adding children easier)
        FrameSize:      0,      $
        EventFunc:      '',     $ ; UNUSED.
        EventProc:      '',     $
        GetFunc:        '',     $ ; func_get_value
        SetProc:        '',     $ ; pro_set_value
        KillProc:       '',     $ ; kill_notify
        XSize:          0,      $
        YSize:          0,      $
        XOffset:        0,      $
        YOffset:        0,      $
        UValue:         '',     $
        Space:          0,      $
        XPad:           0,      $
        YPad:           0,      $
        BaseType:       1,      $ ; Enum { BBS, Row, Col } (Row is dflt)
        NRowCol:        1,      $ ; Number of Rows/Columns
        BaseMapped:     1,      $ ; Is Base Visible?
        TLBEvents:      0,      $ ; Base accepts TLB size events?
        XScrollSize:    0,      $
        YScrollSize:    0       $
    }
END


;
;  MakeAddMenu
;   Create a series of pulldown menu items based on the class
;   definition list
;
FUNCTION MakeAddMenu

  COMMON WidEd_Comm

    Dummy       = { CW_PDMENU_S, flags:0, name:'' }
    Menu        = REPLICATE(Dummy, N_ELEMENTS(AddList))
    Menu.name   = AddList.Menu
    RETURN, Menu
END


;
;  ToolBar_Event
;       Repackage a button press to look like a menu press
;
PRO ToolBar_Event, Event

  COMMON WidEd_Comm

    ;   We will need the pointer for the Object associated with this
    ;   dialog box (the parent for the children we are about to create)

    ;   Can't use /NO_COPY because AddChild assumed TopDlg's UVALUE
    ;   will always be valid and Event.Top may be TopDlg

    WIDGET_CONTROL, Event.top, GET_UVALUE=Binfo

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Build

    ;   Allocate object and create a dialog box as well
    CALL_PROCEDURE, Build + '_Build', Ptr, Binfo.ObjPtr

    ;   Add child to our child list.  Note that Base object
    ;   do not get added to the active dialog box list
    AddChild, Binfo.ObjPtr, Ptr, NO_CANCEL=(Build EQ 'Base')

    ;   Restore dialog box information
    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  BuildToolBar
;   Create a series of bitmapped buttons
;
PRO BuildToolBar, Base, ToolBase

  COMMON WidEd_Comm

    I=0
    N=N_ELEMENTS(AddList)
    WHILE I LT N DO BEGIN
        Icon    = CALL_FUNCTION(Addlist(I).Class + "_Icon")
        IF N_ELEMENTS(Icon) NE 1 THEN BEGIN
            ToolBase    = WIDGET_BASE(Base, /ROW, /FRAME, $
                                SPACE=1, EVENT_PRO='ToolBar_Event')
            FOR I=0,N-1 DO BEGIN
                Icon    = CALL_FUNCTION(Addlist(I).Class + "_Icon")
                IF N_ELEMENTS(Icon) NE 1 THEN BEGIN
                     Button     = WIDGET_BUTTON(ToolBase, VALUE=Icon, $
                                                UVALUE=AddList(I).Class)
                ENDIF
            ENDFOR
        ENDIF

    ENDWHILE

END



;
;  Field
;       Common entry point for creation of a dialog box information entry
;   object (CW_FIELD) for user entry of a value.  Simpler to use
;   layer because we can change options in a single location (here)
;   for (near) global effect.
;
;   Returns Widget Id.
;
FUNCTION Field, Base, Title, Value, Uvalue, $
    SIZE=Size, INT=Int, STRING=String, LONG=Long, FLOAT=Float

  COMMON WidEd_Comm

    RETURN, CW_FIELD(Base, TITLE=Title, VALUE=Value, UVALUE=Uvalue, $
                XSIZE=Size, /ALL_EVENTS, TEXT_FRAME=OnAPC, $
                INT=Int, STRING=String, LONG=Long, FLOAT=Float)
END


;
;  BuildBaseType
;   All base objects have within them a sub base used to set base
;   type information (row v. column, child spacing, etc.).
;
;   Create that information.  Builder provides object information,
;
;   The fields created are used to fill in Focus information starting
;   FOff.  Btns are saved for later showing user object state.
;   RowColId is needed by the parent dialog for enabling/disabling
;   Row-Column information as user changed base type selection.
;
PRO BuildBaseType, Base, Obj, Foci, FOff, RowColId, Btns, ROW=Row

    Btns    = LONARR(3)

    ;   Events get sent to object's event routine (should be called XXX_Event
    Base1   = WIDGET_BASE(Base, /COLUMN, /FRAME, EVENT_PRO=Obj.Type+'_Event')

    ;   Support different widget layouts

    IF KEYWORD_SET(Row) THEN BEGIN
        BBase   = WIDGET_BASE(Base1, /ROW)
        LabVal  = "Base Type:"
    ENDIF ELSE BEGIN
        BBase   = Base1
        LabVal  = "Base Type"
    ENDELSE

    ;   Create subbase contents

    Label   = WIDGET_LABEL(BBase, VALUE=LabVal)
    Base2   = WIDGET_BASE(BBase, /ROW, /EXCLUSIVE)
    Btns(1) = WIDGET_BUTTON(Base2, VALUE='Row', UVALUE='Row', /NO_RELEASE)
    Btns(2) = WIDGET_BUTTON(Base2, VALUE='Column', UVALUE='Column', /NO_REL)
    Btns(0) = WIDGET_BUTTON(Base2, VALUE='Bulletin Board',  $
                    UVALUE='Bbs', /NO_RELEASE)

    RowColId        = WIDGET_BASE(Base1, /COLUMN)
    Foci(FOff)      = Field(RowColId,"Number of Rows/Columns", $
                        Obj.NRowCol, "NROW", /INT, SIZE=5)
    RCBase          = WIDGET_BASE(RowColId, /ROW)
    Foci(FOff+1)    = Field(RcBase, 'Child Spacing:', $
                        Obj.Space, "SPACE", /INT, SIZE=8)
    Foci(FOff+2)    = Field(RcBase, 'X Padding:', $
                        Obj.XPad, "XPAD", /INT, SIZE=8)
    Foci(FOff+3)    = Field(RcBase, 'Y Padding:', $
                        Obj.YPad, "YPAD", /INT, SIZE=8)
END


;
;  BuildXY
;   Every one of the dialog boxes have some fields which control
;   object size, position and/or scroll size.  This routine creates
;   the fields for controlling that information.
;
;   If only 1 keyword is specified, put the X & Y fields in the same row,
;   otherwise, put all the X information in a top row and all the Y
;   information in a lower row.
;
;   The implementation of this routine is obscure. Sorry.
;   However, the usage is pretty straight forward. (c.f. XXX_Build routines)
;
PRO BuildXY, Base, Obj, Foci, FOff, $
    SCROLL=DoScroll, SIZE=DoSize, OFFSET=DoOffset, ALL=All

    ;   Make all of the flags have a value of 0 or 1

    DoSize      = KEYWORD_SET(DoSize)
    DoOffset    = KEYWORD_SET(DoOffset)
    DoScroll    = KEYWORD_SET(DoScroll)

    IF KEYWORD_SET(All) THEN BEGIN
        DoSize      = 1
        DoOffset    = 1
        DoScroll    = 1
    ENDIF

    ;   Y entries will be after X entries
    YOff = DoSize + DoOffset + DoScroll

    ;   Single request?  Make a single row

    IF YOff EQ 1 THEN BEGIN
        Base1   = WIDGET_BASE(Base, /ROW, EVENT_PRO=Obj.Type+'_Event')
        Base2   = Base1
        Base3   = Base1

    ;   Multiple types? Make an X and a Y row
    ENDIF ELSE BEGIN
        Base1   = WIDGET_BASE(Base, /COLUMN, EVENT_PRO=Obj.Type+'_Event')
        Base2   = WIDGET_BASE(Base1, /ROW)
        Base3   = WIDGET_BASE(Base1, /ROW)
    ENDELSE

    ;   Create Size entries
    IF DoSize THEN BEGIN
        Foci(Foff)      = Field(Base2, "X Size:", Obj.XSize, "XSIZE", $
                                /INT, SIZE=8)
        Foci(Foff+YOff) = Field(Base3, "Y Size:", Obj.YSize, "YSIZE", $
                                /INT, SIZE=8)
    ENDIF

    ;   Create Offset Entries
    IF DoOffset THEN BEGIN
        Off = FOff + DoSize
        Foci(Off)       = Field(Base2, "X Offset:", Obj.XOffset, "XOFFSET", $
                                /INT, SIZE=8)
        Foci(Off+YOff)  = Field(Base3, "Y Offset:", Obj.YOffset, "YOFFSET", $
                                    /INT, SIZE=8)
    ENDIF

    ;   Create Scrollsize Entries
    IF DoScroll THEN BEGIN
        Off = FOff + DoSize + DoOffset
        Foci(Off)       = Field(Base2, "X Scroll Size:", $
                                    Obj.XScrollSize, "XSCROLL", /INT, SIZE=8)
        Foci(Off+YOff)  = Field(Base3, "Y Scroll Size:", $
                                    Obj.YScrollSize, "YSCROLL", /INT, SIZE=8)
    ENDIF
END


;
;  BuildOkCancel
;
;   Create Done and Cancel buttons.  Common to the dialog of
;   many object classes.
;
PRO BuildOkCancel, Base, Obj

    Dummy       = WIDGET_LABEL(Base, VALUE=' ')
    Base1       = WIDGET_BASE(Base, /ROW, EVENT_PRO=Obj.Type+'_Event')
    DoneTxt     = '          Done         '
    CancelTxt   = '         Cancel        '
    Dummy       = WIDGET_BUTTON(Base1, VALUE=DoneTxt, UVALUE='DONE' )
    Dummy       = WIDGET_BUTTON(Base1, VALUE=CancelTxt, UVALUE='CANCEL' )
END


;
;  BuildOther
;
;   Many dialogs have a Name, Frame and UVALUE entry.  Common support
;   for creating those items.
;
PRO BuildOther, Base, Obj, Foci, FOff, FRAME=Frame

    Base1           = WIDGET_BASE(Base, FRAME=KEYWORD_SET(Frame), /COLUMN)
    Lab             = WIDGET_LABEL(Base1, VALUE="Other Controls")
    Foci(Foff)      = Field(Base1, "Name:", Obj.Name, 'NAME', SIZE=50, /STRING)
    Base2           = WIDGET_BASE(Base1, /ROW)
    Foci(Foff+1)    = Field(Base2, "Frame Size:", Obj.FrameSize, $
                            "FRAME", /INT, SIZE=8)
    Foci(Foff+2)    = Field(Base2, "User Value:", Obj.UValue, "UVALUE", $
                            SIZE=20, /STRING)
END

;
;  BuildEdit
;   Dialogs for objects which have a STRARR for a value (LIST, BGROUP, etc.)
;   need a Edit Control for entering said text.  Common code for
;   building that portion of the dialog
;
;   Commented portions should be uncommented to add support for using
;   IDL code to generate VALUE (v. Literal strings).
;   This cannot work until EXECUTE won't stop the editor if the user
;   has a typo
;
PRO BuildEdit, Base, Obj, Edit, SINGLE=Single

    Base1       = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Label       = WIDGET_LABEL(Base1, VALUE=Obj.Type + " Widget Value")
    Base2       = WIDGET_BASE(Base1, /ROW)
;   Base3       = WIDGET_BASE(Base2, /COLUMN, /EXCLUSIVE)
;   Button1     = WIDGET_BUTTON(Base3, VALUE="Use Literal Text", $
;                           UVALUE="LITERAL")
;   WIDGET_CONTROL, Button1, /SET_BUTTON
;   Button2     = WIDGET_BUTTON(Base3, VALUE="Use IDL Code", $
;                           UVALUE="CODEBASED");
;   WIDGET_CONTROL, Button2, SENSITIVE=0

    Base3       = WIDGET_BASE(Base2, /COLUMN)
    WIDGET_CONTROL, Obj.Value1, GET_UVALUE=StrValue
    IF KEYWORD_SET(Single) THEN YSize=1 ELSE YSize=5
    MainText    = CW_FIELD(Base3, XSIZE=50, YSIZE=YSize, /ALL, TITLE=" ", $
                        VALUE=StrValue, UVALUE='MAINTEXT')
;   Edit        = CW_FIELD(Base3, XSIZE=44, /ALL, TITLE="VALUE=", $
;                       VALUE=Obj.Value2, UVALUE='VALUETEXT')
;   WIDGET_CONTROL, Edit, SENSITIVE=Obj.ValueType
    Edit        = 0L
END


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   General Event Routines
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;  DoXFont
;   Run the XFont utility to allow the user to choose a font.
;   Set the 'Font:' field to correspond to the user's choice.
;   Only runs on a system running X.
;
PRO DoXFont, Obj, Id
    WIDGET_CONTROL, /HourGlass
    NewFontName = XFont()
    IF NewFontName NE '' THEN BEGIN
        WIDGET_CONTROL, Id, SET_VALUE=NewFontName
        Obj.Font    = NewFontName
    ENDIF
END

;
;  MISC_Kill
;   Called whenever an active dialog box is destroyed (except for
;   base objects [DEP and BASE]).  IF the dialog still has
;   information attached to it AND the object has not been destroyed
;   THEN clear the dialog widget id contained in the object -- indicating
;   that it no longer has an active dialog box associated with it.
;
PRO MISC_Kill, Dlg

  COMMON WidEd_Comm

    ;   Get dialog info
    WIDGET_CONTROL, Dlg, GET_UVALUE=Binfo, /NO_COPY

    IF KEYWORD_SET(Binfo) THEN BEGIN        ; Dialog info valid?

        IF WIDGET_INFO( BInfo.ObjPtr, /VALID) THEN BEGIN    ; ObjPtr valid?

            Ptr2Obj, Binfo.ObjPtr, Obj      ; Get Object

            ;   We may not have any object associated with the
            ;   dialog -- if we here as a result of the object
            ;   being destroyed programmatically.  In that case,
            ;   just don't do anything

            IF N_ELEMENTS(Obj) NE 0 THEN BEGIN  ; Object Valid?
                Obj.Dialog = 0L                 ; Clear Dialog Id
                Obj2Ptr, Obj, Binfo.ObjPtr      ; put object back into pointer
            ENDIF

            ;   See if we have a copy of this object (allows cancel to work)
            ;   If we do, delete extra copy of the object and update the
            ;   active list

            Idx = WHERE(NewDialogs.ObjPtr EQ Binfo.ObjPtr, Count)
            IF Count EQ 1 THEN BEGIN

                Idx     = Idx(0)    ; Where it is in the active list

                ;   Destroy the copy.  BASE objects should never be in
                ;   NewDialogs. Copy (oldptr) may have a valid pointer to
                ;   the dialog. This is bad. If there is a copy and it is
                ;   destroyed, the dialog would be destroyed twice (once
                ;   by user action, once by this routine. The second
                ;   deletion would fail and crashes the widget editor)

                IF NewDialogs(Idx).OldPtr NE 0L THEN BEGIN
                    Ptr = NewDialogs(Idx).OldPtr    ; Get Copy Pointer
                    Ptr2Obj, Ptr, Obj               ; Get copy object

                    ;  There may exist a point in destroying a dialog
                    ;  where we are in the process of destroying the
                    ;  object associated with this dialog and hence
                    ;  things are half destroyed so we check for that
                    IF N_ELEMENTS(Obj) NE 0 THEN BEGIN
                        Obj.Dialog      = 0         ; Clear dialog box pointer
                        Obj2Ptr, Obj, Ptr           ; Put obj back into pointer
                        Destroy, Ptr            ; Destroy it (but not dialog)
                    ENDIF
                ENDIF

                ;   Now we have to remove the deleted object from the list
                ;   of objects with active dialog boxes.

                N   = N_ELEMENTS(NewDialogs)
                IF Idx EQ N-1 THEN $                    ; Last active object?
                    NewDialogs  = NewDialogs(0:N-2) $
                ELSE $
                    NewDialogs  = [ NewDialogs(0:Idx-1), NewDialogs(Idx+1,*) ]
            ENDIF
        ENDIF
    ENDIF

END

;
;  MISC_Event
;   Event processing for simple dialog boxes.  Used by many
;   of the simple object classes.
;
PRO MISC_Event, Event, FontIdx

  COMMON WidEd_Comm 

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'VALUE':    Obj.Value       = Event.Value               ; Generic Fields
    'FONT':     Obj.Font        = Event.Value
    'NAME':     Obj.Name        = Event.Value
    'FRAME':    Obj.FrameSize   = Event.Value
    'UVALUE':   Obj.Uvalue      = Event.Value
    'XSIZE':    Obj.XSize       = Event.Value
    'YSIZE':    Obj.YSize       = Event.Value
    'XOFFSET':  Obj.XOffset     = Event.Value
    'YOFFSET':  Obj.YOffset     = Event.Value
    'XSCROLL':  Obj.XScrollSize = Event.Value
    'YSCROLL':  Obj.YScrollSize = Event.Value

    'XFONT':    DoXFont, Obj, Binfo.Foci(FontIdx)

    'DO_BUTTON':    Obj.DrawBtnEv   = 1 - Obj.DrawBtnEv     ; DRAW Widget only
    'DO_MOTION':    Obj.DrawMoEv    = 1 - Obj.DrawMoEv
    'NO_STORE':     Obj.DrawRetain  = 0
    'SVR_STORE':    Obj.DrawRetain  = 1
    'IDL_STORE':    Obj.DrawRetain  = 2

    'DONE':     BEGIN
        Accept, Obj, Binfo.ObjPtr
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        WIDGET_CONTROL, Event.Top, /DESTROY
        RETURN
        END

    'CANCEL':   BEGIN
        Cancel, Obj, Binfo.ObjPtr
        RETURN
        END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
END

PRO WidBuild
END
;
; $Id: widdep.pro,v 1.11 1994/06/01 23:08:48 ali Exp $
;
;  WidDep
;   Dependent Dep object class definition.
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;


;
;  DEP_Alloc
;       Allocate a dependent base object (if Ptr is NULL or just invalid)
;   There are 3 base object classes (MAIN,DEP, and BASE) so they call
;   a common routine to allocate base objects.
;
PRO DEP_Alloc, Parent, Ptr
  COMMON WidEd_Comm
    IF KEYWORD_SET(Ptr) EQ 0 THEN BEGIN     ; Ptr already allocated
        Ptr = WIDGET_BASE(GROUP=TopDlg)     ; Make a pointer
        MakeBaseObj, Parent, Obj, "DEP"     ; Make a dep base object
        Obj2Ptr, Obj, Ptr                   ; Store object in pointer
        Dirty   = 1                         ; Things have changed since
                                            ; last save.
    ENDIF
END


;
;  DEP_Copy
;       Copy the given dependent base object.
;   Remember to copy contents (children) as well.
;
PRO DEP_Copy, Ptr, Copy
    BASE_Copy, Ptr, Copy
END

;
;  DEP_Destroy
;   Release resources associated with the given object.  Recursively
;   remove children objects as well.
;
PRO DEP_Destroy, Ptr
    BASE_Destroy, Ptr       ; Does the same thing
END


;
;  DEP_Kill
;   Base objects need to do things differently on a 'DONE' than
;   the more typical objects (c.f. MISC_Kill). Thus, a base object
;   specific kill routine.
;
PRO DEP_Kill, Dlg

    WIDGET_CONTROL, Dlg, GET_UVALUE=Binfo, /NO_COPY

    IF WIDGET_INFO( BInfo.ObjPtr, /VALID) THEN BEGIN

        Ptr2Obj, Binfo.ObjPtr, Obj

        ;   We may not have any object associated with the
        ;   dialog -- if we here as a result of the object
        ;   being destroyed programmatically.  In that case,
        ;   just don't do anything

        IF N_ELEMENTS(Obj) NE 0 THEN BEGIN
            ;   Which dialog disappeared?
            IF Obj.Dialog EQ Dlg THEN Obj.Dialog = 0        ; Dialog gone?
            IF Obj.AttrDlg Eq Dlg THEN Obj.AttrDlg = 0      ; Add'l gone?
            Obj2Ptr, Obj, Binfo.ObjPtr                      ; Save new state
        ENDIF
    ENDIF
END


;
;  DEP_BarEvent
;   Event from the pull down menu don't have a <STRING> type UVALUE
;   to use for determining event type.  Instead the event.value is
;   usable.  However, it is easier to provide a separate event handler
;
PRO DEP_BarEvent, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.top, GET_UVALUE=Binfo, /NO_COPY

    IF Event.Value EQ 'Add.Hide Tool Bar' THEN BEGIN

        WIDGET_CONTROL, Binfo.ToolBar, MAP=0
        WIDGET_CONTROL, Binfo.ToolId, SET_VALUE='Show Tool Bar'
        WIDGET_CONTROL, Binfo.ToolId, SET_UVALUE='Add.Show Tool Bar' ; Hack
        SetTag, Binfo.ObjPtr, "TB_Showing", 0

    ENDIF ELSE IF Event.Value EQ 'Add.Show Tool Bar' THEN BEGIN

        WIDGET_CONTROL, Binfo.ToolBar, MAP=1
        WIDGET_CONTROL, Binfo.ToolId, SET_VALUE='Hide Tool Bar'
        WIDGET_CONTROL, Binfo.ToolId, SET_UVALUE='Add.Hide Tool Bar' ; Hack
        
        SetTag, Binfo.ObjPtr, "TB_Showing", 1

    ENDIF ELSE BEGIN

        IF STRMID(Event.Value,0,4) EQ "Add." THEN BEGIN
            Idx     = WHERE(STRMID(Event.Value,4,100) EQ AddList.Menu)
            Build   = AddList(Idx).Class
        ENDIF ELSE MESSAGE, 'Unprocessed event: ' + Event.Value

        ;   Allocate object and create a dialog box as well
        CALL_PROCEDURE, Build+'_Build', Ptr, Binfo.ObjPtr

        ;   Add child to our child list.  Note that Base object
        ;   do not get added to the active dialog box list
        AddChild, Binfo.ObjPtr, Ptr, NO_CANCEL=(Build EQ 'Base')

    ENDELSE

    ;   Restore dialog box information
    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  DEP_Event
;   Normal event handling routine for a dependent base object
;
PRO DEP_Event, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev                 ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY   ; Get Dialog Info
    Ptr2Obj, Binfo.ObjPtr, Obj                              ; Get Object

    CASE Ev OF

    'Bbs':      BEGIN                   ; Base is a bulletin board
        Obj.BaseType        = 0
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=0
        END
    'Row':                BEGIN
        Obj.BaseType        = 1
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END
    'Column':        BEGIN
        Obj.BaseType        = 2
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END

    ;   user has set some characteristic of the object to a new value

    'NROW':         Obj.NRowCol     = Event.Value
    'SPACE':        Obj.Space       = Event.Value
    'XPAD':         Obj.XPad        = Event.Value
    'YPAD':         Obj.YPad        = Event.Value
    'NAME':         Obj.Name        = Event.Value
    'XSCROLL':      Obj.XScrollSize = Event.Value
    'YSCROLL':      Obj.YScrollSize = Event.Value

    ;   User wants to see the 'Additional Attributes' dialog
    'ATTR':     DEP_BuildAttr, Event.Top, Binfo.ObjPtr, Obj

    ;   Additional Attribute Events
    'XSIZE':        Obj.XSize       = Event.Value
    'YSIZE':        Obj.YSize       = Event.Value
    'XOFFSET':      Obj.XOffset     = Event.Value
    'YOFFSET':      Obj.YOffset     = Event.Value
;   'EVENT_FUNC':   Obj.EventFunc   = Event.Value
    'EVENT_PROC':   Obj.EventProc   = Event.Value
    'GETFUNC':      Obj.GetFunc     = Event.Value
    'SETPROC':      Obj.SetProc     = Event.Value
    'KILLPROC':     Obj.KillProc    = Event.Value
    'DO_TLB':       Obj.TLBEvents   = 1 - Obj.TLBEvents
    'MAPPED':       Obj.BaseMapped  = 1 - Obj.BaseMapped
    'DONE':         BEGIN
                    Obj2Ptr, Obj, Binfo.ObjPtr
                    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
                    WIDGET_CONTROL, Event.Top, /DESTROY
                    RETURN
                    END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
END


;
; DEP_Build
;   Create a dialog for a dependent base object. If ptr is nil then
;   create the object as well.
;
PRO DEP_Build, Ptr, Base

  COMMON WidEd_Comm

    DEP_Alloc, 0L, Ptr                      ; Allocate object if necessary
    MgrName = 'WE_BASE' + STRTRIM(Ptr,2)    ; Create dialog box name
    IF XRegistered(MgrName) THEN RETURN     ; See if it already exists

    Title   = 'Dependent Base: ' + GetId(Ptr)
    Ptr2Obj, Ptr, Obj

    ;   Create dialog box

    Base            = WIDGET_BASE(/COLUMN, TITLE=Title, GROUP_LEADER=TopDlg)
    Foci            = LONARR(7)

    ;   Menu bar contents

    Menu            = MakeAddMenu()
    Menu(N_ELEMENTS(Menu)-1).flags  = 2
    MenuBarDesc     = [ { CW_PDMENU_S, 3, 'Add' }, $
                        { CW_PDMENU_S, 0, 'Hide Tool Bar' }, $
                        Menu ]
    If Obj.TB_Showing EQ 0 THEN MenuBarDesc(1).name = 'Show Tool Bar'
    MenuBar         = CW_PDMENU(Base, MenuBarDesc, IDS=Ids, /RETURN_FULL_NAME)
    ToolId          = Ids(1)

    BuildToolBar, Base, ToolBar

    BuildBaseType, Base, Obj, Foci, 0, RowColId, Btns
    Base1   = WIDGET_BASE(Base, /COLUMN, EVENT_PRO='DEP_Event')
    Foci(4) = Field(Base1, "Name:", Obj.Name, 'NAME', SIZE=50, /STRING)
    BuildXY, Base, Obj, Foci, 5, /SIZE
    Dummy   = WIDGET_BUTTON(Base, VALUE='More Attributes', $
                UVALUE='ATTR', EVENT_PRO='DEP_Event')

    Dummy   = WIDGET_LABEL(Base, VALUE=' ')
    Dummy   = WIDGET_BUTTON(Base, VALUE='Done', UVALUE='DONE', $
            EVENT_PRO='DEP_Event')

    DlgInfo = { $
        Foci:       Foci, $
        RowColId:   RowColId, $
        ToolBar:    ToolBar, $
        ToolId:     ToolId, $
        ObjPtr:     Ptr $
    }
    Obj.Dialog  = Base

    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    WIDGET_CONTROL, Btns(Obj.BaseType), /SET_BUTTON
    WIDGET_CONTROL, RowColId, SENSITIVE=(Obj.BaseType NE 0)

    WIDGET_CONTROL, ToolBar, MAP=Obj.TB_Showing

    XMANAGER, MgrName, Base, EVENT_HANDLER='DEP_BarEvent', CLEANUP='DEP_Kill'
    Obj2Ptr, Obj, Ptr
END



;
;  DEP_Save
;   Store object information in a file. Identical to BASE_Save routine.
;
PRO DEP_Save, Unit, Ptr
    BASE_Save, Unit, Ptr
END

;
;  BASE_Restore
;   Read in a dependent base object (and its children) from a file
;
PRO DEP_Restore, Unit, Parent, Ptr
    urBASE_Restore, Unit, Parent, Ptr, "DEP"
END

;
;   DEP_BuildAttr
;       Object contains information about the base.  Ptr is needed
;   for object naming.  Routine builds the 'extra' dialog box that
;   base objects have.
;
;   This is a merged routine -- works for MAIN and DEP base objects
;
PRO DEP_BuildAttr, Leader, Ptr, Obj


    MgrName = 'WidBAttr' + STRTRIM(Ptr,2)   ; Create name an test for
    IF XRegistered(MgrName) THEN RETURN     ; dialog already existing

    ;   Create Additional dialog

    Foci    = LONARR(8)
    IF Obj.Type EQ 'MAIN' THEN BEGIN        ; MAIN Obj special case
        Title   = 'Main Base Attributes'
    ENDIF ELSE BEGIN
        Title   = 'BASE ' + Obj.Id + ' Attributes'
    ENDELSE

    Base    = WIDGET_BASE(  GROUP_LEADER=Leader, /COLUMN, TITLE=Title)

    ;   Event Related Info

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Event Controls")

;    Foci(0) = Field(Base1, "Event Function Name:", Obj.EventFunc, $
;                "EVENT_FUNC", SIZE=20, /STRING)
    Foci(0) = Field(Base1, "Event Procedure Name:", Obj.EventProc, $
                "EVENT_PROC", SIZE=20, /STRING)
    Foci(1) = Field(Base1, "Function Name for GET_VALUE:", Obj.GetFunc, $
                "GETFUNC", SIZE=20, /STRING)
    Foci(2) = Field(Base1, "Procedure Name for SET_VALUE:", Obj.SetProc, $
                "SETPROC", SIZE=20, /STRING)
    Foci(3) = Field(Base1, "Procedure Name for KILL_NOTIFY:", Obj.KillProc, $
                "KILLPROC", SIZE=20, /STRING)
    Base2   = WIDGET_BASE(Base1, /NONEXCLUSIVE, /ROW)
    Btn     = WIDGET_BUTTON(Base2,              $
                    VALUE='Accept TLB Events',  $
                    UVALUE='DO_TLB')

    Base1   = WIDGET_BASE(Base, /FRAME, /COLUMN)
    Lab     = WIDGET_LABEL(Base1, VALUE="Window Appearance Controls")
    BuildXY, Base1, Obj, Foci, 4, /SCROLL, /OFFSET
    Base2   = WIDGET_BASE(Base1, /NONEXCLUSIVE, /ROW)
    Btn     = WIDGET_BUTTON(Base2,              $
                VALUE='Base Starts Mapped', $
                UVALUE='MAPPED')
    IF Obj.BaseMapped EQ 1 THEN WIDGET_CONTROL, Btn, /SET_BUTTON
    Dummy   = WIDGET_LABEL(Base, VALUE=' ')
    Dummy   = WIDGET_BUTTON(Base, VALUE='Done', UVALUE='DONE')

    DlgInfo     = { $
        Foci:       Foci, $
        ObjPtr:     Ptr $
    }
    Obj.AttrDlg = Base

    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, MgrName, Base, EVENT_HANDLER=Obj.Type+'_Event', $
            CLEANUP='DEP_Kill'
END


;
;  TestDraw
;   When creating a preview I thought it would be nice to draw
;   something to the dialogs.  Thus, after creating a preview we
;   search the object hierarchy looking for drawables to put
;   plots in.
;
PRO TestDraw, Ptr

    COMMON TestDraw_Comm, Seed

    Ptr2Obj, Ptr, Obj

    ;   We are only interested in 2 object types:
    ;       Draws to draw in
    ;       Base objects so that we can check their children

    CASE TAG_NAMES(Obj, /STRUCTURE) OF

    'WE_BASE': BEGIN
        Child       = Obj.Children
        WHILE Child NE 0L DO BEGIN
            TestDraw, Child
            Child   = NextPtr(Child)
        ENDWHILE
        END
    'WE_DRAW': BEGIN
        WIDGET_CONTROL, Obj.DrawId, GET_VALUE=WinId
        WSET, WinId

        CASE (FIX(Randomu(Seed,1) * 4))(0) OF
        0:      PLOT,[0,1],TITLE='Sample Plot'
        1:      SURFACE, DIST( (FIX(Randomu(Seed,1)*10))(0) + 2 ), $
                        TITLE='Sample Surface'
        2:      PLOT,sin(findgen(100)/5)/exp(findgen(100)/50), $
                        TITLE='Sample Plot'
        3:      PLOT, Randomu(Seed,10), TITLE='Sample Plot'
        ENDCASE
        END
    ELSE:           ; Do nothing
    ENDCASE
    Obj2Ptr, Obj, Ptr
END


;
;  DEP_Generate
;   Create a dependent (or MAIN) base object and its children
;   for previewing.
;
PRO DEP_Generate, Ptr, Id, Offset

  COMMON WidEd_Comm  

    Ptr2Obj, Ptr, Obj

    Id  = 0L            ; Prevent EXECUTE from creating a new variable

    ;   Generate command string

    Cmd = 'Id = WIDGET_BASE(GROUP_LEADER=' + STRTRIM(TopDlg,2)

;   Tried allowing the user to resize a top level base and having
;   that affect the base's size.  I didn't like it so I have removed
;   that ability (c.f. wided.pro)
;   Cmd = Cmd + ",/TLB_SIZE_EVENTS"

    SAddCmd, Cmd, Obj.Name, 'TITLE'
    IAddCmd, Cmd, Obj.FrameSize, 'FRAME'
    IAddCmd, Cmd, Obj.XSize, 'XSIZE'
    IAddCmd, Cmd, Obj.YSize, 'YSIZE'
    IAddCmd, Cmd, Obj.XOffset, 'XOFFSET'
    IAddCmd, Cmd, Obj.YOffset, 'YOFFSET'
    IAddCmd, Cmd, Obj.XScrollSize, 'X_SCROLL_SIZE'
    IAddCmd, Cmd, Obj.YScrollSize, 'Y_SCROLL_SIZE'


    ;   Row/Column

    IF Obj.BaseType EQ 1 THEN           $
        IAddCmd, Cmd, Obj.NRowCol, 'ROW'    $
    ELSE IF Obj.BaseType EQ 2 THEN      $
        IAddCmd, Cmd, Obj.NRowCol, 'COLUMN'

    IAddCmd, Cmd, Obj.Space, 'SPACE'
    IAddCmd, Cmd, Obj.XPad, 'XPAD'
    IAddCmd, Cmd, Obj.YPad, 'YPAD'

    ; Create base by running command string we just built

    IF EXECUTE(Cmd+')') NE 1 THEN BEGIN
        Obj2Ptr, Obj, Ptr
        MESSAGE,'Could not build base' + VarName(Ptr)
    ENDIF

    ; Create any child widgets

    Child   = Obj.Children
    WHILE Child NE 0L DO BEGIN
        Ptr2Obj, Child, ChObj
        Next    = ChObj.Next
        Type    = ChObj.Type
        Obj2Ptr, ChObj, Child
        CALL_PROCEDURE, Type + "_Generate", Id, Child
        Child   = Next
    ENDWHILE

    WIDGET_CONTROL, Id, /REALIZE
    WIDGET_CONTROL, Id, SET_UVALUE=Ptr

    ;XMANAGER, 'GenBase', Id, /JUST_REG (for TLB event)

    ;   If the user has moved the preview of the base and has not
    ;   specified a position via the control panel then
    ;   use the position of the previous preview as the location
    ;   to rebuild a preview

    ;   If the user has not provided positions for the underlying
    ;   objects, I create them in a cascade form

    IF Obj.XOffset EQ 0 AND Obj.YOffset EQ 0 THEN BEGIN
        Xoff    = BaseXY(0, Offset)
        Yoff    = BaseXY(1, Offset)

        IF Offset NE 0 AND Xoff EQ 0 AND Yoff EQ 0 THEN BEGIN
            ;   Add frame fudge factors
            Xoff    = Offset * 30 + 10
            Yoff    = Offset * 20 + 30
        ENDIF

        ;   Only move it if necessary.

        IF Xoff NE 0 OR Yoff NE 0 THEN $
            WIDGET_CONTROL, Id, TLB_SET_XOFF=Xoff, TLB_SET_YOFF=Yoff
    ENDIF

    XMANAGER, 'Gen', Id, /JUST_REG      ; Suck up events and ignore them

    Obj2Ptr, Obj, Ptr
    TestDraw, Ptr                       ; Put a plot into drawables
END


;
;  SaveEvent
;   Create an case statement in an event handler for the given object
;
PRO SaveEvent, Unit, Ptr

    IF Ptr EQ 0 THEN RETURN

    Id  = GetId( Ptr )
    Ptr2Obj, Ptr, Obj
    UVal    = UValue(Obj, Ptr)
    Type    = Obj.Type

    CASE Type OF

        'LABEL':            ; Labels don't generate events

        ;   Bases don't generate events but their children might
        'BASE':     DoFList, Obj.Children, 'SaveEvent', Unit

        ;   Menus get an event function all their own
        'PDMENU':           BEGIN
            Name    = Type + Obj.Id
            PRINTF, Unit, "  ; Event for ", Id
            PRINTF, Unit, "  '", QString(UVal), "': ", Name, "_Event, Event"
            END

        ;   Button groups have multiple formats (normal,exclusive,non-excl)
        'BGROUP':   BEGIN
            PRINTF, Unit, "  '", QString(UVal), "': BEGIN"
            IF Obj.BaseExcl EQ 2 THEN BEGIN
                PRINTF, Unit, $
                    "      IF Event.Select THEN Sel = 'On' ELSE Sel = 'Off'"
                Format='("      ",I0,": Print,''Button ",A," Turned '', Sel")'
            ENDIF ELSE BEGIN
                Format='("      ",I0,": Print,''Button ",A," Pressed''")'
            ENDELSE

            PRINTF, Unit, "      CASE Event.Value OF"

            GetValue, Obj, Names, "<Nil BGROUP>"
            FOR I=0,N_ELEMENTS(Names)-1 DO BEGIN
                PRINTF, Unit, I, QString(Names(I)), FORMAT=Format
            ENDFOR
            PRINTF, Unit, "      ELSE: Message,'Unknown button pressed'"
            PRINTF, Unit, "      ENDCASE"
            PRINTF, Unit, "      END"
            END


        ;   All other items just need a simple skeleton
        ELSE:   BEGIN
            PRINTF, Unit, "  '", QString(UVal), "': BEGIN"
            PRINTF, Unit, "      Print, 'Event for ", QString(Id), "'"
            PRINTF, Unit, "      END"
            END
    ENDCASE

    Obj2Ptr, Obj, Ptr
END


;
;  DEP_BaseEv
;   Write an event handler for a dependent base object
;
PRO DEP_BaseEv, Unit, OldUnit, Ptr

    ; if the user has chosen a name for the event handler routine
    ; we don't write the handler

    Id  = VarId(Ptr)

    Ptr2Obj, Ptr, Obj
    IF Obj.EventFunc NE '' OR Obj.EventProc NE '' OR $
       FindMagic(Id, Unit, OldUnit) THEN BEGIN
        Obj2Ptr, Obj, Ptr
        RETURN
    ENDIF

    ; Write the routine header

    BeginMagic, Unit, Id

    PRINTF, Unit, FORMAT='(//"PRO ",A,"_Event, Event")', Id
    PRINTF, Unit, FORMAT='(//A//A/)',           $
    '  WIDGET_CONTROL,Event.Id,GET_UVALUE=Ev',  $
    '  CASE Ev OF '

    ;   Write an case statement for each child object

    DoFList, Obj.Children, 'SaveEvent', Unit

    ;   Might need a case statement for a top level base
    ;   if the user desires it to receive TLB events.
    ;   Normally a base does not generate(receive) events.

    IF Obj.TLBEvents THEN BEGIN
        PRINTF, Unit, "  '", UValue(Obj,Ptr), "': BEGIN"
        PRINTF, Unit, "      Print, 'Event for ", Id, "'"
        PRINTF, Unit, "      END"
    ENDIF

    Obj2Ptr, Obj, Ptr

    ;   Write routine footer

    PRINTF, Unit, '  ENDCASE'
    PRINTF, Unit, 'END'

    EndMagic, Unit, Id
END


;
;  GetDrawables
;   Scan object tree looking for drawables.  If we find one,
;   write code to extract the window-id of the draw widget.
;
PRO GetDrawables, Unit, Ptr

    Ptr2Obj, Ptr, Obj

    CASE Obj.Type OF

    'MAIN': DoFList, Obj.Children, 'GetDrawables', Unit
    'DEP':  DoFList, Obj.Children, 'GetDrawables', Unit
    'BASE': DoFList, Obj.Children, 'GetDrawables', Unit
    'DRAW': BEGIN
        VarName = 'DRAW' + Obj.Id
        PRINTF, Unit
        PRINTF, Unit, '  ; Get drawable window index'
        PRINTF, Unit
        PRINTF, Unit, '  COMMON ', VarName, '_Comm, ', VarName, '_Id'
        PRINTF, Unit, '  WIDGET_CONTROL, ', VarName, ', GET_VALUE=', $
                VarName, '_Id'
        END
    ELSE:
    ENDCASE
    Obj2Ptr, Obj, Ptr
END


;
;  DEP_GenWid
;   Generate IDL code for creating a top level base widget
;
PRO DEP_GenWid, Unit, Ptr, Leader

    Name    = VarId(Ptr)

    Ptr2Obj, Ptr, Obj

    ;   BASE000 = WIDGET_BASE(...

    XPRINTF, Unit, FORMAT='("  ",A," = WIDGET_BASE(")', Name, /NO_EOL
    IF KEYWORD_SET(Leader) THEN BEGIN
        XPRINTF, Unit, FORMAT='("GROUP_LEADER=",A)', VarId(Leader), /NO_EOL
    ENDIF ELSE BEGIN
        ; XPRINTF cannot have FORMAT w/o a positional arg
        XPRINTF, Unit, FORMAT='(A)', "GROUP_LEADER=Group", /NO_EOL
    ENDELSE

    ;   Create flag code
    urBase_GenWid, Unit, Ptr, Obj, Name

    Obj2Ptr, Obj, Ptr

    ;   Create code to realize top level base
    PRINTF, UNIT, FORMAT='("  WIDGET_CONTROL, ",A,", /REALIZE")', Name

    ;   Write code to get window ids
    GetDrawables, Unit, Ptr
END

PRO WidDep
END
;
; $Id: widedit.pro,v 1.8 1994/06/01 23:08:48 ali Exp $
;
;  WidEdit
;   Cut/Paste/Copy/Edit dialog routines.
;   These are the other 'Top Level' dialogs and as main, have many
;   externally visible hooks (c.f. wided.com)
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  UpdateCut
;   Update the given dialog box (cut, copy or edit) to reflect a
;   change in the current widget tree.
;
;   General notes:
;
;   If we are looking at some portion of the widget tree and any portion
;   of that tree has been removed, give up and look at the top level.
;
;   If the widget tree is empty (widget tree consists of MAIN alone)
;   then close the dialog (nothing to cut copy or edit)
;
PRO UpdateCut, Id, Removed

  COMMON WidEd_Comm

    WIDGET_CONTROL, Id, GET_UVALUE=Binfo, /NO_COPY      ; Get dialog info

    OldList         = Binfo.Ptrs                        ; Get list aux info

    ;   See if someone has removed any of base objects in our parenting
    TreeDisturbed   = WHERE(Binfo.Parents EQ Removed, Count)
    IF Count NE 0 THEN BEGIN
    Again:
        Binfo.Parents   = TopPtr            ; Make top base current parent
        NewTop          = TopPtr
    ENDIF ELSE BEGIN
        NewTop          = Binfo.Parents     ; Use current parent
        NewTop          = NewTop(0)
    ENDELSE

    MakeLists, NewTop, List, Strs   ; Make list to reflect (possibly)
                                    ; new current parent

    ;   No items in list?
    IF List(0) EQ 0 THEN BEGIN

        ;   If we aren't looking at the top level base there still might
        ;   be something to look at anyway.  Look at the root of the tree
        ;   and try again.
        IF NewTop NE TopPtr THEN GOTO, Again

        WIDGET_CONTROL, Id, /DESTROY        ; Nothing.

        ;   Clear the appropriate common block id to show that this
        ;   dialog is no longer being shown

        IF Id EQ CutId THEN CutId = 0
        IF Id EQ CopyId THEN CopyId = 0
        IF Id EQ EditId THEN EditId = 0
        RETURN
    ENDIF

    ;   If the list has not been disturbed then leave it as it is.

    IF N_ELEMENTS(OldList) EQ N_ELEMENTS(List) THEN BEGIN
        Dummy   = WHERE(OldList NE List, Count)

        ;   If the list has not been disturbed, see if the current
        ;   selection is a base object and has had children added
        ;   or removed from it.  Update the ability to look at its
        ;   children accordingly.

        IF Count EQ 0 THEN BEGIN
            WIDGET_CONTROL, Binfo.ChildBtn, $
                SENSITIVE=HasChildren(List(Binfo.ListIdx))
            WIDGET_CONTROL, Id, SET_UVALUE=Binfo, /NO_COPY
            RETURN
        ENDIF
    ENDIF

    ;   The list has been altered.  Update it to reflect the new changes.

    ;   Redeclare the dialog information.  Because List is an array
    ;   and in all likelyhood is a different size than the original
    ;   Binfo.Ptrs we can't just use:  Binfo.Ptrs   = list


    Binfo   = {                     $
        Ptrs:List,                  $
        Parents:Binfo.Parents,      $
        LabelId:Binfo.LabelId,      $
        ListId:Binfo.ListId,        $
        ListIdx:0,                  $
        ActionBtn:Binfo.ActionBtn,  $
        PasteBtn:Binfo.PasteBtn,    $
        ChildBtn:Binfo.ChildBtn,    $
        ParentBtn:Binfo.ParentBtn   $
    }

    ;   Can't cut or copy DEP objects. Set cut/copy action button accordingly
    Child   = List(0)
    IF Id EQ CutId OR Id EQ CopyId THEN BEGIN
        GetType, Child, Type
        WIDGET_CONTROL, Binfo.ActionBtn, SENSITIVE=(Type NE "DEP")
    ENDIF

    ;   Set labels and controls to reflect our new list

    WIDGET_CONTROL, Binfo.LabelId, SET_VALUE='Children of '+VarId(NewTop)
    WIDGET_CONTROL, Binfo.ListId, SET_VALUE=Strs
    WIDGET_CONTROL, Binfo.ListId, SET_LIST_SELECT=0
    WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=HasChildren(Child)
    WIDGET_CONTROL, Binfo.ParentBtn, SENSITIVE=(NewTop NE TopPtr)

    ;   Restore dialog information
    WIDGET_CONTROL, Id, SET_UVALUE=Binfo, /NO_COPY
END


;
;  UpdateEdit
;   Entry point to updating all of the cut/copy/paste/edit dialogs
;   to reflect a change in the widget tree.
;
PRO UpdateEdit, Removed

  COMMON WidEd_Comm

    ;   Get MAIN Base and dialog information

    Ptr2Obj, TopDlg, DlgInfo        ; So its not really a pointer
    Ptr2Obj, TopPtr, TopObj

    ;   Set the sensitivity of the main EDIT pulldown menu
    Sens    = ((TopObj.Children NE 0) OR (TopObj.Next NE 0))

    ;   Cut/copy/edit requires child widgets to be acted on

    WIDGET_CONTROL, DlgInfo.CutId, SENSITIVE=Sens
    WIDGET_CONTROL, DlgInfo.CopyId, SENSITIVE=Sens
    WIDGET_CONTROL, DlgInfo.EditId, SENSITIVE=Sens

    ;   Pasting requires that there be something to paste
    Sens    = (CutList NE 0L)
    WIDGET_CONTROL, DlgInfo.PasteId, SENSITIVE=Sens

    Obj2Ptr, TopObj, TopPtr     ; Restore info to top pointer
    Obj2Ptr, DlgInfo, TopDlg    ; Restore info to top dialog

    IF N_ELEMENTS(Removed) EQ 0 THEN Removed = 0L

    ;   Update dialogs

    IF CutId NE 0 THEN UpdateCut, CutId, Removed
    IF CopyId NE 0 THEN UpdateCut, CopyId, Removed
    IF EditId NE 0 THEN UpdateCut, EditId, Removed

    ;   Paste dialog is unique.  Special update code required.

    IF PasteId NE 0 THEN BEGIN      ; Do we even have a paste dialog visible?

        WIDGET_CONTROL, PasteId, GET_UVALUE=Binfo, /NO_COPY

        ;   Has a parent widget been removed?

        OldList         = Binfo.Ptrs
        TreeDisturbed   = WHERE(Binfo.Parents EQ Removed, Count)
        IF Count NE 0 THEN BEGIN
            Binfo.Parents   = TopPtr
            NewTop          = TopPtr
        ENDIF ELSE BEGIN
            NewTop          = Binfo.Parents
            NewTop          = NewTop(0)
        ENDELSE

        MakeLists, NewTop, List, Strs   ; Make list to reflect (possibly)
                                        ; new current parent

        ;   Paste list has an additional fake entry. the Top-Of-List.

        IF List(0) EQ 0 THEN BEGIN
            List    = -1L
            Strs    = '<Top of List>'
        ENDIF ELSE BEGIN
            List    = [ -1L, List]
            Strs    = [ '<Top of List>', Strs ]
        ENDELSE

        ;   See if the list remains undisturbed

        IF N_ELEMENTS(OldList) EQ N_ELEMENTS(List) THEN BEGIN
            Dummy   = WHERE(OldList NE List, Count)
            IF Count EQ 0 THEN GOTO, FixCutList
        ENDIF

        ;   Rebuild Dialog info to reflect new child list.
        ;   Note: the from list is built on the fly and not
        ;   reflected in the dialog information structure

        Binfo   = {                     $
            Ptrs:List,                  $
            Parents:Binfo.Parents,      $
            FromIdx:Binfo.FromIdx,      $
            ToIdx:0,                    $
            FromListId:Binfo.FromListId,$
            LabelId:Binfo.LabelId,      $
            ToListId:Binfo.ToListId,    $
            PasteBtn:Binfo.PasteBtn,    $
            ChildBtn:Binfo.ChildBtn,    $
            ParentBtn:Binfo.ParentBtn   $
        }

        ;   Set controls

        WIDGET_CONTROL, Binfo.LabelId, SET_VALUE='Children of '+VarId(NewTop)
        WIDGET_CONTROL, Binfo.ToListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ToListId, SET_LIST_SELECT=0
        WIDGET_CONTROL, Binfo.ParentBtn, SENSITIVE=(NewTop NE TopPtr)

    FixCutList:
        ;   If we jumped here, something has changed but it is
        ;   outside of the visible list.  This can however, affect
        ;   the 'show children' action.

        WIDGET_CONTROL, Binfo.ChildBtn, $
            SENSITIVE=HasChildren(List(Binfo.ToIdx), /NONE_OK)


        ;   Rebuild the cutlist (From)

        FromStrs    = ""
        Ptr         = CutList
        WHILE Ptr NE 0 DO BEGIN
            IdStr   = GetId(Ptr)
            IF StrLen(IdStr) GT 20 THEN $
                IdStr = STRING(FORMAT='(A17,"...")', IdStr)
            FromStrs    = [ FromStrs, VarId(Ptr)+' ('+IdStr+')' ]
            Ptr         = NextPtr(Ptr)
        ENDWHILE

        ;   Show changes
        Binfo.FromIdx   = 0
        WIDGET_CONTROL, Binfo.FromListId, SET_VALUE=FromStrs(1:*)
        WIDGET_CONTROL, Binfo.FromListId, SET_LIST_SELECT=0


        ;   Save new dialog info
        WIDGET_CONTROL, PasteId, SET_UVALUE=Binfo, /NO_COPY
    ENDIF
END


;
;  MakeLists
;   Common routine that given a pointer to a base object, creates
;   2 parallel arrays:  One with the pointers to its children and the
;   other with a name list for the same children.
;
;   List            Strs
;   12              LABEL12 (Press Me)
;
PRO MakeLists, ParPtr, List, Strs

  COMMON WidEd_Comm

    Ptr2Obj, ParPtr, Obj

    ; Dependent bases are considered to be children of the MAIN object

    List    = 0L            ; Start lists
    Strs    = ""

    ;   Add true children first

    Ptr     = Obj.Children
    WHILE Ptr NE 0 DO BEGIN
        List    = [ List, Ptr]
        IdStr   = GetId(Ptr)
        IF StrLen(IdStr) GT 20 THEN $
            IdStr = STRING(FORMAT='(A17,"...")', IdStr)
        Strs    = [ Strs, VarId(Ptr)+' ('+IdStr+')' ]
        Ptr     = NextPtr(Ptr)
    ENDWHILE

    ;   If this is the MAIN base, add dependent bases to the list

    IF ParPtr EQ TopPtr THEN BEGIN
        Ptr     = Obj.Next
        WHILE Ptr NE 0 DO BEGIN
            List    = [ List, Ptr ]
            IdStr   = GetId(Ptr)
            IF StrLen(IdStr) GT 20 THEN $
                IdStr = STRING(FORMAT='(A17,"...")', IdStr)
            Strs    = [ Strs, VarId(Ptr)+' ('+IdStr+')' ]
            Ptr     = NextPtr(Ptr)
        ENDWHILE
    ENDIF

    ;   If we have at least one child, remove the fake entry used
    ;   to start the list.  Otherwise return the fake entry to
    ;   indicate that there are no children

    IF N_ELEMENTS(List) GT 1 THEN BEGIN
        List    = List(1:*)
        Strs    = Strs(1:*)
    ENDIF

    Obj2Ptr, Obj, ParPtr        ; Restore parent information
END


;
;  RemoveDialogs
;   Close any active dialog box associated with the given portion
;   of the object tree.
;   Note: Base objects have 2 possible dialog boxes.
;
PRO RemoveDialogs, Ptr

    Ptr2Obj, Ptr, Obj

    ;   If we have an active dialog box, destroy it

    IF WIDGET_INFO(Obj.Dialog, /VALID_ID) THEN BEGIN
        WIDGET_CONTROL, Obj.Dialog, /DESTROY
        Obj.Dialog  = 0L
    ENDIF

    ;   If we are a base object, see if we have an aux dialog box
    ;   and destroy it and destroy our children's dialog boxes as well

    IF TAG_NAMES(Obj, /STRUCTURE) EQ 'WE_BASE' THEN BEGIN
        IF WIDGET_INFO(Obj.AttrDlg, /VALID_ID) THEN BEGIN
            WIDGET_CONTROL, Obj.AttrDlg, /DESTROY
            Obj.AttrDlg = 0L
        ENDIF
        DoList, Obj.Children, "RemoveDialogs"
    ENDIF

    Obj2Ptr, Obj, Ptr
END


;
;  CutEvent
;   Handle events for the cut/copy/edit dialogs.  Naming is historical
;
PRO CutEvent, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev         ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo     ; Get Dialog info

    CASE Ev OF

    'LIST': BEGIN
        ;   Get new current selection
        Idxs            = Binfo.Ptrs
        Child           = Idxs(Event.Index)
        Binfo.ListIdx   = Event.Index

        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo

        ;   Cannot cut or copy a Dependent base
        IF Event.Top EQ CutId OR Event.Top EQ CopyId THEN BEGIN
            GetType, Child, Type
            WIDGET_CONTROL, Binfo.ActionBtn, SENSITIVE=(Type NE "DEP")
        ENDIF

        ;   Can only look at the children of something that has children
        WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=HasChildren(Child)
        END

    'Cut':  BEGIN
        Dirty       = 1
        Ptrs        = Binfo.Ptrs
        ChildPtr    = Ptrs(Binfo.ListIdx)
        Ptr2Obj, ChildPtr, Child            ; Get Child Info

        Parents     = Binfo.Parents
        ParentPtr   = Parents(0)
        Ptr2Obj, ParentPtr, Parent          ; Get Parent Info

        ;   First child?
        IF Binfo.ListIdx EQ 0 THEN BEGIN
            Parent.Children = Child.Next

            ;   Parent now has no children?
            IF Parent.Children EQ 0 THEN Parent.LastChild = 0
        ENDIF ELSE BEGIN
            PrevPtr = Ptrs(Binfo.ListIdx-1)     ; Get PrevPtr from list
            SetTag, PrevPtr, "Next", Child.Next ; Remove child from list

            ;   Was child lastchild of base?  Set LastChild to show change.
            IF Child.Next EQ 0 THEN Parent.LastChild = PrevPtr
        ENDELSE

        Child.Next  = CutList           ; Child goes onto cut list
        CutList     = ChildPtr
        Obj2Ptr, Child, ChildPtr        ; Save new child info
        Obj2Ptr, Parent, ParentPtr      ; Save new parent info

        RemoveDialogs, ChildPtr         ; Remove active dialog for child tree

        Count   = 1                     ; Cutlist has 10 objects at most
        Ptr     = CutList
        WHILE Ptr NE 0 AND Count LE 10 DO BEGIN
            Prev    = Ptr
            Ptr     = NextPtr(Ptr)
            Count   = Count + 1
        ENDWHILE

        IF Ptr NE 0 THEN BEGIN
            SetTag, Ptr, "Dialog", 0L   ; Don't destroy dialog box
            Destroy, Ptr                ; Destroy 11th item
            SetTag, Prev, "Next", 0L    ; Remove Destroyed item from CutList
        ENDIF
        UpDateEdit, ChildPtr            ; Show changes in cut/copy/paste
        ; We could have destroyed ourselves if we have deleted
        ; the last widget in the hierarchy
        IF CutId NE 0 THEN WIDGET_CONTROL, Binfo.PasteBtn, SENSITIVE=1
        IF CopyId NE 0 THEN BEGIN
            Ptr2Obj, CopyId, CopyInfo
            WIDGET_CONTROL, CopyInfo.PasteBtn, SENSITIVE=1
            Obj2Ptr, CopyInfo, CopyId
        ENDIF

        END

    'Copy': BEGIN
        Ptrs        = Binfo.Ptrs        ; Get Child pointer and type
        ChildPtr    = Ptrs(Binfo.ListIdx)
        GetType, ChildPtr, Type

        CALL_PROCEDURE, Type+"_Copy", ChildPtr, Copy    ; Copy it

        SetTag, Copy, "Next", CutList       ; Add copy to cut list
        CutList     = Copy

        Count       = 1                 ; Cutlist has 10 objects at most
        Ptr         = CutList
        WHILE Ptr NE 0 AND Count LE 10 DO BEGIN
            Prev    = Ptr
            Ptr     = NextPtr(Ptr)
            Count   = Count + 1
        ENDWHILE

        IF Ptr NE 0 THEN BEGIN
            SetTag, Ptr, "Dialog", 0L   ; Don't destroy dialog box
            Destroy, Ptr                ; Destroy 11th item
            SetTag, Prev, "Next", 0L    ; Remove Destroyed item from CutList
        ENDIF

        UpDateEdit                      ; Show changes
        WIDGET_CONTROL, Binfo.PasteBtn, SENSITIVE=1
        IF CutId NE 0 THEN BEGIN
            Ptr2Obj, CutId, CutInfo
            WIDGET_CONTROL, CutInfo.PasteBtn, SENSITIVE=1
            Obj2Ptr, CutInfo, CutId
        ENDIF

        END

    'EDIT': BEGIN
        Ptrs        = Binfo.Ptrs        ; Get child pointer
        ChildPtr    = Ptrs(Binfo.ListIdx)

        Parents     = Binfo.Parents     ; Get parent pointer
        ParentPtr   = Parents(0)

        GetType, ChildPtr, Type         ; Get child type

        ;   Dependent bases are a special case (unfortunately)
        ;   but take the same NUMBER of ARGUMENTS.
        ;   ParentPtr gets set to WIDGET_BASE for the dialog --
        ;   a fact we can ignore.  Just be aware.

        CALL_PROCEDURE, Type+"_Build", ChildPtr, ParentPtr

        ;   If the object being editted is not a base class object
        ;   then we can 'Cancel' it.  That is restore it to a previous
        ;   state.  Here is where we take care of that.  Take a snapshot
        ;   of the current state of the object (copy it) and store
        ;   that information in the active dialog list (NewDialogs)
        ;
        IF Type NE 'BASE' AND Type NE 'DEP' THEN BEGIN
            CALL_PROCEDURE, Type+"_Copy", ChildPtr, Copy

            ;   If we already have dialog in active list (just
            ;   popping it forward) then don't add it to the list

            Dummy       = WHERE(NewDialogs.ObjPtr EQ ChildPtr, Count)
            IF Count EQ 0 THEN BEGIN
                Active  = { WE_NEWOBJ, ParentPtr, ChildPtr, Copy }
                NewDialogs      = [ NewDialogs, Active ]
            ENDIF
        ENDIF
        END

    'CHILD':    BEGIN
        Ptrs        = Binfo.Ptrs            ; Get current pointer
        NewTop      = Ptrs(Binfo.ListIdx)
        Parents     = [ NewTop, Binfo.Parents ] ; Now its the current parent

        MakeLists, Parents(0), List, Strs       ; Make new list

        Binfo   = {                     $       ; Update dialog info
            Ptrs:List,                  $
            Parents:Parents,            $
            LabelId:Binfo.LabelId,      $
            ListId:Binfo.ListId,        $
            ListIdx:0,                  $
            ActionBtn:Binfo.ActionBtn,  $
            PasteBtn:Binfo.PasteBtn,    $
            ChildBtn:Binfo.ChildBtn,    $
            ParentBtn:Binfo.ParentBtn   $
        }

        ;   Set controls to reflect change

        WIDGET_CONTROL, Binfo.LabelId, SET_VALUE='Children of '+VarId(NewTop)
        WIDGET_CONTROL, Binfo.ListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ListId, SET_LIST_SELECT=0

        Child   = List(0)           ; Get type of current (first) child
        GetType, Child, Type

        WIDGET_CONTROL, Binfo.ActionBtn, SENSITIVE=(Type NE "DEP")
        WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=HasChildren(Child)
        WIDGET_CONTROL, Binfo.ParentBtn, SENSITIVE=1    ; Alway can go ..
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        END

    'PARENT':   BEGIN
        Parents     = Binfo.Parents(1:*)    ; New Parent list
        NewTop      = Parents(0)            ; New Top
        MakeLists, NewTop, List, Strs       ; New list of children

        Binfo   = {                     $   ; Update Dialog info
            Ptrs:List,                  $
            Parents:Parents,            $
            LabelId:Binfo.LabelId,      $
            ListId:Binfo.ListId,        $
            ListIdx:0,                  $
            ActionBtn:Binfo.ActionBtn,  $
            PasteBtn:Binfo.PasteBtn,    $
            ChildBtn:Binfo.ChildBtn,    $
            ParentBtn:Binfo.ParentBtn   $
        }

        ;   Set controls to reflect new list

        WIDGET_CONTROL, Binfo.LabelId, SET_VALUE='Children of '+VarId(NewTop)
        WIDGET_CONTROL, Binfo.ListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ListId, SET_LIST_SELECT=0

        ;   Can't cut or copy a DEP base.
        Child   = List(0)
        IF Event.Top EQ CutId OR Event.Top EQ CopyId THEN BEGIN
            GetType, Child, Type
            WIDGET_CONTROL, Binfo.ActionBtn, SENSITIVE=(Type NE "DEP")
        ENDIF
        WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=HasChildren(Child)
        WIDGET_CONTROL, Binfo.ParentBtn, SENSITIVE=(NewTop NE TopPtr)
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        END

    'DOPASTE':  PasteChild

    'DONE':     WIDGET_CONTROL, Event.top, /DESTROY

    ENDCASE
END

;
;  CutChild
;   Bring up Dialog box to allow user to look through
;   existing objects for the one they want to cut/copy
;
PRO CutChild, COPY=Copy

  COMMON WidEd_Comm

    ;   Which kind of dialog are we anyway?
    IF KEYWORD_SET(Copy) THEN Action='Copy' ELSE Action='Cut'

    MgrName = 'Wid' + Action + 'Top'            ; Already up?
    IF XRegistered(MgrName) THEN RETURN

    Title   = Action + ' Widget'
    Ptr2Obj, TopPtr, Obj
    IF Obj.Children EQ 0 AND Obj.Next EQ 0 THEN BEGIN
        ErrorDialog, TopDlg, ['Internal Error: ', $
            'There are no child widgets to ' + Action ]
        RETURN
    ENDIF
    Obj2Ptr, Obj, TopPtr

    ;   Start by using the top level base

    MakeLists, TopPtr, List, Strs

    ;   Build Dialog

    BaseId      = WIDGET_BASE(GROUP_LEADER=TopDlg, /COLUMN, TITLE=Title)
    LabelId     = WIDGET_LABEL(BaseId, VALUE='Children of ' + VarId(TopPtr))
    ListId      = WIDGET_LIST(BaseId, VALUE=Strs, YSIZE=10,UVALUE='LIST')
    ActionBtn   = WIDGET_BUTTON(BaseId, VALUE=Action +' Child', UVALUE=Action)
    ChildBtn    = WIDGET_BUTTON(BaseId, VALUE='Show Children', UVALUE='CHILD')

    Child   = List(0)       ; Can't cut/copy a DEP base
    GetType, Child, Type
    WIDGET_CONTROL, ActionBtn, SENSITIVE=(Type NE "DEP")
    WIDGET_CONTROL, ChildBtn, SENSITIVE=HasChildren(Child)

    ;   Top Base has no parent.  Create the button but disable it.
    ParentBtn   = WIDGET_BUTTON(BaseId, VALUE='Show Parent Base', $
            UVALUE='PARENT')
    WIDGET_CONTROL, ParentBtn, SENSITIVE=0

    PasteBtn    = WIDGET_BUTTON(BaseId, VALUE='Show Paste Dialog', $
                                UVALUE='DOPASTE')
    WIDGET_CONTROL, PasteBtn, SENSITIVE=(CutList NE 0L)

    Button      = WIDGET_BUTTON(BaseId, VALUE='Done', UVALUE='DONE')

    Binfo   = {                 $
        Ptrs:List,              $
        Parents: TopPtr,        $
        LabelId: LabelId,       $
        ListId: ListId,         $
        ListIdx: 0,             $
        ActionBtn: ActionBtn,   $
        PasteBtn: PasteBtn,     $
        ChildBtn: ChildBtn,     $
        ParentBtn: ParentBtn    $
    }
    WIDGET_CONTROL, BaseId, /REALIZE
    WIDGET_CONTROL, ListId, SET_LIST_SELECT=0
    WIDGET_CONTROL, BaseId, SET_UVALUE=Binfo, /NO_COPY
    XMANAGER, MgrName, BaseId, EVENT_HANDLER='CutEvent',CLEANUP='KillEdit'
    IF KEYWORD_SET(Copy) THEN CopyId = BaseId ELSE CutId = BaseId
END


;
;  EditChild
;   Allow user to get to dialog boxes they have dismissed previously.
;
PRO EditChild

  COMMON WidEd_Comm

    MgrName = 'WidEditTop'
    IF XRegistered(MgrName) THEN RETURN             ; Already up?

    Title   = 'Edit Widget'
    Ptr2Obj, TopPtr, Obj
    IF Obj.Children EQ 0 AND Obj.Next EQ 0 THEN BEGIN
        ErrorDialog, TopDlg, ['Internal Error: ', $
            'There are no child widgets to Edit' ]
        RETURN
    ENDIF
    Obj2Ptr, Obj, TopPtr

    ;   Start by showing the top level children.

    MakeLists, TopPtr, List, Strs

    ;   Build Dialog

    EditId  = WIDGET_BASE(GROUP_LEADER=TopDlg, /COLUMN, TITLE=Title)
    LabelId = WIDGET_LABEL(EditId, VALUE='Children of '+ VarId(TopPtr))
    ListId  = WIDGET_LIST(EditId, VALUE=Strs, YSIZE=10, UVALUE='LIST')
    EditBtn = WIDGET_BUTTON(EditId, VALUE='Edit Child', UVALUE='EDIT')
    ChildBtn    = WIDGET_BUTTON(EditId, VALUE='Show Children', UVALUE='CHILD')
    WIDGET_CONTROL, ChildBtn, SENSITIVE=HasChildren(List(0))
    ParentBtn   = WIDGET_BUTTON(EditId, VALUE='Show Parent Base', $
            UVALUE='PARENT')
    WIDGET_CONTROL, ParentBtn, SENSITIVE=0
    Button  = WIDGET_BUTTON(EditId, VALUE='Done', UVALUE='DONE')

    ;   We don't really use the ActionBtn or PasteBtn fields but we
    ;   need to have them so that the dialog information is identical
    ;   to that used by Cut/Copy dialogs (all 3 share a common event handler)

    Binfo   = {             $
        Ptrs:List,          $
        Parents: TopPtr,    $
        LabelId:LabelId,    $
        ListId:ListId,      $
        ListIdx:0,          $
        ActionBtn:EditBtn,  $
        PasteBtn:0L,        $
        ChildBtn:ChildBtn,  $
        ParentBtn:ParentBtn $
    }
    WIDGET_CONTROL, EditId, /REALIZE

    WIDGET_CONTROL, ListId, SET_LIST_SELECT=0
    WIDGET_CONTROL, EditId, SET_UVALUE=Binfo, /NO_COPY
    XMANAGER, MgrName, EditId,  $
        EVENT_HANDLER='CutEvent',CLEANUP='KillEdit'
END


;
;  PasteChildEvent
;   Event handler for the Paste dialog.
;
PRO PasteChildEvent, Event
  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev         ; Get Event
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo     ; Get Dialog Info

    CASE Ev OF

    'CUTLIST':  BEGIN
        Binfo.FromIdx   = Event.Index                   ; Set Currnt From Idx
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo
        END

    'PASTELIST':    BEGIN
        Idxs            = Binfo.Ptrs
        Child           = Idxs(Event.Index)
        Binfo.ToIdx     = Event.Index

        IF Child EQ -1L THEN Type = ';BOGUS' $         ; <Top of List> ?
        ELSE GetType, Child, Type                       ; Regular selection

        ;   Cant paste after a dependent base
        WIDGET_CONTROL, Binfo.PasteBtn, SENSITIVE=(Type NE 'DEP')
        ;   Can look in a base which has no children
        WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=HasChildren(Child,/NONE_OK)

        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo     ; Update Dialog info
        END

    'PASTE':    BEGIN
        Ptrs        = Binfo.Ptrs            ; Get Parent pointer
        Parents     = Binfo.Parents
        ParentPtr   = Parents(0)
        ChildPtr    = Ptrs(Binfo.ToIdx)     ; Get child pointer

        Ptr         = CutList               ; Given From List index
        Count       = Binfo.FromIdx         ; figure out the current
        WHILE Count NE 0 DO BEGIN           ; item to paste
            Ptr     = NextPtr(Ptr)
            Count   = Count - 1
        ENDWHILE

        GetType, Ptr, Type                  ; Copy item to paste
        CALL_PROCEDURE, Type+"_Copy", Ptr, Dup
        SetTag, Dup, "Id", NewId()          ; Give it a new Id.

        ;   Add into child list

        IF ChildPtr EQ -1L THEN BEGIN        ;   First child?

            Ptr2Obj, ParentPtr, PObj

            SetTag, Dup, "Next", PObj.Children
            IF PObj.Children EQ 0 THEN PObj.LastChild = Dup
            PObj.Children    = Dup

            Obj2Ptr, PObj, ParentPtr

        ENDIF ELSE BEGIN

            SetTag, Dup, "Next", NextPtr(ChildPtr)  ; Dup->next = prev->next
            SetTag, ChildPtr, "Next", Dup           ; prev->next = dup

            ;   We keep track of last child.  If ChildPtr was the
            ;   last child it isn't any longer.  Change the Parent's
            ;   LastChild to reflect the addition

            Ptr2Obj, ParentPtr, PObj
            IF PObj.LastChild EQ ChildPtr THEN PObj.LastChild = Dup
            Obj2Ptr, PObj, ParentPtr

        ENDELSE

        UpdateEdit          ; Show changes in cut/paste/etc.
        END

    'CHILD':    BEGIN
        Ptrs        = Binfo.Ptrs                ; Current selection is now
        NewTop      = Ptrs(Binfo.ToIdx)         ; the current parent
        Parents     = [ NewTop, Binfo.Parents ]

        MakeLists, Parents(0), List, Strs

        List    = [ -1L, List]                  ; Add top-of-list item
        Strs    = [ '<Top of List>', Strs ]

        Binfo   = {                     $       ; Create dialog info
            Ptrs:List,                  $
            Parents:Parents,            $
            FromIdx:Binfo.FromIdx,      $
            ToIdx:0,                    $
            FromListId:Binfo.FromListId,$
            LabelId:Binfo.LabelId,      $
            ToListId:Binfo.ToListId,    $
            PasteBtn:Binfo.PasteBtn,    $
            ChildBtn:Binfo.ChildBtn,    $
            ParentBtn:Binfo.ParentBtn   $
        }

        ;   Set dialog controls to reflect current conditions

        WIDGET_CONTROL, Binfo.LabelId, SET_VALUE='Children of '+VarId(NewTop)
        WIDGET_CONTROL, Binfo.ToListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ToListId, SET_LIST_SELECT=0
        WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=0
        WIDGET_CONTROL, Binfo.ParentBtn, SENSITIVE=1    ; Alway can go ..
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        END

    'PARENT':   BEGIN
        Parents     = Binfo.Parents(1:*)   ; Go toward root widget 1 level
        NewTop      = Parents(0)
        MakeLists, NewTop, List, Strs

        List    = [ -1L, List]                  ; Add top-of-list item
        Strs    = [ '<Top of List>', Strs ]

        Binfo   = {                     $       ; Create dialog info
            Ptrs:List,                  $
            Parents:Parents,            $
            FromIdx:Binfo.FromIdx,      $
            ToIdx:0,                    $
            FromListId:Binfo.FromListId,$
            LabelId:Binfo.LabelId,      $
            ToListId:Binfo.ToListId,    $
            PasteBtn:Binfo.PasteBtn,    $
            ChildBtn:Binfo.ChildBtn,    $
            ParentBtn:Binfo.ParentBtn   $
        }

        ;   Set dialog controls to reflect current conditions

        WIDGET_CONTROL, Binfo.LabelId, SET_VALUE='Children of '+VarId(NewTop)
        WIDGET_CONTROL, Binfo.ToListId, SET_VALUE=Strs
        WIDGET_CONTROL, Binfo.ToListId, SET_LIST_SELECT=0
        WIDGET_CONTROL, Binfo.ChildBtn, SENSITIVE=0
        WIDGET_CONTROL, Binfo.ParentBtn, SENSITIVE=(NewTop NE TopPtr)
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        END

    'DELETE':   BEGIN

        ;       Cutting first item on the list?

        IF Binfo.FromIdx EQ 0 THEN BEGIN

            Item        = CutList
            CutList     = NextPtr(CutList)
            Destroy, Item

            ;  Nothing left to paste?  We are done.

            IF CutList EQ 0 THEN BEGIN
                ; Can't paste no more

                Ptr2Obj, TopDlg, DlgInfo
                WIDGET_CONTROL, DlgInfo.PasteId, SENSITIVE=0
                Obj2Ptr, DlgInfo, TopDlg 

                IF CutId NE 0 THEN BEGIN
                    Ptr2Obj, CutId, CutInfo
                    WIDGET_CONTROL, CutInfo.PasteBtn, SENSITIVE=0
                    Obj2Ptr, CutInfo, CutId
                ENDIF

                IF CopyId NE 0 THEN BEGIN
                    Ptr2Obj, CopyId, CopyInfo
                    WIDGET_CONTROL, CopyInfo.PasteBtn, SENSITIVE=0
                    Obj2Ptr, CopyInfo, CopyId
                ENDIF

                WIDGET_CONTROL, Event.top, /DESTROY
                RETURN
            ENDIF

        ENDIF ELSE BEGIN

            Ptr         = CutList           ; Given From List index
            Count       = Binfo.FromIdx     ; figure out the current
            WHILE Count NE 0 DO BEGIN       ; item to paste
                Prev    = Ptr
                Ptr     = NextPtr(Ptr)
                Count   = Count - 1
            ENDWHILE

            SetTag, Prev, "Next", NextPtr(Ptr)
            Destroy, Ptr

        ENDELSE

        ;   Create list entries based on Cutlist contents

        FromStrs    = ""
        Ptr         = CutList
        WHILE Ptr NE 0 DO BEGIN
            IdStr   = GetId(Ptr)
            IF StrLen(IdStr) GT 20 THEN $
                IdStr = STRING(FORMAT='(A17,"...")', IdStr)
            FromStrs    = [ FromStrs, VarId(Ptr)+' ('+IdStr+')' ]
            Ptr         = NextPtr(Ptr)
        ENDWHILE

        ;   Update list and binfo structure

        WIDGET_CONTROL, Binfo.FromListId, SET_VALUE=FromStrs(1:*)
        WIDGET_CONTROL, Binfo.FromListId, SET_LIST_SELECT=0
        Binfo.FromIdx   = 0
        WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
        END

    'DONE':         WIDGET_CONTROL, Event.top, /DESTROY

    ENDCASE
END


;
;  PasteChild
;   Bring up a Dialog box to allow the user to paste(copy) objects
;   that are on the cutlist into the current widget tree.
;
PRO PasteChild

  COMMON WidEd_Comm      

    MgrName = 'WidPasteTop'
    IF XRegistered(MgrName) THEN RETURN         ; Already have dialog?

    Title   = 'Paste Widgets'
    IF CutList EQ 0L THEN BEGIN
        ErrorDialog, TopDlg, ['Internal Error: ', $
            'There are no child widgets to Paste' ]
        RETURN
    ENDIF

    ;   Create the dialog

    PasteId = WIDGET_BASE(GROUP_LEADER=TopDlg, /COLUMN, TITLE=Title)
    Base1   = WIDGET_BASE(PasteId, /ROW)
    Base2   = WIDGET_BASE(Base1, /COLUMN)
    Label   = WIDGET_LABEL(Base2, VALUE='Clipboard')

    ;   Create list entries based on Cutlist contents

    FromStrs    = ""
    Ptr         = CutList
    WHILE Ptr NE 0 DO BEGIN
        IdStr   = GetId(Ptr)
        IF StrLen(IdStr) GT 20 THEN $
            IdStr = STRING(FORMAT='(A17,"...")', IdStr)
        FromStrs    = [ FromStrs, VarId(Ptr)+' ('+IdStr+')' ]
        Ptr         = NextPtr(Ptr)
    ENDWHILE

    FromListId  = WIDGET_LIST(Base2, VALUE=FromStrs(1:*), YSIZE=10, $
            UVALUE='CUTLIST')
    Delete  = WIDGET_BUTTON(Base2, VALUE='Delete Widget', UVALUE='DELETE')
    Base2   = WIDGET_BASE(Base1, /COLUMN)
    LabelId = WIDGET_LABEL(Base2, VALUE='Children of '+VarId(TopPtr))

    MakeLists, TopPtr, List, Strs           ; Make list of top level children

    List    = [ -1L, List]                  ; Add top-of-list entry
    Strs    = [ '<Top of List>', Strs ]

    ToListId    = WIDGET_LIST(Base2, VALUE=Strs, YSIZE=10, $
            UVALUE='PASTELIST')
    PasteBtn    = WIDGET_BUTTON(Base2, VALUE='Paste After', UVALUE='PASTE')
    ChildBtn    = WIDGET_BUTTON(Base2, VALUE='Show Children', UVALUE='CHILD')
    WIDGET_CONTROL, ChildBtn, SENSITIVE=0
    ParentBtn   = WIDGET_BUTTON(Base2, VALUE='Show Parent Base', $
            UVALUE='PARENT')
    WIDGET_CONTROL, ParentBtn, SENSITIVE=0
    Button  = WIDGET_BUTTON(PasteId, VALUE='Done', UVALUE='DONE')

    Binfo   = {                 $               ; Create Dialog info
        Ptrs:List,              $
        Parents: TopPtr,        $
        FromIdx:0,              $
        ToIdx:0,                $
        FromListId:FromListId,  $
        LabelId:LabelId,        $
        ToListId:ToListId,      $
        PasteBtn:PasteBtn,      $
        ChildBtn:ChildBtn,      $
        ParentBtn:ParentBtn     $
    }
    WIDGET_CONTROL, PasteId, /REALIZE
    WIDGET_CONTROL, FromListId, SET_LIST_SELECT=0   ; Select item 0 of from
    WIDGET_CONTROL, ToListId, SET_LIST_SELECT=0     ; Select item 0 of to

    ;   Note:  We know that we can always paste the 1st cutlist item
    ;   after the top-of-list item.  Thats why we don't play with
    ;   PasteBtn sensitivity here

    WIDGET_CONTROL, PasteId, SET_UVALUE=Binfo, /NO_COPY
    XMANAGER, MgrName, PasteId, $
        EVENT_HANDLER='PasteChildEvent',CLEANUP='KillEdit'
END


;
;  KillEdit
;   Common kill routine for all cut/paste/etc. dialogs.  Reset common
;   block id for the appropriate dialog to show dialog has been destroyed.
;
PRO KillEdit, Id

  COMMON WidEd_Comm      

    IF Id EQ CutId THEN CutId = 0L
    IF Id EQ CopyId THEN CopyId = 0L
    IF Id EQ PasteId THEN PasteId = 0L
    IF Id EQ EditId THEN EditId = 0L
END

PRO WidEdit
END
;
; $Id: wided.pro,v 1.16 1995/01/26 03:08:47 billo Exp $
;
;
;  WidEd
;   Entry point for widget builder.
;   Reads in all related functions and procedures.
;
; Copyright (c) 1993, 1994, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; Version   = Beta 0.9
;
;+
; NAME:
;       WIDED
;
; PURPOSE:
;       An IDL dialog Editor.  Lets one graphically produce a widget
;       hierarchy.
;
; CATEGORY:
;       Widgets.
;
; CALLING SEQUENCE:
;       WIDED [, File ]
;
; OPTIONAL INPUTS:
;       File:   Widget builder will read this file.  File should
;               be a widget file (.WID)
;
; KEYWORD PARAMETERS:
;       None.
;
; COMMON BLOCKS:
;
;       FMagic_Comm     -- Store global variable, NoCheck.
;       TestDraw_Comm   -- Saves a seed number used in random plot generation
;       WidDirty_Comm   -- Save Yes/No/Cancel information in Dirty
;       WidEd_Comm      -- Global variables used through the Widget Builder
;                       Definition of this common block in in wided.com
;       XPrintf_Comm    -- Save I/O state to allow multiple I/O operations
;                       to write a single line.  FORMAT=(..., $) doesn't
;                       work on VMS and this needs to work *EVERYWHERE*
;
; SIDE EFFECTS:
;       Builds widget trees.  Writes IDL Code.  Probably more side
;       effects than you can shake a stick at.
;
; RESTRICTIONS:
;       You must have IDL 3.5 or later.  This is a graphical program
;       so widgets must be available.
;
; PROCEDURE:
;       Add, delete, cut, copy and paste widgets to your hearts delight.
;       Save the results if you want to.
;
; EXAMPLE:
;       Please see the "Using the IDL Widget Builder" document.
;
; MODIFICATION HISTORY:
;       Written by:     Joshua Goldstein,       Spring '93
;
;       Fall '93        Complete rewrite using widget UVALUEs instead
;                       of uniform structures to store hierarchy. Added
;                       bitmapped buttons, pull down menus, embedded
;                       comments in .PRO files to save user mods.
;                       Made adding user classes even easier (add 1 line
;                       to widdef.dat).  Still need to write class library.
;                       Added comments to wided.  Hope they help.
;
;-

;


pro wided_common
   ; The only  purpose of this routine is that it should be
   ; the first thing compiled in the widget builder. It defines
   ; WidEd_Comm COMMON block, and allows the other routines to
   ; simply ask for the block name without providing the variable names.

  COMMON WidEd_Comm,  $
    Bases,          $       ; Top level bases in preview
	BaseXY,			$		; Remember if user moves bases
    Dirty,          $       ; TRUE if object tree has been modified
    InDestroy,      $       ; TRUE during parts of destroy processing.
    FileName,       $       ; Current file name
    FileDir,        $       ; Current directory
    NewDialogs,     $       ; Active Dialog information
    TopPtr,         $       ; MAIN Object. Root of object tree
    TopDlg,         $       ; Main dialog box id. Group leader to all
    CutList,        $       ; List of last 10 objects cut
    LastId,         $       ; Last Id used so far.
    AddList,        $       ; class list
    CutId, CopyId,  $       ; Ids for the 4 dialog boxes which need to be
    PasteId, EditId, $      ; updated whenever an object is added/delete
    OnAPC,	    $	    ; PC's have no visible text border
    SmallScreen		    ; MAC's (maybe others) need scrolling bases

end




;
;   We need to predeclare some functions so that things compile properly
;

FUNCTION NextPtr, Ptr & RETURN,0L & END
FUNCTION VarName, Ptr & RETURN,'' & END

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;
;  Init
;   Initialize global variables.  Destroy the old object tree (if it
;   exists).  Create a new object tree with only one object: the MAIN base.
;
PRO Init, COMPILE_ONLY=NoRealize

  COMMON WidEd_Comm

    COMMON  XPrintf_Comm, OutputBuffer, ArgList

    ;   Support and library routines.

    WidUtil
    WidAlloc
    WidBuild
    WidEdit
    WidFile
    WidMain
    WidDep


    ;  PC's need frames on their text fields.

    OnAPC =  (!Version.OS EQ 'Win32')


    IF N_ELEMENTS(TopPtr) EQ 0 THEN TopPtr = 0L
    TopDlg      = 0L

    ;   Destroy the old object tree.

    IF WIDGET_INFO(TopPtr, /VALID) THEN BEGIN

        ;   We can get into a state where TopPtr is valid but
        ;   does not contain anything. So we check everything

        IF WIDGET_INFO(TopPtr, /VALID_ID) THEN BEGIN    ; is TopPtr valid
            Ptr2Obj, TopPtr, Obj
            IF KEYWORD_SET(Obj) THEN BEGIN  ; Does it contain an obj?
                Obj2Ptr, Obj, TopPtr        ; Put obj back into pointer
                Destroy, TopPtr             ; Destroy it
            ENDIF
        ENDIF
    ENDIF ELSE BEGIN
        TopPtr  = 0L
    ENDELSE

    Bases       = LONARR(100)       ; #define MAXTOP 100
    BaseXY      = INTARR(2,100)     ; BaseXY[MAXTOP][2]
    Dirty       = 0                 ; no changes yet
    InDestroy   = 0                 ; not destroying anything right now
    FileName    = "unknown"         ; no current file
    FileDir     = ""                ; no current directory

    ;   declare the different structure types used

    Dummy       = { CW_PDMENU_S, flags:0, name:'' }
    Dummy       = { WE_MENUITEM, Str: '', SubMenuPtr: 0L }
    NewDialogs  = { WE_NEWOBJ, ParPtr:0L, ObjPtr:0L, OldPtr:0L }
    AddList     = { WE_ADDLIST, Menu:'', Class: '' }

    CutId       = 0     ; No Cut Dialog
    CopyId      = 0     ; No Copy Dialog
    EditId      = 0     ; No Edit Child dialog
    PasteId     = 0     ; No Paste Dialog

    LastId      = 1 ; No widgets created yet.

    ;   Assume that there are valid items on the cutlist if it exists
    ;   otherwise make it the nil list.
    IF N_ELEMENTS(CutList) EQ 0 THEN CutList = 0L $
    ELSE IF WIDGET_INFO(CutList, /VALID) EQ 0 THEN CutList = 0L

    ;   Open the definition file
    GET_LUN, Unit
    DefFile     = "widdef.dat"
    OPENR, Unit, DefFile, ERROR = OpenError
    IF OpenError NE 0 THEN BEGIN
        DefFile = FilePath("widdef.dat", SUBDIR="lib")
        OPENR, Unit, DefFile
    ENDIF

    Line    = ''
    Quote   = (BYTE('"'))(0)
    LineNo  = 1

    WHILE NOT EOF(Unit) DO BEGIN
        READF, Unit, Line
        ;   Ignore blank lines and comments
        IF Line NE '' AND STRMID(Line,0,1) NE '#' THEN BEGIN
            ;   Complain about lines which we can't parse
            MenuExt = WHERE(BYTE(Line) EQ Quote, Count)
            IF Count NE 2 THEN BEGIN
                Print, "Error in definition file on line", LineNo
                GOTO, Error
            ENDIF
            Menu    = STRMID(Line, MenuExt(0)+1, MenuExt(1)-MenuExt(0)-1)
            Class   = STRTRIM(STRMID(Line, MenuExt(1)+1, 1000), 2)
            AddList = [ AddList, { WE_ADDLIST, Menu, Class } ]
        ENDIF
    Error:
        LineNo  = LineNo + 1
    ENDWHILE

    FREE_LUN, Unit

    ;   Crash and burn if addlist is empty
    IF N_ELEMENTS(AddList) EQ 1 THEN BEGIN
        MESSAGE, "No classes defined!. Cannot continue."
    ENDIF
    Addlist     = AddList(1:*)

    ;   Load class libraries

    FOR I=0,N_ELEMENTS(AddList)-1 DO BEGIN
        ClearVar, Child
        CALL_PROCEDURE, AddList(I).Class + "_Alloc", 0L, Child
        CALL_PROCEDURE, AddList(I).Class + "_Destroy", Child
    ENDFOR

    IF NOT KEYWORD_SET(NoRealize) THEN BEGIN
        ;   Create primary dialog.
        MAIN_Build, TopPtr, TopDlg
        WIDGET_CONTROL, TopPtr, GROUP=TopDlg
    ENDIF

    LastId          = 2 ; Reset


    ;   Check for small screen size.
    ;   We consider any screen less than 768 pixels tall to be a
    ;   small screen
;
;   Got rid of this hack since the Mac now makes large bases scroll
;   automatically. Besides, this code didn't even work right on the Mac.
;
    DEVICE, GET_SCREEN=ScreenSize
;    IF ScreenSize(1) LT 768 THEN BEGIN
;        SmallScreen     = FIX(ScreenSize * 0.75)
;        SmallScreen(0)  = SmallScreen(0) < 500  ; Hack
;    ENDIF ELSE BEGIN
        SmallScreen = [0,0]
;    ENDELSE

    ;   Set XPRINTF buffer to nil
    ;   Setup Xprintf ArgList (c.f. InternalXprintf in widfile.pro)

    OutputBuffer    = ""
    ArgList         = STRARR(8)
    ArgList(0)      = ""
    ArgList(1)      = "a1"
    ArgList(2)      = "a1,a2"
    ArgList(3)      = "a1,a2,a3"
    ArgList(4)      = "a1,a2,a3,a4"
    ArgList(5)      = "a1,a2,a3,a4,a5"
    ArgList(6)      = "a1,a2,a3,a4,a5,a6"
    ArgList(7)      = "a1,a2,a3,a4,a5,a6,a7"

END


;
;  Gen_Event
;   Generic event handler.  Absorbs events the user has created by
;   playing with the
;
PRO Gen_event, Event

;   Preview event

END

;
;  GenBase_Event
;   A event routine to absorb events handle TLB resize events of
;   preview of the user's GUI. Set XY size/offset/scrollsize in dialogs
;   to reflect change
;
;PRO GenBase_event, Event
;
;   WIDGET_CONTROL, Event.Top, GET_UVALUE=Ptr
;   Ptr2Obj, Ptr, Obj
;
;   WIDGET_CONTROL, Event.Id, TLB_GET_OFFSET=Off, TLB_GET_SIZE=Sz
;   Obj.XOffset = Off(0)
;   Obj.YOffset = Off(1)
;
;   IF Obj.XScrollSize NE 0 OR Obj.YScrollSize NE 0 THEN BEGIN
;       Obj.XScrollSize = Sz(0)
;       Obj.YScrollSize = Sz(1)
;   ENDIF ELSE BEGIN
;       Obj.XSize   = Sz(0)
;       Obj.YSize   = Sz(1)
;   ENDELSE
;
;   IF Obj.Dialog NE 0L THEN BEGIN
;       FociOff = 5 + (Obj.Type EQ "DEP")
;       WIDGET_CONTROL, Obj.Dialog, GET_UVALUE=Binfo, /NO_COPY
;
;       WIDGET_CONTROL, Binfo.Foci(FociOff), SET_VALUE=Obj.XScrollSize
;       WIDGET_CONTROL, Binfo.Foci(FociOff+1), SET_VALUE=Obj.YScrollSize
;
;       WIDGET_CONTROL, Obj.Dialog, SET_UVALUE=Binfo, /NO_COPY
;   ENDIF
;   IF Obj.AttrDlg NE 0L THEN BEGIN
;       FociOff = 5
;       WIDGET_CONTROL, Obj.AttrDlg, GET_UVALUE=Binfo, /NO_COPY
;
;       WIDGET_CONTROL, Binfo.Foci(FociOff), SET_VALUE=Obj.XSize
;       WIDGET_CONTROL, Binfo.Foci(FociOff+1), SET_VALUE=Obj.XOffset
;       WIDGET_CONTROL, Binfo.Foci(FociOff+2), SET_VALUE=Obj.YSize
;       WIDGET_CONTROL, Binfo.Foci(FociOff+3), SET_VALUE=Obj.YOffset
;
;       WIDGET_CONTROL, Obj.AttrDlg, SET_UVALUE=Binfo, /NO_COPY
;   ENDIF
;   Obj2Ptr, Obj, PTr
;END


;
;  Generate
;   Recreate preview to reflect current object tree information
;
PRO Generate

  COMMON WidEd_Comm

    ;   Remove old preview bases

    FOR I=0,N_ELEMENTS(Bases)-1 DO BEGIN
        B   = Bases(I)
        IF B NE 0 AND WIDGET_INFO(B,/VALID_ID) THEN BEGIN
            WIDGET_CONTROL, B, TLB_GET_OFFSET=Off
            BaseXY(*,I) = Off
            WIDGET_CONTROL, B, /DESTROY
        ENDIF ELSE BEGIN
            BaseXY(*,I) = 0
        ENDELSE
        Bases(I)    = 0
    ENDFOR

    ;   Generate new top level bases and save their Id's
    Ptr = TopPtr
    I   = 0
    WHILE Ptr NE 0 DO BEGIN
        DEP_Generate, Ptr, NewBase, I
        Bases(I)    = NewBase
        I           = I + 1
        Ptr         = NextPtr(Ptr)
    ENDWHILE
END


;
;  WidEd
;   Run the widget builder
;
PRO WidEd, File

  COMMON WidEd_Comm

    ; Can only have one widget builder running at a time
    IF XRegistered("Widget_Builder") THEN RETURN

    Init            ; Set up globals.  Build top dialog box
    Generate        ; Show preview of emptywidget tree.
    XManager, 'Widget_Builder', TopDlg, $
        EVENT_HANDLER="MAIN_BarEvent", /JUST_REG

    ;  If user has a file in mind, open it.

    IF N_ELEMENTS(File) NE 0 THEN BEGIN
        InsureExt, File, '.wid'
        InternalFileOpen, File
    ENDIF
    XManager
END
;
; $Id: widfile.pro,v 1.16 1995/01/26 03:32:11 billo Exp $
;
;  WidFile
;   Widget File class library
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;


;
;  Currpath
;   Return the current path. If there is no current path, chose
;   a reasonable default path. (I use the current directory)
;
FUNCTION CurrPath

  COMMON WidEd_Comm

    IF FileDir NE '' THEN RETURN, FileDir       ; FileDir non nil

    CASE !Version.OS OF                         ; Use default (OS dependent)
    'vms':  RETURN,'[]'                         ; VAX VMS
    'Win32':  RETURN,'.'                      ; PC
    'MacOS':  RETURN,''                         ; Macintosh
    ELSE:   RETURN,'.'                          ; UNIX
    ENDCASE
END


;
;  ExtractSimpleName
;   Given a full file name, extract the simple filename without extention
;   or directory path.  See examples below:
;
;   foo.pro                 -> foo
;   /ugh/bar/foo.pro        -> foo
;   c:foo.wid               -> foo
;   a:\b\c\d\e\foo.pro      -> foo
;   xx:[IDL.JOSH]FOO.PRO    -> FOO
;
FUNCTION ExtractSimpleName, File, START=Start

    Idx = WHERE(!Version.OS EQ [ "vms", "Win32", "MacOS" ])
    Idx = Idx(0) + 1

                ;   Unix, VMS, WIN, MAC
    First       = ([ '/', ']', '\', ':'])(Idx)
    Second      = ([ '',  ':', ':', ''])(Idx)
    ExtCh       = ([ '.', '.', '.', '.'])(Idx)
    ExtCh2      = ([ '',  ';', '',  ''])(Idx)

    ;   Find end of path and/or disk/volume descriptor.

    Start       = RSTRPOS(File, First) + 1
    IF Start EQ 0 AND Second NE '' THEN Start = RSTRPOS(File, Second) + 1

    ;   Get filename.
    Simple      = STRMID(File,Start,1000)

    ;   Remove ending if there might be one.
    ;   Most have a '.' ending.  VMS might have a version too.

    IF ExtCh NE '' THEN BEGIN
        Ext = RSTRPOS(Simple, ExtCh)
        IF Ext EQ -1 AND ExtCh2 NE '' THEN Ext = RSTRPOS(Simple, ExtCh2)
        IF Ext NE -1 THEN Simple = STRMID(Simple,0,Ext)
    ENDIF

    RETURN, Simple      ; Return what we found.
END


;
;  InsureExt
;   Make sure a file name has the correct ending
;
PRO InsureExt, File, Ending

    Simple  = ExtractSimpleName( File, START=Start )

    File    = STRMID(File,0,Start) + Simple + Ending
END

;
;  InternalXprintf
;
;   Create a string given a list of arguments and a format string
;
;   Used to write less than a line because PRINTF, FORMAT=(..., $)
;   doesn't work on VMS for the file types we use.
;
FUNCTION InternalXPrintf, n, a1, a2, a3, a4, a5, a6, a7, FORMAT=Fmt

    COMMON  XPrintf_Comm, OutputBuffer, ArgList

    DoFormat    = KEYWORD_SET(Fmt)
    Buffer      = ""

    IF n EQ 0 THEN BEGIN
        IF DoFormat EQ 0 THEN RETURN, ""
        MESSAGE, 'STRING() required a positional argument'
    ENDIF ELSE BEGIN

        StrCmd      = "Buffer = STRING(" + ArgList( n )
        IF KEYWORD_SET(Fmt) THEN BEGIN
            StrCmd  = StrCmd + ', FORMAT=Fmt )'
        ENDIF ELSE BEGIN
            StrCmd  = StrCmd + ')'
        ENDELSE

    ENDELSE

    Dummy   = EXECUTE( StrCmd )
    RETURN, Buffer
END

;
;  XPRINTF
;   VMS can't use FORMAT=(..., $) to have multiple I/O operations
;   write the same line of text.  At least not using the file types
;   we have.  Each I/O operation is its own line
;
PRO XPRINTF, Unit, a1, a2, a3, a4, a5, a6, a7, $
                                FORMAT=Fmt, NO_EOL=NoNewline

    COMMON  XPrintf_Comm, OutputBuffer, ArgList

    n   = N_PARAMS() - 1

    IF KEYWORD_SET(NoNewline) THEN BEGIN
        OutputBuffer    = OutputBuffer + $
                InternalXprintf( n, a1, a2, a3, a4, a5, a6, a7, FORMAT=Fmt )

    ENDIF ELSE BEGIN

        PRINTF, Unit, OutputBuffer + $
                InternalXprintf( n, a1, a2, a3, a4, a5, a6, a7, FORMAT=Fmt )
        OutputBuffer    = ""

    ENDELSE

END

;
;  GenWrite
;   General purpose object save routine.
;   Most objects can be written in one of two ways:
;       1. Just the object.
;       2. The object followed by a string array
;
PRO GenWrite, Unit, Ptr, DEFAULT=Default

  COMMON WidEd_Comm

    ON_IOERROR, BadWrite

    Ptr2Obj, Ptr, Obj
    WRITEU, Unit, Obj               ; Save basic information

    IF N_ELEMENTS(Default) NE 0 THEN BEGIN
        GetValue, Obj, Names, Default   ; Use default if object has no value
        WRITEU, Unit, N_ELEMENTS(Names) ; Save n_elements of value
        WRITEU, Unit, Names             ; Save value
    ENDIF

    Obj2Ptr, Obj, Ptr
    RETURN

  BadWrite:
    Dirty   = 2

END

;
;  MISC_Restore
;   A great many of the objects are stored in a file in the same
;   way.  In fact, except for base objects EVERYTHING is stored
;   in on of 2 ways:  Just the object or an object with a <STRARR>
;   following it.  We handle both (if you tell us which it is)
;
PRO MISC_Restore, Unit, Parent, Ptr, Type, HasValue1

    ; Get an object of the right sort
    CALL_Procedure, Type+'_Alloc', Parent, Ptr
    Ptr2Obj, Ptr, Obj

    IF HasValue1 THEN BEGIN

        SaveV1  = Obj.Value1        ; Save value pointer (crushed by read)
        READU, Unit, Obj            ; Read in object

        N_Str   = 0                 ; Read in STRARR size and then strings
        READU, Unit, N_str
        Names   = STRARR(N_Str)
        READU, Unit, Names

        Obj.Value1  = SaveV1        ; Restore saved value pointer
        Obj2Ptr, Names, Obj.Value1  ; Store names in value pointer

    ENDIF ELSE BEGIN

        READU, Unit, Obj    ; Just object needs to be read

    ENDELSE

    Obj.Dialog  = 0         ; Clear old (and invalid) value
    Obj.Next    = 0         ; Clear old (and invalid) value
    Obj2Ptr, Obj, Ptr       ; Save what we've read
END


;
;  FileNew
;   Function activated by the 'New' option on the File menu.
;   Destroys current widget tree and reinitializes top level base
;   to its starting state.  All dialogs (except main and possibly
;   paste are destroyed)
;
PRO FileNew

  COMMON WidEd_Comm

    ;   Remove old preview bases

    FOR I=0,N_ELEMENTS(Bases)-1 DO BEGIN
        B   = Bases(I)
        IF B NE 0 AND WIDGET_INFO(B,/VALID_ID) THEN WIDGET_CONTROL, B, /DESTROY
        Bases(I)    = 0
    ENDFOR

    ;   Destroy any active dialog box widget copies

    FOR I=1,N_ELEMENTS(NewDialogs)-1 DO BEGIN
        Ptr = NewDialogs(I).OldPtr
        IF Ptr NE 0 THEN Destroy, Ptr
    ENDFOR

    NewDialogs  = { WE_NEWOBJ, 0L, 0L, 0L }     ; No active dialogs
    Dirty       = 0                             ; No change since 'New'

    ;   Close cut/copy/paste/edit boxes

    IF CutId NE 0 THEN BEGIN
        WIDGET_CONTROL, CutId, /DESTROY
        CutId   = 0
    ENDIF

    IF CopyId NE 0 THEN BEGIN
        WIDGET_CONTROL, CopyId, /DESTROY
        CopyId  = 0
    ENDIF

    IF PasteId NE 0 THEN BEGIN
        WIDGET_CONTROL, PasteId, /DESTROY
        PasteId = 0
    ENDIF

    IF EditId NE 0 THEN BEGIN
        WIDGET_CONTROL, EditId, /DESTROY
        EditId  = 0
    ENDIF

    LastId      = 1             ; Reset Id counter

    ;   Destroy widget tree and reinitialize main base to starting
    ;   state.  Show preview of single top base to user.
    IF N_ELEMENTS(TopPtr) THEN Destroy, TopPtr
    Generate
    UpdateEdit
END


;
;  InternalFileOpen
;       Open a file without GUI garbage in front
;
PRO InternalFileOpen, NewFile

  COMMON WidEd_Comm

    TmpLastId   = LastId        ; Save true LastId
    LastId      = 1             ; Reset LastId.

    ;   Try to open the file
    OPENR, Unit, NewFile, /GET_LUN, /XDR, ERROR = OpenError
    IF OpenError NE 0 THEN BEGIN
        ErrorDialog, TopDlg, ['Failed to open file:', NewFile ]
        RETURN
    ENDIF

    ;   Try to recover gracefully from errors encountered
    ;   reading the file

    ON_IOERROR, Bad

    ;   Does it have the right header?

    Header  = 'WidgetEditFile'
    TestHeader  = BYTE(Header)

    READU, Unit, TestHeader
    IF STRING(TestHeader) NE Header THEN BEGIN
        ErrorDialog, TopDlg, [ NewFile + ' is not', 'a valid .WID file']
        RETURN
    ENDIF

    ;   Get LastId

    READU, Unit, TmpLastId

    ;   Get Version Information (which we ignore)
    Version     = 0L
    READU, Unit, Version        ; Get Version
    READU, Unit, Version        ; 4 unused bytes


    ;   Indicate to the user this might take a while

    WIDGET_CONTROL, /HourGlass

    FileNew                     ; Destroy old widget tree
    FileName    = NewFile       ; Set new filename
    MAIN_Restore, Unit, 0L, TopPtr  ; Read in widget tree in file

    ;   Done reading.

    FREE_LUN, Unit      ; Close file.
    Dirty   = 0         ; Clear dirty flag.  Consider this starting state
    Generate            ; Show user preview of what we just read in.
    UpdateEdit
    UpdateMainDlg       ; Show it in main dlg
    LastId  = TmpLastId
    RETURN

Bad:

    ;   Close file.  Show user whatever we read.
    FREE_LUN, Unit
    ErrorDialog, TopDlg, 'File is corrupted or not a Widget Edit file'
    Generate
    UpdateEdit
    LastId  = TmpLastId
END


;
;  FileOpen
;   Get a filename from the user, read object data from that file.
;
PRO FileOpen

  COMMON WidEd_Comm

    ;   Get filename choice from user.

    NewFile = pickfile(GROUP=TopDlg, /READ, $
                PATH=CurrPath(), FILTER='*.wid', $
                /MUST_EXIST, /NOCONFIRM, $
                GET_PATH=FileDir)

    ;   If the user hit Cancel in pickfile then just quit
    IF NewFile EQ '' THEN RETURN

    ;   Certain 'special' operating systems can't handle a
    ;   separator at the end of the pathname.

    IF !Version.OS EQ 'Win32' THEN BEGIN
        FileDir = StrMid(FileDir, 0, StrLen(FileDir) - 1)
    ENDIF

    ;   Add a .WID ending regardless of current ending
    InsureExt, NewFile, ".wid"
    InternalFileOpen, NewFile
END



;
;  FileSave
;   Prompt the user for a file name. Save object data to that file
;   Next/Children pointers saved in a file are ignored. Prefixes and
;   ordering of data in the file is used to show parent/child/peer
;   relationships.
;
PRO FileSave

  COMMON WidEd_Comm

    ; Figure out a default filename
    File    = FileName
    InsureExt,File,''

    ;   Get the user's choice for a filename to save to
    NewFile = pickfile(GROUP=TopDlg, /WRITE, $
                PATH=CurrPath(), FILE=File, GET_PATH=GetPath, $
                FILTER='*.wid')

    ;   Quit if user hit 'Cancel' button
    IF NewFile EQ '' THEN RETURN

    ;   Handle DOS can't handle backslash problem

    IF !Version.OS EQ 'Win32' THEN BEGIN
        GetPath = StrMid(GetPath, 0, StrLen(GetPath) - 1)
    ENDIF

    ;   Add a .WID ending regardless of current ending
    InsureExt, NewFile, ".wid"

    ;   Open the file
    OPENW, Unit, NewFile, /XDR, /GET_LUN, ERROR=OpenError
    IF OpenError NE 0 THEN BEGIN
        ErrorDialog, TopDlg, [ 'Unable to open file', NewFile, 'for output' ]
        RETURN
    ENDIF

    ;   If there is a problem writing the file, tell
    ;   the user there was a problem.

    ON_IOERROR, MsgBad

    ;   Indicate that this can be slow
    WIDGET_CONTROL, /HOURGLASS

    ;   Write the header
    WRITEU, Unit, BYTE('WidgetEditFile')
    WRITEU, Unit, LastId
    WRITEU, Unit, 100L          ; Version Id = 1.00
    WRITEU, Unit, 0L            ; Extra Bytes in case we need them

    Ptr = TopPtr
    WHILE PTR NE 0L DO BEGIN
        WRITEU, Unit, 1
        DEP_Save, Unit, Ptr
        Ptr = NextPtr(Ptr)
    ENDWHILE
    WRITEU, Unit, 0     ; Indicate end of base list
    FREE_LUN, Unit

    ;   Subroutines will indicate I/O error by setting Dirty to 2
    IF Dirty EQ 2 THEN BEGIN
        Dirty   = 1
        GOTO, MsgBad
    ENDIF

    ;   Success. Save new file name as the new default

    FileName    = NewFile
    FileDir     = GetPath
    Dirty       = 0         ; Saved current version.  New clean state.

    RETURN

MsgBad:
    ErrorDialog, TopDlg, 'I/O error. Could not write file.'
Bad:
    Close, Unit
    OPENW, Unit, NewFile, /DELETE, ERROR=IgnoredError   ; Remove bad file
    FREE_LUN, Unit
END


;
;  SSaveCmd
;   Write a string keyword for a widget. Default is to only
;   write the keyword if the keyword is not a null string but
;   the FORCE keyword forces the keyword to always be written.
;
;   It is assumed that there is a previously existing portion
;   to the command which will require a comma and a continuation
;   character to be appended before writing the next keyword.
;
PRO SSaveCmd, Unit, Value, Keyword, FORCE=Force

    IF Value NE '' OR KEYWORD_SET(Force) THEN BEGIN
    XPRINTF, Unit, ", $"
    XPRINTF, FORMAT='("      ",A,"=''",A,"''")', /NO_EOL, $
        Unit, Keyword, Qstring(Value)
    ENDIF
END


;
;  ISaveCmd
;   Write an integer(or long integer) keyword for a widget.
;   Default is to only write the keyword if the keyword is not
;   0 but the FORCE keyword forces the keyword to always be written.
;
;   It is assumed that there is a previously existing portion
;   to the command which will require a comma and a continuation
;   character to be appended before writing the next line of code.
;
PRO ISaveCmd, Unit, Value, Keyword, FORCE=Force

    IF Value NE 0 OR KEYWORD_SET(Force) THEN BEGIN
    XPRINTF, Unit, ", $"
    XPRINTF, FORMAT='("      ",A,"=",A)', /NO_EOL, $
        Unit, Keyword, STRTRIM(Value,2)
    ENDIF
END


;
;  SaveStr
;   Given:
;       A file unit to write to.
;       A name for the variable
;       A default value if the object has no value
;       An object containing a value (*)
;
;   Create IDL code to create a variable whose value is that <STRARR>
;   or the default if none is provided.
;
; (*) actually a widget id whose UVALUE is a <STRARR>
;
PRO SaveStr, Unit, Ptr, Obj, StrName, Default

    GetValue, Obj, Names, Default
    XPRINTF, Unit, '  ', StrName, ' = [ $'

    N   = N_ELEMENTS(Names)
    ;   Every element but the last one is a string followed by ', $'
    FOR I=0,N-2 DO $
        XPRINTF, Unit, "    '", QString(Names(I)), "', $"

    ;   Last item has closing bracket for array we are declaring
    XPRINTF, Unit, "    '", QString(Names(N-1)), "' ]"
END


;
;  BeginMagic
;       Write a magic comment
;
PRO BeginMagic, Unit, Id
    PRINTF, Unit
    PRINTF, Unit, "; CODE MODIFICATIONS MADE ABOVE THIS COMMENT WILL BE LOST. "
    PRINTF, Unit, "; DO NOT REMOVE THIS COMMENT: BEGIN " + Id
    PRINTF, Unit
    PRINTF, Unit
END


;
;  EndMagic
;       Write a magic comment
;
PRO EndMagic, Unit, Id
    PRINTF, Unit
    PRINTF, Unit
    PRINTF, Unit, "; DO NOT REMOVE THIS COMMENT: END " + Id
    PRINTF, Unit, "; CODE MODIFICATIONS MADE BELOW THIS COMMENT WILL BE LOST."
    PRINTF, Unit
END


;
;  FindMagic
;       Look for magic comments.  Return TRUE if we found them.
;
FUNCTION FindMagic, Id, Unit, OldUnit

    COMMON FMagic_Comm, NoCheck

  COMMON WidEd_Comm

    ;   Can't find old stuff if it doesn't exist or
    ;   forced overwrite.

    IF OldUnit EQ 0 OR NoCheck THEN RETURN, 0


    Point_Lun, -OldUnit, SavePos        ; Remember where we are

    StartMagic  = "; DO NOT REMOVE THIS COMMENT: BEGIN " + Id
    EndMagic    = "; DO NOT REMOVE THIS COMMENT: END " + Id
    Line        = ""

    WHILE NOT EOF(OldUnit) DO BEGIN
        READF, OldUnit, Line
        IF Line EQ StartMagic THEN BEGIN
            PRINTF, Unit
            PRINTF, Unit, "; CODE MODIFICATIONS MADE ABOVE THIS COMMENT WILL BE LOST."
            PRINTF, Unit, Line

            WHILE NOT EOF(OldUnit) DO BEGIN
                READF, OldUnit, Line
                PRINTF, Unit, Line
                IF Line EQ EndMagic THEN BEGIN
                    PRINTF, Unit, "; CODE MODIFICATIONS MADE BELOW THIS COMMENT WILL BE LOST."
                    PRINTF, Unit
                    RETURN, 1
                ENDIF
            ENDWHILE

            ;   Its bad if we get here

            ErrorDialog, TopDlg, $
                [ "Could not find END magic comment", $
                  "for " + Id + " section" ]
            EndMagic, Unit, Id  ; Restore magic comment

        ENDIF
    ENDWHILE

    Point_Lun, OldUnit, SavePos
    RETURN, 0
END


;
;  MakeBackup
;       Need to make a backup in a machine independent way (painful,
;       slower, more slower).  VMS does its own backup stuff so we
;       don't have to.
;
PRO MakeBackup, File, Unit

    OPENR, Unit, File, /GET_LUN, ERROR=OpenError
    IF OpenError NE 0 THEN BEGIN
        IF N_ELEMENTS(Unit) NE 0 THEN FREE_LUN, Unit
        Unit = 0
        RETURN
    ENDIF

    IF !VERSION.OS EQ 'vms' THEN RETURN

    ;   On any non VMS system we need to create a backup

    SrcUnit     = Unit
    BackFile    = File
    InsureExt, BackFile, ".bak"

    OPENW, Unit, BackFile, /GET_LUN, ERROR=OpenError
    IF OpenError NE 0 THEN BEGIN
        FREE_LUN, SrcUnit
        FREE_LUN, Unit
        Unit    = 0
        RETURN
    ENDIF

    ;   Read line by line from source file and write it to the backup

    Line    = ''
    WHILE NOT EOF(SrcUnit) DO BEGIN
        READF, SrcUnit, Line
        PRINTF, Unit, Line
    ENDWHILE

    ;   Close files

    FREE_LUN, SrcUnit
    CLOSE, Unit

    ;   Reopen backup file, this time for reading

    OPENR, Unit, BackFile, ERROR=OpenError
    IF OpenError NE 0 THEN BEGIN
        FREE_LUN, Unit
        Unit    = 0
    ENDIF
END


;  FileGenPro
;   Main entry point for writing IDL code to reproduce the current
;   widget tree.  The user may opt to include or not include the
;   standard header document
;
PRO FileGenPro, StdHdr, CheckFlag

    COMMON FMagic_Comm, NoCheck
  COMMON WidEd_Comm

    NoCheck     = CheckFlag

    ;   Get a default filename

    File    = FileName
    InsureExt,File,''

    ;   Ask the user 'which file should I write to?'

    NewFile = pickfile(GROUP=TopDlg, /WRITE, $
            PATH=CurrPath(), FILE=File, GET_PATH=GetPath, $
            FILTER='*.pro')

    ;   If the user hit 'Cancel' quit
    IF NewFile EQ '' THEN RETURN

    IF !Version.OS EQ 'Win32' THEN BEGIN
        GetPath = StrMid(GetPath, 0, StrLen(GetPath) - 1)
    ENDIF

    ;   Add a .PRO ending regardless of current ending
    InsureExt, NewFile, ".pro"

    MakeBackup, NewFile, OldUnit

    ;   Open the file

    OPENW, Unit, NewFile, /GET_LUN, ERROR=OpenError
    IF OpenError NE 0 THEN BEGIN
        ErrorDialog, TopDlg, [ 'Unable to open file', NewFile, 'for output' ]
        RETURN
    ENDIF

    ;   Try to recover from errors
    ;   I/O Error recovery is VERY poor.

    ON_IOERROR, Bad

    WIDGET_CONTROL,/HOURGLASS

    ; Print a header

    PRINTF, Unit, ';'
    PRINTF, Unit, '; Auto Save File For ', NewFile
    PRINTF, Unit, ';'

    IF  !Version.Os EQ 'sunos' OR !Version.Os EQ 'hp-ux' OR $
        !Version.Os EQ 'IRIX' OR !Version.Os EQ 'AIX' OR $
        !Version.Os EQ 'ultrix' OR !Version.Os EQ 'DG/UX' THEN BEGIN
        SPAWN, 'date', time
        PRINTF,Unit,'; ', time & PRINTF,Unit,';'
    ENDIF

    PRINTF, Unit
    PRINTF, Unit

    ; Include the standard header.  Under UNIX we could do
    ; fstat, malloc, readu, writeu -- but under VMS we are hosed so
    ; instead we do while(!eof(fd)) n=read,write(n)

    IF FindMagic("HEADER", Unit, OldUnit) EQ 0 THEN BEGIN
        BeginMagic, Unit, "HEADER"

        IF StdHdr THEN BEGIN
            HeaderFile = FilePath('template.pro', SUBDIR=['help', 'widget'])
            CLOSE,1
            OPENR,1,HeaderFile
            Line    = ''
            WHILE NOT EOF(1) DO BEGIN
                READF,1,Line
                PRINTF,Unit,Line
            ENDWHILE
            CLOSE, 1
        ENDIF

        EndMagic, Unit, "HEADER"
    ENDIF

    DoFList2, TopPtr+0, 'PDMENU_MenuEv', Unit, OldUnit
    DoFList2, TopPtr+0, 'DEP_BaseEv', Unit, OldUnit

    ; Write the widget building/entry point procedure

    Name    = ExtractSimpleName(NewFile)

    PRINTF, Unit, FORMAT='(//"PRO ",A,", GROUP=Group")', Name
    PRINTF, Unit, FORMAT='(//"  IF N_ELEMENTS(Group) EQ 0 THEN GROUP=0"/)'

    ; If we have pull down menus, we need to predeclare
    ; the CW_PDMENU_S structure.  We declare them even if
    ; we don't use them

    Cmd = "  junk   = { CW_PDMENU_S, flags:0, name:'' }"
    PRINTF, Unit, FORMAT='(A//)', Cmd

    ;   Generate code to build and realize all other dependent
    ;   top level bases

    DEP_GenWid, Unit, TopPtr
    Ptr = NextPtr(TopPtr)
    DoFList, Ptr, 'DEP_GenWid', Unit

    ;   Generate code to manage each of the dependent
    ;   top level bases. Note we just register these bases
    ;   with the XManager.

    Ptr = NextPtr(TopPtr)
    WHILE Ptr NE 0 DO BEGIN

        PRINTF, Unit

        Name    = VarId(Ptr)
        Ptr2Obj, Ptr, Obj

        IF Obj.EventProc NE '' THEN BEGIN
            PRINTF, Unit, "  XMANAGER, '",Name,"', ",Name,  $
                ", /JUST_REG, EVENT_HANDLER='", QString( Obj.EventProc ), "'"
        ENDIF ELSE BEGIN
            PRINTF, Unit, "  XMANAGER, '",Name,"', ",Name,", /JUST_REG"
        ENDELSE
        Next    = Obj.Next
        Obj2Ptr, Obj, Ptr
        Ptr     = Next
    ENDWHILE

    ;   Finally, generate code to manage the top level base

    PRINTF, Unit

    Name    = VarId(TopPtr)
    Ptr2Obj, TopPtr, Obj
    IF Obj.EventProc NE '' THEN BEGIN
        PRINTF, Unit, "  XMANAGER, '",Name,"', ",Name, $
                ", EVENT_HANDLER='", QString( Obj.EventProc ), "'"
    ENDIF ELSE BEGIN
        PRINTF, Unit, "  XMANAGER, '",Name,"', ",Name
    ENDELSE
    Obj2Ptr, Obj, TopPtr

    PRINTF, Unit, 'END'

    ;   Success

    FREE_LUN, Unit

    ;   Remember this file as the new default file

    FileName    = NewFile
    FileDir     = GetPath

    RETURN

Bad:
    ErrorDialog, TopDlg, [ 'Failed to write file:', NewFile ]
    Close, Unit
    OPENW, Unit, NewFile, /DELETE, ERROR=IgnoredError
    FREE_LUN, Unit
END


;
;  TestDraw
;   Recursivly decend through the widget hierarchy looking for draw
;   widgets.  Put a sample plot in every draw widget.
;
PRO TestDraw, Ptr
    Ptr2Obj, Ptr, Obj

    CASE TAG_NAMES(Obj, /STRUCTURE) OF

    'WE_BASE': BEGIN
        Child       = Obj.Children
        WHILE Child NE 0L DO BEGIN
            TestDraw, Child
            Child   = NextPtr(Child)
        ENDWHILE
        END
    'WE_DRAW': BEGIN
        WIDGET_CONTROL, Obj.DrawId, GET_VALUE=WinId
        WSET, WinId
        Plot,[0,1]
        END
    ELSE:
    ENDCASE
    Obj2Ptr, Obj, Ptr
END

PRO WidFile
END
;
; $Id: widmain.pro,v 1.12 1995/01/26 03:31:38 billo Exp $
;
;  WidMain
;   Main object class definition.
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;

;
;  UpdateMainDlg
;       Set controls in top level base to reflect current settings
;       in the MAIN widget object
;
PRO UpdateMainDlg

  COMMON WidEd_Comm

    ;   Now update top dialog box to reflect changes

    Ptr2Obj, TopDlg, DialogInfo
    Ptr2Obj, TopPtr, Obj

    Foci    = DialogInfo.Foci

    WIDGET_CONTROL, Foci(0), SET_VALUE=Obj.Name
    WIDGET_CONTROL, Foci(1), SET_VALUE=Obj.NRowCol
    WIDGET_CONTROL, Foci(2), SET_VALUE=Obj.Space
    WIDGET_CONTROL, Foci(3), SET_VALUE=Obj.XPad
    WIDGET_CONTROL, Foci(4), SET_VALUE=Obj.YPad
    WIDGET_CONTROL, Foci(5), SET_VALUE=Obj.XScrollSize
    WIDGET_CONTROL, Foci(6), SET_VALUE=Obj.YScrollSize

    ;   Become a row/col/bbs.  Work around toolkit dependencies
    FOR I=0,2 DO $
        WIDGET_CONTROL, DialogInfo.Btns(I), SET_BUTTON=(Obj.BaseType EQ I)

    WIDGET_CONTROL, DialogInfo.RowColId, SENSITIVE=(Obj.BaseType NE 0)

    Obj2Ptr, Obj, TopPtr
    Obj2Ptr, DialogInfo, TopDlg
END

;
;  MAIN_Alloc
;       Allocate a main object (if Ptr is NULL or just invalid)
;   There are 3 base object classes (MAIN,DEP, and BASE) so they call
;   a common routine to allocate base objects.
;
PRO MAIN_Alloc, Parent, Ptr
  COMMON WidEd_Comm

    ; Make a pointer. Maybe.
    IF KEYWORD_SET(Ptr) EQ 0 THEN $
        Ptr = WIDGET_BASE()
    MakeBaseObj, Parent, Obj, "MAIN"                ; Make a base object
    Obj2Ptr, Obj, Ptr                               ; Store object in pointer

END

;
;  MAIN_Destroy
;   Remove children objects and dependent bases as well.
;   We don't destroy the main base, just reset all of its fields
;   to their default state.
;
PRO MAIN_Destroy, Ptr

  COMMON WidEd_Comm

    Ptr2Obj, Ptr, Obj
    DoList, Obj.Children, "Destroy"     ; Destroy children
    DoList, Obj.Next, "Destroy"         ; Destroy dependent bases
    IF WIDGET_INFO(Obj.AttrDlg, /VALID) THEN $
        WIDGET_CONTROL, Obj.AttrDlg, /DESTROY
    MakeBaseObj, 0L, CleanObj, "MAIN"       ; Create a virgin MAIN
    Obj2Ptr, CleanObj, Ptr              ; Store into used MAIN pointer

    IF WIDGET_INFO(TopDlg, /VALID) EQ 0 THEN BEGIN
        PRint,'Invalid'
        RETURN
    ENDIF

    UpdateMainDlg
END


;
;  MAIN_BarEvent
;   Events from the pull down menu don't have a <STRING> type UVALUE to
;   use.  Thus we have a separate event routine to handle the menu items.
;
;
PRO MAIN_BarEvent, Event

  COMMON WidEd_Comm

    ;   Too complicated to use the /NO_COPY for this event routine

    WIDGET_CONTROL, Event.top, GET_UVALUE=Binfo

    Build       = ''
    Do_Generate = 0

    CASE Event.Value OF

    'File.New':         Dirty, Event.Top, "creating new widget tree", "FileNew"
    'File.Open...':     Dirty, Event.Top, "opening another file", "FileOpen"

    'File.Save...':                             FileSave
    'File.Create .PRO.Normal...':               FileGenPro, 1, 0
    'File.Create .PRO.Rewrite Everything...':   FileGenPro, 1, 1
    'File.Create .PRO.Without Header...':       FileGenPro, 0, 0
    'File.Show Object Tree...':                 ShowObjTree, Binfo.ObjPtr

    'File.Quit':        BEGIN
        Dirty, Event.Top, "quitting", $
                        "WIDGET_CONTROL,/DESTROY,"+STRTRIM(Event.top)
        RETURN
        END

    'Edit.Cut...':              CutChild
    'Edit.Copy...':             CutChild, /COPY
    'Edit.Paste...':            PasteChild
    'Edit.Edit Child...':       EditChild

    'Add.Hide Tool Bar':    BEGIN
        WIDGET_CONTROL, Binfo.ToolBar, MAP=0
        WIDGET_CONTROL, Binfo.ToolId, SET_VALUE='Show Tool Bar'
        WIDGET_CONTROL, Binfo.ToolId, SET_UVALUE='Add.Show Tool Bar' ; Hack
        END
    'Add.Show Tool Bar':    BEGIN
        WIDGET_CONTROL, Binfo.ToolBar, MAP=1
        WIDGET_CONTROL, Binfo.ToolId, SET_VALUE='Hide Tool Bar'
        WIDGET_CONTROL, Binfo.ToolId, SET_UVALUE='Add.Hide Tool Bar' ; Hack
        END

    'Add.Dependent Base':   BEGIN

        ;   the Build facility below only works for adding CHILDREN
        ;   Dependent bases are siblings so we need special code to
        ;   handle that

        DEP_Build, Ptr, Base                    ; Allocate base. Make dialog
        SetTag, Ptr, "Next", NextPtr(Binfo.ObjPtr)  ; Add base to TLB list
        SetTag, Binfo.ObjPtr, "Next", Ptr
        UpdateEdit                              ; Update Cut/Paste dialogs
        Do_Generate = 1                         ; Update preview.
        END

    'Rebuild':          BEGIN

        ;   Hitting the rebuild button causes the interface to
        ;   'Accept' on a newly created widget.  After this, a 'Cancel'
        ;   will not remove the child, instead it will revert it to
        ;   the state it was in when Rebuild was clicked.

        N   = N_ELEMENTS(NewDialogs)
        FOR I=1,N-1 DO BEGIN
            IF NewDialogs(I).OldPtr EQ 0L THEN BEGIN        ; Found new widget

                Ptr     = NewDialogs(I).ObjPtr
                GetType, Ptr, Type
                ClearVar,Copy
                CALL_PROCEDURE, Type+'_Copy', Ptr, Copy     ; Copy it
                NewDialogs(I).OldPtr    = Copy              ; Save copy
            ENDIF
        ENDFOR

        Do_Generate = 1
        END
    'Help':    BEGIN
        HelpFile        = "widabout.txt"
        GET_LUN, Unit
        OPENR, Unit, HelpFile, ERROR=OpenError
        IF OpenError NE 0 THEN $
            HelpFile = FilePath("widabout.txt", SUBDIR=["help", "widget"])
        FREE_LUN, Unit
        XDisplayFile, HelpFile, TITLE='About the Widget Builder'
        END

    ELSE:   BEGIN
        IF STRMID(Event.Value,0,4) EQ "Add." THEN BEGIN
            Idx     = WHERE(STRMID(Event.Value,4,100) EQ AddList.Menu)
            Build   = AddList(Idx).Class
        ENDIF ELSE MESSAGE, 'Unprocessed event: ' + Event.Value
        END
    ENDCASE

    ;   Common functionality for most Add.XXX requests

    IF Build NE '' THEN BEGIN
        ;   Allocate object and create a dialog box as well
        Ptr = 0L                ; Make an invalid ptr but not <UNDEFINED>
        CALL_PROCEDURE, Build+'_Build', Ptr, Binfo.ObjPtr

        ;   Add child to our child list.  Note that Base object
        ;   do not get added to the active dialog box list

        AddChild, Binfo.ObjPtr, Ptr, NO_CANCEL=(Build EQ 'BASE')
    ENDIF

    ;   See if we should update the preview
    IF Do_Generate THEN Generate
END


;
;  MAIN_Event
;   Normal event handling routine for a main object
;   These affect attributes of the MAIN widget
;
PRO MAIN_Event, Event

  COMMON WidEd_Comm

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev
    WIDGET_CONTROL, Event.Top, GET_UVALUE=Binfo, /NO_COPY

    Ptr2Obj, Binfo.ObjPtr, Obj

    CASE Ev OF
    'TITLE':    Obj.Name    = Event.Value

    'Bbs':      BEGIN               ; Make base a bulletin board
        Obj.BaseType        = 0
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=0
        END
    'Row':                BEGIN
        Obj.BaseType        = 1
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END
    'Column':        BEGIN
        Obj.BaseType        = 2
        WIDGET_CONTROL, Binfo.RowColId, SENSITIVE=1
        END

    ;   Characteristic set in main dialog

    'NROW':         Obj.NRowCol     = Event.Value
    'SPACE':        Obj.Space       = Event.Value
    'XPAD':         Obj.XPad        = Event.Value
    'YPAD':         Obj.YPad        = Event.Value
    'XSCROLL':      Obj.XScrollSize = Event.Value
    'YSCROLL':      Obj.YScrollSize = Event.Value

    ;   User wants to see the 'Additional attributes' dialog
    'ATTR':         MAIN_BuildAttr, Event.Top, Binfo.ObjPtr, Obj

    ;   Additional Attribute Events

    'XSIZE':        Obj.XSize       = Event.Value
    'YSIZE':        Obj.YSize       = Event.Value
    'XOFFSET':      Obj.XOffset     = Event.Value
    'YOFFSET':      Obj.YOffset     = Event.Value
;   'EVENT_FUNC':   Obj.EventFunc   = Event.Value
    'EVENT_PROC':   Obj.EventProc   = Event.Value
    'GETFUNC':      Obj.GetFunc     = Event.Value
    'SETPROC':      Obj.SetProc     = Event.Value
    'KILLPROC':     Obj.KillProc    = Event.Value
    'DO_TLB':       Obj.TLBEvents   = 1 - Obj.TLBEvents
    'MAPPED':       Obj.BaseMapped  = 1 - Obj.BaseMapped
    'DONE':         BEGIN
                    Obj2Ptr, Obj, Binfo.ObjPtr
                    WIDGET_CONTROL, Event.Top, SET_UVALUE=Binfo, /NO_COPY
                    WIDGET_CONTROL, Event.Top, /DESTROY
                    RETURN
                    END
    ELSE:           MESSAGE, 'Unprocessed event: ' + Ev
    ENDCASE

    Dirty   = 1     ; We've changed something since the last save

    SetNextFocus, Binfo, Event      ; Set next keyboard focus as necessary
    Obj2Ptr, Obj, Binfo.ObjPtr      ; Put object back into pointer
    WIDGET_CONTROL, Event.top, SET_UVALUE=Binfo, /NO_COPY
END


;
;  MAIN_Build
;   Create the top level dialog box.  Create top level object as well
;   if ptr is nil.
;
PRO MAIN_Build, Ptr, Base

  COMMON WidEd_Comm 

    MAIN_Alloc, 0L, Ptr               ; Allocate object if necessary

    Ptr2Obj, Ptr, Obj

    AddMenu = MakeAddMenu()

    ;   Create menu bar

    MenuBarDesc = [                             $
        { CW_PDMENU_S, 1, 'File' },             $
          { CW_PDMENU_S, 0, 'New' },            $
          { CW_PDMENU_S, 0, 'Open...' },        $
          { CW_PDMENU_S, 0, 'Save...' },        $
          { CW_PDMENU_S, 1, 'Create .PRO' },    $
            { CW_PDMENU_S, 0, 'Normal...' },    $
            { CW_PDMENU_S, 0, 'Rewrite Everything...' },$
            { CW_PDMENU_S, 2, 'Without Header...' },    $
          { CW_PDMENU_S, 0, 'Show Object Tree...' }, $
          { CW_PDMENU_S, 2, 'Quit' },           $
        { CW_PDMENU_S, 1, 'Edit' },             $
          { CW_PDMENU_S, 0, 'Cut...' },         $
          { CW_PDMENU_S, 0, 'Copy...' },        $
          { CW_PDMENU_S, 0, 'Paste...' },       $
          { CW_PDMENU_S, 2, 'Edit Child...' },  $
        { CW_PDMENU_S, 1, 'Add' },              $
          { CW_PDMENU_S, 0, 'Hide Tool Bar' },  $
          AddMenu,                              $
          { CW_PDMENU_S, 2, 'Dependent Base' }, $
        { CW_PDMENU_S, 0, 'Rebuild' },          $
        { CW_PDMENU_S, 2, 'Help' }              $
    ]

    Title       = "Widget Builder"

    Base        = WIDGET_BASE(/COLUMN, TITLE=Title)
    MenuBar     = CW_PDMENU(Base, MenuBarDesc, IDS=Ids, /RETURN_FULL_NAME)

    ;   Save cut/paste ids.  These change sensitivity to reflect
    ;   changes in cutlist and existence of children.

    _CutId      = Ids(11)
    _CopyId     = Ids(12)
    _PasteId    = Ids(13)
    _EditId     = Ids(14)
    ToolId      = Ids(16)

    Foci        = LONARR(7)

    ;   At this point there are no children to cut/copy or edit
    WIDGET_CONTROL, _CutId, SENSITIVE=0
    WIDGET_CONTROL, _CopyId, SENSITIVE=0
    WIDGET_CONTROL, _EditId, SENSITIVE=0

    ;   There could be something to paste if the cutlist is non-nil
    WIDGET_CONTROL, _PasteId, SENSITIVE=(CutList NE 0L)

    BuildToolBar, Base, Toolbar         ; There could be a toolbar


    Base1   = WIDGET_BASE(Base, /COLUMN, EVENT_PRO='MAIN_Event')
    Label   = WIDGET_LABEL(Base1,VALUE='Top Level Base')

    Foci(0) = Field(Base1, "Title:", Obj.Name, "TITLE", SIZE=50, /STRING)
    BuildBaseType, Base, Obj, Foci, 1, RowColId, Btns
    BuildXY, Base, Obj, Foci, 1+4, /SIZE
    Dummy   = WIDGET_BUTTON(Base, VALUE='More Attributes', $
                UVALUE='ATTR', EVENT_PRO='MAIN_Event')

    ;   Top level dialog has quite a bit of information associated with it.

    DlgInfo = { $
        Foci:       Foci, $
        CutId:      _CutId, $
        CopyId:     _CopyId, $
        PasteId:    _PasteId, $
        EditId:     _EditId, $
        RowColId:   RowColId, $
        ToolBar:    ToolBar, $
        ToolId:     ToolId, $
        Btns:       Btns, $
        ObjPtr:     Ptr $
    }

    Obj.Dialog  = Base

    WIDGET_CONTROL, Base, SET_UVALUE=DlgInfo, /NO_COPY
    WIDGET_CONTROL, Base, /REALIZE

    WIDGET_CONTROL, Btns(1), /SET_BUTTON    ; Start life as a row
    WIDGET_CONTROL, RowColId, SENSITIVE=1

    Obj2Ptr, Obj, Ptr
END

;
;   There is no MAIN_Save (see FileSave)
;


;
;  MAIN_Restore
;   Read in an widget tree.  Restores the top base and all of its
;   children and all dependent bases as well.
;
PRO MAIN_Restore, Unit, Parent, Ptr

    Value   = 0
    READU, Unit, Value      ; Part of file format
    urBASE_Restore, Unit, Parent, Ptr, "MAIN"

    ;   Restore Dep Bases

    Last    = Ptr
    WHILE 1 DO BEGIN
        Value   = 0
        READU, Unit, Value
        IF Value NE 1 THEN RETURN           ; Exit here

        ClearVar, Dep
        DEP_Restore, Unit, 0L, Dep
        SetTag, Last, "Next", Dep
        Last    = Dep
    ENDWHILE
END


;
;   MAIN_BuildAttr
;
;   Code for this is so similar to DEP_BuildAttr that I combined them
;   They differed by 1 line
;
PRO MAIN_BuildAttr, Leader, Ptr, Obj
    DEP_BuildAttr, Leader, Ptr, Obj
END

;
;  ShowTree
;   Write an ASCII description of the current object tree
;   Indentation indicates parenting.
;
PRO ShowTree, Unit, Ptr, Level

    ; ASCII Assumption: 32b is a space

    ;   Indentation shows hierarchy

    PRINTF, Unit, STRING(REPLICATE(32b,1 + Level * 3)), $
        VarId(Ptr) + "  ( " + GetId(Ptr) + " )"

    ;   look inside objects with children

    Ptr2Obj, Ptr, Obj
    IF TAG_NAMES(Obj, /STRUCTURE) EQ 'WE_BASE' THEN BEGIN
        Child       = Obj.Children
        NewLevel    = Level + 1
        WHILE Child NE 0L DO BEGIN
            ShowTree, Unit, Child, NewLevel
            Child   = NextPtr(Child)
        ENDWHILE
    ENDIF
    Obj2Ptr, Obj, Ptr
END

;
;  ShowObjTree
;   Create a temp file. Write a description of the object tree
;   to that file and display that file.
;
PRO ShowObjTree, Ptr

    ;   Try to make a filename that will work on all
    ;   operating systems, including special ones
    ;   which only allow 8 character file names. (MS-DOS)
    ;   and ones which require a '.' in every filename (VMS)

    ;   This is the low 5 digits of the system time (to the nearest 1/100th sec)
    ;   Names only collided if:
    ;       They are using the same directory and
    ;       they happen to call ShowObjTree in the same time. (t < 1/100 sec)

    Magic       = LONG( (SysTime(1) * 100.0) MOD 100000.0)

    FileName    = 'wid'+STRTRIM(Magic, 2)+'.tmp'
    OPENW, Unit, FileName, /GET_LUN

    ;   Build file contents

    WHILE Ptr NE 0 DO BEGIN
        Showtree, Unit, Ptr, 0
        Next    = NextPtr(Ptr)
        IF Next NE 0L THEN BEGIN
            PRINTF,Unit
            PRINTF,Unit,'---------------'
            PRINTF,Unit
        ENDIF
        Ptr = Next
    ENDWHILE

    FLUSH, Unit
    CLOSE, Unit

    XDisplayFile, FileName, TITLE='Current Widget Tree'     ; Show it

    ;   Reopen the file just to delete it

    OPENW, Unit, FileName, /DELETE
    CLOSE, Unit
    FREE_LUN, Unit
END

PRO WidMain
END
;
; $Id: widutil.pro,v 1.8 1994/06/01 23:08:48 ali Exp $
;
;  WidUtil
;   Miscellaneous Utility functions and procedures
;
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
; MODIFICATION HISTORY
;       Written by:     Joshua Goldstein,       12/93
;
;



;
;  Event handler loop for Error dialog box
;
PRO ErrorEvent, Event

    ; The only event possible is a 'Done' so we don't bother
    ; to check, just bring the dialog down

    WIDGET_CONTROL, Event.top, /DESTROY
END


;
;  ErrorDialog
;       Create a dialog box and put an error message in it
;   Message can be a string or an array of strings
;
PRO ErrorDialog, Parent, Msg

    ;   Position the error dialog on top of its parent

    WIDGET_CONTROL, Parent, TLB_GET_OFFSET=Off
    Base    = WIDGET_BASE(/COLUMN, TITLE='ERROR!', $
                        XOFFSET=Off(0)+50, YOFFSET=Off(1)+50)

    ;   Add a label(line) for each line of the message
    FOR I=1,N_ELEMENTS(Msg) DO BEGIN
        Label   = WIDGET_LABEL(base,VALUE=Msg(I-1))
    ENDFOR

    ;   Make an acknowledge button for the user to press
    ;   We move it over (looks better).  Of course the fixed
    ;   offset stuff is not the best solution but seems to work
    Ok      = WIDGET_BUTTON(Base, VALUE='  OK  ', XOFF=70)  ; Bad?

    WIDGET_CONTROL, Base, /REALIZE
    XMANAGER, 'WidError', Base, /MODAL, EVENT_HANDLER='ErrorEvent'
END

;
;  Qstring(String)
;   Return a string which can be included in single quotes. That is.
;   double every single quote. E.g. QString("Do's 'n Don'ts") returns
;   Do''s ''n Don''ts.  Note that there is a bug in the IDL parser
;   which barfs on leading single quotes: '''' is a syntax error
;
;   Side Effect: Due to the nature of IDL variable passing, if
;   the string passed in is a named variable it will be altered
;
FUNCTION Qstring, String

    Len         = STRLEN(String)+1                  ; Starting length
    PrevQuote   = 0                                 ; Previous quote pos
    Quote       = STRPOS(String, "'", PrevQuote)    ; Current quote pos

    WHILE Quote NE -1 DO BEGIN                          ; given xx'yy
        Front       = STRMID(String,0,Quote+1)          ;   Front = xx'
        Back        = STRMID(String,Quote, Len - Quote) ;-) Back  = 'yy
        String      = Front + Back                      ; xx' + 'yy
        Len         = Len + 1                           ; string got longer

        PrevQuote   = Quote + 2                         ; quote is not previous quote
        Quote       = STRPOS(String, "'", PrevQuote)
    ENDWHILE
    RETURN, String
END


;
;  ClearVar
;   Reset a variable to <UNDEFINED> if it isn't already.
;
PRO ClearVar, Var
    IF N_ELEMENTS(Var) NE 0 THEN Dummy  = TEMPORARY(Var)
END


;
;  DoList
;       Given the pointer to a list of objects, perform a FIXED
;   function on each object in the list of the form:
;               Procstr,Ptr
;
PRO DoList, Ptr, ProcStr

    WHILE Ptr NE 0L DO BEGIN
        Next    = NextPtr(Ptr)
        Dummy   = EXECUTE(ProcStr + ",Ptr")
        Ptr     = Next
    ENDWHILE
END

;
;  DoFList
;       Given the pointer to a list of objects, perform an I/O
;   function on each object in the list of the form:
;               Procstr,Unit,Ptr
;
PRO DoFList, Ptr, ProcStr, Unit

    WHILE Ptr NE 0L DO BEGIN
        Next    = NextPtr(Ptr)
        Dummy   = EXECUTE(ProcStr + ",Unit,Ptr")
        Ptr     = Next
    ENDWHILE
END

;
;  DoFList2
;       Given the pointer to a list of objects, perform an I/O
;   function on each object in the list of the form:
;               Procstr,Unit1,Unit2,Ptr
;
PRO DoFList2, Ptr, ProcStr, Unit1, Unit2

    WHILE Ptr NE 0L DO BEGIN
        Next    = NextPtr(Ptr)
        Dummy   = EXECUTE(ProcStr + ",Unit1,Unit2,Ptr")
        Ptr     = Next
    ENDWHILE
END


;
;  GetType
;   Get the Type field out of an object.
;
PRO GetType, Ptr, Type
    Ptr2Obj, Ptr, Obj
    Type    = Obj.Type
    Obj2Ptr, Obj, Ptr
END


;
;  SetTag
;       Set an arbitrary field in an object given a pointer
;       to the object, the tag and its new value
;
PRO SetTag, Ptr, Tag, Value
    Ptr2Obj, Ptr, Obj
    Dummy       = EXECUTE("Obj."+ Tag + "= Value")
    Obj2Ptr, Obj, Ptr
END


;
;  NewId
;   Create a new name for an object
;
FUNCTION NewId

  COMMON WidEd_Comm

    New         = STRTRIM(LastId,2)
    LastId      = LastId + 1
    RETURN, New
END


;
;  VarId
;   Return the logical name of an object
;
FUNCTION VarId, Ptr
    Ptr2Obj, Ptr, Obj
    VarName = Obj.Type + Obj.Id
    Obj2Ptr, Obj, Ptr
    RETURN, VarName
END


;
;  GetId
;   Return what we think would be the best symbolic name for an object
;   This is either: the name the user gave it, its value(title) or its
;   logical name
;
FUNCTION GetId, Ptr

  COMMON WidEd_Comm

    IF Ptr EQ TopPtr THEN RETURN, 'Top Base'

    Ptr2Obj, Ptr, Obj

    IF Obj.Name NE '' THEN BEGIN
        Id  = Obj.Name
        Obj2Ptr, Obj, Ptr
        RETURN, Id
    ENDIF

    IF (Obj.Type EQ 'LABEL' OR Obj.Type EQ 'BUTTON') THEN BEGIN
        IF Obj.Value NE '' THEN BEGIN
            Id  = Obj.Value
            Obj2Ptr, Obj, Ptr
            RETURN, Id
        ENDIF
    ENDIF

    IF Obj.Type EQ 'FIELD' OR Obj.Type EQ 'SLIDER' OR $
       Obj.Type EQ 'FSLID' THEN BEGIN

        IF Obj.Title NE '' THEN BEGIN
            Id  = Obj.Title
            Obj2Ptr, Obj, Ptr
            RETURN, Id
        ENDIF
    ENDIF

    IF Obj.UValue NE '' THEN    Id = Obj.UValue $
    ELSE                        Id = Obj.Type + Obj.Id
    Obj2Ptr, Obj, Ptr
    RETURN, Id
END


;
;  UValue
;   If the user has not provided a UVALUE for an object we do so that
;   we can write an event handler.
;
FUNCTION UValue, Obj, Ptr
    IF Obj.UValue NE '' THEN RETURN, Obj.UValue
    RETURN, Obj.Type + Obj.Id
END


;
;  HasChildren
;   Returns TRUE if the object has children or is a base object
;   and has no children but thats OK. Otherwise return FALSE.
;
FUNCTION HasChildren, Ptr, NONE_OK=NoneOk

    ;   Bad pointers don't have children
    IF WIDGET_INFO(Ptr, /VALID_ID) EQ 0 THEN RETURN, 0

    Ptr2Obj, Ptr, Obj
    Name    = TAG_NAMES(Obj, /STRUCTURE)

    ;   Only Base objects can have children (so far)
    IF Name EQ 'WE_BASE' THEN BEGIN

        ; Actually has children or could have children but thats enough?
        IF Obj.Children NE 0 OR KEYWORD_SET(NoneOk) THEN BEGIN
            Obj2Ptr, Obj, Ptr
            RETURN, 1
        ENDIF
    ENDIF

    ;   Have a base object but it has no children and NoneOk is false

    Obj2Ptr, Obj, Ptr
    RETURN, 0
END


;
;  Dirty_Event
;   Event handler for the asking the user Dirty dialog (see below)
;
PRO Dirty_Event, Event

COMMON  WidDirty_Comm, DoCall

    WIDGET_CONTROL, Event.Id, GET_UVALUE=Ev

    ;   Save First?
    IF Ev EQ "Yes" THEN FileSave

    ;   Do we want to do whatever it is that we were asking about
    ;   saving before doing? We do for Yes or No but not Cancel
    DoCall  = (Ev NE "Cancel")

    ;   Done
    WIDGET_CONTROL, Event.Top, /DESTROY
END


;
;  Dirty
;   Give a user a chance to save changes before destroying the
;   object tree.  A 'Do you want to save the object tree before
;   doing XXX?' failsafe.
;
;   The way this works might be a tad confusing.
;   Run the widget builder, add some widget and hit 'Quit'.
;   That will make this a lot more understandable.
;
PRO Dirty, Parent, Thing, Call

COMMON  WidDirty_Comm, DoCall

  COMMON WidEd_Comm    

    ;   If there is no chance of loosing data then just do it

    IF Dirty EQ 0 THEN Dummy=EXECUTE(Call) $
    ELSE BEGIN

        ;   Position the 'Wanna do <Thing>?' dialog on top of parent
        WIDGET_CONTROL, Parent, TLB_GET_OFFSET=Off
        Base    = WIDGET_BASE(/COLUMN, XOFFSET=Off(0)+50, YOFFSET=Off(1)+50)

        ;   Build question
        Label   = WIDGET_LABEL(Base, VALUE="Save changes before");
        Label   = WIDGET_LABEL(Base, VALUE=Thing+"?");

        ;   Build possible answers
        Base1   = WIDGET_BASE(Base, /ROW)
        Btn     = WIDGET_BUTTON(Base1, VALUE="  Yes  ", UVALUE="Yes")
        Btn     = WIDGET_BUTTON(Base1, VALUE="   No  ", UVALUE="No")
        Btn     = WIDGET_BUTTON(Base1, VALUE=" Cancel", UVALUE="Cancel")

        ;   Wait for user to answer your question
        WIDGET_CONTROL, Base, /REALIZE
        XMANAGER, 'WidError', Base, /MODAL, EVENT_HANDLER='Dirty_Event'

        ;   Event handler will set DoCall to TRUE if the user wants
        ;   to do whatever it is (Call).  Have to do this here to prevent
        ;   XMANAGER MODAL looping bug.

        IF DoCall THEN Dummy = EXECUTE(Call)
    ENDELSE
END


;
;  SAddCmd
;   Append a string keyword to a command string. Only append
;   keyword if value is not the null string ('') or the FORCE
;   keyword is set
;
;   E.g.
;       Cmd='WidCre(XXX' & SAddCmd, Cmd, "Hello", "VALUE"
;       HELP,Cmd
;   CMD STRING  = "WidCre(XXX,VALUE='Hello'"
;
PRO SAddCmd, Cmd, Value, Keyword, FORCE=Force
    IF Value NE '' OR KEYWORD_SET(FORCE) THEN $
        Cmd = Cmd + ',' + Keyword + "='" + QString(Value) + "'"
END


;
;  IAddCmd
;   Same as SAddCmd but for integer values. Only appends keyword
;   if value is non-zero or FORCE keyword set.
;
PRO IAddCmd, Cmd, Value, Keyword, FORCE=Force
    IF Value NE 0 OR KEYWORD_SET(FORCE) THEN $
        Cmd = Cmd + ',' + Keyword + '=' + STRTRIM(Value,2)
END


;
;  SetFocus
;   Set the focus to the given widget.  Id should be either:
;   a TEXT widget or a compound widget (base) whose first text object
;   in it is what should receive the keyboard focus
;
PRO SetFocus, Id

    IF WIDGET_INFO(Id, /TYPE) EQ 3 THEN BEGIN   ; Text Widget?
        TextId  = Id
    ENDIF ELSE BEGIN
        TextId  = WIDGET_INFO(Id, /CHILD)       ; Assume Base

        ;   Hunt through children looking for first text widget
        WHILE TextId NE 0 AND WIDGET_INFO(TextId,/TYPE) NE 3 DO BEGIN
            TextId  = WIDGET_INFO(TextId, /SIBLING)
        ENDWHILE
    ENDELSE

    WIDGET_CONTROL, TextId, /INPUT_FOCUS        ; Set keyboard focus
END


;
;  SetNextFocus
;   If the user has hit <CR> (event.update will be TRUE) and we
;   can find the current focus then determine the next focus and
;   give it the keyboard focus.
;
PRO SetNextFocus, Binfo, Event

    ;   Look for the current id in our list of known foci

    Current        = WHERE(BInfo.Foci EQ Event.Id, Count)
    IF Count EQ 1 THEN BEGIN

        ;   Did user hit <CR>? Goto next focus if they did
        IF Event.Update THEN BEGIN
            ;   Next is a relative term (wrap from last to first)
            Current = (Current(0) + 1) MOD N_ELEMENTS(BInfo.Foci)
            SetFocus, BInfo.Foci(Current)
        ENDIF
    ENDIF
END


;
;  GetValue
;   Given an object with an text field for a value (STRARR)
;   get that value.  If the value is nil then use the default (NoName)
;   value instead: Returning <UNDEFINED> is not good.
;
PRO GetValue, Obj, Names, NoName

;   (c.f. BuildEdit in widbuild.pro)

;   IF Obj.ValueType EQ 0 THEN BEGIN

        Ptr2Obj, Obj.Value1, Names, /COPY
        IF N_ELEMENTS(Names) EQ 0 THEN Names=NoName

;   ENDIF ELSE BEGIN
;       Unsupportable.
;       Names = '<User Code>'
;   ENDELSE
END

PRO WidUtil
END
; $Id: write_bmp.pro,v 1.6 1994/10/31 16:09:58 dave Exp $

PRO WRITE_BMP, File, Image, Red, Green, Blue, $
    FOUR_BIT = four_bit, Ihdr = Ihdr, HEADER_DEFINE = h
; Copyright (c) 1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	WRITE_BMP
;
; PURPOSE:
;   	This procedure writes a Microsoft Windows Version 3 device
;	independent bitmap file (.BMP).
;
; CATEGORY:
;   	Input/Output.
;
; CALLING SEQUENCE:
;   	WRITE_BMP, File, Image [, R, G, B]
;
; INPUTS:
;   	File:	   The full path name of the bitmap file to write.
;   	Image:	   The array to write into the new bitmap file. The array
;	 	   should be scaled into a range of bytes for 8 and 24
;		   bit deep images. Scale to 0-15 for 4 bit deep images.
;       	   If the image has 3 dimensions and the first dimension
;		   is 3, a 24 bit deep bitmap file is created.
;		   NOTE: for 24 bit images, color interleaving is blue,
;		   green, red: image(0,i,j) = blue, image(1,i,j) = green, etc.
;
; OPTIONAL INPUTS:
;   	R, G, B:   Color tables. If omitted, the colors loaded in the
;		   COLORS common block are used.
;
; KEYWORD PARAMETERS:
;   	FOUR_BITS: Set this keyword to write as a four bit device
;	  	   independent bitmap. If omitted or zero, an eight bit
;		   deep map is written.
;   	IHDR:	   { BITMAPINFOHEADER } structure containing the file header
;       	   fields that are not obtained from the image parameter.
;       	   (The only fields that the user can set are:
;		   bi{XY}PelsPerMeter, biClrUsed, and biClrImportant.)
;
; OUTPUTS:
;   	No explicit outputs.
;
; KEYWORD OUTPUT PARAMETERS:
;   	HEADER_DEFNIE: Returns an empty BITMAPINFOHEADER structure,
;		       containing zeroes. No other actions are performed.
;		       This structure may be then modified with the
;		       pertinent fields and then passed in via the Ihdr
;       	       keyword parameter. See the Microsoft Windows
;		       Programmers Reference Guide for a description of
;		       each field in the structure. NOTE: this parameter
;		       must be defined before the call.  e.g.:
;           		h = 0
;           		WRITE_BMP, HEADER_DEFINE = h
;
; COMMON BLOCKS:
;   	COLORS:    Used with 4- and 8-bit images if no colors are specified.
;
; SIDE EFFECTS:
;   	IO is performed.
;
; RESTRICTIONS:
;   	Does not handle 1-bit images or compressed images.
;   	Is not fast for 4-bit images. Works best on images where the
;   	number of bytes in each scan line is evenly divisible by 4.
;
; PROCEDURE:
;   	Straightforward. Will work on both big endian and little endian
;	machines.
;
; EXAMPLES:
;       Pseudo screen dump from the current window:
;         WRITE_BMP, 'test.bmp', TVRD()
;
;       Scale an image to 0-15, and then write a four bit BMP file,
;       using a gray scale color table:
;         r = BYTSCL(INDGEN(16))   ;Ramp from 0 to 255.
;         WRITE_BMP, 'test.bmp', BYTSCL(Image, MAX=15), r, r, r, /FOUR
;
; MODIFICATION HISTORY:
;   DMS, RSI.   March 1993.	Original version.
;   DMS, RSI.   May, 1993.	Now works on all machines...
;-

common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr


on_ioerror, bad
on_error, 2         ;Return on error


if n_elements(ihdr) eq 0 then $         ;Define our header?
  ihdr = { BITMAPINFOHEADER, $
    bisize: 0L, $
    biwidth: 0L, $
    biheight: 0L, $
    biplanes: 0, $
    bibitcount: 0, $
    bicompression: 0L, $
    bisizeimage: 0L, $
    bixpelspermeter: 0L, $
    biypelspermeter: 0L, $
    biclrused: 0L, $
    biclrimportant: 0L $
  } $
else if tag_names(ihdr, /STRUCTURE_NAME) ne "BITMAPINFOHEADER" then $
    message, 'IHDR must contain a BITMAPINFOHEADER structure'

if n_elements(h) gt 0 then begin
    h = ihdr
    return
    endif

fhdr = { BITMAPFILEHEADER, $
    bftype: bytarr(2), $        ;A two char string
    bfsize: 0L, $
    bfreserved1: 0, $
    bfreserved2: 0, $
    bfoffbits: 0L $
  }
s = size(image)
if s(0) lt 2 then message,'Image parameter must have 2 or 3 dimensions.'
nx = s(1)
ny = s(2)
if keyword_set(four_bit) then begin     ;4 bit image
    ihdr.bibitcount = 4 
    nc = 16
    bperl = (nx + 1)/2                  ;bytes / line
endif else if (s(0) eq 3) and (s(1) eq 3) then begin  ;True color
    ihdr.bibitcount = 24
    nx = ny
    ny = s(3)
    nc = 0
    bperl = 3 * nx
endif else begin                ;Plain 8 bit image
    ihdr.bibitcount = 8
    nc = 256
    bperl = nx
endelse

padded = (bperl + 3) and (not 3)   ;padded length
if padded ne bperl then pad = bytarr(padded - bperl)

fhdr.bftype = byte("BM")
ihdr.bisize = 40        ;Init some fields, size of info header

;                filehdr   ihdr          colors  
fhdr.bfoffbits = 14L +     ihdr.bisize + 4 * nc   ;Data start
ihdr.bisizeimage = padded * ny              ;bytes in image part
fhdr.bfsize = fhdr.bfoffbits + ihdr.bisizeimage  ;Total bytes in file
ihdr.biwidth = nx
ihdr.biheight = ny
ihdr.biplanes = 1
ihdr.bicompression = 0          ;For BI_RGB

openw, unit, file, /GET_LUN, /BLOCK
if (byte(1,0,2))(0) eq 0b then $	;Big endian machine
  writeu, unit, swap_endian(fhdr), swap_endian(ihdr) $  ;Swap bytes
else writeu, unit, fhdr, ihdr           ;Write the file and info headers

if nc ne 0 then begin               ;Pseudo color?
    colors = bytarr(nc, 4)          ;Transposed color array
    if n_elements(red) le 0 then begin  ;Get current color table?
        if n_elements(r_curr) eq 0 then loadct,0, /silent  ;Fake it
        n = (nc < n_elements(r_curr))-1     ;# of colors to take
        colors(0,2) = r_curr(0:n)
        colors(0,1) = g_curr(0:n)
        colors(0,0) = b_curr(0:n)
    endif else begin                ;Parameters passed in
        n = (nc < n_elements(red)) -1  ;# of colors to take
        colors(0,2) = red(0:n)
        colors(0,1) = green(0:n)
        colors(0,0) = blue(0:n)
    endelse
    writeu, unit, transpose(colors)  ;Write colors
    endif

if ihdr.bibitcount eq 4 then begin  ;4 bits/pixel?
    if padded ne bperl then pad = bytarr(padded - bperl)
    even = lindgen(nx/2) * 2
    odd = even + 1
    for i=0, ny-1 do begin
        buff = ishft(byte(image(even, i)), 4) + $
		(byte(image(odd,i)) and 15b) ;combine
        if (nx and 7) eq 0 then writeu, unit, buff $  ;No messing?
        else if nx and 1 then begin         ;Odd # of columns?
            t = ishft(byte(image(nx-1, i)), 4)       ;Last byte
            if n_elements(pad) ne 0 then writeu, unit, buff, t, pad $
            else writeu, unit, buff, t
        endif else writeu, unit, buff, pad  ;Even, but add padding
        endfor
endif else if ihdr.bibitcount eq 8 then begin          ;8 bits/pixel?
    if n_elements(pad) eq 0 then writeu, unit, byte(image) $     ;Slam dunk it
    else begin                      ;Must write line by line...
       for i=0, ny-1 do writeu, unit, byte(image(*,i)), pad  ;Write each line
    endelse
endif else begin                    ;24 bits / pixel....
    if n_elements(pad) eq 0 then writeu, unit, byte(image) $  ;Again, dunk it.
    else begin
        for i=0, ny-1 do writeu, unit, byte(image(*,*,i)), pad
    endelse
endelse

free_lun, unit                  ;All done
return

bad:  if n_elements(unit) gt 0 then free_lun, unit
Message, 'Error writing BMP file: ' + file
return
end

; $Id: write_gif.pro,v 1.2 1993/08/23 16:38:19 steve Exp $

PRO WRITE_GIF, FILE, IMG, R, G, B
;+
; NAME:
;	WRITE_GIF
;
; PURPOSE:
;	Write an IDL image and color table vectors to a
;	GIF (graphics interchange format) file.
;
; CATEGORY:
;
; CALLING SEQUENCE:
;
;	WRITE_GIF, File, Image  ;Write a given array.
;
;	WRITE_GIF, File, Image, R, G, B  ;Write array with given color tables.
;
;
; INPUTS:
;	Image:	The 2D array to be output.
;
; OPTIONAL INPUT PARAMETERS:
;      R, G, B:	The Red, Green, and Blue color vectors to be written
;		with Image.
; KEYWORD PARAMETERS:
;	None.
;
; OUTPUTS:
;	If R, G, B values are not provided, the last color table
;	established using LOADCT is saved. The table is padded to
;	256 entries. If LOADCT has never been called, we call it with
;	the gray scale entry.
;
;
; COMMON BLOCKS:
;	COLORS
;
; SIDE EFFECTS:
;	If R, G, and B aren't supplied and LOADCT hasn't been called yet,
;	this routine uses LOADCT to load the B/W tables.
;
; RESTRICTIONS:
;	This routine only writes 8-bit deep GIF files of the standard
;	type: (non-interlaced, global colormap, 1 image, no local colormap)
;
; MODIFICATION HISTORY:
;	Written 9 June 1992, JWG.
;-
; Copyright (c) 1992, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
COMMON colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

; Check the arguments
ON_ERROR, 1		;Return to main level if error
n_params = N_PARAMS();

IF ((n_params NE 2) AND (n_params NE 5))THEN $
  message, "usage: WRITE_GIF, file, image, [r, g, b]"

; Is the image a 2-D array of bytes?

img_size	= SIZE(img)
IF img_size(0) NE 2 OR img_size(3) NE 1 THEN	$
	message, 'Image must be a byte matrix.'

cols	= img_size(1)
rows	= img_size(2)

; If any color vectors are supplied, do they have right attributes ?
IF (n_params EQ 2) THEN BEGIN
	IF (n_elements(r_curr) EQ 0) THEN LOADCT, 0	; Load B/W tables
	r	= r_curr
	g	= g_curr
	b	= b_curr
ENDIF

r_size	= SIZE(r)
g_size	= SIZE(g)
b_size	= SIZE(b)
IF ((r_size(0) + g_size(0) + b_size(0)) NE 3) THEN $
	message, "R, G, & B must all be 1D vectors."
IF ((r_size(1) NE g_size(1)) OR (r_size(1) NE b_size(1)) ) THEN $
	message, "R, G, & B must all have the same length."

;	Pad color arrays

clrmap	= BYTARR(3,256)

tbl_size		= r_size(1)-1
clrmap(0,0:tbl_size)	= r
clrmap(0,tbl_size:*)	= r(tbl_size)
clrmap(1,0:tbl_size)	= g
clrmap(1,tbl_size:*)	= g(tbl_size)
clrmap(2,0:tbl_size)	= b
clrmap(2,tbl_size:*)	= b(tbl_size)

; Write the result
; MACTYPE find me
if (!version.os EQ 'MacOS') then begin
  OPENW, unit, file, /STREAM, /GET_LUN, MACTYPE = "GIFf"
endif else begin 
  OPENW, unit, file, /STREAM, /GET_LUN
endelse

hdr	=  { giffile, $		;Make the header
	magic:'GIF87a', 		$
	width_lo:0b, width_hi:0b,	$
	height_lo:0b, height_hi:0b,	$
	global_info: BYTE('F7'X),	$	; global map, 8 bits color
	background:0b, reserved:0b }		; 8 bits/pixel

hdr.width_lo	= cols AND 255
hdr.width_hi	= cols / 256
hdr.height_lo	= rows AND 255
hdr.height_hi	= rows / 256

ihdr	= { 	imagic: BYTE('2C'X),		$	; BYTE(',')
		left:0, top: 0,			$
		width_lo:0b, width_hi:0b,	$
		height_lo:0b, height_hi:0b,	$
		image_info:7b }

ihdr.width_lo	= cols AND 255
ihdr.width_hi	= cols / 256
ihdr.height_lo	= rows AND 255
ihdr.height_hi	= rows / 256

WRITEU, unit, hdr				;Write header
WRITEU, unit, clrmap				;Write color map

WRITEU, unit, ihdr

ENCODE_GIF, unit, img

FREE_LUN, unit			; Close file and free unit


END
; $Id: write_nrif.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO WRITE_NRIF, FILE, IMAGE, R, G, B

;+
; NAME:
;	WRITE_NRIF
;
; PURPOSE:
;	Write an IDL image and color table vectors to an
;	NCAR Raster Interchange Format (NRIF) rasterfile.
;
; CATEGORY:
;	Input/Output.
;
; CALLING SEQUENCE:
;	WRITE_NRIF, File, Image, [R, G, B]
;
; INPUTS:
;	File:	A string containing the name of the rasterfile to write.
;
;	Image:	The byte array to be output.  If Image is dimensioned (n,m) an
;		8-bit NCAR Raster File with color tables is output.  If Image 
;		is dimensioned (3,n,m), a 24-bit NCAR Raster File is output, 
;		where each byte triple represents the red, green, and blue 
;		intensities at (n,m) on a scale from 0 to 255.  In either 
;		case, IMAGE must be a byte array.  The NRIF image will be 
;		rendered from bottom to top, in accordance with IDL standards,
;		so the !ORDER variable should not be changed from its default 
;		value of zero.
;
; OPTIONAL INPUT PARAMETERS:
;      R, G, B:	The Red, Green, and Blue color vectors to be used as a color
;		table with 8-bit images.  If color vectors are supplied, they
;		are included in the output (8-bit images only).  If color 
;		vectors are not supplied, the color vectors established by 
;		LOADCT or PALETTE are included in the output.  If LOADCT or 
;		PALETTE have not yet been used to define color vectors, 
;		"LOADCT, 0" is called to load the standard grayscale color
;		table.
;
;		This routine does not recognize color vectors loaded directly 
;		using TVLCT, so if a custom color table is desired and it is 
;		not convenient to use PALETTE, include the R, G, and B vectors
;		that were used to create the color table.
;
; OUTPUTS:
;	No explicit outputs.  The specified File will contain header 
;	information, color vectors (8-bit images only), and the image, in
;	NCAR Raster Interchange Format (NRIF).
;
; COMMON BLOCKS:
;	COLORS:  The IDL color table common block.
;
; SIDE EFFECTS:
;	If R, G, and B aren't supplied and color tables haven't been previously
;	established by LOADCT or PALETTE, this routine calls "LOADCT, 0" to 
;	load the standard gray scale color table.
;
; RESTRICTIONS:
;	This routine only writes 8 or 24-bit deep rasterfiles of types
;	"Indexed Color" (for 8-bit) and "Direct Color integrated" for 24-bit.
;	The color map is included only for 8-bit files.
;
; FURTHER INFORMATION:
;	See the document "NCAR Raster Interchange Format and TAGS Raster
;	Reference Manual", available from the Scientific Computing Division,
;	National Center for Atmospheric Research, Boulder, CO, 80307-3000,
;	for the structure of NCAR Raster Interchange Format (NRIF) files.
;
; MODIFICATION HISTORY:
;	Written February, 1991 by Stan Solomon, LASP, University of Colorado.
;	(Adapted from the WRITE_SRF procedure.)
;-
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

; Check the arguments:
on_error, 1
n_params = n_params()
if ((n_params ne 2) and (n_params ne 5))then $
  message, "usage: WRITE_NRIF, file, image, [r, g, b]"

; Check that image has the required attributes:
img_size = size(image)
if ( (img_size(0) ne 2) and (img_size(0) ne 3) ) then  $
  message, 'Image must be a matrix.'
if ( (img_size(0) eq 3) and (img_size(1) ne 3) ) then $
  message, '24 bit images must be dimensioned (3,n,m)'
if ( (img_size(0) eq 2) and (img_size(3) ne 1) ) then $
  message, 'Image must be a byte array.'
if ( (img_size(0) eq 3) and (img_size(4) ne 1) ) then $
  message, 'Image must be a byte array.'

; Determine if this is an 8-bit or 24-bit image:
if (img_size(0) eq 3) then begin
  depth = 24L
  cols = img_size(2)
  rows = img_size(3)
endif else begin
  depth = 8L
  cols = img_size(1)
  rows = img_size(2)
endelse

; Load color vectors into color map if supplied, otherwise use loadct vectors:
if (n_params eq 5) then begin
  r_size = size(r)
  g_size = size(g)
  b_size = size(b)
  if ((r_size(0) + g_size(0) + b_size(0)) ne 3) then $
    message, "R, G, & B must all be 1D vectors."
  if ( (r_size(1) ne g_size(1)) or (r_size(1) ne b_size(1)) ) then $
    message, "R, G, & B must all have the same length."
  map_len = r_size(1) * 3L
  rmap = byte(r)
  gmap = byte(g)
  bmap = byte(b)
endif else begin
  if (n_elements(r_orig) eq 0) then loadct, 0
  tmp = size(r_orig)
  map_len = tmp(1) * 3L
  rmap = byte(r_orig)
  gmap = byte(g_orig)
  bmap = byte(b_orig)
endelse

; Construct header:
magic= 'NRIF'
flags= 2L
width= cols
height= rows
cmtlen= 0L
dev= 0L
devlen= 0L
ibits= 8L
cbits= 8L
ncolor= map_len/3L
if (depth eq 8) then begin
  encoding= 2L
  enclen= map_len+12L
endif
if (depth eq 24) then begin
  encoding= 4L
  enclen= 4L
endif

; If this is a small-endian machine, reverse the byte order of longword
; integers in the header:
test = byte(1L,0,4)
if (test(0) eq 1b) then begin
  flags = long_reverse(flags)
  width = long_reverse(width)
  height = long_reverse(height)
  cmtlen = long_reverse(cmtlen)
  dev = long_reverse(dev)
  devlen = long_reverse(devlen)
  encoding = long_reverse(encoding)
  enclen = long_reverse(enclen)
  ibits = long_reverse(cbits)
  ncolor = long_reverse(ncolor)
  cbits = long_reverse(cbits)
endif

; Write header:
openw, unit, file, /stream, /get_lun
if (depth eq 8) then begin
  writeu, unit, magic, flags, width, height, cmtlen, dev, devlen, $
    encoding, enclen, ibits, ncolor, cbits
  writeu, unit, rmap, gmap, bmap
endif
if (depth eq 24) then begin
  writeu, unit, magic, flags, width, height, cmtlen, dev, devlen, $
    encoding, enclen, cbits
endif

; Write image:
writeu, unit, image

; Close file and free unit:
free_lun, unit

end

; $Id: write_pict.pro,v 1.5 1994/06/24 21:17:16 davee Exp $

pro write_pict_item, unit, data, key
;       procedure write
;       This procedure swaps bytes for short and long words on little endian
;       machines.
common write_pict_rev, rev

   if (key eq 0) or (rev eq 0) then begin
      writeu, unit, data
      return
   endif

   if (key eq 1) then begin
         x = data
         byteorder,x,/sswap
         writeu, unit, x
   endif else if (key eq 2) then begin
         x = data
         byteorder,x,/lswap
         writeu, unit, x
   endif else writeu, unit, data
end

FUNCTION PackData, image

;       Function PackData
;       This function is used by the WRITE_PICT user library routine and
;       it performs the Quickdraw style run length encoding for PICT
;       files.  Image is the unpacked data.  

imagesize = SIZE(image)
IF (imagesize(0) NE 2) THEN MESSAGE, "non two dimensional array passed to pack"
width = FIX(imagesize(1))
height = FIX(imagesize(2))

retval = BYTARR((LONG(width) + 10L) * LONG(height), /NOZERO)
retvalindex = 0L
pack = bytarr(width * 1.5, /NOZERO)
indexarray = lindgen(width)

FOR scanline = height - 1, 0, -1 DO BEGIN

  in = image(*,scanline)
  IF width GT 250 THEN packindex = 2 ELSE packindex = 1

  runstart = WHERE((in EQ in(1:*)) AND (in EQ in(2:*)), found)
  IF (found EQ 0) THEN runstart = width ELSE runstart = [runstart, width]

  inpind = 0
  endrun = -1

  FOR i = 0,N_ELEMENTS(runstart)-1 DO BEGIN     ;For each run
    IF (endrun LT runstart(i)) THEN BEGIN
      WHILE inpind LT runstart(i) DO BEGIN      ;Send out the bytes before it
        packlen = (runstart(i) - inpind) < 128  ;in 128 byte chunks
        pack(packindex) = packlen-1
        pack(packindex+1:packindex+packlen) = in(inpind:inpind+packlen-1)
        packindex = packindex + packlen + 1
        inpind = inpind + packlen
      ENDWHILE
      IF runstart(i) NE width THEN BEGIN
        runinds = WHERE((WHERE(in(runstart(i)) EQ in(runstart(i):*)) EQ $
                      indexarray))
        runsize = N_ELEMENTS(runinds)
        WHILE (runsize NE 0) DO BEGIN
          runlen = runsize < 128
          pack(packindex) = 256 - (runlen - 1)
          pack(packindex+1) = in(runstart(i))
          packindex = packindex + 2
          inpind = inpind + runlen
          endrun = inpind
          runsize = runsize - runlen
        ENDWHILE
      ENDIF
    ENDIF
  ENDFOR

  IF WIDTH GT 250 THEN BEGIN
    pack(0) = (packindex - 2) / 256
    pack(1) = (packindex - 2) mod 256
  ENDIF ELSE BEGIN
    pack(0) = packindex - 1
  ENDELSE

  retval(retvalindex:retvalindex + packindex - 1) = pack(0:packindex-1)
  retvalindex = retvalindex + packindex

ENDFOR

RETURN, retval(0:retvalindex - 1)

END
;------------------------ end of PackData routine --------------------------
  

  

PRO WRITE_PICT, FILE, IMAGE, R, G, B

;+
; NAME:         WRITE_PICT
; PURPOSE:      Writes image files with the current color palette in the PICT
;               Version 2 Format.  This format is used by Apple Macintosh 
;               Computers.
; CATEGORY:     
; CALLING SEQUENCE:
;       WRITE_PICT, FILE                ;Writes contents of current window
;       WRITE_PICT, FILE, IMAGE         ;Writes given array
;       WRITE_PICT, FILE, IMAGE, R, G, B  ;Writes array w/given color table
; INPUTS:
;       FILE = Scalar string giving the name of the PICT file to write.
;       IMAGE = 2D matrix to be output.  If IMAGE is omitted,
;         the entire current window is read into an array and written
;         to the PICT file.
; OPTIONAL INPUT PARAMETERS:
;       R, G, B = The Red, Green, and Blue color vectors to be written
;               with IMAGE.  If not specified, the current color table is used
; OUTPUTS:
;       FILE contains the image in a PICT version 2 file format.  If color
;       vectors were supplied, they are used. Otherwise, the last color tables
;       established by LOADCT are used (If LOADCT hasn't been used
;       to establish color tables yet it is used to load the B/W tables.).
; SIDE EFFECTS:
;       If R, G, and B aren't supplied and LOADCT hasn't been called yet,
;       this routine uses LOADCT to load the B/W tables.
; RESTRICTIONS:
;       Only creates Version 2 PICT files.  Only works with 8-bit displays
; PROCEDURE:
;       Write out the header, size, and the following quickdraw opcodes:
;               Version, HeaderOp, DefHilite, Clip, and PackBitsRect
;       Then pack the image data using the QUICKDRAW PackBits
;       run length encoding algorithm.
;       Packing method:
;               Each line is preceeded by a byte if the image width
;               is less than 250 or a integer otherwise.  This prefix
;               tells how many bytes are in the packed line to follow.
;               The line following this length descriptor is made up of
;               a series of runs and data as follows:
;       - Runs
;               If there is a run, the high bit of the first byte is 
;               set and the other seven bits tell how many elements are
;               in the run.  The next byte is then the value of the run.
;               Runs can only be 128 bytes in length so longer runs are
;               broken up into smaller runs if they exceed 128 bytes.
;               The smallest run is three bytes.
;       - Data
;               If there are a series of image values that differ at least
;               every two bytes, they are written out after a byte that
;               describes how many dissimilar data bytes are to follow.
;               As with runs, the length of a run of data can not be 
;               longer than 128 without setting the high bit of the
;               length descriptor so long strings of data are broken up
;               into chunks 128 bytes or smaller.
; MODIFICATION HISTORY:
;       Written 16 November 1990, Steve Richards.
;       SMR, Aug 25, '92        Rewrote the packing routine and fixed bugs.
;       JIY, Mar 30, '92        added fix to work on Ultrix and VMS.
;       SMR, Oct 12, '93        Added changes suggested by Joe Gurman that
;                               prevented the clobbering of color vectors on
;                               exit from the routine.
;       SMR, Jan 12, '94        Added a case for OSF byte ordering, suggested
;                               by Joe Gurman.
;       DMS, Jun 24, 1994       Fixed byte ordering logic.
;                               Added code to clip image to # of colors-1
;-

common write_pict_rev, rev

i  = byte(1,0,2)                        ;Test byte ordering of this machine
rev = i(0) eq 1b                        ;TRUE to reverse for little endian

ON_ERROR, 2                             ;Return to main level if error

n_params = N_PARAMS();                  ;Check the arguments

IF (n_params EQ 1) THEN BEGIN           ;if no image passed in,
  n_params = 2                          ;Fake 2 param call
  IMAGE = TVRD()                        ;Read screen
ENDIF

IF ((n_params NE 2) AND (n_params NE 5)) THEN $         ;return error if args
  MESSAGE, "usage: WRITE_PICT, file, [IMAGE], [r,g,b]"  ;were incorrect

; If any color vectors are supplied, do they have right attributes ?
IF (n_params EQ 5) THEN BEGIN
  r_size = SIZE(r)
  g_size = SIZE(g)
  b_size = SIZE(b)
  IF ( (r_size(0) + g_size(0) + b_size(0)) NE 3) THEN $
    MESSAGE, "R, G, & B must all be 1D vectors."
  IF ( (r_size(1) NE g_size(1)) OR (r_size(1) NE b_size(1)) ) THEN $
    MESSAGE, "R, G, & B must all have the same length."
ENDIF ELSE BEGIN
  tvlct, r,g,b,/GET
ENDELSE

r_mac = long(r) * 256L          ;macs use ints for
g_mac = long(g) * 256L          ;color values so move
b_mac = long(b) * 256L          ;the values up

arraysize = fix(SIZE(IMAGE))    ;make sure correct dimensions of image
IF(arraysize(0) NE 2) THEN $    ;were used
  MESSAGE, "IMAGE must be a two dimensional matrix."

if (!version.os EQ 'MacOS') then begin
        OPENW, unit, FILE, /GET_LUN,/STREAM, $
            MACTYPE = "PICT"            ;open the file for writing
endif else begin
        OPENW, unit, FILE, /GET_LUN,/STREAM     ;open the file for writing
endelse

hdr = BYTARR(512)               ;pad the file with a 512 byte IMAGE
write_pict_item, unit, hdr, 0   ;that contains nothing important

imagesize = 0                   ;integer padding for IMAGE size which
write_pict_item, unit, imagesize,1      ;is ignored by version 2 PICT files

Rect = {rect, top:0, left:0, bottom:arraysize(2), right:arraysize(1)}
write_pict_item, unit, Rect, 1

opcode = 17                             ;Version Opcode
version = 2b                            ;This is a version 2 file
lowbyte = 255b                          ;being written
  write_pict_item, unit, opcode, 1
  write_pict_item, unit, version, 0
  write_pict_item, unit, lowbyte, 0

opcode = 3072                           ;HeaderOp Opcode
  headerdata = BYTE([[255,255,255,255],bytarr(20)])
  write_pict_item, unit, opcode, 1
  write_pict_item, unit, headerdata, 0

opcode = 30                             ;DefHilite Opcode
  write_pict_item, unit, opcode, 1

opcode = 1                              ;Clip Opcode
  regionsize = 10
  clipregion = Rect
  write_pict_item, unit, opcode, 1
  write_pict_item, unit, regionsize, 1
  write_pict_item, unit, clipregion, 1

opcode = 152                            ;PackBitsRect Opcode
  pixMap = {pixMapstr,  $
                rowBytes:fix(32768 + Rect.right),$      ;set high bit
                Boundtop:0,                     $
                Boundleft:0,                    $
                Boundbottom:Rect.bottom,        $
                Boundright:Rect.right,          $
                version:0,                      $
                packType:0,                     $
                packSize:0L,                    $
                hRes:4718592L,                  $
                vRes:4718592L,                  $
                pixelType:0,                    $
                pixelSize:8,                    $
                cmpCount:1,                     $
                cmpSize:8,                      $
                planeBytes:0L,                  $
                pmTable:0L,                     $
                pmReserved:0L}

  colorlistsize = n_elements(r_mac)
  colorTable = {colorTablestr,  ctseed:1038L,           $
                                transIndex:0,           $
                                ctSize:FIX(colorlistsize)-1}

  colors = INTARR(4, colorlistsize)
  colors(0,*) = INDGEN(colorlistsize)
  colors(1,*) = r_mac
  colors(2,*) = g_mac
  colors(3,*) = b_mac

  srcRect = Rect
  dstRect = Rect

  mode = 0

  imagedata = byte(IMAGE) < byte(colorlistsize-1)  ;Clip it
  IF(Rect.right GE 8) THEN BEGIN                ;pack data
    imagedata = PackData(imagedata)
  ENDIF

  write_pict_item, unit, opcode, 1
  write_pict_item, unit, pixmap.rowbytes, 1
  write_pict_item, unit, pixmap.boundtop, 1
  write_pict_item, unit, pixmap.boundleft, 1
  write_pict_item, unit, pixmap.boundbottom, 1
  write_pict_item, unit, pixmap.boundright, 1
  write_pict_item, unit, pixmap.version, 1
  write_pict_item, unit, pixmap.packtype, 1
  write_pict_item, unit, pixmap.packsize, 1
  write_pict_item, unit, pixmap.hres, 2
  write_pict_item, unit, pixmap.vres, 2
  write_pict_item, unit, pixmap.pixeltype, 1
  write_pict_item, unit, pixmap.pixelsize, 1
  write_pict_item, unit, pixmap.cmpcount, 1
  write_pict_item, unit, pixmap.cmpsize, 1
  write_pict_item, unit, pixmap.planebytes, 2
  write_pict_item, unit, pixmap.pmtable, 2
  write_pict_item, unit, pixmap.pmreserved, 2
  write_pict_item, unit, colortable.ctseed, 2
  write_pict_item, unit, colortable.transindex, 1
  write_pict_item, unit, colortable.ctsize, 1
  write_pict_item, unit, colors, 1
  write_pict_item, unit, srcrect, 1
  write_pict_item, unit, dstrect, 1
  write_pict_item, unit, mode, 1
  write_pict_item, unit, imagedata, 0 

  IF ((N_ELEMENTS(imagedata) MOD 2) NE 0) THEN $
    write_pict_item, unit, 0B, 0

  write_pict_item, unit, 255, 1         ;EOF Opcode

  FREE_LUN, unit

END
; $Id: write_ppm.pro,v 1.1 1994/11/18 23:28:57 dave Exp $
; Copyright (c) 1994. Research Systems, Inc. All rights reserved.
;	Unauthorized reproduction prohibited.

PRO WRITE_PPM, FILE, Image, ASCII = ascii
;+
; NAME:
;	WRITE_PPM
;
; PURPOSE:
;	Write an image to a PPM (true-color) or PGM (gray scale) file.
;	PPM/PGM format is supported by the PMBPLUS and Netpbm packages.
;
;	PBMPLUS is a toolkit for converting various image formats to and from
;	portable formats, and therefore to and from each other.
;
; CATEGORY:
;	Input/Output.
;	
; CALLING SEQUENCE:
;
;	WRITE_PPM, File, Image  ;Write a given array.
;
; INPUTS:
;	Image:	The 2D (gray scale) or 3D (true-color) array to be output.
;
; KEYWORD PARAMETERS:
;	ASCII = if set, formatted ASCII IO is used to write the image data.
;		If omitted, or set to zero, the far more efficient
;		binary IO (RAWBITS) format is used to write the image data.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A file is written.
;
; RESTRICTIONS:
;	This routine only writes 8-bit deep PGM/PPM files of the standard
;	type.
;	Images should be ordered so that the first row is the top row.
;	If your image is not, use WRITE_PPM, File, REVERSE(Image, 2)
;
; MODIFICATION HISTORY:
;	Written Nov, 1994, DMS.
;-
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;

; Check the arguments
ON_IOERROR, bad_io
ON_ERROR, 1

; Is the image a 2-D array of bytes?
img_size	= SIZE(image)
maxval = max(image)
if maxval gt 255 then message, $
		'Data larger than 255 not allowed'
IF img_size(0) eq 2 then begin
    cols = img_size(1)
    rows = img_size(2)
    type = 5 - 3 * keyword_set(ascii)
endif else if img_size(0) eq 3 then begin
    if img_size(1) ne 3 then MESSAGE, 'True-color images must be (3,n,m)'
    cols = img_size(2)
    rows = img_size(3)
    type = 6 - 3 * keyword_set(ascii)
endif else message, 'IMAGE parameter must be dimensioned (n,m) or (3,n,m)'


OPENW, unit, file, /GET_LUN, /BLOCK
printf, unit, 'P'+strtrim(type,2)
printf, unit, cols, rows, byte(maxval)
if keyword_set(ascii) then printf, unit, byte(image) $
else writeu, unit, byte(image)
FREE_LUN, unit
return

BAD_IO: Message, 'Error occured accessing PGM/PPM file:' + file
end
;$Id: write_spr.pro,v 1.4 1994/03/02 15:42:06 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       WRITE_SPR
;
; PURPOSE:
;       This procedure writes a row-indexed sparse matrix stucture to a 
;	specified file.  A  row-indexed sparse matrix is created by the
;	Numerical Recipes routine NR_SPRSIN.
;
; CATEGORY:
;       Sparse Matrix File I/O 
;
; CALLING SEQUENCE:
;       WRITE_SPR, AS, 'Filename' 
;
; INPUTS:
;       AS:  row indexed sparse matrix created by NR_SPRSIN
;	Filename:  Name of file to contain AS.
;
; KEYWORDS:
;	NONE
;
; OUTPUTS:
;	NONE
;
; EXAMPLE:
;	a = [[3.,0., 1., 0., 0.],$
;	     [0.,4., 0., 0., 0.],$
;     	     [0.,7., 5., 9., 0.],$
;     	     [0.,0., 0., 0., 2.],$
;     	     [0.,0., 0., 6., 5.]]
;
;	as = NR_SPRSIN(transpose(a))
;
;	WRITE_SPR, as, 'sprs.as'
;
; MODIFICATION HISTORY:
;       Written by:     BMH, 1/94.
;-
 
PRO WRITE_SPR, as, filename

; as structure format = {sa:FLTARR(nmax) or sa:DBLARR(nmax),  - value array
;			 ija:LONARR(nmax)}                    - index array
;

ON_IOERROR, BADFILE
info = SIZE(as.(0))   ;Access type and size information for the sa array 

nmax = info(1) ;sa and ija vectors are of equal length. 
type = info(2) ;Type of matrix value vector (sa)

OPENW, fileLUN, filename, /GET_LUN

;Store type and size info for file read 
WRITEU, fileLUN, nmax, type, as  

FREE_LUN, fileLUN


RETURN

BADFILE:
IF (N_Elements(fileLUN) GT 0L) THEN $
   FREE_LUN, fileLUN
MESSAGE, 'Error writing to sparse matrix file: ' + filename
 

END



; $Id: write_srf.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO WRITE_SRF, FILE, IMG, R, G, B, WRITE_32 = write_32, ORDER = ORDER
;+
; NAME:
;	WRITE_SRF
;
; PURPOSE:
;	Write an IDL image and color table vectors to a
;	Sun rasterfile.
;
; CATEGORY:
;
; CALLING SEQUENCE:
;	WRITE_SRF, File		;Write contents of current window. 
;
;	WRITE_SRF, File, Image  ;Write a given array.
;
;	WRITE_SRF, File, Image, R, G, B  ;Write array with given color tables.
;
; INPUTS:
;	File:	Scalar string giving the name of the rasterfile to write.
;
;	Image:	The 2D array to be output.  If Image is dimensioned (3,n,m),
;		a 24-bit Sun Raster File is written.  If Image is omitted,
;		the entire current window is read into an array and written
;		to the SRF file.  IMAGE should be of byte type, and in top
;		to bottom scan line order.
;
; OPTIONAL INPUT PARAMETERS:
;      R, G, B:	The Red, Green, and Blue color vectors to be written
;		with Image.
;
; KEYWORD PARAMETERS:
;	ORDER:	If specified, the image is written from the top down instead
;		of bottom up.  This only has effect
;		when writing a file from the current IDL window instead of 
;		an image passed as a parameter.
;
;     WRITE_32:	If the input image is a true color image, dimensioned (3,n,m), 
;		it is normally written as a 24-bit raster file.  Set this 
;		keyword to write the result as a 32-bit file.
;
; OUTPUTS:
;	FILE contains the image in rasterfile format. If color vectors
;	were supplied, they are used. Otherwise, the last color tables
;	established by LOADCT are used (If LOADCT hasn't been used
;	to establish color tables yet it is used to load the B/W tables.).
;
;	See the file /usr/include/rasterfile.h for the structure of
;	Sun rasterfiles.
;
; COMMON BLOCKS:
;	COLORS
;
; SIDE EFFECTS:
;	If R, G, and B aren't supplied and LOADCT hasn't been called yet,
;	this routine uses LOADCT to load the B/W tables.
;
; RESTRICTIONS:
;	This routine only writes 32, 24, & 8-bit deep rasterfiles of
;	type RT_STANDARD.  Use the Unix command rasfilter8to1(1) to convert 
;	these files to 1-bit deep files.
;
; MODIFICATION HISTORY:
;	Written 26 June 1988, AB.
;
;	Added 24 bit color, March 1990, DMS.
;
;	Added 32 bit color, July, 1990, DMS.
;
;	Changed to use CURRENT, rather than ORIGINAL colortables, if
;	the color parameter is not provided.  Made sure
;	that colortables were written as bytes.  April, 1991.
;		
;	Fixed bug that misordered the colors when writing a 24 bit
;	image.  Jan, 1992.
;-
; Copyright (c) 1990, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

; Check the arguments
on_error, 1		;Return to main level if error
n_params = n_params();

if n_params eq 1 then begin
	n_params = 2		;Fake 2 param call
	if n_elements(order) ne 1 then order = 1  ;Set default
	img = tvrd(0,0,!d.x_vsize, !d.y_vsize, ORDER = order)
	endif

IF ((n_params NE 2) AND (n_params NE 5))THEN $
  message, "usage: WRITE_SRF, image, [r, g, b]"

; Does image have the required attributes?
img_size = SIZE(img)
IF (img_size(0) NE 2) and (img_size(0) ne 3) THEN  $
	message, 'Image must be a matrix.'

if (img_size(0) eq 3) and (img_size(1) ne 3) then $
	message, '24 or 32 Bit images must be dimensioned (3,n,m)'


if img_size(0) eq 3 then begin
	if keyword_set(write_32) then depth = 32L else depth = 24L
	istart = 1
	cols = img_size(2)
	rows = img_size(3)
  endif else begin
	depth = 8L
	istart = 0
	cols = img_size(1)
	rows = img_size(2)
 endelse

; If any color vectors are supplied, do they have right attributes ?
IF (n_params EQ 5) THEN BEGIN
	r_size = SIZE(r)
	g_size = SIZE(g)
	b_size = SIZE(b)
	IF ((r_size(0) + g_size(0) + b_size(0)) NE 3) THEN $
		message, "R, G, & B must all be 1D vectors."
	IF ((r_size(1) NE g_size(1)) OR (r_size(1) NE b_size(1)) ) THEN $
		message, "R, G, & B must all have the same length."
	map_len = r_size(1) * 3L
    ENDIF ELSE BEGIN
	IF (n_elements(r_curr) EQ 0) THEN LOADCT, 0	; Load B/W tables
	map_len = n_elements(r_curr) * 3
    ENDELSE

; Write the result
OPENW, unit, file, /STREAM, /GET_LUN
a =  { rasterfile, $		;Make the header
	magic:'59a66a95'XL, $
	width: cols, $
	height: rows, $
	depth: depth, $
	length: rows * cols, $
	type:1L, $
	maptype: 1L, $
	maplength: map_len}

test = byte(1L,0,4)  ;Get the byte order of this machine

if test(0) eq 1b then begin  ;I386 order?
	byteorder, a, /htonl		;To network order
	endif

WRITEU, unit,a				;Write header
IF (n_params EQ 5) THEN BEGIN
	WRITEU, unit, BYTE(r)		;Write out color tables
	WRITEU, unit, BYTE(g)
	WRITEU, unit, BYTE(b)
	ENDIF ELSE WRITEU, unit, BYTE(r_curr), BYTE(g_curr), BYTE(b_curr)

if depth eq 32 then begin		;Pad out 24 to 32 bits
	for i=0, rows-1 do $
		writeu, unit, byte(img([2,2,1,0],*,i)) ; 3 bytes/pixel to 4
	FREE_LUN, unit
	return
endif

if (cols and 1) ne 0 then begin ;Odd number of columns?
	message, 'Warning, image width should be even, adding padding.',/info
	if depth eq 8 then $
		for i=0,rows-1 do $  ;Each row
		   writeu, unit, byte(img(*,i)), 0b $
	else for i=0, rows-1 do $
		writeu, unit, byte(img(*,*,i)), [0b,0b,0b]
  endif else WRITEU, unit, BYTE(img)

FREE_LUN, unit			; Close file and free unit

end
; write_sylk.pro


; Writes a single line of sylk cell data to file.

PRO WriteSylkCell, lunOutfile, Data, iRow, iCol

    ON_ERROR, 2

    ; If the data is anything but a string, simply write it to file.
    IF ((SIZE(Data))(1) NE 7) THEN BEGIN
        PRINTF, lunOutfile, "C;X", STRCOMPRESS(STRING(iCol), /REMOVE_ALL), $
            ";Y", STRCOMPRESS(STRING(iRow), /REMOVE_ALL), ";K", $
            STRCOMPRESS(STRING(Data), /REMOVE_ALL)

    ; Otherwise, surround the string in double quotes.
    ENDIF ELSE BEGIN
        PRINTF, lunOutfile, "C;X", STRCOMPRESS(STRING(iCol), /REMOVE_ALL), $
            ";Y", STRCOMPRESS(STRING(iRow), /REMOVE_ALL), ";K", '"', $
            STRCOMPRESS(STRING(Data), /REMOVE_ALL), '"'
    ENDELSE

    RETURN
END


FUNCTION WRITE_SYLK, Outfile, SourceData, STARTROW = iStartRow, STARTCOL = iStartCol

;
;+
; NAME:
;   WRITE_SYLK
;
; PURPOSE:
;   Writes the contents of an IDL variable to a sylk (Symbolic Link) format 
;   spreadsheet data file. 
;
; CATEGORY:
;   Input/Output.
;
; CALLING SEQUENCE:
;   fStatus = WRITE_SYLK(OutFile, SourceData [, STARTROW, STARTCOL])
;
; INPUT:
;   OutFile: Scalar string with the name of the sylk file to write.
;   SourceData: A scalar, a vector, or a 2D array to be written to file.
;
; OUTPUT:
;   fStatus: Boolean flag.  Returns TRUE if function was successful. 
;
; OPTIONAL INPUT PARAMETERS:
;   STARTROW: The starting (0-based) row of spreadsheet cells to which the 
;       routine will write the data.  If not specified, this value defaults 
;       to row 0. 
;   STARTCOL: The starting (0-based) column of spreadsheet cells to which the
;       routine will write the data.  If not specified, this value defaults 
;       to column 0.
;
; SIDE EFFECTS:
;   None.
;
; RESTRICTIONS:
;   This routine *only* writes numerical and string sylk data.  It connot
;   handle spreadsheet and cell formatting information such as cell width, text
;   justification, font type, date, time, and monetary notations, etc.  A 
;   particular sylk data file cannot be appended with data blocks through 
;   subsequent calls.
;
; EXAMPLES:
;   Assume you wished to write the contents of a 2x2 array of floats, 
;   arrfltData, to a sylk data file called "bar.slk" such that, when read into 
;   a spreadsheet, the matrix would appear with it's upper left data at the 
;   cell in the 10th row and the 20th column.  The following call would 
;   accomplish this task:
;   
;       fStatus = WRITE_SYLK("bar.slk", arrflData, STARTROW = 9, STARTCOL = 19)
;
;
; MODIFICATION HISTORY:
;   Written October 1994, AJH
;-
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;   Unauthorized reproduction prohibited.
;
    
    ON_ERROR, 2
    ON_IOERROR, CleanUp

    _BAD_ =    0B
    _SCALAR_ = 1B
    _VECTOR_ = 2B
    _MATRIX_ = 3B
    _TABLE_ =  4B

    typeData = _BAD_
    lunOutfile = 0
    fStatus = 0

    ; First check to see if the correct number of positional parameters have
    ; been passed
    IF (N_PARAMS() NE 2) THEN BEGIN
        MESSAGE, "Calling sequence - WRITE_SYLK, Outfile, SourceData, " + $
            "STARTROW, STARTCOL", /CONTINUE
        GOTO, CleanUp
    ENDIF

    ; Check the validity of the file parameter
    IF (N_ELEMENTS(Outfile) EQ 0) THEN BEGIN
        MESSAGE, "Error - A STRING filename must be passed in the Outfile " + $
            "parameter.", /CONTINUE
        GOTO, CleanUp
    ENDIF

    ; Check the validity and type of the SourceData parameter
    IF (N_ELEMENTS(SourceData) NE 0) THEN BEGIN
        sizeSourceData = SIZE(SourceData)
        CASE sizeSourceData(0) OF
            0:      typeData = _SCALAR_
            1:      BEGIN
                        typeData = _VECTOR_
                        IF (sizeSourceData(2) EQ 8) THEN BEGIN
                            typeData = _TABLE_
                        ENDIF
                    END
            2:      BEGIN
                        typeData = _MATRIX_
                        IF (sizeSourceData(3) EQ 8) THEN BEGIN
                            typeData = _BAD_
                        ENDIF
                    END
            ELSE:   typeData = _BAD_
        ENDCASE
    ENDIF

    IF (typeData EQ _BAD_) THEN BEGIN
        MESSAGE, "Error - Either a scalar, a vector, or a 2D ARRAY of " + $
            "scalars must be passed in the SourceData parameter.", /CONTINUE
        GOTO, CleanUp
    ENDIF

    ; Setup keyword default values.
    IF (N_ELEMENTS(iStartRow) EQ 0) THEN BEGIN
        iStartRow = 0
    ENDIF ELSE BEGIN
        iStartRow = (iStartRow > 0)
    ENDELSE

    IF (N_ELEMENTS(iStartCol) EQ 0) THEN BEGIN
        iStartCol = 0
    ENDIF ELSE BEGIN
        iStartCol = (iStartCol > 0)
    ENDELSE

    IF (N_ELEMENTS(fUpdate) EQ 0) THEN fUpdate = 0
    
    ; If Outfile is a filename, open it for reading and get its lun
    IF ((SIZE(Outfile))(1) EQ 7) THEN BEGIN
        OPENW, lunOutfile, Outfile, /GET_LUN, ERROR = fOpenWrite
        IF (fOpenWrite NE 0) THEN BEGIN
            MESSAGE, "Error - File " + STRCOMPRESS(Outfile, /REMOVE_ALL) + $
                " cannot be opened.", /CONTINUE
            GOTO, CleanUp           
        ENDIF
        fstatResult = FSTAT(lunOutfile)
        IF (fstatResult.WRITE EQ 0) THEN BEGIN
            MESSAGE, "Error - File " + STRCOMPRESS(Outfile, /REMOVE_ALL) + $
                " cannot be written to.", /CONTINUE
            GOTO, CleanUp
        ENDIF
    ENDIF

    ; Write the SYLK file creation app id to file.
    PRINTF, lunOutfile, "ID;PIDL"
    
    CASE typeData OF
        _SCALAR_:   WriteSylkCell, lunOutfile, SourceData, iStartRow + 1, $
                        iStartCol + 1   
        _VECTOR_:   BEGIN
                        FOR i = 0, sizeSourceData(1) - 1 DO BEGIN
                            WriteSylkCell, lunOutfile, SourceData(i), $
                                i + iStartRow + 1, iStartCol + 1
                        ENDFOR
                    END
        _MATRIX_:   BEGIN
                        FOR i = 0, sizeSourceData(1) - 1 DO BEGIN
                            FOR j = 0, sizeSourceData(2) - 1 DO BEGIN
                                WriteSylkCell, lunOutfile, SourceData(i, j), $
                                    i + iStartRow + 1, j + iStartCol + 1
                            ENDFOR
                        ENDFOR
                    END
        _TABLE_:    BEGIN
                        nTags = N_TAGS(SourceData)
                        FOR i = 0, sizeSourceData(1) - 1 DO BEGIN
                            FOR j = 0, nTags - 1 DO BEGIN
                                WriteSylkCell, lunOutfile, $
                                    SourceData(i).(j), i + iStartRow + 1, $
                                    j + iStartCol + 1
                            ENDFOR
                        ENDFOR
                    END
    ENDCASE
    
    ; Write the SYLK end-of-data descriptor.
    PRINTF, lunOutfile, "E"
    fStatus = 1
    
    GOTO, CleanUp

    CleanUp: BEGIN
        IF (lunOutfile NE 0) THEN BEGIN
            FREE_LUN, lunOutfile
        ENDIF
    END

    RETURN, fStatus
END
; $Id: write_wave.pro,v 1.2 1994/01/03 22:35:39 doug Exp $

PRO write_wave, filename, data, BIN = BIN, NOMESHDEF = NOMESHDEF, $
		DATANAME = DATANAME, $
		MESHNAME = MESHNAME, $
		VECTOR = VECTOR
;+
; NAME:
;	WRITE_WAVE
;
; PURPOSE:
;	Write a three dimensional IDL array to a .wave or .bwave file
;	for use with the Wavefront Visualizer.
;
; CALLING SEQUENCE:
;	WRITE_WAVE, File, Array
;
; INPUTS:
;	File: 	   Scalar string giving the name of the Wavefront file to write.
;	Array:	   3D matrix to be output.
;
; KEYWORD PARAMETERS:
;	BIN:       If the BIN keyword is set, the file will be written in
;		   Binary mode, otherwise, it is written as a text file.
;	DATANAME:  The name of the data inside of the Wavefront file.  If
;		   not specified, the name used is "idldata".
;	MESHNAME:  The name of the mesh used in the Wavefront file.  When
;		   not specified, the name used is "idlmesh".
;	NOMESHDEF: When set, no mesh definition is included.
;	VECTOR:    When set, the variable being written is written as a 
;		   vector
;
; OUTPUTS:
;	FILE contains the array in Wavefront file format. If DATANAME
;	was supplied, the scalar data field in the Wavefront file is given
;	that name. 
;
; RESTRICTIONS:
;	This routine only writes one scalar field for each Wavefront file
;	that it creates.
;
; MODIFICATION HISTORY:
;	Written July 3, 1991, by Steve Richards.
;-
; Copyright (c) 1991, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;


IF NOT(KEYWORD_SET(DATANAME)) THEN DATANAME = "idldata"
IF NOT(KEYWORD_SET(MESHNAME)) THEN MESHNAME = "idlmesh"

s = size(data)
IF (KEYWORD_SET(VECTOR) AND (s(1) EQ 3)) THEN vectwrite = 2 $
ELSE vectwrite = 1

OPENW, unit, filename, /GET_LUN

IF (KEYWORD_SET(BIN)) THEN BEGIN

  WRITEU, unit, 257L					;new block
  WRITEU, unit, 276L					;definevolume
  WRITEU, unit, LONG(STRLEN(DATANAME)), DATANAME
  WRITEU, unit, 277L					;definevolume_mesh
  WRITEU, unit, LONG(STRLEN(MESHNAME)), MESHNAME
  WRITEU, unit, 278L					;definevolume_vdata
  WRITEU, unit, LONG(STRLEN(DATANAME)), DATANAME

  IF (NOT(KEYWORD_SET(NOMESHDEF))) THEN BEGIN
    WRITEU, unit, 257L					;newblock
    WRITEU, unit, 273L					;definemesh
    WRITEU, unit, LONG(STRLEN(MESHNAME)), MESHNAME
    WRITEU, unit, 274L					;definemesh_topology
    WRITEU, unit, 6L, "idltop"
    WRITEU, unit, 275L					;definemesh_grid
    WRITEU, unit, 7L, "idlgrid"
  
    WRITEU, unit, 257L					;newblock
    WRITEU, unit, 259L					;definereg_topology
    WRITEU, unit, 6L, "idltop"
    WRITEU, unit, 260L					;defineelem_samp
    WRITEU, unit, (s(vectwrite:s(0)) - 1)
  
    WRITEU, unit, 257L					;newblock
    WRITEU, unit, 265L					;definereg_grid
    WRITEU, unit, 7L, "idlgrid"
    WRITEU, unit, 266L					;definegrid_samp
    WRITEU, unit, s(vectwrite:s(0))
    WRITEU, unit, 267L					;defineorigin
    WRITEU, unit, LONARR(s(0))
    WRITEU, unit, 268L					;definestep
    WRITEU, unit, (FLTARR(s(0)) + 1.)
  ENDIF

  WRITEU, unit, 257L					;newblock
  WRITEU, unit, 258L					;definevdata
  WRITEU, unit, 1L
  IF (vectwrite EQ 2) THEN $
    DATANAME = DATANAME + "(3)"
  WRITEU, unit, LONG(STRLEN(DATANAME)), DATANAME
  WRITEU, unit, LONG(N_ELEMENTS(data))
  WRITEU, unit, FLOAT(data)

ENDIF ELSE BEGIN					;else write text file

  PRINTF, unit, ""
  PRINTF, unit, ""
  PRINTF, unit, ""

  PRINTF, unit, "define volume " + DATANAME
  PRINTF, unit, "  volume_mesh " + MESHNAME
  PRINTF, unit, "  volume_vdata " + DATANAME
  PRINTF, unit, ""

  IF (NOT(KEYWORD_SET(NOMESHDEF))) THEN BEGIN
    PRINTF, unit, "define mesh " + MESHNAME
    PRINTF, unit, "  mesh_topology idltop"
    PRINTF, unit, "  mesh_grid idlgrid"
    PRINTF, unit, ""
  
    PRINTF, unit, "define reg_topology idltop"
    endofline = STRCOMPRESS(s(1:s(0)) - 1)
    PRINTF, unit, "  elem_samp" + $
    	STRCOMPRESS(REFORM(BYTE(STRING(s(vectwrite:s(0)) - 1)), 36, /OVER))
    PRINTF, unit, ""
    PRINTF, unit, "define reg_grid idlgrid"
    PRINTF, unit, "  grid_samp" + $
    	STRCOMPRESS(REFORM(BYTE(STRING(s(vectwrite:s(0)))), 36, /OVERW))
    PRINTF, unit, "  origin" + $
    	STRCOMPRESS(REFORM(BYTE(STRING(lonarr(3))), 36, /OVERW))
    PRINTF, unit, "  step" + $
    	STRCOMPRESS(REFORM(BYTE(STRING(fltarr(3) + 1.0)), 39, /OVERW))
    PRINTF, unit, ""
  ENDIF

  IF (vectwrite EQ 2) THEN $
    DATANAME = DATANAME + "(3)"
  PRINTF, unit, "define vdata 1 " + DATANAME + STRCOMPRESS(N_ELEMENTS(data))
  PRINTF, unit, ""
  IF (vectwrite EQ 2) THEN $
    PRINTF, unit, data, FORMAT = '(F8.3, F8.3, F8.3)' $
  ELSE PRINTF, unit, data, FORMAT = '(F8.3)'
ENDELSE

FREE_LUN, unit

END

; $Id: xbm_edit.pro,v 1.3 1993/11/10 17:02:49 beth Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	XBM_EDIT
;
; PURPOSE:
;	This routine allows users to create and edit bitmaps for use with IDL
;	widgets as icons.
;
;	The icons can be saved in two different file formats.  IDL "array 
;	definition files" are text files that can be inserted into IDL 
;	programs.  "Bitmap array files" are data files that can be read into 
;	IDL programs.  Bitmap array files are to be used temporarily until 
;	the final icon design is determined and then they can be saved as 
;	IDL array definitions for inclusion in the final code.  This routine 
;	does not check the file types of the files being read in and assumes 
;	that they are of the correct size and type for reading.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XBM_EDIT
;
; KEYWORD PARAMETERS:
;     FILENAME:	A scalar string that contains the file name to be used.  If 
;		this argument is not specified, the name "idl.bm" is used.
;
;	GROUP:	The widget ID of the widget that calls XBM_EDIT.  When this
;		ID is specified, the death of the caller results in the death
;		of XBM_EDIT.
;
;	XSIZE:	The number of pixels across the bitmap is in the horizontal
;		direction.  The default value is 16 pixels.
;
;	YSIZE:	The number of pixels across the bitmap is in the vertical
;		direction.  The default value is 16 pixels.
;
; SIDE EFFECTS:
;	Initiates the XManager if it is not already running.
;
; RESTRICTIONS:
;	XBM_EDIT maintains its state in a common block so it is restricted
;	to one working copy at a time.
;
; PROCEDURE:
;	Create and register the widget and then exit.
;
; MODIFICATION HISTORY:
;	Created from a template written by: Steve Richards, January, 1991
;-



;------------------------------------------------------------------------------
;	procedure update_display
;------------------------------------------------------------------------------
; This procedure redraws both the drawing area and the small icon example 
; displays.
;------------------------------------------------------------------------------

PRO update_display

COMMON bitedit, bytemap, drawwin, showwin, thexsize, theysize, multiplier, $
		nameid, drawmode

wset, showwin
tv, 255 - bytemap, 6, 6
tv, bytemap, thexsize + 12 , 6
wset, drawwin
grid = 255 - REBIN(bytemap, $
		thexsize * multiplier, $
		theysize * multiplier, /SAMPLE)
FOR i = 0, thexsize - 1 do grid(i * multiplier, *) = 150
FOR i = 0, theysize - 1 do grid(*, i * multiplier) = 150
tv, grid

END ;============= end of xbm_edit display update routine  =============


;------------------------------------------------------------------------------
;	procedure draw_pixel
;------------------------------------------------------------------------------
; This routine draws a pixel on the drawing area of the widget.  When the MARK
; keyword is set, a pixel with a mark is drawn to be used when drawing lines,
; circles, and rectangles.
;------------------------------------------------------------------------------

PRO draw_pixel, x, y, color, MARK = MARK

COMMON bitedit, bytemap, drawwin, showwin, thexsize, theysize, multiplier, $
		nameid, drawmode

IF(KEYWORD_SET(MARK))THEN BEGIN
  little = BYTARR(multiplier-1, multiplier-1)
  FOR i = 0, multiplier-2 DO BEGIN
    little(i,i) = 255
    little(i,multiplier-i-2) = 255
  END
  WSET, drawwin
  tv, little, multiplier * x + 1, multiplier * y + 1
ENDIF ELSE BEGIN
  little = bytarr(multiplier-1, multiplier-1) + color
  wset, drawwin
  tv, little, multiplier * x + 1, multiplier * y + 1
  wset, showwin
  tv, 255 - bytemap, 6, 6
  tv, bytemap, thexsize + 12, 6
ENDELSE

END ;============= end of xbm_edit pixel draw routine  =============


;------------------------------------------------------------------------------
;	procedure xbm_edit_ev
;------------------------------------------------------------------------------
; This procedure processes the events being sent from the xmanager.
;------------------------------------------------------------------------------

PRO xbm_edit_ev, event

COMMON bitedit, bytemap, drawwin, showwin, thexsize, theysize, multiplier, $
		nameid, drawmode
COMMON eventstuff, lastx, lasty

WIDGET_CONTROL, event.id, GET_UVALUE = eventval		;find the user value
							;of the widget where
							;the event occured
CASE eventval OF

  "XLOADCT": XLoadct, GROUP = event.top

  "XPALETTE": XPalette, GROUP = event.top

  "XMANTOOL": XMTool, GROUP = event.top

  "DRAW": BEGIN
	event.x = 0 > event.x < (thexsize * multiplier - 1)
	event.y = 0 > event.y < (theysize * multiplier - 1)
	xpos = (event.x / multiplier)
	ypos = (event.y / multiplier)
	IF((event.press NE 0)) THEN BEGIN
	  CASE drawmode OF

	    0: IF(bytemap(xpos, ypos) NE 0) THEN BEGIN
		 bytemap(xpos, ypos) = 0
		 draw_pixel, xpos, ypos, 255
		 drawmode = 2
	       ENDIF ELSE BEGIN
		 bytemap(xpos, ypos) = 255
		 draw_pixel, xpos, ypos, 0
		 drawmode = 1
	       ENDELSE

	    3: BEGIN
		 draw_pixel, xpos, ypos, 0, /MARK
		 lastx = xpos
		 lasty = ypos
	       END

	    4: BEGIN
		 draw_pixel, xpos, ypos, 0, /MARK
		 lastx = xpos
		 lasty = ypos
	       END

	    5: BEGIN
		 draw_pixel, xpos, ypos, 0, /MARK
		 lastx = xpos
		 lasty = ypos
	       END
	    ELSE:
	  ENDCASE
	ENDIF ELSE IF((event.press EQ 0) AND (event.release EQ 0)) THEN BEGIN
	  CASE drawmode OF

	    0: BEGIN
		 lastx = -1
		 lasty = -1
	       END

	    1: IF(NOT((xpos EQ lastx) AND (ypos EQ lasty))) THEN BEGIN
		 fill = 0
		 lastx = xpos
		 lasty = ypos
		 bytemap(xpos, ypos) = 255 - fill
		 draw_pixel, xpos, ypos, 0
	       ENDIF

	    2: IF(NOT((xpos EQ lastx) AND (ypos EQ lasty))) THEN BEGIN
		 lastx = xpos
		 lasty = ypos
		 bytemap(xpos, ypos) = 0
		 draw_pixel, xpos, ypos, 255
		ENDIF

	    ELSE:
	  ENDCASE
	ENDIF ELSE IF(event.release EQ 1) THEN BEGIN
	  CASE drawmode OF

	    1: drawmode = 0

	    2: drawmode = 0

	    3: BEGIN
		 smallx = lastx < xpos
		 bigx = lastx > xpos
		 smally = lasty < ypos
		 bigy = lasty > ypos
		 xrad = (bigx - smallx)/2.
		 yrad = (bigy - smally)/2.
		 cy = smally + yrad
		 cx = smallx + xrad
		 samples = xrad * yrad * 4.0
                 IF samples NE 0 THEN BEGIN
                    FOR i = 0, samples DO BEGIN
                        a = (i/samples)*!pi*2
                        bytemap(cx + cos(a)*xrad, cy + sin(a)*yrad) = 255
                    ENDFOR
                 ENDIF ELSE BEGIN
                    a=0
                    bytemap(cx + cos(a)*xrad, cy + sin(a)*yrad) = 255
                 ENDELSE
		 update_display
		 drawmode = 0
	       END

	    4: BEGIN
		 smallx = lastx < xpos
		 bigx = lastx > xpos
		 smally = lasty < ypos
		 bigy = lasty > ypos
		 FOR i = smallx, bigx DO BEGIN
		   bytemap(i,smally) = 255
		   bytemap(i,bigy) = 255
		 ENDFOR
		 FOR i = smally, bigy DO BEGIN
		   bytemap(smallx, i) = 255
		   bytemap(bigx, i) = 255
		 ENDFOR
		 update_display
		 drawmode = 0
	       END

	    5: BEGIN					;Generalized Bresenhams
		 x = lastx				;Line Drawing Algorithm
		 y = lasty
		 deltax = ABS(xpos - lastx)
		 deltay = ABS(ypos - lasty)
		 so = -1 > (xpos - lastx) < 1
		 st = -1 > (ypos - lasty) < 1
		 IF(deltay GT deltax) THEN BEGIN
		   temp = deltax
		   deltax = deltay
		   deltay = temp
		   interchange = 1
		 ENDIF ELSE interchange = 0
		 ebar = 2 * deltay - deltax
		 FOR i = 1, deltax + 1 DO BEGIN
		   bytemap(x,y) = 255
		   WHILE(ebar GE 0) DO BEGIN
		     IF(interchange EQ 1) THEN x = x + so ELSE y = y + st
		     ebar = ebar - 2 * deltax
		   ENDWHILE
		   IF(interchange EQ 1) THEN y = y + st ELSE x = x + so
		   ebar = ebar + 2 * deltay
		 ENDFOR
		 update_display
		 drawmode = 0
	       END
		 
	  ELSE:
	  ENDCASE
	ENDIF
	  END

  "SVBM": BEGIN
	    WIDGET_CONTROL, nameid, GET_VALUE = filename
	    xdim = thexsize / 8
	    IF((thexsize MOD 8) NE 0) THEN xdim = xdim + 1
 	    data = BYTARR(xdim, theysize)
	    FOR y = 0, theysize - 1 DO $
	      FOR x = 0, thexsize - 1 DO BEGIN
		IF((bytemap(x,y) AND 2^(x mod 8)) NE 0) THEN $
	          data(x / 8, theysize-y-1) = data(x/8,theysize-y-1) OR $
						2^(x mod 8)
	      ENDFOR
	    OPENW, unit, filename(0), /GET_LUN
	    WRITEU, unit, data
	    FREE_LUN, unit
	  END

  "RDBM": BEGIN
	    WIDGET_CONTROL, nameid, GET_VALUE = filename
	    OPENR, unit, filename(0), /GET_LUN
	    fsize = FSTAT(unit)
	    dim = SQRT(fsize.size * 8)
	    IF (dim mod 8) NE 0 THEN $
	      data = BYTARR(dim/8 + 1, dim) $
	    ELSE $
	      data = BYTARR(dim/8, dim)
	    READU, unit, data
	    CLOSE, unit
	    bytemap = BYTARR(thexsize, theysize)
	    FOR y = 0, theysize - 1 DO BEGIN
	      FOR x = 0, thexsize - 1 DO BEGIN
		IF((data(x/8, y) AND (2^(7 - (x mod 8)))) NE 0) THEN $
		  bytemap((x/8)*8 + (7-(x mod 8)), theysize-y-1) = 255
	      ENDFOR
	    ENDFOR
	    update_display
	  END

  "SVIA": BEGIN
	    WIDGET_CONTROL, nameid, GET_VALUE = filename
	    xdim = thexsize / 8
	    IF((thexsize MOD 8) NE 0) THEN xdim = xdim + 1
 	    data = BYTARR(xdim, theysize)
	    FOR y = 0, theysize - 1 DO $
	      FOR x = 0, thexsize - 1 DO BEGIN
		IF((bytemap(x,y) AND 2^(x mod 8)) NE 0) THEN $
	          data(x/8, theysize-y-1) = data(x/8,theysize-y-1) OR $
						2^(x mod 8)
	      ENDFOR
	    IF !VERSION.OS NE "MacOS" THEN newline = string(10B) $
	    ELSE newline = string(13B)
	    OPENW, unit, filename(0), /GET_LUN
	    WRITEU, unit, + $
		"							;" + $
		filename(0) + " bitmap" + newline + $
		"							;" + $
		"definition" + newline
	    WRITEU, unit, filename(0) + $
		" = 	[				$"
	    WRITEU, unit, newline
	    FOR y = 0, theysize - 1 DO BEGIN
	      line = string(data(*,y), $
		format = '("		[",(i3.3,"B",:,", "))')
	      WRITEU, unit, line
	      WRITEU, unit, "]"
	      IF(y LT theysize-1) THEN $
		WRITEU, unit ,",			$" + newline $
	      ELSE WRITEU, unit, "			$" + newline
	    ENDFOR
	    WRITEU, unit, "		]"
	    FREE_LUN, unit
	  END

  "erase.bm": BEGIN
		bytemap = bytarr(thexsize, theysize)
		update_display
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "cw.bm": BEGIN
		bytemap = rotate(bytemap, 3)
		update_display
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	   END

  "ccw.bm": BEGIN
		bytemap = rotate(bytemap, 1)
		update_display
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	    END

  "flip.bm":BEGIN
		bytemap = rotate(bytemap, 5)
		update_display
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	    END

  "invert.bm": BEGIN
		 bytemap = 255 - bytemap
		 update_display
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	       END

  "circle.bm": BEGIN
		drawmode = 3
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	       END

  "rect.bm": BEGIN
		drawmode = 4
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	     END

  "line.bm": BEGIN
		drawmode = 5
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	     END

  "FILENAME": 

  "EXIT": WIDGET_CONTROL, event.top, /DESTROY

  ELSE: MESSAGE, "Event User Value Not Found"

ENDCASE

END ;============= end of xbm_edit event handling routine task =============


;------------------------------------------------------------------------------
;	procedure xbm_edit
;------------------------------------------------------------------------------
; This is the main routine, it creates and then registers the widget with the
; XManager.
;------------------------------------------------------------------------------

PRO xbm_edit, XSIZE = XSIZE, YSIZE = YSIZE, GROUP = GROUP, FILENAME = FILENAME

COMMON bitedit, bytemap, drawwin, showwin, thexsize, theysize, multiplier, $
		nameid, drawmode

common eventstuff, lastx, lasty

IF(XRegistered("xbm_edit")) THEN RETURN			;only one instance of
							;the xbm_edit widget
							;is allowed.  If it is
							;already managed, do
							;nothing and return

IF(NOT(KEYWORD_SET(FILENAME)))THEN FILENAME = "idl.bm"
IF(NOT(KEYWORD_SET(XSIZE)))THEN XSIZE = 16
IF(NOT(KEYWORD_SET(YSIZE)))THEN YSIZE = 16

IF(XSIZE LT 17) THEN mult = 14 ELSE mult = 8

bytemap = bytarr(XSIZE,YSIZE)
drawwin = 0
showwin = 0
thexsize = XSIZE
theysize = YSIZE
multiplier = mult
nameid = 0L
drawmode = 0L

xbm_editbase = WIDGET_BASE(TITLE = "xbm_edit", $
		/COLUMN)				;create the main base

XPdMenu, [	'"Done"					EXIT',		$
		'"File"	{',						$
		'"Save BitMap Array File"		SVBM',		$
		'"Save IDL Array Definition File" 	SVIA',		$
		'"Read BitMap Array File"		RDBM',		$
		'}',							$
		'"Tools"	{',					$
			'"XLoadct"			XLOADCT',	$
			'"XPalette"			XPALETTE',	$
			'"XManagerTool"			XMANTOOL',	$
		'}'],							$
	xbm_editbase

xbm_topbase = WIDGET_BASE(xbm_editbase, $
		/ROW)

version = WIDGET_INFO(/version)
IF VERSION.STYLE EQ 'OPEN LOOK' THEN $
  xbm_palette = WIDGET_BASE(xbm_topbase, $
		COLUMN = 2, $
		/FRAME, $
		/EXCLUSIVE) $
ELSE $
  xbm_palette = WIDGET_BASE(xbm_topbase, $
		COLUMN = 2, $
		/FRAME)

controls = [	"erase.bm",		$
		"line.bm",		$
		"rect.bm",		$
		"circle.bm",		$
		"cw.bm",		$
		"ccw.bm",		$
		"flip.bm",		$
		"invert.bm"		$
	]

controlicons = [						$
		;eraser icon
	 	[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 252B, 255B, 255B, 031B],			$
		[000B, 003B, 000B, 000B, 022B],			$
		[192B, 000B, 000B, 128B, 017B],			$
		[224B, 255B, 255B, 127B, 008B],			$
		[032B, 000B, 000B, 064B, 008B],			$
		[032B, 000B, 000B, 064B, 008B],			$
		[016B, 000B, 000B, 032B, 004B],			$
		[016B, 000B, 000B, 032B, 004B],			$
		[016B, 000B, 000B, 032B, 004B],			$
		[008B, 000B, 000B, 016B, 002B],			$
		[008B, 000B, 000B, 016B, 002B],			$
		[008B, 000B, 000B, 016B, 003B],			$
		[004B, 000B, 000B, 200B, 000B],			$
		[004B, 000B, 000B, 056B, 000B],			$
		[252B, 255B, 255B, 015B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;line icon
		[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 004B, 000B, 000B, 000B],			$
		[000B, 004B, 000B, 000B, 000B],			$
		[000B, 004B, 000B, 000B, 000B],			$
		[000B, 004B, 000B, 000B, 000B],			$
		[000B, 002B, 000B, 000B, 000B],			$
		[000B, 002B, 000B, 000B, 000B],			$
		[000B, 002B, 000B, 000B, 000B],			$
		[000B, 002B, 000B, 000B, 000B],			$
		[000B, 001B, 000B, 000B, 000B],			$
		[000B, 001B, 000B, 000B, 000B],			$
		[000B, 001B, 000B, 192B, 015B],			$
		[000B, 001B, 224B, 063B, 000B],			$
		[128B, 240B, 031B, 000B, 000B],			$
		[128B, 000B, 000B, 000B, 000B],			$
		[128B, 000B, 000B, 000B, 000B],			$
		[128B, 000B, 000B, 000B, 000B],			$
		[064B, 000B, 000B, 000B, 000B],			$
		[064B, 000B, 000B, 000B, 000B],			$
		[064B, 064B, 000B, 000B, 000B],			$
		[064B, 128B, 000B, 000B, 000B],			$
		[032B, 000B, 001B, 000B, 000B],			$
		[032B, 000B, 002B, 000B, 000B],			$
		[032B, 000B, 004B, 000B, 000B],			$
		[032B, 000B, 008B, 000B, 000B],			$
		[016B, 000B, 016B, 000B, 000B],			$
		[016B, 000B, 032B, 000B, 000B],			$
		[016B, 000B, 064B, 000B, 000B],			$
		[016B, 000B, 128B, 000B, 000B],			$
		[008B, 000B, 000B, 001B, 000B],			$
		[008B, 000B, 000B, 002B, 000B],			$
		[008B, 000B, 000B, 004B, 000B],			$
		[008B, 000B, 000B, 008B, 000B],			$
		[000B, 000B, 000B, 016B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;rect icon
	 	[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[224B, 255B, 255B, 031B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 016B, 000B],			$
		[224B, 255B, 255B, 031B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 063B, 000B, 000B, 000B],			$
		[000B, 033B, 000B, 000B, 000B],			$
		[000B, 033B, 000B, 000B, 000B],			$
		[000B, 033B, 000B, 000B, 000B],			$
		[000B, 033B, 000B, 252B, 015B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 004B, 008B],			$
		[000B, 033B, 000B, 252B, 015B],			$
		[000B, 063B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;circle icon
	 	[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 192B, 031B, 000B, 000B],			$
		[000B, 056B, 224B, 000B, 000B],			$
		[000B, 006B, 000B, 003B, 000B],			$
		[000B, 001B, 000B, 004B, 000B],			$
		[128B, 000B, 000B, 008B, 000B],			$
		[064B, 000B, 000B, 016B, 000B],			$
		[032B, 000B, 000B, 032B, 000B],			$
		[032B, 000B, 000B, 032B, 000B],			$
		[016B, 000B, 000B, 064B, 000B],			$
		[016B, 000B, 000B, 064B, 000B],			$
		[016B, 000B, 000B, 064B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[016B, 000B, 000B, 064B, 000B],			$
		[016B, 000B, 000B, 064B, 000B],			$
		[016B, 000B, 000B, 064B, 000B],			$
		[032B, 000B, 000B, 032B, 000B],			$
		[032B, 000B, 000B, 032B, 000B],			$
		[064B, 000B, 000B, 016B, 000B],			$
		[128B, 000B, 000B, 008B, 000B],			$
		[000B, 001B, 000B, 004B, 000B],			$
		[000B, 006B, 000B, 227B, 000B],			$
		[000B, 056B, 224B, 016B, 001B],			$
		[000B, 192B, 031B, 008B, 002B],			$
		[000B, 000B, 000B, 008B, 002B],			$
		[000B, 000B, 000B, 008B, 002B],			$
		[000B, 000B, 000B, 016B, 001B],			$
		[000B, 000B, 000B, 224B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;clockwise rotation icon
	 	[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[192B, 127B, 000B, 000B, 000B],			$
		[064B, 128B, 007B, 000B, 000B],			$
		[064B, 000B, 024B, 000B, 000B],			$
		[064B, 000B, 096B, 000B, 000B],			$
		[064B, 000B, 128B, 001B, 000B],			$
		[064B, 000B, 000B, 002B, 000B],			$
		[064B, 000B, 000B, 004B, 000B],			$
		[064B, 000B, 000B, 008B, 000B],			$
		[064B, 000B, 000B, 016B, 000B],			$
		[192B, 063B, 000B, 016B, 000B],			$
		[000B, 192B, 001B, 032B, 000B],			$
		[000B, 000B, 002B, 032B, 000B],			$
		[000B, 000B, 004B, 064B, 000B],			$
		[000B, 000B, 008B, 064B, 000B],			$
		[000B, 000B, 016B, 064B, 000B],			$
		[000B, 000B, 016B, 064B, 000B],			$
		[000B, 000B, 016B, 128B, 000B],			$
		[000B, 000B, 032B, 128B, 000B],			$
		[000B, 000B, 032B, 128B, 000B],			$
		[000B, 000B, 032B, 128B, 000B],			$
		[000B, 000B, 063B, 128B, 031B],			$
		[000B, 000B, 002B, 000B, 008B],			$
		[000B, 000B, 004B, 000B, 004B],			$
		[000B, 000B, 008B, 000B, 002B],			$
		[000B, 000B, 016B, 000B, 001B],			$
		[000B, 000B, 032B, 128B, 000B],			$
		[000B, 000B, 064B, 064B, 000B],			$
		[000B, 000B, 128B, 032B, 000B],			$
		[000B, 000B, 000B, 017B, 000B],			$
		[000B, 000B, 000B, 010B, 000B],			$
		[000B, 000B, 000B, 004B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;counter clockwise rotation icon
	 	[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 254B, 003B],			$
		[000B, 000B, 224B, 001B, 002B],			$
		[000B, 000B, 024B, 000B, 002B],			$
		[000B, 000B, 006B, 000B, 002B],			$
		[000B, 128B, 001B, 000B, 002B],			$
		[000B, 064B, 000B, 000B, 002B],			$
		[000B, 032B, 000B, 000B, 002B],			$
		[000B, 016B, 000B, 000B, 002B],			$
		[000B, 008B, 000B, 000B, 002B],			$
		[000B, 008B, 000B, 252B, 003B],			$
		[000B, 004B, 128B, 003B, 000B],			$
		[000B, 004B, 064B, 000B, 000B],			$
		[000B, 002B, 032B, 000B, 000B],			$
		[000B, 002B, 016B, 000B, 000B],			$
		[000B, 002B, 008B, 000B, 000B],			$
		[000B, 002B, 008B, 000B, 000B],			$
		[000B, 001B, 008B, 000B, 000B],			$
		[000B, 001B, 004B, 000B, 000B],			$
		[000B, 001B, 004B, 000B, 000B],			$
		[000B, 001B, 004B, 000B, 000B],			$
		[248B, 001B, 252B, 000B, 000B],			$
		[016B, 000B, 064B, 000B, 000B],			$
		[032B, 000B, 032B, 000B, 000B],			$
		[064B, 000B, 016B, 000B, 000B],			$
		[128B, 000B, 008B, 000B, 000B],			$
		[000B, 001B, 004B, 000B, 000B],			$
		[000B, 002B, 002B, 000B, 000B],			$
		[000B, 004B, 001B, 000B, 000B],			$
		[000B, 136B, 000B, 000B, 000B],			$
		[000B, 080B, 000B, 000B, 000B],			$
		[000B, 032B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;flip icon
	 	[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 128B, 000B, 000B],			$
		[000B, 000B, 192B, 000B, 000B],			$
		[000B, 000B, 160B, 000B, 000B],			$
		[000B, 000B, 144B, 000B, 000B],			$
		[000B, 000B, 136B, 000B, 000B],			$
		[000B, 000B, 132B, 000B, 000B],			$
		[000B, 000B, 130B, 000B, 000B],			$
		[000B, 000B, 129B, 000B, 000B],			$
		[000B, 128B, 128B, 000B, 000B],			$
		[000B, 064B, 128B, 000B, 000B],			$
		[000B, 032B, 128B, 000B, 000B],			$
		[000B, 032B, 128B, 000B, 000B],			$
		[000B, 063B, 128B, 255B, 000B],			$
		[224B, 032B, 128B, 000B, 007B],			$
		[024B, 032B, 128B, 000B, 024B],			$
		[004B, 032B, 128B, 002B, 032B],			$
		[028B, 032B, 128B, 006B, 032B],			$
		[228B, 032B, 128B, 010B, 032B],			$
		[004B, 255B, 255B, 019B, 032B],			$
		[004B, 000B, 000B, 032B, 032B],			$
		[004B, 000B, 000B, 192B, 032B],			$
		[004B, 000B, 000B, 128B, 039B],			$
		[004B, 000B, 000B, 000B, 057B],			$
		[004B, 000B, 000B, 000B, 033B],			$
		[008B, 000B, 000B, 128B, 000B],			$
		[048B, 000B, 000B, 064B, 000B],			$
		[192B, 001B, 000B, 032B, 000B],			$
		[000B, 254B, 255B, 019B, 000B],			$
		[000B, 192B, 128B, 010B, 000B],			$
		[000B, 128B, 128B, 006B, 000B],			$
		[000B, 000B, 129B, 002B, 000B],			$
		[000B, 000B, 130B, 000B, 000B],			$
		[000B, 000B, 132B, 000B, 000B],			$
		[000B, 000B, 136B, 000B, 000B],			$
		[000B, 000B, 144B, 000B, 000B],			$
		[000B, 000B, 160B, 000B, 000B],			$
		[000B, 000B, 192B, 000B, 000B],			$
		[000B, 000B, 128B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;invert icon
	 	[						$
		[000B, 000B, 000B, 000B, 128B],			$
		[224B, 127B, 000B, 000B, 192B],			$
		[024B, 128B, 001B, 000B, 224B],			$
		[004B, 000B, 002B, 000B, 240B],			$
		[004B, 000B, 002B, 000B, 248B],			$
		[098B, 096B, 004B, 000B, 252B],			$
		[098B, 096B, 004B, 000B, 254B],			$
		[002B, 000B, 004B, 000B, 255B],			$
		[002B, 000B, 004B, 128B, 255B],			$
		[002B, 006B, 004B, 192B, 255B],			$
		[002B, 006B, 004B, 224B, 255B],			$
		[002B, 000B, 004B, 240B, 255B],			$
		[002B, 000B, 004B, 248B, 255B],			$
		[034B, 064B, 004B, 252B, 255B],			$
		[098B, 096B, 004B, 254B, 255B],			$
		[196B, 057B, 002B, 255B, 255B],			$
		[004B, 015B, 130B, 255B, 255B],			$
		[024B, 128B, 193B, 255B, 255B],			$
		[224B, 127B, 224B, 255B, 255B],			$
		[000B, 000B, 240B, 255B, 255B],			$
		[000B, 000B, 248B, 000B, 248B],			$
		[000B, 000B, 060B, 255B, 231B],			$
		[000B, 000B, 222B, 255B, 223B],			$
		[000B, 000B, 223B, 255B, 223B],			$
		[000B, 128B, 239B, 252B, 185B],			$
		[000B, 192B, 239B, 252B, 185B],			$
		[000B, 224B, 239B, 255B, 191B],			$
		[000B, 240B, 239B, 255B, 191B],			$
		[000B, 248B, 239B, 255B, 191B],			$
		[000B, 252B, 239B, 159B, 191B],			$
		[000B, 254B, 239B, 159B, 191B],			$
		[000B, 255B, 239B, 255B, 191B],			$
		[128B, 255B, 239B, 255B, 191B],			$
		[192B, 255B, 239B, 253B, 187B],			$
		[224B, 255B, 239B, 249B, 185B],			$
		[240B, 255B, 223B, 099B, 220B],			$
		[248B, 255B, 223B, 015B, 223B],			$
		[252B, 255B, 063B, 255B, 231B],			$
		[254B, 255B, 255B, 000B, 248B],			$
		[255B, 255B, 255B, 255B, 255B]			$
		]						$
		]

FOR i = 0,N_ELEMENTS(controls)-1 DO BEGIN
  toss = WIDGET_BUTTON(xbm_palette, $
		VALUE = controlicons(*,*,i), $
		UVALUE = controls(i))
ENDFOR

xbm_draw = WIDGET_DRAW(xbm_topbase, $
		XSIZE = thexsize * multiplier, $
		YSIZE = theysize * multiplier, $
		/BUTTON_EVENTS, $
		/MOTION_EVENTS, $
		RETAIN = 2, $
		UVALUE = "DRAW", $
		/FRAME)

showbase = WIDGET_BASE(xbm_editbase, $
		/ROW)

xbm_show = WIDGET_DRAW(showbase, $
		XSIZE = thexsize * 2 + 18, $
		YSIZE = theysize + 12, $
		RETAIN = 2, $
		/FRAME)

tempbase = WIDGET_BASE(xbm_editbase, $
		/ROW, $
		/FRAME)
label = WIDGET_LABEL(tempbase, $
		VALUE = "Filename:")
nameid = WIDGET_TEXT(tempbase, $
		VALUE = FILENAME, $
		XSIZE = 40, $
		YSIZE = 1, $
		/EDITABLE, $
		UVALUE = "FILENAME")

WIDGET_CONTROL, xbm_editbase, /REALIZE			;create the widgets
							;that is defined

WIDGET_CONTROL, xbm_draw, GET_VALUE = test1		;drawwin
WIDGET_CONTROL, xbm_show, GET_VALUE = test2		;showwin

drawwin = test1
showwin = test2

WSET, showwin
ERASE, 149

update_display

lastx = 0
lasty = 0

XManager, "xbm_edit", xbm_editbase, $			;register the widgets
		EVENT_HANDLER = "xbm_edit_ev", $	;with the XManager
		GROUP_LEADER = GROUP

END ;================ end of xbm_edit background task =====================






; $Id: xdisplayfile.pro,v 1.5 1994/10/10 16:25:08 hilary Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
PRO XDispFile_evt, event

WIDGET_CONTROL, GET_UVALUE = retval, event.id

IF(retval EQ "EXIT") THEN WIDGET_CONTROL, event.top, /DESTROY

END


PRO XDisplayFile, FILENAME, TITLE = TITLE, GROUP = GROUP, WIDTH = WIDTH, $
		HEIGHT = HEIGHT, TEXT = TEXT, FONT = font
;+
; NAME: 
;	XDISPLAYFILE
;
; PURPOSE:
;	Display an ASCII text file using widgets and the widget manager.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XDISPLAYFILE, Filename
;
; INPUTS:
;     Filename:	A scalar string that contains the filename of the file
;		to display.  The filename can include a path to that file.
;
; KEYWORD PARAMETERS:
;	FONT:   The name of the font to use.  If omitted use the default
;		font.
;	GROUP:	The widget ID of the group leader of the widget.  If this 
;		keyword is specified, the death of the group leader results in
;		the death of XDISPLAYFILE.
;
;	HEIGHT:	The number of text lines that the widget should display at one
;		time.  If this keyword is not specified, 24 lines is the 
;		default.
;
;	TEXT:	A string or string array to be displayed in the widget
;		instead of the contents of a file.  This keyword supercedes
;		the FILENAME input parameter.
;
;	TITLE:	A string to use as the widget title rather than the file name 
;		or "XDisplayFile".
;
;	WIDTH:	The number of characters wide the widget should be.  If this
;		keyword is not specified, 80 characters is the default.
;
; OUTPUTS:
;	No explicit outputs.  A file viewing widget is created.
;
; SIDE EFFECTS:
;	Triggers the XMANAGER if it is not already in use.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Open a file and create a widget to display its contents.
;
; MODIFICATION HISTORY:
;	Written By Steve Richards, December 1990
;	Graceful error recovery, DMS, Feb, 1992.
;       12 Jan. 1994  - KDB
;               If file was empty, program would crash. Fixed.
;       4 Oct. 1994     MLR Fixed bug if /TEXT was present and /TITLE was not.
;-
                                                        ;use the defaults if
IF(NOT(KEYWORD_SET(HEIGHT))) THEN HEIGHT = 24		;the keywords were not
IF(NOT(KEYWORD_SET(WIDTH))) THEN WIDTH = 80		;passed in

IF(NOT(KEYWORD_SET(TEXT))) THEN BEGIN
  IF(NOT(KEYWORD_SET(TITLE))) THEN TITLE = FILENAME     
  OPENR, unit, FILENAME, /GET_LUN, ERROR=i		;open the file and then
  if i lt 0 then begin		;OK?
	a = [ !err_string, ' Can not display ' + filename]  ;No
  endif else begin
	  a = strarr(1000)				;Maximum # of lines
	  i = 0
	  c = ''
	  while not eof(unit) do begin
		readf,unit,c
		a(i) = c
		i = i + 1
		endwhile
	  a = a(0:(i-1)>0)  ;Added empty file check -KDB
	  FREE_LUN, unit				;free the file unit.
  endelse
ENDIF ELSE BEGIN
    IF(NOT(KEYWORD_SET(TITLE))) THEN TITLE = 'XDisplayFile'
    a = TEXT
ENDELSE

filebase = WIDGET_BASE(TITLE = TITLE, $			;create the base
		/COLUMN, $
		SPACE = 20, $
		XPAD = 20, $
		YPAD = 20)

filequit = WIDGET_BUTTON(filebase, $			;create a Done Button
		VALUE = "Done with " + TITLE, $
		UVALUE = "EXIT")

IF n_elements(font) gt 0 then $
 filetext = WIDGET_TEXT(filebase, $			;create a text widget
		XSIZE = WIDTH, $			;to display the file's
		YSIZE = HEIGHT, $			;contents
		/SCROLL, FONT = font, $
		VALUE = a) $
ELSE filetext = WIDGET_TEXT(filebase, $			;create a text widget
		XSIZE = WIDTH, $			;to display the file's
		YSIZE = HEIGHT, $			;contents
		/SCROLL, $
		VALUE = a)


WIDGET_CONTROL, filebase, /REALIZE			;instantiate the widget

Xmanager, "XDisplayFile", $				;register it with the
		filebase, $				;widget manager
		GROUP_LEADER = GROUP, $
		EVENT_HANDLER = "XDispFile_evt" 

END  ;--------------------- procedure XDisplayFile ----------------------------

; $Id: xdistfile.pro,v 1.4 1995/08/04 15:40:40 idl Exp $

; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

PRO XDistfile, FILENAME, SUBDIRECTORY, _EXTRA=extra
;+
; NAME: 
;	XDISTFILE
;
; PURPOSE:
;	Displays ASCII text files from the IDL distribution. Unlike
;	XDISPLAYFILE, this routine understands that under VMS, IDL
;	routines are packed in VMS text libraries.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XDISTFILE, Filename, Subdirectory
;
; INPUTS:
;     Filename:	A scalar string that contains the filename of the file
;		to display NOT INCLUDING the '.pro' extension or any
;		path information.
;     Subdirectory: Subdirectory information in the style of the
;		FILEPATH user library routine.
;
; KEYWORD PARAMETERS:
;	Any keywords allowed by XDISPLAYFILE are also allowed.
;
; OUTPUTS:
;	No explicit outputs.  A file viewing widget is created.
;
; SIDE EFFECTS:
;	Triggers the XMANAGER if it is not already in use.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	This is a thin wrapper over the XDISPLAYFILE routine.
;	In the case of VMS text libraries, the last element of the
;	SUBDIRECTORY argument is taken to be the TLB file name, and
;	FILENAME is actually the module name in that library.
;
; MODIFICATION HISTORY:
;	1 June 1994, AB
;-

  if (!version.os eq 'vms') then begin
    n = n_elements(subdirectory)
    subn = n
    if (subn lt 1) then message,'SUBDIRECTORY doesn''t contain enough elements.'
 
    module = subdirectory(n-1)
    subd = subdirectory(0:n-subn)
    n=n-1

    library=filepath(module+'.tlb', SUBDIRECTORY=subd)
    ;
    ; WARNING:
    ;
    ;	READ_VMSTLB is undocumented and likely to disappear or change
    ;   radiacally in future IDL releases. Use at your own risk.
    ;
    text = READ_VMSTLB(library, filename, count=c)
    if (c ne 0) then begin
      title = library + '  (' + STRUPCASE(filename) + '.PRO)'
      XDISPLAYFILE, TEXT=TEXT, title=title, _extra=extra
      return
    endif
  endif


  XDISPLAYFILE, FILEPATH(filename + '.pro', SUBDIRECTORY=SUBDIRECTORY), $
			 _extra=extra

END
; $Id: xfont.pro,v 1.5 1995/07/03 15:45:24 idl Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	XFONT
;
; PURPOSE:
;	XFONT is a modal widget for selecting and viewing an X Windows font.
; 
; CATEGORY:
;	Widgets, Fonts
;
; CALLING SEQUENCE:
;	Selected_font = XFONT()
;
; INPUTS:
;	No explicit inputs.
;
; KEYWORD PARAMETERS:
;	GROUP:    The widget ID of the widget that calls XFONT. When this
;		  ID is specified, a death of the caller results in a death
;		  of XFONT.
;	PRESERVE: If set, XFONT saves the server font directory in common
;		  blocks so that subsequent calls to XFONT start-up much
;		  faster. If not set, the common block is cleaned.
;
; OUTPUTS:
;	A string containing the font name.  If nothing is selected, or
;	the CANCEL button is pressed, a null string is returned.
;
; COMMON BLOCKS:
;	XFONT_COM.
;
; SIDE EFFECTS:
;	Initiates the XManager if it is not already running.
;	Resets the current X Window font.  
;
; RESTRICTIONS:
;	The current X window font is manipulated without being restored.
;
; PROCEDURE:
;	Create and register the widget and then exit.
;
; MODIFICATION HISTORY:
;	Modified from a template written by: Hans-Joachim Bothe, CreaSo GmbH,
;		November, 1991, by DMS, RSI, November, 1992.
;	1 July 1995, AB, Fixed sizing of toggle buttons.
;-




FUNCTION xfont_select, sstring		;Find fonts matching sstring
;  Return -1 if none there....
common xfont_com, s, f, xreg, private, nfields, nreg, uniqi, uniqs, $
	t_buttons, t_list, s_list, s_string, t_button_select, t_text, $
	l_text, to_do, t_selections, selected_font, view_text, $
	view_window, reg_base, priv, display_string, s_text, preserve, $
	point_base, point_txt, size_index



l = replicate(1b, nreg)			;Matching fonts so far

for i=0, n_elements(to_do)-1 do begin
	if s_string(i) ne '*' then begin  ;Search this field
		bad = where(f(i,*) ne s_string(i), count)
		if count gt 0 then l(bad) = 0
		endif
	endfor
return, where(l)
end


FUNCTION xfont_scal_fname, name
; Given a font name, s.  See if field 8 (the size field, counting the
; first '-') contains the string '0'.  If so, substitute the contents of 
; the point_size text widget, followed by -75-75.
;	
common xfont_com, s, f, xreg, private, nfields, nreg, uniqi, uniqs, $
	t_buttons, t_list, s_list, s_string, t_button_select, t_text, $
	l_text, to_do, t_selections, selected_font, view_text, $
	view_window, reg_base, priv, display_string, s_text, preserve, $
	point_base, point_txt, size_index

t = str_sep(name, '-')
if n_elements(t) lt 11 then return, name
if fix(t(8)) ne 0 then return, name
widget_control, point_txt, GET_VALUE = x
if fix(x(0)) eq 0 then return, name	;No size specified
t(8) = x		;Substitute point size
t(9) = '75'		;Diddle our fields
t(10) = '75'
n = n_elements(t)
r = ''
for i=1, n_elements(t)-1 do r = r + '-' + t(i)   ;Re-combine

return ,r
end






PRO xfont_event, event			;Main & only event procedure
                     
common xfont_com, s, f, xreg, private, nfields, nreg, uniqi, uniqs, $
	t_buttons, t_list, s_list, s_string, t_button_select, t_text, $
	l_text, to_do, t_selections, selected_font, view_text, $
	view_window, reg_base, priv, display_string, s_text, preserve, $
	point_base, point_txt, size_index



WIDGET_CONTROL, event.top, /HOURGLASS
WIDGET_CONTROL, event.id, GET_UVALUE=eventval

   ; Determine event type

CASE eventval OF

    "TBUTTON": BEGIN		;Font-type button
	if t_button_select ne -1 then $
		widget_control, t_buttons(t_button_select), $
			SET_BUTTON = 0  ;Remove prev
	t_button_select = (where(event.id eq t_buttons))(0)  ;New button
	n = t_button_select
	s_string(n) = '*'	;Make this one wild
	WIDGET_CONTROL, t_text(n), SET_VALUE = '*'
	q = xfont_select(s_string)	;Fonts OK so far.

	if q(0) ne -1 then begin	;Anything there?
		t_strings = f(n,q)	;Names that we can select
		t_selections = uniq(t_strings, sort(t_strings))
		t_selections = t_strings(t_selections)
	endif else t_selections = '<Nothing Matches>'
	WIDGET_CONTROL, t_list, set_value = t_selections
	goto, update_s_list
	ENDCASE
	
    "T_LIST": BEGIN		;Picked a list item
	if t_button_select eq -1 then return
	s_string(t_button_select) = t_selections(event.index)
	WIDGET_CONTROL, t_text(t_button_select), $
		SET_VALUE = t_selections(event.index)
	q = xfont_select(s_string)	;Matching fonts
	if t_button_select eq size_index then begin
		i =  s_string(size_index) eq '0' 
		WIDGET_CONTROL, point_base, MAP=i
		endif
    update_s_list:
	selected_font = -1
	if q(0) ne -1 then BEGIN
		WIDGET_CONTROL, s_list, SET_VALUE=s(xreg(q))
		selected_font = xreg(q(0))
	ENDIF ELSE WIDGET_CONTROL, s_list, SET_VALUE = '<No matching fonts>'
	WIDGET_CONTROL, l_text, SET_VALUE= strtrim(n_elements(q),2) + $
	   ' matching fonts.'
	goto, view_font
	ENDCASE	

    "S_LIST": BEGIN
	if priv then selected_font = private(event.index) $
	else begin
		q = xfont_select(s_string)	;Matching fonts
		selected_font = xreg(q(event.index))
	endelse
; 	print,s(selected_font)
  view_font:
	if selected_font lt 0 then begin
	    WIDGET_CONTROL, view_text, SET_VALUE = 'No font selected'
	    return
	    endif
	font = xfont_scal_fname(s(selected_font))
	WIDGET_CONTROL, view_text, SET_VALUE=font
	swin = !d.window
	wset, view_window
	erase
	device, font = font
	xyouts, 10, !d.y_size - 1.5 * !d.y_ch_size, /DEV, /FONT, display_string
	if swin ge 0 then wset, swin
	ENDCASE
    "PRIV":  BEGIN
	WIDGET_CONTROL, reg_base, map=0
	WIDGET_CONTROL, s_list, SET_VALUE = s(private)
	priv = 1
	ENDCASE
    "REG":   BEGIN
	WIDGET_CONTROL, reg_base, map=1
	priv = 0
	q = xfont_select(s_string)	;Matching fonts
	goto, update_s_list
	ENDCASE

    "DRAW": WIDGET_CONTROL, event.top, /DESTROY   ;Clicked draw window

    "VIEW": BEGIN
	if selected_font lt 0 then return
	device, font = xfont_scal_fname(s(selected_font))
	junk = WIDGET_BASE(title = s(selected_font))
	chx = !d.x_ch_size * 2. > 8	;X Spacing
	chy = !d.y_ch_size * 1.7 > 12	;Y Spacing
	draw = WIDGET_DRAW(junk, xsize = chx * 18, ysize = chy * 18, $
		/BUTTON_EVENTS, UVALUE="DRAW", RET=2)
	WIDGET_CONTROL, junk, /realize
	WIDGET_CONTROL, draw, GET_VALUE = i
	WSET, i
	for i=0,15 do xyouts, (i+2)*chx, !d.y_size - chy, /DEV, $
		string(i, format='(z1)')
	for i= 0, 15 do begin
		y = !d.y_size - (i+2) * chy
		xyouts, 0, y, /DEV, string(i, format='(z1)')
		k = i*16
		for j=0, 15 do $
		    if j+k ne 0 then xyouts, (j+2) *chx, y, /DEV, /FONT, $
				string(byte(j+k))
		ENDFOR
	XMANAGER, 'xfont', junk, EVENT_HANDLER = 'xfont_event', $
		GROUP_LEADER = event.top
	ENDCASE
    "HELP": BEGIN
;	xdisplayfile, 'xfont.txt', $	;Debugging
	xdisplayfile, filepath("xfont.txt", subdir=['help', 'widget']), $  ;Working
		title = "xfont help", $
		group = event.top, $
		width = 72, height = 24
	ENDCASE

    "STEXT": BEGIN
	WIDGET_CONTROL, s_text, GET_VALUE = display_string
	display_string = display_string(0)
	goto, view_font
	ENDCASE

    "PTXT": goto, view_font	
    "DONE": BEGIN
	if selected_font ge 0 then begin
		s_string = xfont_scal_fname(s(selected_font))
		goto, exit
		endif
	ENDCASE
    "CANCEL": BEGIN
	selected_font = -1
    exit:
	WIDGET_CONTROL, event.top, /DESTROY
	if preserve eq 0 then BEGIN	;Clean up space consuming arrays
		f = 0
		if selected_font ge 0 then s = s(selected_font) else s = ''
		private = 0
		uniqs = 0
		xreg = 0
		ENDIF
	ENDCASE
ENDCASE
END




Function xfont, GROUP = GROUP, PRESERVE_FONT_INFO = pres

common xfont_com, s, f, xreg, private, nfields, nreg, uniqi, uniqs, $
	t_buttons, t_list, s_list, s_string, t_button_select, t_text, $
	l_text, to_do, t_selections, selected_font, view_text, $
	view_window, reg_base, priv, display_string, s_text, preserve, $
	point_base, point_txt, size_index
                     

   ; Check for other copies and do nothing if xfont is already running:

   IF(XRegistered('xfont') NE 0) THEN RETURN, ''

   if n_elements(pres) gt 0 then preserve = pres else preserve = 0
   pwin = -1
   selected_font = -1
   t_button_select = -1
   priv = 0
   display_string = 'The quick brown fox jumped over the lazy dog.' + $
	'!C!CABCDEFG abcdefg 01234567'

   to_do = [ 0,1,2,3,4,7 ]	;Fields we care about
   m = n_elements(to_do)
   field_names = [ 'Foundry', 'Family', 'Weight', 'Slant', 'Width', $
		'Size' ]
   t_buttons = lonarr(m)
   t_text = lonarr(m)
   s_string = replicate('*', m)
   size_index = 5		;The index of the point size field


   if !d.window lt 0 then $	;So we don't create an empty window
	window, /pix, xs=100, ys=100, /free, pwin

   if n_elements(s) gt 1 then goto, processed_fonts  ;Saved info?
   t0 = systime(1)
   device, font ='*', get_fontname=s	  ;Get the fonts
   nf = n_elements(s)			;# of fonts

   char1 = strmid(s, 0, 1)		;Parse fontname strings
   ext = where(char1 eq '+', count)  	;Any Font name extensions?
   for i=0, count-1 do begin		;Remove them
	j = ext(i)
	s(j) = strmid(s(j), strpos(s(j), '-'), 1000)
	endfor
				;Separate the X window fonts
   if count gt 0 then xreg = [ where(char1 eq '-'), ext ] $
   else xreg = where(char1 eq '-')

   private = lonarr(nf)		;Get private fonts
   private(xreg) = 1		;Ones that are X
   private = where(private eq 0)  ;Ones that aren't
   private = private(sort(s(private)))  ;Sort into lexical order

   nreg = n_elements(xreg)	; Separate information from font names

   f = strarr(m, nreg)		;Fields we care about
   nfields = max(to_do)
   this_one = replicate(-1, nfields+1)  ;-1 in fields we don't want
   this_one(to_do) = indgen(m)    ;Index in ones we do

   for j=0, nreg-1 do begin	;Each registered font
	t = s(xreg(j))		;The string
	anchor = 1		;1st char to search
	for i=0, nfields do begin	;Extract each field
		n = strpos(t, '-', anchor)
		k = this_one(i)
		if k ge 0 then begin
		   tt = strmid(t, anchor, n - anchor)
		   if tt eq '' then f(k,j) = '<blank>' else f(k,j) = tt
		   endif
		anchor = n + 1
		endfor
	endfor

   uniqi = lonarr(m+1)		;Indices to unique names
   
   for i=0L, m-1 do begin	;Get unique items for each field
	t = f(i,*)
	t = uniq(t, sort(t))
	uniqi(i+1) = n_elements(t) + uniqi(i)	;Startind indices
	if i eq 0 then uniqs = t $
	else uniqs = [ uniqs, t]
	endfor
;   print, systime(1) - t0, ' seconds getting fonts'


processed_fonts:
   xfontbase = WIDGET_BASE(TITLE='Font Widget', /COLUMN)
   junk = WIDGET_BASE(xfontbase, /ROW)
   junk1 = WIDGET_BUTTON(junk, value = "OK", UVALUE = "DONE", /NO_REL)
   junk1 = WIDGET_BUTTON(junk, value = "Cancel", UVALUE = "CANCEL", /NO_REL)
   junk1 = WIDGET_BUTTON(junk, value = "View", UVALUE = "VIEW", /NO_REL)
   junk1 = WIDGET_BUTTON(junk, value = "Help", UVALUE = "HELP", /NO_REL)
   junk1 = WIDGET_BASE(junk, /ROW, /EXCLUSIVE)
   junk2 = WIDGET_BUTTON(junk1, VALUE = 'Registered', UVALUE='REG')
   junk3 = WIDGET_BUTTON(junk1, VALUE = 'Private', UVALUE='PRIV')
   WIDGET_CONTROL, junk2, SET_BUTTON=1
   
   point_base = WIDGET_BASE(junk, /ROW, /FRAME)
   junk2 = WIDGET_LABEL(point_base, VALUE='deciPoint Size:')
   point_txt = WIDGET_TEXT(point_base, xsize=4, /EDIT, value='120', $
		UVALUE='PTXT')
   WIDGET_CONTROL, point_base, MAP=0

   reg_base = WIDGET_BASE(xfontbase, /ROW)
   lbase = WIDGET_BASE(reg_base, /COLUMN)
   rbase = WIDGET_BASE(reg_base, /COLUMN)

   for i=0, n_elements(to_do)-1 do begin	;Make exclusive bases
	j = to_do(i)
	junk = widget_base(lbase, /ROW, /FRAME)
	junk2 = WIDGET_BASE(junk, /EXCLUSIVE)
	t_buttons(i) = $
		WIDGET_BUTTON(junk2, value= field_names(i), /NO_RELEASE, $
			UVALUE='TBUTTON')
	t_text(i) = WIDGET_TEXT(junk, value = '*', ysize=1, xsize=24)
	endfor
   ; Set all the buttons to the width of the widest
   junk = max(strlen(field_names), junk2)
   geo = WIDGET_INFO(t_buttons(junk2), /geometry)
   for i=0, n_elements(to_do)-1 do $
   	widget_control, scr_xsize=geo.scr_xsize, t_buttons(i)

   l_text = WIDGET_TEXT(lbase, /FRAME, xsize = 32)

   t_list = WIDGET_LIST(rbase, value = string(replicate(77b,24)), $
			UVALUE = 'T_LIST', ysize = 9)

   base = xfontbase
   s_list = WIDGET_LIST(base, value = string(replicate(77b,56)), $
			UVALUE = 'S_LIST', ysize = 8)

   junk  = WIDGET_BASE(base, /ROW, /FRAME)
   junk1 = WIDGET_LABEL(junk, VALUE='Current font:')
   view_text = WIDGET_TEXT(junk, value = string(replicate(77B, 64)), $
		XSIZE=64)

   junk = WIDGET_BASE(base, /ROW, /FRAME)
   junk1 = WIDGET_LABEL(junk, VALUE='Display Text:')
   s_text = WIDGET_TEXT(junk, value = display_string, $
		XSIZE=64, UVALUE = "STEXT", /EDIT)

   view_draw = WIDGET_DRAW(base, xsize = 400, ysize=120, RETAIN = 2)
   
   WIDGET_CONTROL, xfontbase, /REALIZE

   WIDGET_CONTROL, t_list, SET_VALUE=' '	;Remove beginning junk
   WIDGET_CONTROL, s_list, SET_VALUE=' '
   WIDGET_CONTROL, view_text, SET_VALUE=' '
   WIDGET_CONTROL, view_draw, GET_VALUE = view_window

   ; Register the widgets with the XManager.
 
   if pwin ge 0 then wdelete, pwin		;Clean up initialization
   XManager, 'xfont', xfontbase, $
                EVENT_HANDLER = 'xfont_event', $
		GROUP_LEADER = GROUP, /MODAL

   if selected_font lt 0 then return, '' else $
	return, s_string
END
; $Id: xinteranimate.pro,v 1.3 1993/10/18 19:46:19 dave Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

;+
; NAME:
;		XINTERANIMATE
;
; PURPOSE:
;	Display an animated sequence of images using X-windows Pixmaps.
;	The speed and direction of the display can be adjusted using 
;	the widget interface.
;
; CATEGORY:
;	Image display, widgets.
;
; CALLING SEQUENCE:
;	To initialize:
;		XINTERANIMATE, SET = [Sizex, Sizey, Nframes]
;
;	To load a single image:
;		XINTERANIMATE, IMAGE = Image, FRAME = Frame_Index
;
;	To load a single image that is already displayed in an existing window:
;		XINTERANIMATE, FRAME = Frame_index, $
;			WINDOW = [Window_Number [, X0, Y0, Sx, Sy]]
;	(This technique is much faster than reading back from the window.)
;
;	To display the animation after all the images have been loaded:
;		XINTERANIMATE [, Rate] 
;
;	To close and deallocate the pixmap/buffer (which also takes place
;	automatically when the user presses the "Done With Animation"
;	button or closes the window with the window manager):
;		XINTERANIMATE, /CLOSE
;
; OPTIONAL INPUTS:
;	Rate:	A value between 0 and 100 that represents the speed of the 
;		animation as a percentage of the maximum display rate.
;		The fastest animation is with a value of 100 and the slowest
;		is with a value of 0.  The default animation rate is 100.  
;		The animation must be initialized using the SET
;		keyword before calling XINTERANIMATE with a rate value.
;
; KEYWORD PARAMETERS:
;	CLOSE:	Set this keyword to delete the offscreen pixwins and Widget, 
;		freeing storage.
;
;	CYCLE: If set, cycle.  Normally, frames are displayed going either
;		forward or backwards.  If CYCLE is set, reverse direction
;		after the last frame in either direction is displayed.
;		Provide this keyword with the SET keyword.
;
;	FRAME:	The frame number when loading frames.  This keyword only has
;		an effect when used in conjunction with the SET keyword.
;		FRAME must be set to a number in the range 0 to Nframes-1.
;
;	GROUP:	The widget ID of the widget that calls XINTERANIMATE.  When 
;		this ID is specified, the death of the caller results in the 
;		death of XINTERANIMATE.
;
;	IMAGE:	A single image to be loaded at the animation position given 
;		by FRAME.  The keyword parameter FRAME must also be specified.
;
;	KEEP_PIXMAPS: If TRUE, XINTERANIMATE doesn't destroy the animation
;		pixmaps when it is killed. Calling it again without
;		going through the SET and LOAD steps will cause the same
;		animation to play without the overhead of creating
;		the pixmaps.
;	ORDER:	Set this keyword to display images from the top down instead
;		of the default bottom up.  This keyword is only used when 
;		loading images.
;
;     SHOWLOAD:	Set this keyword (in conjunction with the SET keyword) to 
;		display each frame and update the frame slider as frames are 
;		loaded.
;
;	SET:	This keyword initializes XINTERANIMATE.  SET should be equated
;		to a 3-element integer vector containing the following 
;		parameters:
;		  Sizex, Sizey:	The width and height of the images to be 
;				displayed, in pixels.
;
;		  Nframes:	The number of frames in the animated sequence 
;				(since XINTERANIMATE is an animation routine, 
;				Nframes must be at least 2 frames).
;
;	TITLE:	A string to be used as the title of the widget.  If this 
;		keyword is not specified, the title is set to "XInterAnimate" 
;		This keyword has an effect only when used in conjunction with
;		the SET keyword).
;
;	TRACK: If set, the frame slider tracks the current frame.  Default
;		is not to track.  Provide this keyword with the SET keyword.
;
;	WINDOW:	When this keyword is specified, an image is copied from an 
;		existing window to the animation pixmap.  When using X 
;		windows, this technique is much faster than reading
;		from the display and then calling XINTERANIMATE with a 2D 
;		array.
;
;		The value of this parameter is either an IDL window
;		number (in which case the entire window is copied),
;		or a vector containing the window index and the rectangular 
;		bounds of the area to be copied, for example:
;		WINDOW = [Window_Number, X0, Y0, Sx, Sy]
;
;      XOFFSET:	The horizontal offset, in pixels from the left of the frame, 
;		of the image in the destination window.
;
;      YOFFSET:	The vertical offset, in pixels from the bottom of the frame,
;		of the image in the destination window.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	XINTERANIMATE_COM: a private common block.
;
; SIDE EFFECTS:
;	A pixmap and widget are created.
;
; RESTRICTIONS:
;	Only a single copy of XINTERANIMATE can run at a time.
;
; PROCEDURE:
;	When initialized, this procedure creates an approximately square
;	pixmap or memory buffer, large enough to contain Nframes of
;	the requested size.  Once the images are loaded, using the 
;	IMAGE and FRAME keywords, they are displayed by copying the images 
;	from the pixmap or buffer to the visible draw widget.
;
; EXAMPLE:
;	Enter the following commands to open the file ABNORM.DAT (a series
;	of images of a human heart) and animate the images it contains using
;	XINTERANIMATE.  For a more detailed example of using XINTERANIMATE, 
;	see the example in the "Using IDL Widgets" chapter of "IDL Basics".
;	Read the images into the variable H by entering:
;
;		OPENR, 1, FILEPATH('abnorm.dat', SUBDIR = 'images')
;		H = BYTARR(64, 64, 16)
;		READU, 1, H
;		CLOSE, 1
;		H = REBIN(H, 128, 128, 16)
;
;	Initailize XINTERANIMATE with the command:
;
;		XINTERANIMATE, SET=[128, 128, 16], /SHOWLOAD
;		
;	Load the images into XINTERANIMATE and play the animation by entering:
;
;		FOR I=0,15 DO XINTERANIMATE, FRAME = I, IMAGE = H(*,*,I)
;		XINTERANIMATE
;
; MODIFICATION HISTORY:
;	DMS, April, 1990.
;	SMR, December, 1990.  	Modified the XANIMATE code to work
;				interactively with widgets.
;
;	DMS, March, 1991.	Modified the routine to use individual pixmaps
;				for each frame of the animation.  Also added
;				the ability to read in from current IDL 
;				windows directly into offscreen bitmap.
;
;	SMR, March, 1991.	Modified to use new XMANAGER keyword CLEANUP
;				to clean up the offscreen pixmaps when dying.
;
;	SMR, Jan, 1992.		Modified the /CLOSE portion to check for a 
;				valid widget before using WIDGET_CONTROL 
;				and /DESTROY.
;
;	AB, June 1992		Rewrite using the new CW_ANIMATE compound
;				widget. Added the KEEP_PIXMAPS keyword.
;-

PRO xintanim_kill_pix
; If there are pixmaps currently open, free them.

  COMMON XInterAnimate_com, topbase, animatebase, pwin

  i = size(pwin)
  if (i(0) ne 0) then begin		; Not scalar, so contains valid IDs
    i = i(i(0) + 2)			; # of elements in pwin
    FOR j=0, i-1 DO IF pwin(j) GE 0 THEN WDELETE, pwin(j) ;Delete the windows
  pwin = -1		;Show nothing there by setting to scalar value
  endif

end








PRO xintanim_event, ev
; The only event that can be seen by this application is the "DONE"
; event from the CW_ANIMATION cluster.

  widget_control, /destroy, ev.top
END







PRO XInterAnimate, RATE, SET = SET, IMAGE = IMAGE, FRAME = FRAME, $
	ORDER = ORDER, CLOSE = CLOSE, TITLE = TITLE, $
	SHOWLOAD = SHOWLOAD, GROUP = GROUP, WINDOW = WINDOW, $
	XOFFSET = XOFFSET, YOFFSET = YOFFSET, KEEP_PIXMAPS=KEEP_PIXMAPS, $
	CYCLE = cycle, TRACK = track

COMMON XInterAnimate_com, topbase, animatebase, pwin


;--------------------- CLOSE Portion of Xinteranimate -------------------------

  IF KEYWORD_SET(CLOSE) THEN BEGIN
    if (widget_info(topbase, /valid)) THEN $
	  WIDGET_CONTROL, topbase, /DESTROY
    xintanim_kill_pix
    RETURN
  ENDIF

  ;Don't allow two copies of xinternimate to run at once
  IF xregistered("XInterAnimate") THEN begin
    XANNOUNCE, 'XINTERANIMATE', 'Only one animation at a time is allowed.'
    return
  endif



;----------------------  SET Portion of Xinteranimate ------------------------

  IF KEYWORD_SET(SET) THEN BEGIN

    ;This is the first call to xinteranimate.  Here the pixmap is
    ;	created and the widgets are initialized.

    xintanim_kill_pix				;If old pixmap exists, delete 

    IF NOT(KEYWORD_SET(TITLE)) THEN TITLE = "XInterAnimate"
    topbase = WIDGET_BASE(TITLE = TITLE)
    animatebase = CW_ANIMATE(topbase, set(0), set(1), set(2), $
		TRACK = KEYWORD_SET(track), CYCLE=KEYWORD_SET(cycle))

    ; If the SHOWLOAD keyword is set, realize things now so the load is seen
    IF KEYWORD_SET(SHOWLOAD) THEN $
      WIDGET_CONTROL, topbase, /REALIZE, /HOURGLASS

    RETURN
  ENDIF

;-----------------  IMAGE Loading Portion of Xinteranimate --------------------

  nwindow = N_ELEMENTS(WINDOW)
  nimage = N_ELEMENTS(image)
  if (nwindow gt 0) or (nimage gt 0) then begin
    old_window = !D.WINDOW				;Save old window

    ; Make sure a widget has been created before trying to load it.
    if (not widget_info(topbase, /valid)) then MESSAGE, 'Not initialized'

    IF (N_ELEMENTS(YOFFSET) EQ 0) THEN YOFFSET = 0
    IF (N_ELEMENTS(XOFFSET) EQ 0) THEN XOFFSET = 0

    if (N_ELEMENTS(WINDOW) gt 0) then begin
      CW_ANIMATE_LOAD, animatebase, frame=frame, window=window, $
		XOFFSET = XOFFSET, YOFFSET = YOFFSET
    endif else begin
      IF (N_ELEMENTS(ORDER) EQ 0) THEN ORDER = 0
      CW_ANIMATE_LOAD, animatebase, frame=frame, image=image, $
		XOFFSET = XOFFSET, YOFFSET = YOFFSET, ORDER = ORDER
    endelse
    IF (old_window GE 0) THEN WSET, old_window
    RETURN
  ENDIF

;---------------  Register and Run Portion of Xinteranimate -------------------

  ; If the base is not valid, it means that we have skipped
  ; calling this routine with the SET keyword. In this case, we can restart
  ; the last animation if the KEEP_PIXMAP keyword was used to preserve them
  ; in the previous call.

  if (not widget_info(topbase, /valid)) then begin
    s = size(pwin)
    if (s(0) eq 0) then message, 'No image frames loaded'
    ; Scan the pixmaps to figure out the image size
    n = s(s(0) + 2)
    xs = 0
    for i = 0, n-1 do begin
      if pwin(i) ne -1 then begin
        old_window = !D.WINDOW
	wset, pwin(i)
        xs = !d.x_vsize
        ys = !d.y_vsize
	IF (old_window GE 0) THEN WSET, old_window
        goto, found		; Like a "break" in C
      endif
    endfor
  found:
    if (xs ne 0) then begin
      IF NOT(KEYWORD_SET(TITLE)) THEN TITLE = 'XInterAnimate'
      topbase = WIDGET_BASE(TITLE = TITLE)
      animatebase = CW_ANIMATE(topbase, xs, ys, 0, PIXMAPS=pwin)
      ; The pixmaps are no longer our responsibility. They will get destroyed
      ; by CW_ANIMATE as usual unless this invocation of XINTERANIMATE
      ; specifies the KEEP_PIXMAP keyword. 
      pwin = 0			; Indicate that we aren't saving them anymore.
    endif else message, 'No image frames loaded'
  endif


  ; At this point, the application must be realized if it isn't already
  if (not widget_info(topbase, /realized)) then $
    WIDGET_CONTROL, topbase, /REALIZE

  ; Save the pixmaps for later restart
  if keyword_set(keep_pixmaps) then CW_ANIMATE_GETP, animatebase, pwin

  if N_ELEMENTS(RATE) EQ 0 THEN RATE = 100
  cw_animate_run, animatebase, rate

  Xmanager, "XInterAnimate", topbase, EVENT_HANDLER = "xintanim_event", $
	  GROUP_LEADER = GROUP
END
; $Id: xloadct.pro,v 1.8 1995/06/22 17:54:48 mattr Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
PRO XLCT_PSAVE			;Save/Restore our plotting state.
;  Swaps our state with the current state each time its called.

COMMON xloadct_com, r0, g0, b0, tfun, state, filename, cps, psave, pnt, $
	top, bot, silent, chop, lock, g_lbl, vbot, vtop, g_slider, $
	gamma, color, use_values, ncolors, cbot

tmp = { xlct_psave, win: !d.window, x: !x.s, y: !y.s }

if psave.win ne -1 then wset, psave.win
!x.s = psave.x
!y.s = psave.y
psave = tmp
end

PRO xlct_draw_cps, i, c
COMMON colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
COMMON xloadct_com, r0, g0, b0, tfun, state, filename, cps, psave, pnt, $
	top, bot, silent, chop, lock, g_lbl, vbot, vtop, g_slider, $
	gamma, color, use_values, ncolors, cbot

tc = color
if n_elements(c) gt 0 then begin
	tc = c
	if c ne 0 then color = c
	endif

if i(0) eq -1 then j = indgen(n_elements(cps)) else j = i

plots, cps(j), tfun(j), /noclip, color = tc
plots, cps(j), tfun(j), /noclip, psym=6, color = tc
end

PRO xlct_transfer
COMMON colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
COMMON xloadct_com, r0, g0, b0, tfun, state, filename, cps, psave, pnt, $
	top, bot, silent, chop, lock, g_lbl, vbot, vtop, g_slider, $
	gamma, color, use_values, ncolors, cbot

l = lonarr(ncolors)		;Subscripts
m = n_elements(cps)
for i=0, m-2 do begin
	n = cps(i+1)-cps(i)		;Interval
	b = (tfun(i+1)-tfun(i))/float(n)
	l(cps(i)) = findgen(n) * b + (tfun(i) + cbot)
	endfor
l(ncolors-1) = tfun(m-1)		;Last point
if use_values then begin
  r_curr(cbot) = (r = l(r_orig))
  g_curr(cbot) = (g = l(g_orig))
  b_curr(cbot) = (b = l(b_orig))
endif else begin
  r_curr(cbot) = (r = r_orig(l))
  g_curr(cbot) = (g = g_orig(l))
  b_curr(cbot) = (b = b_orig(l))
endelse

tvlct, r,g,b, cbot
end

PRO xloadct_event, event
COMMON colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
COMMON xloadct_com, r0, g0, b0, tfun, state, filename, cps, psave, pnt, $
	top, bot, silent, chop, lock, g_lbl, vbot, vtop, g_slider, $
	gamma, color, use_values, ncolors, cbot


IF event.id eq state.draw THEN BEGIN	;** PROCESS DRAWABLE EVENTS **
	if event.press ne 0 then begin		;Pressed button?
		dmin = 1.0e8		;Find closest control pnt
		xlct_psave		;Remove old
		p = convert_coord(event.x, event.y, /TO_DATA, /DEVICE)
		xlct_psave		;Restore old
		x = fix(p(0))
		y = fix(p(1))
		for i=0, n_elements(cps)-1 do begin
			d = (p(0)-cps(i))^2 + (p(1)-tfun(i))^2  ; dist ^ 2
			if d lt dmin then begin
				dmin = d
				pnt = i
				endif
			endfor
		return
		endif
	if event.release ne 0 then begin	;Released button?
		pnt = -1
		return
		endif
	if pnt lt 0 then return			;Don't care here...

	xlct_psave				;Remove old
	p = convert_coord(event.x, event.y, /TO_DATA, /DEVICE)	;Coord of mouse
	n = ncolors -1		;Into range....
	m = n_elements(cps)-1
	x = fix(p(0)) > 0 < n
	if pnt eq 0 then x = 0 else $		;1st & last are fixed
	if pnt eq m then x = n else $
	x = x > (cps(pnt-1) + 1) < (cps(pnt+1)-1)  ;Others must be between

	if pnt eq 0 then xlct_draw_cps, [0, 1],0 $  ;Erase old segment
	else if pnt eq m then xlct_draw_cps, [m-1, m],0 $
	else xlct_draw_cps, [pnt-1, pnt, pnt+1],0
	cps(pnt) = x
	tfun(pnt) = fix(p(1)) > 0 < n
	xlct_transfer

	b = r_curr * .3 + g_curr * .586 + b_curr * .114 ;Ntsc colors
	c = max(abs(b-b(cbot)), j)  ; *** J is color index furthest from 0

	if pnt eq 0 then xlct_draw_cps, [0, 1], j $
	else if pnt eq m then xlct_draw_cps, [m-1, m], j $
	else xlct_draw_cps, [pnt-1, pnt, pnt+1], j

	xlct_psave		;Remove old
	return
	ENDIF

WIDGET_CONTROL, event.id, GET_UVALUE = eventval

abstop = NCOLORS -1

if event.id eq state.name_list then begin
	LOADCT, silent=silent, event.index, FILE=filename, NCOLORS=ncolors, $
		BOTTOM=cbot
	goto, set_gamma
	ENDIF

CASE eventval OF
    "TOP":    BEGIN
		WIDGET_CONTROL, top, GET_VALUE = vtop
                if lock ne 0 then begin
                        vbot = (vtop - lock) > 0 < 100
                        widget_control, bot, SET_VALUE=vbot
                        endif
                GOTO, set_gamma
              END

    "BOTTOM": BEGIN
		WIDGET_CONTROL, bot, GET_value = vbot
                if lock ne 0 then begin
                        vtop = (vbot + lock) > 0 < 100
                        widget_control, top, SET_VALUE=vtop
                        ENDIF
   set_gamma:
	if use_values then nc = 256 else nc = ncolors
	s = (nc-1)/100.
	x0 = vbot * s
	x1 = vtop * s
	if x0 ne x1 then s = (nc-1.0)/(x1 - x0) else s = 1.0
	int = -s * x0
	if gamma eq 1.0 then s = round(findgen(nc) * s + int > 0.0) $
	else s = ((findgen(nc) * (s/nc) + (int/nc) > 0.0) ^ gamma) * nc
	if chop ne 0 then begin
	    too_high = where(s ge nc, n)
	    if n gt 0 then s(too_high) = 0L
	    endif
	if use_values then begin
	    s = s < 255L
	    l = lindgen(ncolors) + cbot
	    r_curr(cbot) = (r = s(r_orig(l)))
	    g_curr(cbot) = (g = s(g_orig(l)))
	    b_curr(cbot) = (b = s(b_orig(l)))
	endif else begin
	    s = s + cbot
	    r_curr(cbot) = (r = r_orig(s))
	    g_curr(cbot) = (g = g_orig(s))
	    b_curr(cbot) = (b = b_orig(s))
 	endelse
	tvlct, r,g,b, cbot
	ENDCASE

    "GAMMA": BEGIN
                WIDGET_CONTROL, g_slider, GET_VALUE = gamma
                gamma = 10^((gamma/50.) - 1)
                WIDGET_CONTROL, g_lbl, SET_VALUE = $
			STRING(gamma, format='(f6.3)')
		goto, set_gamma
             ENDCASE

    "GANG" : IF event.value eq 0 then lock = 0 else lock = vtop - vbot

    "CHOP" : BEGIN
        chop = event.value
        goto, set_gamma         ;And redraw
        ENDCASE

    "VALUES": BEGIN
	use_values = event.value
	ENDCASE

    "HELP" : XDisplayFile, FILEPATH("xloadct.txt", subdir=['help', 'widget']), $
                TITLE = "Xloadct Help", $
                GROUP = event.top, $
                WIDTH = 55, $
                HEIGHT = 16

    "RESTORE" : BEGIN                   ;Restore the original tables
        r_curr = (r_orig = r0)
        g_curr = (g_orig = g0)
        b_curr = (b_orig = b0)
	tvlct, r_curr, g_curr, b_curr
        ENDCASE

    "OVERWRITE" : BEGIN                 ;overwrite original tables
	r0 = (r_orig = r_curr)
	g0 = (g_orig = g_curr)
	b0 = (b_orig = b_curr)
    reset_all:
        WIDGET_CONTROL, top, SET_VALUE = 100
        WIDGET_CONTROL, bot, SET_VALUE = 0
        WIDGET_CONTROL, g_slider, SET_VALUE = 50
	vbot = 0
	vtop = 100
	gamma = 1.0
	GOTO, set_gamma
	ENDCASE

    "REVERSE" : BEGIN                   ;Reverse the table
	l = lindgen(ncolors) + cbot
        r_orig(cbot) = reverse(r_orig(l))
        g_orig(cbot) = reverse(g_orig(l))
        b_orig(cbot) = reverse(b_orig(l))
        goto, set_gamma                 ;And redraw
        ENDCASE

    "DONE": BEGIN
        WIDGET_CONTROL, event.top, /DESTROY
        r0 = 0 & g0 = 0 & b0 = 0  ;Free common
        ENDCASE

    "NEWBASE": BEGIN
	mode = event.value
	b = ([0, 0, 1])(mode)		;Top base to map: 0 or 1.
	for i=0,1 do WIDGET_CONTROL, state.bases(i), MAP=i eq b
	if b eq 0 then begin		;table or option mode?
	   b = ([2,3,0])(mode)		;bottom base to map (mode eq 0 or 1)
	   for i=2,3 do WIDGET_CONTROL, state.bases(i), MAP=i eq b
	   endif
	if mode eq 2 then begin
	    reset_all = 1
	    xlct_psave			;Save old state
	    plot, [0, ncolors-1], [0, ncolors-1], xstyle=3, $
		ystyle=3, xmargin = [1,1], ymargin=[1,1], ticklen = -0.03, $
		/NODATA, $
		xtickname = replicate(' ', 10), ytickname = replicate(' ', 10)
	    goto, interp_cps
	    endif
	
	ENDCASE

    "TFUNR": BEGIN
     reset_tfun:
	xlct_psave
	xlct_draw_cps, -1, 0	;Erase all
	tfun = cps		;Linear ramp
	goto, interp_cps
	ENDCASE

    "REMCP": BEGIN
	n = n_elements(cps)
	if n gt 2 then begin
	  xlct_psave
	  xlct_draw_cps, -1, 0
	  igap = 0
	  for i=0, n-2 do $
		if (cps(i+1) - cps(i)) lt (cps(igap+1)-cps(igap)) then $
			igap = i
	  keep = where(indgen(n) ne (igap > 1))
	  cps = cps(keep)
	  tfun = tfun(keep)
	  goto, interp_cps
	  ENDIF
	ENDCASE
    "ADDCP": BEGIN
	xlct_psave
	xlct_draw_cps, -1, 0
	igap = 0			;Find largest gap
	for i=0, n_elements(cps)-2 do $
		if (cps(i+1) - cps(i)) gt (cps(igap+1)-cps(igap)) then $
			igap = i
	cps = [ cps(0:igap), (cps(igap)+cps(igap+1))/2, cps(igap+1:*)]
	tfun = [ tfun(0:igap), (tfun(igap)+tfun(igap+1))/2, tfun(igap+1:*)]
      interp_cps:  xlct_draw_cps, -1  ;Redraw new
	xlct_transfer
	xlct_psave		;Restore old points
	if n_elements(reset_all) then goto, reset_all
	ENDCASE
ENDCASE

END


;+
; NAME:
;       XLOADCT
; PURPOSE:
;       A graphical interface to the LOADCT user library procedure.
;       XLOADCT displays the current color map and provides
;       an array of buttons, one per availible predefined color
;       table. Using the mouse to press these buttons causes
;       the corresponding color map to be loaded.
; CATEGORY:
;       Widgets
; CALLING SEQUENCE:
;       XLOADCT
; INPUTS:
;       None.
; KEYWORDS:
;	FILE:	If this keyword is set, the file by the given name is used
;		instead of the file colors1.tbl in the IDL directory.  This
;		allows multiple IDL users to have their own color table file.
;       GROUP = The widget ID of the widget that calls XLoadct.  When 
;               this ID is specified, a death of the caller results in a 
;               death of XLoadct
;	NCOLORS = number of colors to use.  Use color indices from BOTTOM
;		to the smaller of !D.TABLE_SIZE-1 and NCOLORS-1.
;		Default = !D.TABLE_SIZE = all available colors.
;	BOTTOM = first color index to use. Use color indices from BOTTOM to
;		BOTTOM+NCOLORS-1.  Default = 0.
;       PICK_ONE - Normally, XLOADCT remains running until the user
;               presses the "QUIT" button. If PICK_ONE is present and 
;               non-zero, the "QUIT" button is not displayed, and
;               XLOADCT quits after a single selection.
;       SILENT - Normally, no informational message is printed when
;               a color map is loaded. If this keyword is present and
;               zero, this message is printed.
;	USE_CURRENT: If set, use the current color tables, regardless of
;		the contents of the COMMON block COLORS.
; OUTPUTS:
;       None.
; COMMON BLOCKS:
;       None.
; SIDE EFFECTS:
;       One of the predefined color maps may be loaded.
; RESTRICTIONS:
;       This routine uses the LOADCT user library procedure to
;       do the actual work.
; MODIFICATION HISTORY:
;       24, August, 1990, Written by AB, RSI.
;       March 1, 1992  Mark Rivers added Reverse Table to options menu.
;	7/92, DMS, Added new color tables (allows more than 16).
;	9/92, ACY, Add FILE keyword.
;-

PRO XLoadct, PICK_ONE=PICK_ONE, SILENT=silent_f, GROUP = GROUP, FILE=file, $
	USE_CURRENT = use_current, NCOLORS = nc, BOTTOM=bottom

COMMON colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
COMMON xloadct_com, r0, g0, b0, tfun, state, filename, cps, psave, pnt, $
	top, bot, silent, chop, lock, g_lbl, vbot, vtop, g_slider, $
	gamma, color, use_values, ncolors, cbot


IF(XRegistered("xloadct") NE 0) THEN return

values_button = lonarr(2)

IF KEYWORD_SET(SILENT_f) THEN silent = SILENT_F ELSE silent = 1

IF N_ELEMENTS(file) GT 0 THEN filename = file

siz = 256			;Basic width of tool
names = 0
LOADCT, GET_NAMES = names, FILE = file	;Get table names
w_height = 50                   ;Height of ramp
cur_win = !D.WINDOW
lock = 0
chop = 0
vbot = 0
vtop = 100
gamma = 1.0
use_values=0


; Bases:
;  0 = slider base  (stretch bottom, stretch top, gamma)
;  1 = transfer function drawable + buttons
;  2 = color table list
;  3 = options base  (sliders. top, stretch)

state = { bases: lonarr(4), draw: 0L, name_list: 0L }

base = WIDGET_BASE(TITLE="XLoadct", /COLUMN)


show = WIDGET_DRAW(base, YSIZE=w_height, XSIZE=siz, /FRAME, RETAIN = 2)
IF(NOT(KEYWORD_SET(pick_one))) THEN BEGIN
  junk = WIDGET_BASE(base, /ROW)
  done = WIDGET_BUTTON(junk, VALUE=' Done ', UVALUE = "DONE")
  junk1 = WIDGET_BUTTON(junk, VALUE=' Help ', UVALUE = "HELP")

  junk = CW_BGROUP(base, /ROW, /EXCLUSIVE, /NO_REL, $
	['Tables', 'Options', 'Function'], $
	UVALUE='NEWBASE', SET_VALUE=0)

  junk = widget_base(base)
  for i=0,1 do state.bases(i) = WIDGET_BASE(junk, /COLUMN)

  sbase=WIDGET_BASE(state.bases(0), /COLUMN)
  bot = WIDGET_SLIDER(sbase, TITLE = "Stretch Bottom", MINIMUM = 0, $
        MAXIMUM = 100, VALUE = 0, /DRAG, UVALUE = "BOTTOM", xsize=siz)
  top = WIDGET_SLIDER(sbase, TITLE = "Stretch Top", MINIMUM = 0, $
        MAXIMUM = 100, VALUE = 100, /DRAG, UVALUE = "TOP", xsize=siz)
  g_lbl = WIDGET_LABEL(sbase, VALUE = STRING(1.0))
  g_slider = WIDGET_slider(sbase, TITLE = "Gamma Correction", $
        MINIMUM = 0, MAXIMUM = 100, VALUE = 50, UVALUE = "GAMMA", $
        /SUPPRESS_VALUE, /DRAG, xsize=siz)
ENDIF ELSE BEGIN
  done = 0
ENDELSE

junk = WIDGET_BASE(sbase)
for i=2,3 do state.bases(i) = WIDGET_BASE(junk, /COLUMN)
DEVICE, GET_SCREEN = junk
if junk(1) le 768 then junk = 8 else junk = 16
state.name_list = WIDGET_LIST(state.bases(2), VALUE = names, ysize = junk)


;		Drawable for transfer function

junk = WIDGET_BASE(state.bases(1), /COLUMN, /FRAME)
junk1 = WIDGET_BUTTON(junk, VALUE = 'Reset Transfer Function', $
	UVALUE='TFUNR')
junk1 = WIDGET_BUTTON(junk, VALUE='Add Control Point', UVALUE='ADDCP')
junk1 = WIDGET_BUTTON(junk, VALUE='Remove Control Point', UVALUE='REMCP')

state.draw = WIDGET_DRAW(state.bases(1), xsize = siz, ysize = siz, $
	/BUTTON_EVENTS, /MOTION_EVENTS)


 opt_id = state.bases(3)
 junk = CW_BGROUP(opt_id, /ROW, LABEL_LEFT='Sliders:', /EXCLUSIVE, /NO_REL, $
		['Independent', 'Gang'], UVALUE='GANG', SET_VALUE=lock)
 junk = CW_BGROUP(opt_id, /ROW, LABEL_LEFT = 'Top:',  /EXCLUSIVE, /NO_REL, $
		['Clip', 'Chop'], SET_VALUE=chop, UVALUE='CHOP')
 junk = CW_BGROUP(opt_id, /ROW, LABEL_LEFT='Stretch:',  /EXCLUSIVE, /NO_REL, $
		['Indices', 'Intensity'], UVALUE='VALUES', $
		SET_VALUE=use_values)
 junk = WIDGET_BUTTON(opt_id, VALUE='Reverse Table', $
                UVALUE="REVERSE", /NO_REL)
 junk = WIDGET_BUTTON(opt_id, VALUE='REPLACE Original Table', $
		UVALUE = "OVERWRITE", /NO_REL)
 junk = WIDGET_BUTTON(opt_id, VALUE='RESTORE Original Table', $
                UVALUE="RESTORE", /NO_REL)

WIDGET_CONTROL, state.bases(1), MAP=0	;Tfun is not visible
WIDGET_CONTROL, state.bases(3), MAP=0	;options are not visible

WIDGET_CONTROL, base, /REALIZE
WIDGET_CONTROL, state.draw, GET_VALUE=tmp

if n_elements(bottom) gt 0 then cbot = bottom else cbot = 0
ncolors = !d.table_size - cbot
if n_elements(nc) gt 0 then ncolors = ncolors < nc
if ncolors le 0 then message,'Number of colors is 0 or negative'

psave = { xlct_psave, win: tmp, x: !x.s, y: !y.s }   ;Our initial state
wset, tmp			;Initial graph
xlct_psave		;Save original scaling & window
plot, [0, ncolors-1], [0, ncolors-1], xstyle=3, ystyle=3, $
	xmargin = [1,1], ymargin=[1,1], ticklen = -0.03, /NODATA
xlct_psave		;Restore original scaling & window

			;If no common, use current colors
IF KEYWORD_SET(use_current) or N_ELEMENTS(r_orig) LE 0 THEN BEGIN
	TVLCT, r_orig, g_orig, b_orig, /GET
	r_curr = r_orig
	b_curr = b_orig
	g_curr = g_orig
	ENDIF

r0 = r_curr             ;Save original colors
g0 = g_curr
b0 = b_curr
color = ncolors + cbot -1
cps = [0, ncolors-1]
tfun = cps
pnt = -1

WIDGET_CONTROL, show, GET_VALUE=show_win
WSET, show_win
TVSCL, BYTSCL(INDGEN(siz) # REPLICATE(1, w_height), top = ncolors-1)
IF(cur_win NE -1) THEN WSET, cur_win

XManager, "xloadct", base, GROUP_LEADER = GROUP

END
; $Id: xmanager.pro,v 1.8 1995/04/27 23:25:33 davee Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

PRO XUnregister, corpse

	;This procedure removes a dead widget from the Xmanagers common
	;block.  The space taken by the dead widget in the id and name
	;lists is just zeroed.

COMMON MANAGED, ids, names, $
		nummanaged, inuseflag, $
		backroutines, backids, backnumber, nbacks, validbacks, $
		blocksize, $
		cleanups, $
		outermodal

janitor = 0						;check to see if the
victim = WHERE(ids EQ corpse, janitor)			;dying widget has a
IF(janitor NE 0) THEN $					;cleanup routine and
  IF(STRLEN(cleanups(victim(0))) NE 0) THEN $		;call it if so.
    CALL_PROCEDURE, cleanups(victim(0)), corpse

deadindex = WHERE(ids EQ corpse, found)			;find dead index
IF(found NE 0) THEN BEGIN
  IF(KEYWORD_SET(backroutines)) THEN BEGIN		;find living background
    backindex = WHERE(backids EQ corpse, backfound)
    IF(backfound NE 0) THEN BEGIN			;if background tasks
      backroutines(backindex) = ''			;are registered for
      backids(backindex) = 0L				;the corpse, remmove
      backnumber = 0					;them
      nbacks = nbacks - backfound
    ENDIF
    IF(nbacks NE 0) THEN $				;keep a list of which
      validbacks = WHERE(backids NE 0) $		;background slots are
    ELSE validbacks = -1				;valid in the id list
  ENDIF
  ids(deadindex) = 0L					;zero out the dead
  names(deadindex) = ''					;widgets list entries
  cleanups(deadindex) = ''
  nummanaged = nummanaged - found
ENDIF
END		;end of XUnregister procedure

;-----------------------------------------------------------------------------

PRO XManager, NAME, ID, $
		BACKGROUND = BACKGROUND, $
		CLEANUP = CLEANUP, $
		EVENT_HANDLER = EVENT_HANDLER, $
		GROUP_LEADER = GROUP_LEADER, $
		JUST_REG = JUST_REG, $
		MODAL = MODAL
;+
; NAME:
;	XMANAGER
;
; PURPOSE:
;	Provide main event loop and management for widgets created using IDL.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XMANAGER [, Name, ID]
;
; OPTIONAL INPUTS:
;	NAME:	A string that contains the name of the routine that creates 
;		the widget.
;  
;	ID:	The widget ID of the base of the new widget.
;
; KEYWORD PARAMETERS:
;   BACKGROUND:
;      -------------------------------------------------------------------
;      | PLEASE NOTE: This keyword is OBSOLETE. It's functionality is    |
;      | provided by the TIMER keyword to the WIDGET_CONTROL procedure.  |
;      -------------------------------------------------------------------
;		A string that contains the name of a background task procedure
;		to be called when the event loop is idle.  The background task
;		procedure has only one parameter.  The parameter is the widget
;		ID of the top-level base widget associated with the background
;		task.  The background task should be very short and quick in 
;		execution.  Long, complicated routines will hinder the 
;		smoothness of event processing.  See the "Simple Widget
;		Examples" (available from the XDEMO examples menu or by
;		entering WEXMASTER at the IDL prompt) for an example of a 
;		background task widget.
;
;      CLEANUP:	This keyword contains a string that is the name of the
;		routine called when the widget dies.  If not specified,
;		no routine is called.  The cleanup routine must accept one 
;		parameter which is the widget id of the dying widget.
;
;EVENT_HANDLER:	The name of the routine that is to be called when a
;		widget event occurs in the widget being registered.  If this 
;		keyword is not supplied, the Xmanager will try to process the
;		event by calling the routine name with "_event" appended.  See
;		below for a more detailed explanation.
;
; GROUP_LEADER:	The widget id of the group leader for the
;		widget being processed.  When the leader dies either by the 
;		users actions or some other routine, all widgets that have that
;		leader will also die.
;
;		For example, a widget that views a help file for a demo 
;		widget would have that demo widget as it's leader.  When
;		the help widget is registered, it sets the keyword 
;		GROUP_LEADER to the widget id of the demo widget. If 
;		the demo widget is destroyed, the help widget led by 
;		the it would be killed by the XMANAGER.
;
;     JUST_REG:	This keyword tells the manager to just register the widget
;		but not to start doing the event processing.  This is useful
;		when you want to register a group of related top level widgets
;		before beginning processing.
;
;	 MODAL:	When this keyword is set, the widget that is being registered
;		traps all events and desensitizes all the other widgets.  It
;		is useful when input from the user is necessary to continue.
;		Once the modal widget dies, the others are resensitized and the
;		normal event processing is restored.
;
; OUTPUTS:
;	No explicit outputs.
;
; COMMON BLOCKS:
;	MANAGED:  Common block used for widget maintenance.  This common block
;		is internal and should not be referenced outside the IDL
;		supplied routines.  It is subject to change without notice.
;	XMAN_BCK_OBSOLETE: Used to keep track of BACKGROUND keyword message.
;	
;
; SIDE EFFECTS:
;	XMANAGER takes control of event processing and locks out the IDL 
;	prompt until all widgets have been destroyed.
;
; RESTRICTIONS:
;	Widgets being registered with the Xmanager must provide at least two 
;	routines.  The first routine creates the widget and registers it with
;	the manager and the second routine processes the events that occur 
;	within that widget.  Optionally, a third routine can is used for the
;	processing of background tasks while awaiting input.  An example 
;	widget is suplied below that uses only two routines.  For more 
;	information on using the background tasks, see the XEXAMPLE routine
;	that is found in this same library.  It demonstrates background 
;	routines.  Also, the "Simple Widget Examples", that can be viewed by
;	entering WEXMASTER at the IDL prompt, demonstrate many aspects of
;	widget programming. 
;
;   !!!!! WARNING !!!!!!!!! WARNING !!!!!!!!! WARNING !!!!!!!!! WARNING !!!!!
;
;	Although this is a library routine, it may change in the future in
;	its internal implementation.  For future upgradability, it is best
;	not to modify or even worry about what this routine does internally.
;
; EXAMPLE USE:
;	To create a widget named Example that is just a base widget with a done
;	button using the XMANAGER you would do the following:
;
;
;	;------ first - the event handler routine ------;
;
;     PRO example_event, ev			;this is the routine that 
;						;deals with the events in the 
;						;example widget.
;	
;	WIDGET_CONTROL, ev.id, GET_UVALUE = uv	;the uservalue is retrieved 
;						;from the widget where the 
;						;event occured
;
;	if(uv eq 'DONE') then $			;if the event occured in the
;	  WIDGET_CONTROL, ev.top, /DESTROY	;done button then kill the 
;     END					;widget example
;
;
;	;------ second - the main routine ------;
;
;     PRO example				;this is the main routine
;						;that builds the widget and
;						;registers it with the Xmanager
;	
;	base = WIDGET_BASE(TITLE = 'Example')	;first the base is created
;	
;	done = WIDGET_BUTTON(base, $		;next the done button is 
;			     TITLE = 'DONE', $	;created and it's user value
;			     UVALUE = 'DONE')	;set to "DONE"
;
;	WIDGET_CONTROL, base, /REALIZE		;the widget is realized
;
;	XManager, 'example', base		;finally the example widget
;						;is registered with the 
;						;Xmanager
;     END
;
;	notes:	First the event handler routine is listed.  The handler
;		routine has the same name as the main routine with the 
;		characters "_event" added.  If you would like to use another
;		event handler name, you would need to pass it's name in as
;		a string to the EVENT_HANDLER keyword.  Also notice that the
;		event routine is listed before the main routine.  This is 
;		because the compiler will not compile the event routine if
;		it was below the main routine.  This is only needed if both
;		routines reside in the same file and the file name is the same
;		as the main routine name with the ".pro" extension added.
;
;
; PROCEDURE:
;	When the first widget is registered, initialize the lists and then 
;	start processing events.  Continue registering widgets and dispatching
;	events until all the widgets have been destroyed.  When a widget is 
;	killed, destroy all widgets that list the destroyed widget as their 
;	leader, if any.
;
; RELATED FUNCTIONS AND PROCEDURES:
;	XREGISTERED, XMANAGERTOOL, XBACKREGISTER
;
; MODIFICATION HISTORY: Written by Steve Richards, November, 1990
;	SMR, Mar,  1991	Added a cleanup routine keyword to allow dying
;			widgets to clean themselves up when dying.
;	SMR, May,  1991 Fixed a bug found by Diane Parchomchuk where 
;			an error occured when registering a widget 
;			right after destroying another.
;	SMR & ACY, July, 1991
;			Fixed a bug found by Debra Wolkovitch where
;			lone widgets being destroyed and new ones 
;			created caused problems.
;	SMR, Sept, 1991	Changed cleanup to use the new WIDGET_INFO
;			routine.
;	SMR & ACY, Oct,  1991
;			Fixed a bug where a background event that 
;			unregistered itself after a time would result
;			in an XMANAGER error.
; 	SMR, Mar.  1992	Changed XMANAGER to use enhanced widget functions for
;			event processing.
;	SMR, Nov.  1992 Changed modal widget handling allowing nesting of
;			modal widgets.  The first modal desensitizes all 
;			current widgets and subsequent modals only desensitize
;			the modal that called them.
;	JIY, Apr.  1993 Changed modal widget handling process to not run
;			the event loop for nested modal widgets.
;			Allowed for multiple modal widgets.
;	AB & SMR, 17 November 1993
;			Added ID validity checking to desensitizing of modal
;			widgets to fix a bug where already dead widgets
;			were being accessed.
;	DJE, Feb, 1995
;			Made it so that non-modal widgets created from a modal
;			widget have events processed in the modal widget's
;			event loop. This fixes a bug where xmanager wouldn't
;			return immediately if there was a modal widget somewhere
;			in the nesting, even though a non-modal widget was being
;			added. The nesting level could get _very_ deep.
;	DJE, Apr 1995
;			Pass a local variable to WIDGET_EVENT in the MODAL
;			case, instead of passing the common block variable
;			outermodal. This avoids a bug where outermodal gets
;			changed behind WIDGET_EVENT's back.
;-

COMMON MANAGED, ids, names, $
		nummanaged, inuseflag, $
		backroutines, backids, backnumber, nbacks, validbacks, $
		blocksize, $
		cleanups, $
		outermodal

COMMON XMAN_BCK_OBSOLETE, obsolete

IF(NOT(KEYWORD_SET(outermodal))) THEN outermodal = 0	;initialization

doeventloop = 0						;flag set if the main
							;event loop to be used

;------------- New Widget Registration Section ---------

IF(N_PARAMS() EQ 0) THEN BEGIN				;no parameters so just
  IF (NOT(KEYWORD_SET(nummanaged))) THEN RETURN		;start up the xmanager
  validids = WIDGET_INFO(ids(0:nummanaged-1), /VALID)	;loop if widgets 
  badids = WHERE((validids EQ 0), deaduns)		;present
  IF(deaduns NE 0) THEN $
    FOR i = 0, deaduns-1 do $
      XUnRegister, ids(badids(i))			;event loop again
  IF(KEYWORD_SET(ids)) THEN doeventloop = 1
  IF(NOT(KEYWORD_SET(nummanaged))) THEN $
    MESSAGE, 'No Widgets Are Currently being managed'
ENDIF ELSE IF(N_PARAMS() NE 2) THEN BEGIN
  MESSAGE, 'Wrong Number of Arguments, ' + $
	   'Usage = Xmanager, [name, id]'

ENDIF ELSE BEGIN					;register a new widget

  IF (KEYWORD_SET(IDS)) THEN BEGIN			;make sure that the new
    position = WHERE(ID EQ IDS, found)			;widget ID is not
    IF (found NE 0) THEN $				;currently in the IDS
      XUnregister, ID					;common block.
  ENDIF							;This is only
							;true when a widget is
							;killed and another is
							;created before
							;events are processed

  IF(NOT KEYWORD_SET(EVENT_HANDLER)) THEN $		;if no event handler 
		EVENT_HANDLER = NAME + '_event'		;was specified, assume
							;that the widget name +
							;"_event" exists

  IF(KEYWORD_SET(BACKGROUND)) THEN BEGIN
    ; Make sure the window manager will not kill a widget that has a
    ; background in progress
    WIDGET_CONTROL, id, /DELAY_DESTROY
    if not KEYWORD_SET(obsolete) then begin
      obsolete = 1
      message,/INFO,"The BACKGROUND keyword to theXMANAGER procedure is obsolete. It is superceeded by the TIMER keyword to the WIDGET_CONTROL procedure."
    endif
  endif

  WIDGET_CONTROL, id, /MANAGED				; Mark it.

  IF(NOT KEYWORD_SET(CLEANUP)) THEN $			;specify a null cleanup
		CLEANUP = ''				;if keyword not set

  IF(KEYWORD_SET(GROUP_LEADER)) THEN $			;register the group
    WIDGET_CONTROL, ID, GROUP_LEADER = GROUP_LEADER	;leader

  IF(NOT(KEYWORD_SET(nummanaged))) THEN $		;keep track of the
    nummanaged = 1 $					;number of managed
  ELSE $						;widgets
    nummanaged = nummanaged + 1

  IF(NOT(KEYWORD_SET(inuseflag)) AND $			;if just_register is
     NOT(KEYWORD_SET(JUST_REG))) THEN $			;set, don't process
	doeventloop = 1					;events

  IF(N_ELEMENTS(ids) EQ 0) THEN BEGIN			;create the first block
    blocksize = 64					;and set the size of
    ids = LONARR(blocksize)				;the blocks to be used
    names = STRARR(blocksize)				;in the future
    cleanups = STRARR(blocksize)
    freeindex = 0
  ENDIF ELSE BEGIN
    freeindex = WHERE(ids EQ 0, found)			;otherwise find holes
    IF(found EQ 0) THEN BEGIN				;in the current blocks
      ids = [ids, LONARR(blocksize)]			;or allocate a new one
      names = [names, STRARR(blocksize)]		;if all are full
      cleanups = [cleanups, STRARR(blocksize)]
      freeindex = nummanaged - 1
    ENDIF
  ENDELSE

  names(freeindex(0)) = NAME				;put the information
  ids(freeindex(0)) = ID				;into the blocks
  cleanups(freeindex(0)) = CLEANUP

  IF(NOT(KEYWORD_SET(nbacks))) THEN $
    nbacks = 0

  IF(KEYWORD_SET(BACKGROUND)) THEN BEGIN

    nbacks = nbacks + 1

    IF(N_ELEMENTS(backids) EQ 0) THEN BEGIN
      backids = LONARR(blocksize)			;build the first block
      backroutines = STRARR(blocksize)			;for background tasks
      freebacks = 0
      backnumber = 0
    ENDIF ELSE BEGIN					;otherwise, just
      freebacks = WHERE(backids EQ 0, found)		;find free spots or
      IF(found EQ 0) THEN BEGIN				;make new ones if full
        backids = [backids, LONARR(blocksize)]
        backroutines = [backroutines, $
			STRARR(blocksize)]
        freebacks = nbacks - 1
      ENDIF
    ENDELSE

    backids(freebacks(0)) = ID				;add the background
    backroutines(freebacks(0)) = STRUPCASE(BACKGROUND)	;in the first free spot

    validbacks = WHERE(backids NE 0)

    WIDGET_CONTROL, /EVENT_BREAK			;since an xmanager
							;loop could have called
							;this routine that is
							;not processing bcks, 
							;break out so this one
  ENDIF ;background set					;gets processed.

  WIDGET_CONTROL, ID, KILL_NOTIFY = 'XUnregister', $	;set the new widget's
		      EVENT_PRO = EVENT_HANDLER		;callbacks

;----------------- Modal Section -----------------------

  IF (keyword_set(outermodal) and (not keyword_set(modal))) THEN BEGIN

    ; a non-modal widget was added when there was already a modal widget
    ; up - just add the new widget to the modal list and return
    outermodal = [ outermodal, ID ]
    doeventloop = 0

    ; need to break out of the outer widget_event call so that the
    ; outer xmanager can see that outmodal has changed
    WIDGET_CONTROL, /EVENT_BREAK
    
  END ELSE IF (KEYWORD_SET(MODAL)) THEN BEGIN
							;when a modal widget
							;is called, all widgets
    IF (KEYWORD_SET(outermodal)) THEN BEGIN		;currently sensitive
      IF ((where(outermodal eq ID))(0) eq -1) THEN BEGIN
							;need to be desenitized
        senslist = outermodal				;making sure that a
        numsens  = n_elements(senslist)			;widget ID is not being
      ENDIF ELSE numsens = 0				;reused.
      doeventloop = 0
    ENDIF ELSE BEGIN					;nested calls to modal
      desens = where(ids NE ID, found)			;widgets are handled by
      IF (found NE 0) THEN BEGIN			;the stack so each 
	senslist = ids(desens)				;new modal only
	numsens = N_ELEMENTS(senslist)			;desensitizes the modal
      ENDIF ELSE numsens = 0				;below it.
    ENDELSE

    oldouter = outermodal
    outermodal = ID

    IF (numsens NE 0) THEN $	
      FOR i = 0, numsens - 1 DO $			;desensitize all
        IF (WIDGET_INFO(senslist(i), /VALID) EQ 1) THEN $ ;widgets active when
	  WIDGET_CONTROL, senslist(i), SENSITIVE = 0	;this modal is called.
							;either all or the 
							;modal that called me.

    bad = 0
    while (not bad) do begin				;loop as long as 
      ; pass a local var to widget_event, since outermodal could be
      ; changed by a reentrant call to xmanager
      temp = outermodal
      junk = widget_event (temp, bad_id = bad)	;modal list is alive.
      if ((where(outermodal eq bad))(0) eq -1) then bad = 0 else begin
        good = where(outermodal ne bad)
        if (good(0) eq -1) then bad = 1 else begin
          outermodal = outermodal (good)
          bad = 0;
        endelse
      endelse
    endwhile

    IF (numsens NE 0) THEN $
      FOR i = 0, numsens - 1 DO $
        IF(WIDGET_INFO(senslist(i),/VALID) EQ 1) THEN $	;now resensitize only
	  WIDGET_CONTROL, senslist(i), /SENSITIVE	;the widgets made 
      							;insensitive by this
							;modal request

    outermodal = oldouter				;restore my caller
							;as the outer modal
  ENDIF ;modal
ENDELSE ;xmanager called with 2 params

;----------------- Main Event Loop ---------------------

IF(doeventloop NE 0) THEN BEGIN				;if not modal and the
  WHILE(KEYWORD_SET(nummanaged)) DO BEGIN		;event loop should be
    inuseflag = 1					;executed, do it!
    active = WIDGET_INFO(/ACTIVE)
    WHILE (active NE 0) DO BEGIN
      IF(nbacks NE 0) THEN BEGIN			;Non-blocking BG task
        WHILE(nbacks NE 0) DO BEGIN
	  IF(backnumber GE nbacks) THEN backnumber = 0;
	  CALL_PROCEDURE, backroutines(validbacks(backnumber)), $
			  backids(validbacks(backnumber))
	  backnumber = backnumber + 1
	  newevent = WIDGET_EVENT(/NOWAIT)
        ENDWHILE
      ENDIF ELSE $					;Blocking mode
        newevent = WIDGET_EVENT()
      active = WIDGET_INFO(/ACTIVE)
    ENDWHILE
    nummanaged = 0
  ENDWHILE
  inuseflag = 0						;done so unset the 
ENDIF ;doeventloop NE 0					;inuse flag

END ;xmanager.pro
;----------------------- end of procedure XManager ----------------------------
; $Id: xmng_tmpl.pro,v 1.1 1993/04/02 19:54:08 idl Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	XMNG_TMPL
;
; PURPOSE:
;	This routine is a template for widgets that use the XManager.  Use
;	this template instead of writing your widget applications from
;	"scratch".
;
;	This documentation should be altered to reflect the actual 
;	implementation of the XMNG_TMPL widget.  Use a global search and 
;	replace to replace the word "Xmng_tmpl" with the name of the routine 
;	you would like to use.  The name should be no longer than "XMng_tmpl".
;	All the comments with a "***" in front of them should be read, decided 
;	upon and removed for your final copy of the XMng_tmpl widget
;	routine.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XMNG_TMPL
;
; INPUTS:
;
; OPTIONAL INPUT PARAMETERS:
;
; KEYWORD PARAMETERS:
;	GROUP:	The widget ID of the widget that calls XMng_tmpl.  When this
;		ID is specified, the death of the caller results in the death
;		of Xmng_tmpl.
;
; OUTPUTS:
;
; OPTIONAL OUTPUT PARAMETERS:
;
; COMMON BLOCKS:
;
; SIDE EFFECTS:
;	Initiates the XMANAGER if it is not already running.
;
; RESTRICTIONS:
;
; PROCEDURE:
;	Create and register the widget and then exit.
;
; MODIFICATION HISTORY:
;	Created from a template written by: Steve Richards, January, 1991.
;-

;*** Above is a comment template for all IDL library routines with some of the
;*** specifics for XMng_tmpl filled in.  All library routines should use this
;*** format so that the DOC_LIBRARY routine in IDL can be used to find out
;*** more about a given routine.  You should modify the above comments for 
;*** your application.  This header will then be displayed when DOC_LIBRARY is
;*** called for your routine.

;------------------------------------------------------------------------------
;	procedure XMng_tmpl_bck
;------------------------------------------------------------------------------
; This routine performs the background tasks while the XManager awaits new
; events.
;*** This is the background task.  If you need to update your widget while
;*** waiting for events, the task should go inside this routine.  The task
;*** should be very simple and quick or else it will bog down the processing
;*** of events and other background tasks.  If XMng_tmpl does not require
;*** a background task, this routine should be removed from this file and the
;*** line at the bottom of the file that reads:
;*** 		BACKGROUND = "XMng_tmpl_bck", $
;*** should be removed.
;------------------------------------------------------------------------------

PRO XMng_tmpl_bck, baseid


;*** here is where the background task should go


END ;============== end of XMng_tmpl background task routine ================



;------------------------------------------------------------------------------
;	procedure XMng_tmpl_ev
;------------------------------------------------------------------------------
; This procedure processes the events being sent by the XManager.
;*** This is the event handling routine for the XMng_tmpl widget.  It is 
;*** responsible for dealing with the widget events such as mouse clicks on
;*** buttons in the XMng_tmpl widget.  The tool menu choice routines are 
;*** already installed.  This routine is required for the XMng_tmpl widget to
;*** work properly with the XManager.
;------------------------------------------------------------------------------
PRO XMng_tmpl_ev, event

WIDGET_CONTROL, event.id, GET_UVALUE = eventval		;find the user value
							;of the widget where
							;the event occured
CASE eventval OF

;*** here is where you would add the actions for your events.  Each widget
;*** you add should have a unique string for its user value.  Here you add
;*** a case for each of your widgets that return events and take the
;*** appropriate action.

  "XLOADCT": XLoadct, GROUP = event.top			;XLoadct is the library
							;routine that lets you
							;select and adjust the
							;color palette being
							;used.

  "XPALETTE": XPalette, GROUP = event.top		;XPalette is the
							;library routine that
							;lets you adjust 
							;individual color
							;values in the palette.

  "XMANTOOL": XMTool, GROUP = event.top			;XManTool is a library
							;routine that shows 
							;which widget
							;applications are 
							;currently registered
							;with the XManager as
							;well as which
							;background tasks.

  "EXIT": WIDGET_CONTROL, event.top, /DESTROY		;There is no need to
							;"unregister" a widget
							;application.  The
							;XManager will clean
							;the dead widget from
							;its list.

  ELSE: MESSAGE, "Event User Value Not Found"		;When an event occurs
							;in a widget that has
							;no user value in this
							;case statement, an
							;error message is shown
ENDCASE

END ;============= end of XMng_tmpl event handling routine task =============



;------------------------------------------------------------------------------
;	procedure XMng_tmpl
;------------------------------------------------------------------------------
; This routine creates the widget and registers it with the XManager.
;*** This is the main routine for the XMng_tmpl widget.  It creates the
;*** widget and then registers it with the XManager which keeps track of the 
;*** currently active widgets.  
;------------------------------------------------------------------------------
PRO XMng_tmpl, GROUP = GROUP

;*** If XMng_tmpl can have multiple copies running, then delete the following
;*** line and the comment for it.  Often a common block is used that prohibits
;*** multiple copies of the widget application from running.  In this case, 
;*** leave the following line intact.

IF(XRegistered("XMng_tmpl") NE 0) THEN RETURN		;only one instance of
							;the XMng_tmpl widget
							;is allowed.  If it is
							;already managed, do
							;nothing and return

;*** Next the main base is created.  You will probably want to specify either
;*** a ROW or COLUMN base with keywords to arrange the widget visually.

XMng_tmplbase = WIDGET_BASE(TITLE = "XMng_tmpl")	;create the main base

;*** Here some default controls are built in a menu.  The descriptions of these
;*** procedures can be found in the XMng_tmpl_ev routine above.  If you would
;*** like to add other routines or remove any of these, remove them both below
;*** and in the XMng_tmpl_ev routine.

XPdMenu, [	'"Done"				EXIT',		$
		'"Tools"	{',				$
				'"XLoadct"	XLOADCT',	$
				'"XPalette"	XPALETTE',	$
				'"XManagerTool"	XMANTOOL',	$
				'}'],				$
	 XMng_tmplbase

;*** Typically, any widgets you need for your application are created here.
;*** Create them and use XMng_tmplbase as their base.  They will be realized
;*** (brought into existence) when the following line is executed.

WIDGET_CONTROL, XMng_tmplbase, /REALIZE			;create the widgets
							;that are defined

XManager, "XMng_tmpl", XMng_tmplbase, $			;register the widgets
		BACKGROUND = "XMng_tmpl_bck", $
		EVENT_HANDLER = "XMng_tmpl_ev", $	;with the XManager
		GROUP_LEADER = GROUP			;and pass through the
							;group leader if this
							;routine is to be 
							;called from some group
							;leader.

END ;==================== end of XMng_tmpl main routine =======================
; $Id: xmtool.pro,v 1.2 1993/06/17 22:33:34 steve Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.

PRO XManTool_event, event

COMMON MANAGED, ids, names, $
		nummanaged, inuseflag, $
		backroutines, backids, backnumber, nbacks, validbacks, $
		blocksize, $
		cleanups, $
		outermodal

COMMON MYMANTOOL, mylast, toollist, toolbase, mynum, selectedwid, $
		litcontbase, enabler, disablelist, selectedback

WIDGET_CONTROL, event.id, GET_UVALUE = evntval

CASE evntval OF
  "COLADJ": xloadct, GROUP = event.top

  "TOOLLIST" : BEGIN
		 validids = WHERE(ids NE 0)
		 selectedwid = validids(event.index)
		 selectedwid = selectedwid(0)
		 WIDGET_CONTROL, litcontbase, $
			/SENSITIVE
	       END

  "KILLER" : BEGIN
	       WIDGET_CONTROL, litcontbase, $
			SENSITIVE = 0
	       WIDGET_CONTROL, ids(selectedwid), /DESTROY
	     END

  "SHOWSTER" : BEGIN
	       WIDGET_CONTROL, litcontbase, $
			SENSITIVE = 0
	       WIDGET_CONTROL, ids(selectedwid), /SHOW
	     END

   "UPDATE" : BEGIN
   		WIDGET_CONTROL, event.id, TIMER = 1
		newids = ids(WHERE(ids NE 0))
		IF(N_ELEMENTS(mylast) EQ 0) THEN $
		  update = 1 $
		ELSE BEGIN
		  ; if there are any differences between old and new 
		  ; lists, update
		  IF ( N_ELEMENTS(mylast) NE N_ELEMENTS(newids) ) THEN $
		    update = 1 $
		  ELSE BEGIN
		    idval = [mylast EQ newids]
		    toss = WHERE(idval EQ 0, update)
		  ENDELSE
		ENDELSE
		IF(update NE 0) THEN BEGIN
		  WIDGET_CONTROL, toollist, $
			SET_VALUE = names(WHERE(names NE ''))
		  mylast = newids
		ENDIF
	      END

  "DONE": WIDGET_CONTROL, event.top, /DESTROY

  ELSE:
ENDCASE

END
;-----------------------------------------------------------------------------

PRO XMTool, GROUP = GROUP

;+
; NAME:
;	XMTOOL
;
; PURPOSE:
;	Provide a tool for viewing Widgets currently being managed by the 
;	XMANAGER.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XMTOOL
;
; KEYWORD PARAMETERS:
;	GROUP:	The widget ID of the group leader that the XMANAGERTOOL 
;		is to live under.  If the group is destroyed, the 
;		XMANAGERTOOL is also destroyed.
;
; COMMON BLOCKS:
;	MYMANTOOL:  This ommon block keeps track of the state of the XMANAGER
;		the last time the XMANAGERTOOL background routine was called.
;
; SIDE EFFECTS:
;	This procedure creates a widget that has the ability to destroy other 
;	widgets being managed by the XManager.
;
; RESTRICTIONS:
;	Only one instance of the XMANAGERTOOL can run at one time.
;
; PROCEDURE:
;	Initiate the widget and then let the timer routine update the
;	lists as the widgets being managed by the XMANAGER are changed.
;
; MODIFICATION HISTORY:
;	Written by Steve Richards, Dec, 1990.
;	SMR - 6/93	Modified the routine to work with a timer instead
;			of the obsolete background tasks.
;-

COMMON MANAGED, ids, names, $
		nummanaged, inuseflag, $
		backroutines, backids, backnumber, nbacks, validbacks, $
		blocksize, $
		cleanups, $
		outermodal

COMMON MYMANTOOL, mylast, toollist, toolbase, mynum, selectedwid, $
		litcontbase, enabler, disablelist, selectedback

IF(XRegistered("XManagerTool")) THEN RETURN

toolbase = WIDGET_BASE(TITLE = "Xmanager Tool", $
		/COLUMN, $
		SPACE = 10, $
		UVALUE = "UPDATE")
buttonbase = WIDGET_BASE(toolbase, /ROW)
tooldone = WIDGET_BUTTON(buttonbase, $
		VALUE = "Exit Xmanager Tool", $
		UVALUE = "DONE")
coladjust = WIDGET_BUTTON(buttonbase, $
		VALUE = "XLoadct...", $
		UVALUE = "COLADJ")
litbase = WIDGET_BASE(toolbase, $
		/COLUMN, $
;		/FRAME, $
		SPACE = 10)
toollabel = WIDGET_LABEL(litbase, $
		VALUE = "Managed Widgets")
toollist = WIDGET_LIST(litbase, $
		VALUE = "XmanagerTool      ", $
		YSIZE = 10, $
		UVALUE = "TOOLLIST")
litcontbase = WIDGET_BASE(litbase, $
		/ROW)
showster = WIDGET_BUTTON(litcontbase, $
		VALUE = "Bring To Front", $
		UVALUE = "SHOWSTER")
killer = WIDGET_BUTTON(litcontbase, $
		VALUE = "Kill Widget", $
		UVALUE = "KILLER")

WIDGET_CONTROL, litcontbase, SENSITIVE = 0
WIDGET_CONTROL, toolbase, /REALIZE

mylast = ''
IF(KEYWORD_SET(nummanaged)) THEN mynum = nummanaged ELSE mynum = 0

WIDGET_CONTROL, toolbase, TIMER = 1

Xmanager, "XManagerTool", $
		toolbase, $
		EVENT_HANDLER = "XManTool_event", $
		GROUP_LEADER = GROUP

END

; $Id: xpalette.pro,v 1.7 1995/07/31 17:10:10 mattr Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       XPALETTE
;
; PURPOSE:
;       Interactively create color tables using the RGB, CMY, HSV, and
;       HLS color systems using the mouse, three sliders, and a cell
;       for each color index. Single colors can be defined or multiple
;       color indices between two endpoints can be interpolated.
;
; CATEGORY:
;       Color tables, widgets.
;
; CALLING SEQUENCE:
;       XPALETTE
;
; INPUTS:
;       No explicit inputs.  The current color table is used as a starting
;       point.
;
; KEYWORD PARAMETERS:
;       None.
;
; OUTPUTS:
;       None.
;
; COMMON BLOCKS:
;       COLORS: Contains the current RGB color tables.
;       XP_COM: Private to this module.
;
; SIDE EFFECTS:
;       XPALETTE uses two colors from the current color table as
;       drawing foreground and background colors. These are used
;       for the RGB plots on the left, and the current index marker on
;       the right. This means that if the user set these two colors
;       to the same value, the XPALETTE display could become unreadable
;       (like writing on black paper with black ink). XPALETTE minimizes
;       this possibility by noting changes to the color map and always
;       using the brightest available color for the foreground color
;       and the darkest for the background. Thus, the only way
;       to make XPALETTE's display unreadable is to set the entire color
;       map to a single color, which is highly unlikely. The only side
;       effect of this policy is that you may notice XPALETTE redrawing
;       the entire display after you've modified the current color.
;       This simply means that the change has made XPALETTE pick new
;       drawing colors.
;
;       The new color tables are saved in the COLORS common and loaded
;       to the display.
;
; PROCEDURE:
;       The XPALETTE widget has the following controls:
;
;       Left:   Three plots showing the current Red, Green, and Blue vectors.
;
;       Center: A status region containing:
;               1) The total number of colors.
;               2) The current color. XPALETTE allows changing
;                  one color at a time. This color is known as
;                  the "current color" and is indicated in the
;                  color spectrum display with a special marker.
;               3) The current mark index. The mark is used to
;                  remember a color index. It is established by
;                  pressing the "Set Mark Button" while the current
;                  color index is the desired mark index.
;               4) The current color. The special marker used in
;                  color spectrum display prevents the user from seeing
;                  the color of the current index, but it is visible
;                  here.
;
;               A panel of control buttons, which do the following when
;               pressed:
;
;               Done:   Exits XPALETTE.
;
;         Predefined:   Starts XLOADCT to allow selection of one of the
;                       predefined color tables. Note that when you change
;                       the color map via XLOADCT, XPALETTE is not always
;                       able to keep its display accurate.  This problem can
;                       be overcome by pressing the XPALETTE "Redraw" button
;                       after changing things via XLOADCT.
;
;               Help:   Supplies help information similar to this header.
;
;               Redraw: Completely redraws the display using the current
;                       state of the color map.
;
;             Set Mark: Set the value of the mark index to the
;                       current index.
;
;          Switch Mark: Exchange the mark and the current index.
;
;         Copy Current: Every color lying between the current
;                       index and the mark index (inclusive) is given
;                       the current color.
;
;          Interpolate: The colors lying between the current
;                       index and the mark index are interpolated linearly
;                       to lie between the colors of two endpoints.
;
;       Three sliders (R, G, and B) that allow the user to modify the
;       current color.
;
;       Right:  A display which shows the current color map as a series of
;               squares. Color index 0 is at the upper left. The color index
;               increases monotonically by rows going left to right and top
;               to bottom.  The current color index is indicated by a special
;               marker symbol. There are 4 ways to change the current color:
;                       1) Press any mouse button while the mouse
;                          pointer is over the color map display.
;                       2) Use the "By Index" slider to move to
;                          the desired color index.
;                       3) Use the "Row" Slider to move the marker
;                          vertically.
;                       4) Use the "Column" Slider to move the marker
;                          horizontally.
;
; MODIFICATION HISTORY:
;       July 1990, AB.          Based on the PALETTE procedure, which does
;                               similar things using only basic IDL graphics
;                               commands.
;
;       7 January 1991, Re-written for general use.
;       1 April 1992, Modified to use the CW_RGBSLIDER and CW_COLORSEL
;               compound widgets. The use of color systems other than
;               RGB is now supported.
;       15 June 1992, Modified to use the CW_FIELD and CW_BGROUP compound
;               widgets.
;       7 April 1993, Removed state caching. Fixed a bug where switching
;		the current index and the mark would fail to update the
;		current index label.
;-

function XP_NEW_COLORS
; Choose the best foreground and background colors for the current
; color maps and set !P appropriately. Returns 1 if the colors changed,
; 0 otherwise.
  common xp_com, xpw, state

  res = 0
  junk = CT_LUMINANCE(dark=dark_col, bright=bright_col)

  if (bright_col ne !p.color) then begin
    !p.color = bright_col
    res = 1
  endif

  if (dark_col ne !p.background) then begin
    !p.background = dark_col
    res = 1
  endif

  return, res
end







pro XP_REPLOT, color_index, type
; Re-draw the RGB plots. Type has the following possible values.
;;      - 'D': Draw the data part of all three plots
;       - 'F': draw all three plots
;       - 'R': Draw the data part of the Red plot
;       - 'G': Draw the data part of the Green plot
;       - 'B': Draw the data part of the Blue plot

  common xp_com, xpw, state
  common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
  common pscale, r_x_s, r_y_s, g_x_s, g_y_s, b_x_s, b_y_s

  ; Update the plots of RGB
  wset, state.plot_win
  save_p_region = !p.region
  save_x_margin = !x.margin
  save_y_margin = !y.margin
  save_x_s = !x.s
  save_y_s = !y.s

  !y.margin= [2, 2]
  !x.margin= [6, 2]

  if (type eq 'F') then begin
    !p.region = [0,.6667, 1, 1]
    plot,xstyle=2, ystyle=3, yrange=[0, 260], r_curr, title='Red'
    r_x_s = !x.s
    r_y_s = !y.s

    !p.region = [0,.333, 1, .6667]
    plot,/noerase, xstyle=2,ystyle=3, yrange=[0, 260], g_curr, title='Green'
    g_x_s = !x.s
    g_y_s = !y.s

    !p.region = [0,0, 1, .333]
    plot,/noerase, xstyle=2,ystyle=3, yrange=[0, 260], b_curr, title='Blue'
    b_x_s = !x.s
    b_y_s = !y.s
  endif else begin
    if ((type eq 'D') or (type eq 'R')) then begin
      !p.region = [0,.6667, 1, 1]
      !x.s = r_x_s
      !y.s = r_y_s
      oplot, r_curr, color=color_index
    endif
    if ((type eq 'D') or (type eq 'G')) then begin
      !p.region = [0,.333, 1, .6667]
      !x.s = g_x_s
      !y.s = g_y_s
      oplot, g_curr, color=color_index
    endif
    if ((type eq 'D') or (type eq 'B')) then begin
      !p.region = [0,0, 1, .333]
      !x.s = b_x_s
      !y.s = b_y_s
      oplot, b_curr, color=color_index
    endif
  endelse

  !p.region = save_p_region
  !x.margin = save_x_margin
  !y.margin = save_y_margin
  !x.s = save_x_s
  !y.s = save_y_s

end




pro XP_CHANGE_COLOR, type, value
; Change current color. Type has the following possible values.
;       - 'R': Change the R part of the current color
;       - 'G': ...
;       - 'B': ...
  common xp_com, xpw, state
  common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr


  cur_idx = state.cur_idx

  XP_REPLOT, !p.background, type

  if (type eq 'R') then r_curr(cur_idx) = value;
  if (type eq 'G') then g_curr(cur_idx) = value;
  if (type eq 'B') then b_curr(cur_idx) = value;

  tvlct, r_curr(cur_idx), g_curr(cur_idx), b_curr(cur_idx), cur_idx

  if (XP_NEW_COLORS()) then begin
    ; Highlight the current position using the marker
    WIDGET_CONTROL, xpw.colorsel, set_value=-1  ; Re-initialize
    XP_REPLOT, !p.color, 'F'
  endif else begin
    XP_REPLOT, !p.color, type
  endelse

end







pro XP_BUTTON_EVENT, event

  common xp_com, xpw, state
  common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

  ; NOTE: The value of these tags depend on the order of the buttons
  ;     in the base.
  case (event.value) of

    ; DONE
    0: begin
      if state.old_window ge 0 then wset, state.old_window
	empty

	;WRITE_MASKS not valid for MS Windows
	IF (!VERSION.OS NE 'Win32') AND (!VERSION.OS NE 'MacOS') THEN $
		device,set_write=state.old_mask         ;Restore old write mask
	r_orig = r_curr & g_orig = g_curr & b_orig = b_curr ;new orig color tbl
	WIDGET_CONTROL, /DESTROY, event.top
	!p = state.old_p
      end

    ; PREDEFINED
    1: xloadct, /silent, group=xpw.base

    ; HELP
    2: XDisplayFile, FILEPATH("xpalette.txt", subdir=['help', 'widget']), $
	TITLE = "XPalette Help", GROUP = event.top, WIDTH = 55, HEIGHT = 16

    ; REDRAW
    3: begin
	junk = XP_NEW_COLORS()
	WIDGET_CONTROL, xpw.colorsel, set_value=-1
	XP_REPLOT, !p.color, 'F'        ; Update the plots of RGB
	end

    ; SET MARK
    4: begin
      state.mark_idx = state.cur_idx
      WIDGET_CONTROL, xpw.mark_label, $
		  set_value=strcompress(state.mark_idx, /REMOVE)
    endif

    ; SWITCH MARK
    5 : if (state.mark_idx ne state.cur_idx) then begin
      tmp = state.mark_idx
      state.mark_idx = state.cur_idx
      state.cur_idx = tmp
      WIDGET_CONTROL, xpw.colorsel, set_value=tmp
      WIDGET_CONTROL, xpw.idx_label, $
		    set_value=strcompress(state.cur_idx, /REMOVE)
      WIDGET_CONTROL, xpw.mark_label, $
		    set_value=strcompress(state.mark_idx, /REMOVE)
      endif

    ; COPY CURRENT
    6 : begin
      do_copy:
	cur_idx = state.cur_idx
	if (state.mark_idx le cur_idx) then begin
	  s = state.mark_idx
	  e = cur_idx
	endif else begin
	  s = cur_idx
	  e = state.mark_idx
	endelse
	n = e-s+1
	XP_REPLOT, !p.background, 'D'
	if (event.value eq 6) then begin
	  r_curr(s:e) = r_curr(cur_idx)
	  g_curr(s:e) = g_curr(cur_idx)
	  b_curr(s:e) = b_curr(cur_idx)
	endif else begin                        ; Interpolate
	  scale = findgen(n)/float(n-1)
	  r_curr(s:e) = r_curr(s) + (fix(r_curr(e)) - fix(r_curr(s))) * scale
	  g_curr(s:e) = g_curr(s) + (fix(g_curr(e)) - fix(g_curr(s))) * scale
	  b_curr(s:e) = b_curr(s) + (fix(b_curr(e)) - fix(b_curr(s))) * scale
	endelse
	tvlct, r_curr(s:e), g_curr(s:e), b_curr(s:e), s
	if (XP_NEW_COLORS()) then begin
	  WIDGET_CONTROL, xpw.colorsel, SET_VALUE=-1
	  XP_REPLOT, !p.color, 'F'
	endif else begin
	  XP_REPLOT, !p.color, 'D'
	endelse
	end

    7: goto, do_copy
    else:
  endcase

end







pro XP_EVENT, event

  common xp_com, xpw, state
  common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

  case (event.id) of

  xpw.button_base: XP_BUTTON_EVENT, event

  xpw.rgb_base: begin
	cur_idx = state.cur_idx
	if (event.r ne r_curr(cur_idx)) then XP_CHANGE_COLOR, "R", event.r
	if (event.g ne g_curr(cur_idx)) then XP_CHANGE_COLOR, "G", event.g
	if (event.b ne b_curr(cur_idx)) then XP_CHANGE_COLOR, "B", event.b
	end

  xpw.colorsel: begin
	cur_idx = state.cur_idx
	new_pos = event.value ne cur_idx
	; Update the RBG sliders
	if (event.value ne cur_idx) then begin
	  state.cur_idx = (cur_idx = event.value)
	  WIDGET_CONTROL, xpw.idx_label,  $
			  set_value=strcompress(cur_idx, /REMOVE_ALL)
	  ; Mark new square
	  wset, state.cur_color_win
	  erase, color=cur_idx

	  WIDGET_CONTROL, xpw.rgb_base, $
		  set_value=[r_curr(cur_idx), g_curr(cur_idx), b_curr(cur_idx)]
	  endif
	end

    else:
    endcase

end







pro XPALETTE, group=group

  common xp_com, xpw, state
  common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

  xpw = { xp_widgets, base:0L,  $
	colorsel:0L, mark_label:0L, idx_label:0L, button_base:0L, rgb_base:0L}

  state = {xp_state, old_window:0L, $   ; Original window index
	   old_mask:0L, $               ; Original mask
	   old_p:!p, $                  ; Original value of !P
	   mark_idx:0, $                ; Current mark index
	   cur_idx:0, $                 ; Current index
	   cur_color_win:0, $           ; Current Color draw window index
	   plot_win:0 }                 ; RGB plot draw window index

  if (XREGISTERED('XPALETTE')) then return      ; Only one copy at a time

  on_error,2              ;Return to caller if an error occurs

  ;WRITE_MASKS not valid for MS Windows
  IF (!VERSION.OS NE 'Win32') AND (!VERSION.OS NE 'MacOS') THEN $
	device,get_write=tmp,set_write=255  ELSE $ ;Enable all bits
	tmp = 0

  state.old_mask=tmp

  nc = !d.table_size            ;# of colors avail
  if nc eq 0 then message, "Device has static color tables.  Can't modify."
  if (nc eq 2) then message, 'Unable to work with monochrome system.'

  state.old_p = !p              ;Save !p
  !p.noclip = 1                 ;No clipping
  !p.color = nc -1              ;Foreground color
  !p.font = 0                   ;Hdw font
  state.old_window = !d.window  ;Previous window

  IF N_ELEMENTS(r_orig) LE 0 THEN BEGIN	;If no common, use current colors
	TVLCT, r_orig, g_orig, b_orig, /GET
	r_curr = r_orig
	b_curr = b_orig
	g_curr = g_orig
	ENDIF

  ; Create widgets
  xpw.base=WIDGET_BASE(title='XPalette', /ROW, space=30)

  version = WIDGET_INFO(/VERSION)
  if (version.style='Motif') then junk=510 else junk = 580
  plot_frame = WIDGET_DRAW(xpw.base, xsize=200, ysize=junk)

  c1 = WIDGET_BASE(xpw.base, /COLUMN, space=20)
    status = WIDGET_BASE(c1, /COLUMN, /FRAME)
      ncw = WIDGET_LABEL(WIDGET_BASE(status), /DYNAMIC_RESIZE)
      xpw.idx_label = CW_FIELD(status, title='Current Index: ', value='0', $
			       xsize=20, /STRING)
      xpw.mark_label = CW_FIELD(status, title='Mark Index:    ', value='0', $
				xsize=20, /STRING)
      c1_1 = widget_base(status, /ROW)
	junk = WIDGET_LABEL(c1_1, value="Current Color: ")
	  cur_color = WIDGET_DRAW(c1_1, xsize = 125, ysize=50, /frame)
    names = [ 'Done', 'Predefined', 'Help', 'Redraw', 'Set Mark', $
		'Switch Mark', 'Copy Current', 'Interpolate' ]
    xpw.button_base = CW_BGROUP(c1, names, COLUMN=3, /FRAME)
    xpw.rgb_base = CW_RGBSLIDER(c1, /FRAME, /DRAG)

    junk = WIDGET_BASE(xpw.base)        ; Responds to YOFFSET
    if (version.style='Motif') then junk2=30 else junk2 = 50
    xpw.colorsel = CW_COLORSEL(junk, yoffset=junk2)


  state.cur_idx = 0
  state.mark_idx = 0

  ; Position RGB slider appropriately
  WIDGET_CONTROL, xpw.rgb_base, SET_VALUE=[r_curr(0), g_curr(0), b_curr(0)]
  WIDGET_CONTROL, /REALIZE, xpw.base

  WIDGET_CONTROL, ncw, $
	set_value='Number Of Colors: ' + strcompress(!d.n_colors, /REMOVE_ALL)
  WIDGET_CONTROL, get_value=tmp, cur_color
  state.cur_color_win = tmp
  WIDGET_CONTROL, get_value=tmp, plot_frame
  state.plot_win = tmp


  ; Update the plots of RGB
  junk = XP_NEW_COLORS()
  XP_REPLOT, !p.color, 'F'

  XMANAGER, 'XPalette', xpw.base, event_handler='XP_EVENT', group=group
end
; $Id: xregistered.pro,v 1.2 1993/11/17 19:05:32 ali Exp $

; Copyright (c) 1992-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.


function XRegistered, NAME, NOSHOW = NOSHOW
;+
; NAME: 
;	XREGISTERED
;
; PURPOSE:
;	This function returns true if the widget named as its argument 
;	is currently registered with the XMANAGER as an exclusive widget, 
;	otherwise this routine returns false.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	Result = XREGISTERED(Name)
;
; INPUTS:
;	Name:	A string containing the name of the widget in question.
;
; KEYWORD PARAMETERS:
;	NOSHOW:	If the widget in question is registered, it is brought
;		to the front of all the other windows by default.  Set this
;		keyword to keep the widget from being brought to the front.
;
; OUTPUTS:
;	If the named widget is registered, XREGISTERED returns the number
;	of instances of that name in the list maintained by XMANAGER.  
;	Otherwise, XREGISTERED returns 0.
;
; COMMON BLOCKS:
;	MANAGED
;
; SIDE EFFECTS:
;	Brings the widget to the front of the desktop if it finds one.
;
; RESTRICTIONS:
;	None.
;
; PROCEDURE:
;	Searches the list of exclusive widget names and if a match is found
;	with the one in question, the return value is modified.
;
; MODIFICATION HISTORY:
;	Written by Steve Richards, November, 1990
;	Jan, 92 - SMR	Fixed a bug where an invalid widget
;			was being referenced with 
;			WIDGET_CONTROL and the /SHOW keyword.
;	17 November 1993 - AB and SMR. Added ID validity checking to
;			fix a bug where already dead widgets were being
;			accessed.
;-

  COMMON MANAGED, ids, names, $
		nummanaged, inuseflag, $
		backroutines, backids, backnumber, nbacks, validbacks, $
		blocksize, $
		cleanups, $
		outermodal

  answer = 0					; Nothing matched yet

  IF(KEYWORD_SET(nummanaged)) THEN begin
    validids = WHERE(ids ne 0, answer)
    if (answer eq 0) then goto, done		; No valid ids
    registered = WHERE(names(validids) EQ NAME, answer)
    if (answer eq 0) then goto, done		; Name not registered
    registered = validids(registered)
  endif else goto, done				; Nothing being managed.

  ; Assertion: answer cannot be 0 at this point
  validids = WIDGET_INFO(ids(registered), /VALID)
  IF((validids(0) EQ 1) AND $
     (NOT(KEYWORD_SET(NOSHOW)))) THEN $
    WIDGET_CONTROL, ids(registered(0)), /SHOW

done:
  RETURN, answer

END


;$Id: xsq_test.pro,v 1.2 1994/11/29 20:51:52 beth Exp $
;
; Copyright (c) 1994, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       XSQ_TEST
;
; PURPOSE:
;       This function computes the chi-squared goodness-of-fit test
;       between observed frequencies and the expected frequencies of
;       a theoretical distribution. The result is a two-element vector
;       containing the chi-squared test statistic X2 and probability
;       of obtaining a value of X2 or greater.
;
; CATEGORY:
;       Statistics.
;
; CALLING SEQUENCE:
;       Result = XSQ_TEST(OBFREQ, EXFREQ)
;
; INPUTS:
;       OBFREQ:  An n-element vector of type integer, float or double
;                containing observed frequencies.
;
;       EXFREQ:  An n-element vector of type integer, float or double
;                containing expected frequencies.
;
; KEYWORD PARAMETERS:
;       OBCELL:  Use this keyword to specify a named variable which returns
;                a vector of observed frequencies used to formulate the chi-
;                squared test statistic. The elements of this vector are 
;                often refered to as the "cells" of the observed frequencies.
;                The length of this vector is determined by the length of 
;                EXCELL described below.
;
;       EXCELL:  Use this keyword to specify a named variable which returns 
;                a vector of expected frequencies used to formulate the chi-
;                squared test statistic. If each of the expected frequencies 
;                contained in the n-element input vector, EXFREQ, has a 
;                magnitude of 5 or greater, then this vector is identical to 
;                EXFREQ. If EXFREQ contains elements of magnitude less than 5,
;                adjacent expected frequencies are combined. The identical
;                combinations are performed on the corresponding elements of 
;                OBFREQ.  
;
;     RESIDUAL:  Use this keyword to specify a named variable which returns
;                a vector of signed differences between corresponding cells
;                of observed frequencies and expected frequencies.
;                RESIDUAL(i) = OBCELL(i) - EXCELL(i). The length of this 
;                vector is determined by the length of EXCELL described
;                above. 
;
; EXAMPLE:
;       Define the vectors of observed and expected frequencies.
;         obfreq = [2, 1, 4, 15, 10, 5, 3]
;         exfreq = [0.5, 2.1, 5.9, 10.3, 10.7, 7.0, 3.5]
;       Test the hypothesis that the given observed frequencies are
;       an accurate approximation to the expected frequency distribution.
;         result = $
;           xsq_test(obfreq, exfreq, obcell = obcell, excell = excell)
;       The result should be the two-element vector [3.05040, 0.383920].
;       Since the vector of expected frequencies contains elements of
;       magnitude less than 5, adjacent expected frequencies are combined
;       resulting in fewer cells. The identical combinations are performed
;       on the corresponding elements of observed frequencies.
;       The cells used to formulate the chi-squared test statistic are 
;       contained in the keyword parameters, obcell and excell.
;       They should contain the values, [7, 15, 10, 8] and 
;       [8.5, 10.3, 10.7, 10.5], respectively.
;       The computed value of 0.383920 indicates that there is no reason to
;       reject the proposed hypothesis at the 0.05 significance level.
;
; PROCEDURE:
;       XSQ_TEST computes chi-squared goodness-of-fit test between observed 
;       frequencies and the expected frequencies of a theoretical distribution.
;       Expected frequencies of magnitude less than 5 are combined with 
;       adjacent elements resulting in a reduction of cells used to formulate
;       the chi-squared test statistic. If the observed frequencies differ 
;       significantly from the expected frequencies, the chi-squared test 
;       statistic will be large and the fit is poor. This situation requires 
;       the rejection of the hypothesis that the given observed frequencies 
;       are an accurate approximation to the expected frequency distribution. 
;
; REFERENCE:
;       PROBABILITY and STATISTICS for ENGINEERS and SCIENTISTS (3rd edition)
;       Ronald E. Walpole & Raymond H. Myers
;       ISBN 0-02-424170-9
;
; MODIFICATION HISTORY:
;       Written by:  GGS, RSI, August 1994
;-

pro freq_cell, obfreq, exfreq
  ;Combine elements of the expected frequency that are less than 5.
  ;Make corresponding changes to the vector of observed frequencies.
  ief = where(exfreq lt 5, nex)
  if nex ne 0 then begin
    while nex ne 0 do begin
      nfreq = n_elements(exfreq)
      if exfreq(ief(0)) eq exfreq(0) then begin
        ;First element less than 5.
        exfreq(1) = exfreq(0) + exfreq(1)
        exfreq = exfreq(1:*)
        obfreq(1) = obfreq(0) + obfreq(1)
        obfreq = obfreq(1:*)
      endif else if exfreq(ief(0)) eq exfreq(nfreq-1) then begin
        ;Last element less than 5.
        exfreq(nfreq-2) = exfreq(nfreq-2) + exfreq(nfreq-1)
        exfreq = exfreq(0:nfreq-2)
        obfreq(nfreq-2) = obfreq(nfreq-2) + obfreq(nfreq-1)
        obfreq = obfreq(0:nfreq-2)
      endif else begin
        ;Some middle element less than 5.
        exfreq(ief(0)) = exfreq(ief(0)) + exfreq(ief(0)+1)
        obfreq(ief(0)) = obfreq(ief(0)) + obfreq(ief(0)+1)
        if ief(0) ne nfreq-2 then begin ;Second to last element?
          exfreq = [ exfreq(0:ief(0)), exfreq(ief(0)+2:*) ]
          obfreq = [ obfreq(0:ief(0)), obfreq(ief(0)+2:*) ]
        endif else begin 
          exfreq = [ exfreq(0:ief(0)) ]
          obfreq = [ obfreq(0:ief(0)) ]
        endelse
      endelse
      ief = where(exfreq lt 5, nex)
    endwhile
  endif
end

function xsq_test, obfreq, exfreq, excell = excell, obcell = obcell, $
                                   residual = residual

  on_error, 2
  nex = n_elements(exfreq)
  if nex ne n_elements(obfreq) then $
    message, 'Observed and expected frequencies must be n-element vectors.'

  ineg = where(obfreq lt 0, nneg)
  if nneg ne 0 then message, $
    'Vector of observed frequencies cannot contain negative data.'

  if total(exfreq) lt 5 then $
    message, 'Total of expected frequencies must be 5 or greater.'

  iex = where(exfreq lt 5, nex)
  if nex ne 0 then begin
  ;Combine adjacent elements of expected frequency vector that are 
  ;less than 5. Corresponding changes are made to adjacent elements 
  ;of the observed frequency vector.
    obcell = obfreq 
    excell = exfreq
    freq_cell, obcell, excell
    ;Adjust degrees of freedom
    df = n_elements(excell)-1
    ;Chi-square test statistic.
    residual = (obcell - excell)
    z = total(residual^2.0 / excell)
    ;Probability of obtaining a value of z or larger
    prob = 1 - chisqr_pdf(z, df)
    return, [z, prob]
  endif else begin
    obcell = obfreq
    excell = exfreq
    ;Degrees of freedom
    df = n_elements(excell)-1
    residual = (obcell - excell)
    z = total(residual^2.0 / excell)
    prob = 1 - chisqr_pdf(z, df)
    return, [z, prob] 
  endelse
end
; $Id: xsurface.pro,v 1.2 1993/06/22 16:46:50 steve Exp $

; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	XSURFACE
;
; PURPOSE:
;	This routine provides a graphical interface to the SURFACE and
;	SHADE_SURFACE commands.  Different controls are provided to change 
;	the viewing angle and other plot parameters.  The command used to 
;	generate the resulting surface plot is shown in a text window.
;
; CATEGORY:
;	Widgets.
;
; CALLING SEQUENCE:
;	XSURFACE, Data
;
; INPUT PARAMETERS:
;	Data:	The two-dimensional array to display as a wire-mesh or
;		shaded surface.
;
; KEYWORD PARAMETERS:
;	GROUP:	The widget ID of the widget that calls XSURFACE.  When this
;		keyword is specified, the death of the caller results in the
;		death of XSURFACE.
;
; SIDE EFFECTS:
;	The XMANAGER is initiated if it is not already running.
;
; RESTRICTIONS:
;	XSURFACE does not accept any of the keywords that the IDL command 
;	SURFACE does.
;
; PROCEDURE:
;	Create and register the widget with the XMANAGER and then exit.
;
; MODIFICATION HISTORY:
;	Created from a template written by: Steve Richards, January, 1991.
;-

;------------------------------------------------------------------------------
;	procedure XSurface_draw
;------------------------------------------------------------------------------

PRO XSurface_draw

COMMON orientation, zrot, thedata, xrot, skirt, shade, axes, thedraw, $
		xmargin, ymargin, upper, commandid

WSET, thedraw

IF(shade EQ 0) THEN BEGIN
  IF(skirt EQ 0) THEN $
    SURFACE, thedata, $
		XSTYLE = axes, $
		YSTYLE = axes, $
		ZSTYLE = axes, $
		UPPER_ONLY = upper, $
		XMARGIN = xmargin, $
		YMARGIN = ymargin, $
		AZ = zrot, $
		AX = xrot $
  ELSE SURFACE, thedata, $
		XSTYLE = axes, $
		YSTYLE = axes, $
		ZSTYLE = axes, $
		UPPER_ONLY = upper, $
		XMARGIN = xmargin, $
		YMARGIN = ymargin, $
		AZ = zrot, $
		AX = xrot, $
		SKIRT = MIN(thedata)
ENDIF ELSE BEGIN
  IF(skirt EQ 0) THEN $
    SHADE_SURF, thedata, $
		XSTYLE = axes, $
		YSTYLE = axes, $
		ZSTYLE = axes, $
		UPPER_ONLY = upper, $
		XMARGIN = xmargin, $
		YMARGIN = ymargin, $
		AZ = zrot, $
		AX = xrot $
    ELSE SHADE_SURF, thedata, $
		XSTYLE = axes, $
		YSTYLE = axes, $
		ZSTYLE = axes, $
		UPPER_ONLY = upper, $
		XMARGIN = xmargin, $
		YMARGIN = ymargin, $
		AZ = zrot, $
		AX = xrot, $
		SKIRT = MIN(thedata)
ENDELSE

IF(shade EQ 0) THEN command = "SURFACE, data" $
ELSE command = "SHADE_SURF, data"
IF(xrot NE 30.0) THEN command = command + STRING(xrot, $
					FORMAT = '(", AX = ",I3.3)')
IF(zrot NE 30.0) THEN command = command + STRING(zrot, $
					FORMAT = '(", AZ = ",I3.3)')
IF(skirt NE 0) THEN command = command + ", /SKIRT"
IF(xmargin(0) NE 10.0) THEN $
	command = command + STRING(xmargin, $
	FORMAT = '(", XMARGIN = [",F4.1,", ",F4.1,"]")')
IF(ymargin(0) NE 4.0) THEN $
	command = command + STRING(ymargin, $
	FORMAT = '(", YMARGIN = [",F4.1,", ",F4.1,"]")')
IF(upper NE 0) THEN command = command + ", /UPPER_ONLY"
IF(axes NE 0) THEN command = command + $
	", XSTYLE = 4, YSTYLE = 4, ZSTYLE = 4"

WIDGET_CONTROL, commandid, SET_VALUE = command

END


;------------------------------------------------------------------------------
;	procedure XSurface_ev
;------------------------------------------------------------------------------

PRO XSurface_ev, event

COMMON orientation, zrot, thedata, xrot, skirt, shade, axes, thedraw, $
		xmargin, ymargin, upper, commandid

WIDGET_CONTROL, event.id, GET_UVALUE = eventval		;find the user value
							;of the widget where
							;the event occured
CASE eventval OF

  "       0": BEGIN
		zrot = (zrot + 15) mod 360
		IF(zrot LT 0) THEN zrot = 360 + zrot
		XSurface_draw
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "       1": BEGIN
		zrot = (zrot - 15) mod 360
		IF(zrot LT 0) THEN zrot = 360 + zrot
		XSurface_draw
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "       2": BEGIN
		xrot = (xrot - 15) mod 360
		IF(xrot LT 0) THEN xrot = 360 + xrot
		XSurface_draw
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "       3": BEGIN
		xrot = (xrot + 15) mod 360
		IF(xrot LT 0) THEN xrot = 360 + xrot
		XSurface_draw
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "       4": BEGIN	;shrink
		xmargin = xmargin * 1.2
		ymargin = ymargin * 1.2
		XSurface_draw
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "       5": BEGIN	;grow
		xmargin = xmargin * 0.8
		ymargin = ymargin * 0.8
		XSurface_draw
		WIDGET_CONTROL, event.id, SET_BUTTON = 0
	      END

  "SKIRTON": IF(event.select EQ 1) THEN BEGIN
		skirt = 1
		XSurface_draw
	     ENDIF

  "SKIRTOFF":  IF(event.select EQ 1) THEN BEGIN
		skirt = 0
		XSurface_draw
	      ENDIF

  "SHADEOFF":  IF(event.select EQ 1) THEN BEGIN
		shade = 0
		XSurface_draw
	      ENDIF

  "SHADEON":  IF(event.select EQ 1) THEN BEGIN
		shade = 1
		XSurface_draw
	      ENDIF

  "AXESOFF":  IF(event.select EQ 1) THEN BEGIN
		AXES = 4
		XSurface_draw
	      ENDIF

  "AXESON":  IF(event.select EQ 1) THEN BEGIN
		AXES = 0
		XSurface_draw
	      ENDIF

  "UPPERON": IF(event.select EQ 1) THEN BEGIN
		upper = 0
		XSurface_draw
	      ENDIF

  "UPPEROFF": IF(event.select EQ 1) THEN BEGIN
		upper = 1
		XSurface_draw
	      ENDIF

  "XLOADCT": XLoadct, GROUP = event.top

  "XPALETTE": XPalette, GROUP = event.top

  "XMANTOOL": XMTool, GROUP = event.top

  "EXIT": WIDGET_CONTROL, event.top, /DESTROY

  ELSE:; MESSAGE, "Event User Value Not Found"

ENDCASE

END ;============= end of XSurface event handling routine task =============



;------------------------------------------------------------------------------
;	procedure XSurface
;------------------------------------------------------------------------------

PRO XSurface, DATA, GROUP = GROUP

COMMON orientation, zrot, thedata, xrot, skirt, shade, axes, thedraw, $
		xmargin, ymargin, upper, commandid

IF(XRegistered("XSurface")) THEN RETURN			;only one instance of
							;the XSurface widget
							;is allowed.  If it is
							;already managed, do
							;nothing and return

thesize = SIZE(DATA)
zrot = 30.
xrot = 30.
skirt = 0
shade = 0
axes = 0
xmargin = [10.0, 3.0]
ymargin = [4.0, 2.0]
upper = 0
commandid = 0L

XSurfacebase = WIDGET_BASE(TITLE = "XSurface", $
		/COLUMN)

XPdMenu, [	'"Done"				EXIT',		$
		'"Tools"	{',				$
				'"XLoadct"	XLOADCT',	$
				'"XPalette"	XPALETTE',	$
				'"XManagerTool"	XMANTOOL',	$
				'}'],				$
	 XSurfacebase

thebase = WIDGET_BASE(XSurfacebase, /ROW)

ver	= widget_info(/version)
case ver.style OF
'OPEN LOOK': BEGIN
	  XSurfacepalette = WIDGET_BASE(thebase, $
				/COLUMN, $
				/FRAME, $
				/EXCLUSIVE)
	END
ELSE:	    BEGIN
	  XSurfacepalette = WIDGET_BASE(thebase, $
				/COLUMN, $
				/FRAME)
	END
ENDCASE

controls = [							$
		[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 248B, 255B, 063B, 000B],			$
		[128B, 007B, 000B, 224B, 001B],			$
		[112B, 000B, 000B, 000B, 014B],			$
		[136B, 000B, 016B, 000B, 016B],			$
		[052B, 000B, 048B, 000B, 056B],			$
		[172B, 000B, 080B, 000B, 032B],			$
		[124B, 000B, 144B, 000B, 040B],			$
		[164B, 007B, 016B, 001B, 048B],			$
		[012B, 248B, 031B, 062B, 056B],			$
		[036B, 000B, 000B, 228B, 033B],			$
		[004B, 000B, 000B, 008B, 062B],			$
		[012B, 000B, 000B, 016B, 048B],			$
		[036B, 000B, 000B, 016B, 032B],			$
		[008B, 000B, 000B, 008B, 000B],			$
		[112B, 000B, 000B, 004B, 000B],			$
		[128B, 007B, 000B, 002B, 000B],			$
		[000B, 248B, 031B, 001B, 000B],			$
		[000B, 000B, 144B, 000B, 000B],			$
		[000B, 000B, 080B, 000B, 000B],			$
		[000B, 000B, 048B, 000B, 000B],			$
		[000B, 000B, 016B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
;		dnz.bmdef
		[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 252B, 255B, 031B, 000B],			$
		[128B, 007B, 000B, 224B, 001B],			$
		[112B, 000B, 000B, 000B, 014B],			$
		[008B, 000B, 008B, 000B, 017B],			$
		[028B, 000B, 012B, 000B, 044B],			$
		[004B, 000B, 010B, 000B, 053B],			$
		[020B, 000B, 009B, 000B, 062B],			$
		[012B, 128B, 008B, 224B, 037B],			$
		[028B, 124B, 248B, 031B, 048B],			$
		[132B, 039B, 000B, 000B, 036B],			$
		[124B, 016B, 000B, 000B, 032B],			$
		[012B, 008B, 000B, 000B, 048B],			$
		[004B, 008B, 000B, 000B, 036B],			$
		[000B, 016B, 000B, 000B, 016B],			$
		[000B, 032B, 000B, 000B, 014B],			$
		[000B, 064B, 000B, 224B, 001B],			$
		[000B, 128B, 248B, 031B, 000B],			$
		[000B, 000B, 009B, 000B, 000B],			$
		[000B, 000B, 010B, 000B, 000B],			$
		[000B, 000B, 012B, 000B, 000B],			$
		[000B, 000B, 008B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;upz.bm
		[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 128B, 255B, 001B, 000B],			$
		[000B, 064B, 169B, 002B, 000B],			$
		[000B, 160B, 254B, 007B, 000B],			$
		[000B, 160B, 068B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 008B, 016B, 000B, 000B],			$
		[000B, 008B, 016B, 000B, 000B],			$
		[000B, 008B, 144B, 001B, 000B],			$
		[000B, 008B, 112B, 006B, 000B],			$
		[000B, 008B, 016B, 008B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 006B, 096B, 000B],			$
		[000B, 008B, 001B, 128B, 000B],			$
		[000B, 136B, 000B, 000B, 001B],			$
		[000B, 200B, 015B, 240B, 003B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 016B, 004B, 008B, 000B],			$
		[000B, 016B, 004B, 008B, 000B],			$
		[000B, 016B, 005B, 008B, 000B],			$
		[000B, 080B, 004B, 008B, 000B],			$
		[000B, 032B, 147B, 004B, 000B],			$
		[000B, 160B, 042B, 005B, 000B],			$
		[000B, 064B, 149B, 002B, 000B],			$
		[000B, 128B, 255B, 001B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;dnx.bm
		[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 128B, 255B, 001B, 000B],			$
		[000B, 064B, 149B, 002B, 000B],			$
		[000B, 160B, 042B, 005B, 000B],			$
		[000B, 032B, 147B, 004B, 000B],			$
		[000B, 080B, 004B, 008B, 000B],			$
		[000B, 016B, 005B, 008B, 000B],			$
		[000B, 016B, 004B, 008B, 000B],			$
		[000B, 016B, 004B, 008B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 200B, 015B, 240B, 003B],			$
		[000B, 136B, 000B, 000B, 001B],			$
		[000B, 008B, 001B, 128B, 000B],			$
		[000B, 008B, 006B, 096B, 000B],			$
		[000B, 008B, 008B, 016B, 000B],			$
		[000B, 008B, 016B, 008B, 000B],			$
		[000B, 008B, 112B, 006B, 000B],			$
		[000B, 008B, 144B, 001B, 000B],			$
		[000B, 008B, 016B, 000B, 000B],			$
		[000B, 008B, 016B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 016B, 032B, 000B, 000B],			$
		[000B, 160B, 068B, 000B, 000B],			$
		[000B, 160B, 254B, 007B, 000B],			$
		[000B, 064B, 169B, 002B, 000B],			$
		[000B, 128B, 255B, 001B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		],						$
		;shrink.bm
		[						$
		[000B, 000B, 008B, 000B, 000B],			$
		[000B, 000B, 008B, 000B, 000B],			$
		[000B, 000B, 073B, 000B, 000B],			$
		[000B, 000B, 042B, 000B, 000B],			$
		[000B, 000B, 028B, 000B, 000B],			$
		[000B, 000B, 008B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[128B, 255B, 255B, 255B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[132B, 000B, 000B, 000B, 033B],			$
		[136B, 000B, 000B, 000B, 017B],			$
		[144B, 000B, 000B, 000B, 009B],			$
		[191B, 000B, 000B, 000B, 253B],			$
		[144B, 000B, 000B, 000B, 009B],			$
		[136B, 000B, 000B, 000B, 017B],			$
		[132B, 000B, 000B, 000B, 033B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 000B, 000B, 000B, 001B],			$
		[128B, 255B, 255B, 255B, 001B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 008B, 000B, 000B],			$
		[000B, 000B, 028B, 000B, 000B],			$
		[000B, 000B, 042B, 000B, 000B],			$
		[000B, 000B, 073B, 000B, 000B],			$
		[000B, 000B, 008B, 000B, 000B],			$
		[000B, 000B, 008B, 000B, 000B]			$
		],						$
		;grow.bm
		[						$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[248B, 255B, 255B, 255B, 031B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[008B, 000B, 008B, 000B, 016B],			$
		[008B, 000B, 028B, 000B, 016B],			$
		[008B, 000B, 042B, 000B, 016B],			$
		[008B, 000B, 073B, 000B, 016B],			$
		[008B, 000B, 008B, 000B, 016B],			$
		[008B, 000B, 008B, 000B, 016B],			$
		[008B, 000B, 008B, 000B, 016B],			$
		[008B, 000B, 008B, 000B, 016B],			$
		[008B, 000B, 008B, 000B, 016B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[008B, 001B, 000B, 000B, 016B],			$
		[136B, 000B, 000B, 128B, 016B],			$
		[072B, 000B, 000B, 000B, 017B],			$
		[232B, 063B, 000B, 000B, 018B],			$
		[072B, 000B, 000B, 252B, 023B],			$
		[136B, 000B, 000B, 000B, 018B],			$
		[008B, 001B, 000B, 000B, 017B],			$
		[008B, 000B, 000B, 128B, 016B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[008B, 000B, 016B, 000B, 016B],			$
		[008B, 000B, 016B, 000B, 016B],			$
		[008B, 000B, 016B, 000B, 016B],			$
		[008B, 000B, 016B, 000B, 016B],			$
		[008B, 000B, 146B, 000B, 016B],			$
		[008B, 000B, 084B, 000B, 016B],			$
		[008B, 000B, 056B, 000B, 016B],			$
		[008B, 000B, 016B, 000B, 016B],			$
		[008B, 000B, 000B, 000B, 016B],			$
		[248B, 255B, 255B, 255B, 031B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B],			$
		[000B, 000B, 000B, 000B, 000B]			$
		]						$
	   ]

FOR i = 0,N_ELEMENTS(controls(0,0,*))-1 DO $
  toss = WIDGET_BUTTON(XSurfacepalette, $
		VALUE = controls(*,*,i), $
		UVALUE = STRING(i))

XSurfacedisplay = WIDGET_DRAW(thebase, $
		XSIZE = 375, $
		YSIZE = 300, $
		RETAIN = 2)

XSurfacecontrols = WIDGET_BASE(XSurfacebase, $
		/ROW)

skirtbase = WIDGET_BASE(XSurfacecontrols, $
		/COLUMN, $
		/EXCLUSIVE, $
		/FRAME)

skirtoff = WIDGET_BUTTON(skirtbase, $
		VALUE = "No Skirt", $
		UVALUE = "SKIRTOFF")

skirton = WIDGET_BUTTON(skirtbase, $
		VALUE = "Skirt", $
		UVALUE = "SKIRTON")

shadebase = WIDGET_BASE(XSurfacecontrols, $
		/COLUMN, $
		/EXCLUSIVE, $
		/FRAME)

shadeoff = WIDGET_BUTTON(shadebase, $
		VALUE = "Wire Frame", $
		UVALUE = "SHADEOFF")

shadeon = WIDGET_BUTTON(shadebase, $
		VALUE = "Shaded Surface", $
		UVALUE = "SHADEON")


axesbase = WIDGET_BASE(XSurfacecontrols, $
		/COLUMN, $
		/EXCLUSIVE, $
		/FRAME)

axeson = WIDGET_BUTTON(axesbase, $
		VALUE = "Show Axes", $
		UVALUE = "AXESON")

axesoff = WIDGET_BUTTON(axesbase, $
		VALUE = "Hide Axes", $
		UVALUE = "AXESOFF")

upperbase = WIDGET_BASE(XSurfacecontrols, $
		/COLUMN, $
		/EXCLUSIVE, $
		/FRAME)

upperon = WIDGET_BUTTON(upperbase, $
		VALUE = "Show Top and Bottom", $
		UVALUE = "UPPERON")

upperoff = WIDGET_BUTTON(upperbase, $
		VALUE = "Only Show Top", $
		UVALUE = "UPPEROFF")

commandbase = WIDGET_BASE(XSurfacebase, $
		/FRAME, $
		/COLUMN)

commandlabel = WIDGET_LABEL(commandbase, $
		VALUE = "IDL Commmand To Produce Above Output:")

case ver.style of
'OPEN LOOK':  commandid = WIDGET_LABEL(commandbase, VALUE = "SURFACE, data")
ELSE:	      commandid = WIDGET_TEXT(commandbase, $
				VALUE = "SURFACE, data", $
				/SCROLL, $
				YSIZE = 1)
ENDCASE

WIDGET_CONTROL, XSurfacebase, /REALIZE			;create the widgets
							;that is defined

WIDGET_CONTROL, skirtoff, /SET_BUTTON
WIDGET_CONTROL, shadeoff, /SET_BUTTON
WIDGET_CONTROL, axeson, /SET_BUTTON
WIDGET_CONTROL, upperon, /SET_BUTTON
WIDGET_CONTROL, XSurfacedisplay, GET_VALUE = temp & thedraw = temp

IF(N_PARAMS() gt 0) THEN BEGIN
	thedata = DATA
	XSurface_draw
END

XManager, "XSurface", XSurfacebase, $			;register the widgets
		EVENT_HANDLER = "XSurface_ev", $	;with the XManager
		GROUP_LEADER = GROUP

END ;================ end of XSurface background task =====================



; $Id: xvaredit.pro,v 1.1 1993/04/02 19:54:08 idl Exp $

;
; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	XVAREDIT
; PURPOSE:
;	This routine provides an editor for any IDL variable.
; CATEGORY:
;	Widgets
; CALLING SEQUENCE:
;	XVAREDIT, VAR
; INPUTS:
;	VAR = The variable that is to be edited.
; KEYWORD PARAMETERS:
;	NAME = The NAME of the variable.  This keyword is overwritten with the
;		structure name if the variable is a structure.
;	GROUP = The widget ID of the widget that calls XVarEdit.  When this
;		ID is specified, a death of the caller results in a death of
;		XVarEdit.
; OUTPUTS:
;	VAR= The variable that has been edited, or the original when the user
;		selects the "Cancel" button in the editor.
; COMMON BLOCKS:
;	Xvarcom - stores the state of the variable that is being edited.
; SIDE EFFECTS:
;	Initiates the XManager if it is not already running.
; RESTRICTIONS:
;	If the variable is exceedingly large such as a giant structure or
;	huge array, the editor will not fit on the screen and may not be able
;	to create enough widget components to edit the whole variable.
; PROCEDURE:
;	Create and register the widget and then exit.
;	If the user selects "accept", the values in the editor are written
;	to the variable passed in, otherwise, they are ignored.
; MODIFICATION HISTORY:
;	Written by: Steve Richards,	February, 1991
;-


;------------------------------------------------------------------------------
;	procedure XVarEdit_ev
;------------------------------------------------------------------------------
; This procedure processes the events being sent by the XManager.
;------------------------------------------------------------------------------
PRO XVarEdit_ev, event

COMMON Xvarcom, thevar, initialvar, entries

WIDGET_CONTROL, event.id, GET_UVALUE = eventval		;find the user value
							;of the widget where
							;the event occured
CASE eventval OF

  "DONT": BEGIN						;the user chose the 
	    thevar = initialvar				;cancel button so just
	    WIDGET_CONTROL, event.top, /DESTROY		;return the initial
	  END						;variable

  "DO": BEGIN						;the user chose accept
          i = 0						;so go ahead and modify
 	  WHILE(i LT N_ELEMENTS(entries))DO BEGIN	;the user's variable to
	    IF(entries(i).type NE 6)THEN BEGIN		;reflect his or her 
	      WIDGET_CONTROL, entries(i).widid, $	;choice
			GET_VALUE = newval
	      error = EXECUTE(entries(i).name  + $
			"= newval(0)")
	    ENDIF ELSE BEGIN				;when the user's 
	      WIDGET_CONTROL, entries(i).widid, $	;variable has a complex
			GET_VALUE = realval		;value, the real and
	      i = i + 1					;imaginary components
	      WIDGET_CONTROL, entries(i).widid, $	;must be reassembled
			GET_VALUE = imagval		;from its respective
	      error = EXECUTE(entries(i).name  + $	;editable widget
				"= complex(" + $	;components
				string(realval(0)) + $
				"," + $
				string(imagval(0)) + $
				")")
	    ENDELSE
	    i = i + 1
	  ENDWHILE
	  WIDGET_CONTROL, event.top, /DESTROY		;once the variables 
	END						;have been retrieved, 
							;the widget heiarchy
  ELSE: 						;can be destroyed

ENDCASE

END ;============= end of XVarEdit event handling routine task =============


;------------------------------------------------------------------------------
;	procedure AddEditEntry
;------------------------------------------------------------------------------
; This procedure adds an entry to the list that contains the variables names
; and the widget id for the edit field corresponding to the variable name.
;------------------------------------------------------------------------------

PRO AddEditEntry, thename, thetype, thewidid

COMMON Xvarcom, thevar, initialvar, entries

IF N_ELEMENTS(thewidid) EQ 0 THEN thewidid = 0L
newelt = {entstr, name:thename, $			;first create a record
		  widid:thewidid, $			;and then 
		  type:thetype}				;just create a list
numents = N_ELEMENTS(entries)				;with one more element
IF(NOT(KEYWORD_SET(entries)))THEN ENTRIES = newelt $	;and replace the old 
ELSE BEGIN						;one
  newentries = REPLICATE(newelt, numents + 1)
  newentries(0:numents - 1) = entries
  newentries(numents) = newelt
  entries = newentries
ENDELSE
END ;============== end of XVarEdit event handling routine task ===============


;------------------------------------------------------------------------------
;	procedure XvarEditField
;------------------------------------------------------------------------------
;  This routine is used to create the widget or widgets needed for a given 
;  variable type.  It could call itself recursively if the variable was itself
;  a structure comprised of other IDL variables.
;------------------------------------------------------------------------------

FUNCTION XvarEditField, base, type, val, NAME = NAME	;this is a dummy 
RETURN,0						;declaration so that
END							;this routine can call
							;itself recursively
FUNCTION XvarEditField, base, val, NAME = NAME, $
		RECNAME = RECNAME

dimarr = [18, 4, 7, 10, 12, 16, 12, 20]			;an array of lengths of
							;each type

typarr = ["Undefined", "Byte", "Integer", $		;an array of names of 
	  "Longword Integer", "Floating Point", $	;each type
	  "Double Precision Floating", $
	  "Complex Floating Point", $
	  "String", "Structure"]

varsize = size(val)					;determine the size and
vardims = N_ELEMENTS(varsize) - 2			;type of the variable
type = varsize(vardims)
numelements = varsize(vardims + 1)

IF(numelements GE 5) THEN $				;if the array is larger
  scrollval = 1 $					;than 5 elements, use
ELSE scrollval = 0					;a scrolling base to
							;conserve screen space

abase = WIDGET_BASE(base, $				;create a base for the
		/FRAME, $				;variable to live in
		/COLUMN, $
		XPAD = 8, $
		YPAD = 8, $
		SCROLL = scrollval)

IF(numelements GT 1) THEN BEGIN				;if the variable is an
  suffix = " Array("					;array, then say so and
  FOR j = 1, varsize(0) DO BEGIN			;show the array
    suffix = suffix + strtrim(varsize(j), 2)		;dimensions.
    IF j NE varsize(0) THEN suffix = suffix + ", "
  ENDFOR
  suffix = suffix + ")"
ENDIF ELSE suffix = ""


IF(type EQ 8) THEN NAME = TAG_NAMES(val, /STRUCTURE)	;if the variable is a 
							;structure, use its 
							;name

IF(KEYWORD_SET(NAME)) THEN $				;build up the name of
  lbl = WIDGET_LABEL(abase, $				;variable with the 
		VALUE = NAME + $			;type in parenthesese
			" (" + $
			typarr(type) + $
			suffix + $
			")") $
ELSE lbl = WIDGET_LABEL(abase, $
		value = typarr(type) + suffix)


IF(NOT(KEYWORD_SET(RECNAME))) THEN RECNAME = "thevar"	;establish the name
							;if not being called 
							;recursively

IF(varsize(0) GT 1) THEN BEGIN
  moduli = LONARR(varsize(0)-1) + 1
  FOR i = varsize(0), 2,-1 DO BEGIN
    FOR j = 1,i-1 DO $
      moduli(i - 2) = moduli(i - 2) * varsize(j)
  ENDFOR
ENDIF

FOR element = 0, numelements - 1 DO BEGIN		;for each array element

  IF(numelements NE 1) THEN BEGIN			;use array subscripting
    indexname = "("					;if variable is an
    indexname = indexname + $
		strtrim(element mod varsize(1),2)
    IF(varsize(0) GT 1) THEN BEGIN
      indexarr = lonarr(varsize(0) - 1)
      flatindex = element
      FOR i = varsize(0) - 2, 0, -1 DO BEGIN
	indexarr(i) = flatindex / moduli(i)
	flatindex = flatindex mod moduli(i)
      ENDFOR
      FOR i = 0, varsize(0) - 2 DO $
	indexname = indexname + ", " + $
		strtrim(indexarr(i), 2)
    ENDIF
    indexname = indexname + ")"
    thename = RECNAME + indexname			;build up the name from
    thebase = WIDGET_BASE(abase, $			;any previous recursive
		/FRAME, $				;names
		/ROW)
    alabel = WIDGET_LABEL(thebase, $
		VALUE = indexname + ": ")
    FRAMESETTING = 0
  ENDIF ELSE BEGIN
    FRAMESETTING = 1
    thename = RECNAME
    thebase = abase
  ENDELSE

  CASE type OF						;depending on the type,
							;build a string 
							;variable with proper
							;formatting

    0: thevalue = "Undefined Variable"			;Undefined

    1: thevalue = string(val(element), $		;Byte
		FORMAT = '(I3)')

    6: BEGIN						;Complex Float
	 rowbase = WIDGET_BASE(thebase, $		;here the variable must
		/ROW)					;be displayed in two
	 lable = WIDGET_LABEL(rowbase, $		;separate widgets for
		VALUE = "Real: ")			;its real and imaginary
	 id = WIDGET_TEXT(rowbase, $			;components
		VALUE = STRING(FLOAT(val(element))), $
		FRAME = FRAMESETTING, $
		YSIZE = 1, $
		XSIZE = dimarr(type), $
		/EDITABLE, $
		UVALUE = ' ')
	 AddEditEntry, thename, type, id
	 lable = WIDGET_LABEL(rowbase, $
		VALUE = "Imaginary: ")
	 id = WIDGET_TEXT(rowbase, $
		VALUE = STRING(IMAGINARY(val(element))), $
		FRAME = FRAMESETTING, $
		YSIZE = 1, $
		XSIZE = dimarr(type), $
		/EDITABLE, $
		UVALUE = ' ')
	AddEditEntry, thename, type, id
      END
    
    7: thevalue = val(element)				;String

    8: BEGIN						;Structure
	 tags = TAG_NAMES(val(element))
	 FOR i = 0, N_ELEMENTS(tags) - 1 DO BEGIN
	   error = EXECUTE("fieldvalue = val(element)." + tags(i))
	   fldsize = size(fieldvalue)
	   flddims = N_ELEMENTS(fldsize) - 2
	   id = XvarEditField(thebase, $
		fieldvalue, $
		NAME = tags(i), $
		RECNAME = thename + "." + tags(i))
	 ENDFOR
	END

    ELSE: thevalue = strtrim(val(element), 2)
  ENDCASE

  IF((type NE 6) AND (type NE 8)) THEN BEGIN		;here the actual widget
    id = WIDGET_TEXT(thebase, $				;is created if it was
		value = thevalue, $			;neither a structure or
		FRAME = FRAMESETTING, $			;a complex value
		YSIZE = 1, $
		XSIZE = dimarr(type), $
		/EDITABLE, $
		UVALUE = ' ')
    AddEditEntry, thename, type, id
  END

ENDFOR

return,id

END ;============= end of XVarEdit event handling routine task =============


;------------------------------------------------------------------------------
;	procedure XVarEdit
;------------------------------------------------------------------------------
; this is the actual routine that is called.  It builds up the variable editing
; fields by calling other support routines and then registers the widget 
; heiarchy with the XManager.  Notice that the widget is registered as a MODAL
; widget so it will desensitize all other current widgets until it is done.
;------------------------------------------------------------------------------
PRO XVarEdit, var, GROUP = GROUP, NAME = NAME

COMMON Xvarcom, thevar, initialvar, entries

if(n_params() ne 1) THEN $
  MESSAGE, "Must have one parameter"

IF(XRegistered("XVarEdit")) THEN RETURN			;only one instance of
							;the XVarEdit widget
							;is allowed.  If it is
							;already managed, do
							;nothing and return

XVarEditbase = WIDGET_BASE(TITLE = "XVarEdit", $	;create the main base
		/COLUMN)

XPdMenu, [	'"Cancel"		DONT',	$	;create the menu 
 		'"Accept"		DO'	$	;selections
	],					$
	 XVarEditbase

initialvar = var
thevar = var
varsize = size(var)
vardims = N_ELEMENTS(varsize) - 2

ids = XvarEditField(XVarEditbase, var, NAME = NAME)

WIDGET_CONTROL, XVarEditbase, /REALIZE			;create the widgets
							;that are defined

XManager, "XVarEdit", XVarEditbase, $			;register the widgets
		EVENT_HANDLER = "XVarEdit_ev", $	;with the XManager
		GROUP_LEADER = GROUP, $			;and pass through the
		/MODAL					;group leader if this
							;routine is to be 
							;called from some group
							;leader.

entries = 0
var = thevar

END ;================== end of XVarEdit main routine =======================


; $Id: zoom_24.pro,v 1.2 1994/06/08 22:37:34 dan Exp $

pro zoom_24, xsize=xs, ysize=ys, fact=fact, right=right
;+
; NAME:	
;	ZOOM_24
;
; PURPOSE:
;	Display part of a 24-bit color image from the current window
;	expanded in another window.  (This procedure was modified from the 
;	8-bit procedure ZOOM).
;
;	The cursor and left mouse button are used to mark the center of the 
;	zoom.  The cursor can be moved into the zoom window to determine the 
;	coordinates (in the original image) and color values of individual 
;	pixels.  In the zoom window, the right mouse button returns you to the
;	mode for selecting a new zoom window or magnification factor
;	from the original image.  The center mouse button is used in the 
;	original picture window to bring up the magnification-factor 
;	selector.  The mouse button erases the zoom window and pixel window
;	and exits.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	ZOOM_24 [, XSIZE = Xsize, YSIZE = Ysize, FACT = Fact, /RIGHT] 
;
; INPUTS:
;	All input parameters are passed as keywords.
;
; KEYWORDS:
;	XSIZE:	The X size of the zoom window.  The default is 512.
;
;	YSIZE:	The Y size of zoom window.  The default is 512.
;
;	FACT:	The zoom enlargement factor.  The default is 4.
;
;	RIGHT:	Position keyword (0 = left screen, 1 = right screen).
;
; OUTPUTS:
;	No explicit outputs. Two new windows are created, and both
;	are destroyed when the procedure is exited.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	Two windows are created/destroyed.  An auxiliary image
;	array is created.
;
; RESTRICTIONS:
;	ZOOM_24 only works with 24-bit color systems.
;
; PROCEDURE:
;	Straightforward.
;
; MODIFICATION HISTORY:
;	Original: 9-March-1990	W. T. Vetterling
;-

if n_elements(xs) le 0 then xs=512	; Default x-size
if n_elements(ys) le 0 then ys=512	; Default y-size
if n_elements(fact) le 0 then fact=4	; Default magnification

waitflg=3			; Wait for mouse clicks
ifact = fact       		
orig_w = !d.window		; Save original window number
orig_ysiz=!d.y_vsize		; Save original window y-size
xs = xs < !d.x_vsize		; For small originals, don't
ys = ys < !d.y_vsize	  	;   make zoom window too large
tvcrs,1				; Enable cursor
ierase = 0			; Erase zoom window flag

lm=50				; Left margin, pixel window
bm=50                           ; Bottom margin, pixel window
box=60				; Size of color box
barw=20				; Width of color bars
barl=128			; Maximum length of bars
bars=20				; Separation of color bars

lbar=lm+box+30			; Left end of color bars
rbar=lbar+barl			; Right end of color bars

rbox=lm+box			; Right side of box
tbox=bm+box			; Top of box

rtext=lm+300			; Right end of text
btext=bm+120			; Bottom of text
ttext=bm+175			; Top of text

bar1b=bm			; Bar 1 bottom
bar1t=bm+barw                   ; Bar 1 top
bar2b=bar1t+bars                ; Bar 2 bottom
bar2t=bar2b+barw                ; Bar 2 top
bar3b=bar2t+bars                ; Bar 3 bottom
bar3t=bar3b+barw                ; Bar 3 top

red=255L			; Colors for graphics
green=red*256                   ;   in pixel window
blue=green*256
black=0
white=red+green+blue

if keyword_set(right) then xp=!d.x_size+20 else xp=0
; Position expansion windows to left or right of original

window,xpos=xp,ypos=0,xsize=xs,ysize=ys,title='Zoomed Image',/free
zoom_w = !d.window

window,xpos=xp,ypos=ys+30,xsize=rbar+20,ysize=ttext+40,title='Pixel Values',/free
pixel_w = !d.window

!p.color=white          ; Post instructions
xyouts,lm,bm+125,'Make Selection From Original:',/dev
xyouts,lm,bm+100,'   Left Button Selects Region',/dev
xyouts,lm,bm+75,'   Center Button Selects Size',/dev
xyouts,lm,bm+50,'   Right Button Exits',/dev

wset,orig_w

again:
	tvrdc,x,y,waitflg,/dev	;Wait for mousie

	case !err of

4:	goto, done		; Right-hand mouse button quits

2:	if !d.name eq 'SUN' or !d.name eq 'X' then begin
				; Center mouse button brings up
				;   scale for choosing magnification
		s  = ['New Zoom Factor:',strtrim(indgen(19)+2,2)]
		ifact = wmenu(s,init=ifact-1,title=0)+1
                IF (!Version.Os NE 'MacOS') THEN $
                        tvcrs,x,y,/dev $        ;Restore cursor
                ELSE tvcrs,1
		ierase = 1
	endif else begin
		Read,'Current factor is',ifact+0,'.  Enter new factor: ',ifact
		if ifact le 0 then begin
			ifact = 4
			print,'Illegal Zoom factor.'
		endif
		ierase = 1	; Clean out previous display
	endelse

else:	begin	 				; Left-hand mouse button gives 
						;   expanded image
		nx = xs/ifact			; Size of new image
		ny = ys/ifact

		x0 = 0 > (x-nx/2)	 	; Make sure we don't crop
		y0 = 0 > (y-ny/2)	 	;   image on left or bottom
		x0 = x0 < (!d.x_vsize - nx)     ; Make sure we don't crop
		y0 = y0 < (!d.y_vsize - ny)     ;   image on the right or top

		a = tvrd(x0,y0,nx,ny,true=3)	; Read image, pixel interleaved

		wset,pixel_w			; Erase pixel window
		erase

		wset,zoom_w			; Go to zoom window
		if ierase then erase		; Erase it?
		ierase = 0

		xss = nx * ifact		; Make integer rebin factors
		yss = ny * ifact

		b=rebin(a,xss,yss,3,/sample)	; Rebin to correct size
						;   using pixel replication
						;   if necessary
		tv,b,0,0,true=3			; Show the magnified image
	
loop:
		wset,zoom_w			; Go to the zoomed window
		tvrdc,x,y,2,/dev		; Continuously sample the
						;   mouse coordinates
		if (!err eq 4) then goto,another
						; If right-hand button is
						;   pushed, get another sample
						;   from the original
		wset,pixel_w			; Otherwise, go to pixel
						;   window

		xx=string(format='(i3)',(x0+x/ifact))	; Coordinate text
     		yy=string(format='(i3)',(orig_ysiz-y0-1-y/ifact))
		ybar=ys-y-1

		rstr=string(format='(i3)',b(x,ybar,0))
						; Color text
		gstr=string(format='(i3)',b(x,ybar,1))
		bstr=string(format='(i3)',b(x,ybar,2))

		bar1=lbar+b(x,ybar,0)/2
		bar2=lbar+b(x,ybar,1)/2
		bar3=lbar+b(x,ybar,2)/2

		!p.color=black			; Cover old text
		polyfill,[lm,rtext,rtext,lm],[btext,btext,ttext,ttext],/dev
		; Note: This is faster than erase

       		!p.color=white			; Set color to white
		xyouts,lm,bm+155,'Position: ('+xx+','+yy+')',/dev
		xyouts,lm,bm+130,'Value:    ('+rstr+','+gstr+','+bstr+')',/dev

		!p.color=black			; Cover old color bars
		polyfill,[lbar,rbar,rbar,lbar],[bar1b,bar1b,bar3t,bar3t],/dev

		!p.color=red			; Red bar
		polyfill, [lbar,bar1,bar1,lbar],[bar3b,bar3b,bar3t,bar3t],/dev

		!p.color=green			; Green bar
		polyfill, [lbar,bar2,bar2,lbar],[bar2b,bar2b,bar2t,bar2t],/dev

		!p.color=blue			; Blue bar
		polyfill, [lbar,bar3,bar3,lbar],[bar1b,bar1b,bar1t,bar1t],/dev

		!p.color=b(x,ybar,0)+256.0*(b(x,ybar,1)+256.0*b(x,ybar,2))
					;Box showing pixel color
		polyfill, [lm,rbox,rbox,lm],[bm,bm,tbox,tbox],/dev
	
		goto,loop		; Get another pixel value

another:				; Get another section of original
					;   image

		wset,pixel_w            ; Erase pixel window
		erase

		!p.color=white          ; ... and give instructions
		xyouts,lm,bm+125,'Make Selection From Original:',/dev
		xyouts,lm,bm+100,'   Left Button Selects Region',/dev
		xyouts,lm,bm+75,'   Center Button Selects Size',/dev
		xyouts,lm,bm+50,'   Right Button Exits',/dev

		wset,orig_w		; Set to original image
	endelse	
endcase

goto,again				; Return to original state

done:
	if zoom_w ge 0 then wdelete,zoom_w	; Done with windows
	if pixel_w ge 0 then wdelete,pixel_w
	b=0				; Eliminate intermediate image
end















; $Id: zoom.pro,v 1.5 1994/06/08 22:37:17 dan Exp $
pro zoom,xsize=xs, ysize=ys, fact = fact, interp = interp, continuous = cont, $
        keep=keep, zoom_window=zoom_win, new_window=new_win
;+
; NAME:	
;	ZOOM
;
; PURPOSE:
;	Display part of an image (or graphics) from the current window
;	enlarged in another window.
;
;	The cursor is used to mark the center of the zoom.
;
; CATEGORY:
;	Image display.
;
; CALLING SEQUENCE:
;	ZOOM [, FACT = Fact, /INTERP, XSIZE = Xs, YSIZE = Ys, /CONTINUOUS, $
;		/KEEP, ZOOM_WINDOW=Zoom_Win, /NEW_WINDOW ]
;
; INPUTS:
;	All input parameters are passed as keywords.
;
; KEYWORDS:
;	FACT:	Zoom factor.  This parameter must be an integer.  The default
;		zoom factor is 4.
;
;	INTERP:	Set this keyword to use bilinear interpolation, otherwise 
;		pixel replication is used.
;
;	XSIZE:	The X size of the zoom window.  The default is 512.
;
;	YSIZE:	The Y size of the zoom window.  The default is 512.
;
;   CONTINUOUS:	Set this keyword to make the zoom window track the mouse
;		without requiring the user to press the left mouse button.
;		This feature only works well on fast computers.
;
;         KEEP: Keep the zoom window after exiting the procedure.
;
;  ZOOM_WINDOW:	When used with KEEP, returns the index of the zoom window.
;		Otherwise, if KEEP is not set, then -1 is returned.
;
;   NEW_WINDOW:	Normally, if ZOOM is called with /KEEP and then called again,
;		it will use the same window to display the zoomed image.
;		Calling ZOOM with /NEW_WINDOW forces it to create a new window
;		for this purpose.
;
; OUTPUTS:
;	No explicit outputs.   A new window is created if necessary. It
;	is destroyed upon exit if KEEP is not specified.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	A window is created/destroyed.
;
;	When ZOOM is reusing a zoom window from a previous call to ZOOM,/KEEP,
;	then the XSIZE and YSIZE parameters are reset to the actual size of the
;	window.
;
; RESTRICTIONS:
;	ZOOM only works with color systems.
;
; PROCEDURE:
;	Straightforward.
; 
; MODIFICATION HISTORY:
;	?
;       William Thompson, March 1992, added common block ZOOM_WINDOW
;		and KEEP keyword.
;	William Thompson, 20 May 1993, added ZOOM_WINDOW and NEW_WINDOW
;		keywords.
;
;-
on_error,2              ;Return to caller if an error occurs
common zoom_window, zoom_w
;
if n_elements(xs) le 0 then xs = 512
if n_elements(ys) le 0 then ys = 512
if n_elements(fact) le 0 then fact=4
if keyword_set(cont) then waitflg = 2 else waitflg = 3
ifact = fact
old_w = !d.window
if keyword_set(new_win) then zoom_w = -1	;Don't use old window (if any)
if n_elements(zoom_w) eq 0 then zoom_w = -1		;No zoom window yet
;
;  If an old window is to be used, then make sure it still exists.  (Added by
;  William Thompson, 20 May 1993.)
;
if zoom_w ge 0 then begin
	device, window_state=win_state
	if not win_state(zoom_w) then zoom_w = -1
endif
;
;  Make sure the parameters xs and ys agree with the size of the window, in
;  case a window is being reused from a previous call to ZOOM,/KEEP.  (Added by
;  William Thompson, 20 May 1993.)
;
IF ZOOM_W GE 0 THEN BEGIN
	OLD_WINDOW = !D.WINDOW
	WSET, ZOOM_W
	XS = !D.X_SIZE
	YS = !D.Y_SIZE
	WSET, OLD_WINDOW
ENDIF
tvcrs,1			;enable cursor
ierase = 0		;erase zoom window flag
print,'Left for zoom center, Middle for new zoom factor, Right to quit'
again:
	tvrdc,x,y,waitflg,/dev	;Wait for change
	case !err of
4:	goto, done
2:	if !d.name eq 'SUN' or !d.name eq 'X' then begin	;Sun view?
		s  = ['New Zoom Factor:',strtrim(indgen(19)+2,2)]
		ifact = wmenu(s, init=ifact-1,title=0)+1
		IF (!Version.Os NE 'MacOS') THEN $
			tvcrs,x,y,/dev $	;Restore cursor
                ELSE tvcrs,1
		ierase = 1
	endif else begin
		Read,'Current factor is',ifact+0,'.  Enter new factor: ',ifact
		if ifact le 0 then begin
			ifact = 4
			print,'Illegal Zoom factor.'
			endif
			ierase = 1	;Clean out previous display
	endelse
else:	begin
	x0 = 0 > (x-xs/(ifact*2)) 	;left edge from center
	y0 = 0 > (y-ys/(ifact*2)) 	;bottom
	nx = xs/ifact			;Size of new image
	ny = ys/ifact
	nx = nx < (!d.x_vsize-x0)
	ny = ny < (!d.y_size-y0)
	x0 = x0 < (!d.x_vsize - nx)
	y0 = y0 < (!d.y_vsize - ny)
	a = tvrd(x0,y0,nx,ny)		;Read image
	if zoom_w lt 0 then begin	;Make new window?
		window,/free,xsize=xs,ysize=ys,title='Zoomed Image'
		zoom_w = !d.window
	endif else begin
		wset,zoom_w
		if ierase then erase		;Erase it?
		ierase = 0
	endelse
	xss = nx * ifact	;Make integer rebin factors
	yss = ny * ifact
	tv,rebin(a,xss,yss,sample=1-keyword_set(interp))
	wset,old_w
	endcase
endcase
goto,again

done:
IF NOT KEYWORD_SET(KEEP) THEN BEGIN
        if zoom_w ge 0 then wdelete,zoom_w              ;Done with window
        ZOOM_W = -1
ENDIF
zoom_win = zoom_w	;Return index of zoom window to user
end

